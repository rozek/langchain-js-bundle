function HA(t, e) {
  for (var n = 0; n < e.length; n++) {
    const a = e[n];
    if (typeof a != "string" && !Array.isArray(a)) {
      for (const r in a)
        if (r !== "default" && !(r in t)) {
          const i = Object.getOwnPropertyDescriptor(a, r);
          i && Object.defineProperty(t, r, i.get ? i : {
            enumerable: !0,
            get: () => a[r]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
function GA(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var LP = { exports: {} }, ot = LP.exports = {}, ta, na;
function Mb() {
  throw new Error("setTimeout has not been defined");
}
function Ab() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? ta = setTimeout : ta = Mb;
  } catch {
    ta = Mb;
  }
  try {
    typeof clearTimeout == "function" ? na = clearTimeout : na = Ab;
  } catch {
    na = Ab;
  }
})();
function UP(t) {
  if (ta === setTimeout)
    return setTimeout(t, 0);
  if ((ta === Mb || !ta) && setTimeout)
    return ta = setTimeout, setTimeout(t, 0);
  try {
    return ta(t, 0);
  } catch {
    try {
      return ta.call(null, t, 0);
    } catch {
      return ta.call(this, t, 0);
    }
  }
}
function WA(t) {
  if (na === clearTimeout)
    return clearTimeout(t);
  if ((na === Ab || !na) && clearTimeout)
    return na = clearTimeout, clearTimeout(t);
  try {
    return na(t);
  } catch {
    try {
      return na.call(null, t);
    } catch {
      return na.call(this, t);
    }
  }
}
var Js = [], Lu = !1, qo, ah = -1;
function XA() {
  !Lu || !qo || (Lu = !1, qo.length ? Js = qo.concat(Js) : ah = -1, Js.length && BP());
}
function BP() {
  if (!Lu) {
    var t = UP(XA);
    Lu = !0;
    for (var e = Js.length; e; ) {
      for (qo = Js, Js = []; ++ah < e; )
        qo && qo[ah].run();
      ah = -1, e = Js.length;
    }
    qo = null, Lu = !1, WA(t);
  }
}
ot.nextTick = function(t) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n = 1; n < arguments.length; n++)
      e[n - 1] = arguments[n];
  Js.push(new xP(t, e)), Js.length === 1 && !Lu && UP(BP);
};
function xP(t, e) {
  this.fun = t, this.array = e;
}
xP.prototype.run = function() {
  this.fun.apply(null, this.array);
};
ot.title = "browser";
ot.browser = !0;
ot.env = {};
ot.argv = [];
ot.version = "";
ot.versions = {};
function Ks() {
}
ot.on = Ks;
ot.addListener = Ks;
ot.once = Ks;
ot.off = Ks;
ot.removeListener = Ks;
ot.removeAllListeners = Ks;
ot.emit = Ks;
ot.prependListener = Ks;
ot.prependOnceListener = Ks;
ot.listeners = function(t) {
  return [];
};
ot.binding = function(t) {
  throw new Error("process.binding is not supported");
};
ot.cwd = function() {
  return "/";
};
ot.chdir = function(t) {
  throw new Error("process.chdir is not supported");
};
ot.umask = function() {
  return 0;
};
var QA = LP.exports;
const ue = /* @__PURE__ */ GA(QA), Eb = "RFC3986", Ib = {
  RFC1738: (t) => String(t).replace(/%20/g, "+"),
  RFC3986: (t) => String(t)
}, YA = "RFC1738", eE = Array.isArray, Sr = (() => {
  const t = [];
  for (let e = 0; e < 256; ++e)
    t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
  return t;
})(), am = 1024, tE = (t, e, n, a, r) => {
  if (t.length === 0)
    return t;
  let i = t;
  if (typeof t == "symbol" ? i = Symbol.prototype.toString.call(t) : typeof t != "string" && (i = String(t)), n === "iso-8859-1")
    return escape(i).replace(/%u[0-9a-f]{4}/gi, function(o) {
      return "%26%23" + parseInt(o.slice(2), 16) + "%3B";
    });
  let s = "";
  for (let o = 0; o < i.length; o += am) {
    const l = i.length >= am ? i.slice(o, o + am) : i, f = [];
    for (let u = 0; u < l.length; ++u) {
      let c = l.charCodeAt(u);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      r === YA && (c === 40 || c === 41)) {
        f[f.length] = l.charAt(u);
        continue;
      }
      if (c < 128) {
        f[f.length] = Sr[c];
        continue;
      }
      if (c < 2048) {
        f[f.length] = Sr[192 | c >> 6] + Sr[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        f[f.length] = Sr[224 | c >> 12] + Sr[128 | c >> 6 & 63] + Sr[128 | c & 63];
        continue;
      }
      u += 1, c = 65536 + ((c & 1023) << 10 | l.charCodeAt(u) & 1023), f[f.length] = Sr[240 | c >> 18] + Sr[128 | c >> 12 & 63] + Sr[128 | c >> 6 & 63] + Sr[128 | c & 63];
    }
    s += f.join("");
  }
  return s;
};
function nE(t) {
  return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
}
function Ey(t, e) {
  if (eE(t)) {
    const n = [];
    for (let a = 0; a < t.length; a += 1)
      n.push(e(t[a]));
    return n;
  }
  return e(t);
}
const rE = Object.prototype.hasOwnProperty, VP = {
  brackets(t) {
    return String(t) + "[]";
  },
  comma: "comma",
  indices(t, e) {
    return String(t) + "[" + e + "]";
  },
  repeat(t) {
    return String(t);
  }
}, ra = Array.isArray, aE = Array.prototype.push, zP = function(t, e) {
  aE.apply(t, ra(e) ? e : [e]);
}, iE = Date.prototype.toISOString, gt = {
  addQueryPrefix: !1,
  allowDots: !1,
  allowEmptyArrays: !1,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encodeDotInKeys: !1,
  encoder: tE,
  encodeValuesOnly: !1,
  format: Eb,
  formatter: Ib[Eb],
  /** @deprecated */
  indices: !1,
  serializeDate(t) {
    return iE.call(t);
  },
  skipNulls: !1,
  strictNullHandling: !1
};
function sE(t) {
  return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint";
}
const im = {};
function ZP(t, e, n, a, r, i, s, o, l, f, u, c, h, p, d, m, b, g) {
  let _ = t, P = g, C = 0, R = !1;
  for (; (P = P.get(im)) !== void 0 && !R; ) {
    const I = P.get(t);
    if (C += 1, typeof I < "u") {
      if (I === C)
        throw new RangeError("Cyclic object value");
      R = !0;
    }
    typeof P.get(im) > "u" && (C = 0);
  }
  if (typeof f == "function" ? _ = f(e, _) : _ instanceof Date ? _ = h?.(_) : n === "comma" && ra(_) && (_ = Ey(_, function(I) {
    return I instanceof Date ? h?.(I) : I;
  })), _ === null) {
    if (i)
      return l && !m ? (
        // @ts-expect-error
        l(e, gt.encoder, b, "key", p)
      ) : e;
    _ = "";
  }
  if (sE(_) || nE(_)) {
    if (l) {
      const I = m ? e : l(e, gt.encoder, b, "key", p);
      return [
        d?.(I) + "=" + // @ts-expect-error
        d?.(l(_, gt.encoder, b, "value", p))
      ];
    }
    return [d?.(e) + "=" + d?.(String(_))];
  }
  const T = [];
  if (typeof _ > "u")
    return T;
  let O;
  if (n === "comma" && ra(_))
    m && l && (_ = Ey(_, l)), O = [{ value: _.length > 0 ? _.join(",") || null : void 0 }];
  else if (ra(f))
    O = f;
  else {
    const I = Object.keys(_);
    O = u ? I.sort(u) : I;
  }
  const A = o ? String(e).replace(/\./g, "%2E") : String(e), M = a && ra(_) && _.length === 1 ? A + "[]" : A;
  if (r && ra(_) && _.length === 0)
    return M + "[]";
  for (let I = 0; I < O.length; ++I) {
    const N = O[I], w = (
      // @ts-ignore
      typeof N == "object" && typeof N.value < "u" ? N.value : _[N]
    );
    if (s && w === null)
      continue;
    const k = c && o ? N.replace(/\./g, "%2E") : N, L = ra(_) ? typeof n == "function" ? n(M, k) : M : M + (c ? "." + k : "[" + k + "]");
    g.set(t, C);
    const B = /* @__PURE__ */ new WeakMap();
    B.set(im, g), zP(T, ZP(
      w,
      L,
      n,
      a,
      r,
      i,
      s,
      o,
      // @ts-ignore
      n === "comma" && m && ra(_) ? null : l,
      f,
      u,
      c,
      h,
      p,
      d,
      m,
      b,
      B
    ));
  }
  return T;
}
function oE(t = gt) {
  if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof t.encodeDotInKeys < "u" && typeof t.encodeDotInKeys != "boolean")
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  const e = t.charset || gt.charset;
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  let n = Eb;
  if (typeof t.format < "u") {
    if (!rE.call(Ib, t.format))
      throw new TypeError("Unknown format option provided.");
    n = t.format;
  }
  const a = Ib[n];
  let r = gt.filter;
  (typeof t.filter == "function" || ra(t.filter)) && (r = t.filter);
  let i;
  if (t.arrayFormat && t.arrayFormat in VP ? i = t.arrayFormat : "indices" in t ? i = t.indices ? "indices" : "repeat" : i = gt.arrayFormat, "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  const s = typeof t.allowDots > "u" ? t.encodeDotInKeys ? !0 : gt.allowDots : !!t.allowDots;
  return {
    addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : gt.addQueryPrefix,
    // @ts-ignore
    allowDots: s,
    allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : gt.allowEmptyArrays,
    arrayFormat: i,
    charset: e,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : gt.charsetSentinel,
    commaRoundTrip: !!t.commaRoundTrip,
    delimiter: typeof t.delimiter > "u" ? gt.delimiter : t.delimiter,
    encode: typeof t.encode == "boolean" ? t.encode : gt.encode,
    encodeDotInKeys: typeof t.encodeDotInKeys == "boolean" ? t.encodeDotInKeys : gt.encodeDotInKeys,
    encoder: typeof t.encoder == "function" ? t.encoder : gt.encoder,
    encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : gt.encodeValuesOnly,
    filter: r,
    format: n,
    formatter: a,
    serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : gt.serializeDate,
    skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : gt.skipNulls,
    // @ts-ignore
    sort: typeof t.sort == "function" ? t.sort : null,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : gt.strictNullHandling
  };
}
function uE(t, e = {}) {
  let n = t;
  const a = oE(e);
  let r, i;
  typeof a.filter == "function" ? (i = a.filter, n = i("", n)) : ra(a.filter) && (i = a.filter, r = i);
  const s = [];
  if (typeof n != "object" || n === null)
    return "";
  const o = VP[a.arrayFormat], l = o === "comma" && a.commaRoundTrip;
  r || (r = Object.keys(n)), a.sort && r.sort(a.sort);
  const f = /* @__PURE__ */ new WeakMap();
  for (let h = 0; h < r.length; ++h) {
    const p = r[h];
    a.skipNulls && n[p] === null || zP(s, ZP(
      n[p],
      p,
      // @ts-expect-error
      o,
      l,
      a.allowEmptyArrays,
      a.strictNullHandling,
      a.skipNulls,
      a.encodeDotInKeys,
      a.encode ? a.encoder : null,
      a.filter,
      a.sort,
      a.allowDots,
      a.serializeDate,
      a.format,
      a.formatter,
      a.encodeValuesOnly,
      a.charset,
      f
    ));
  }
  const u = s.join(a.delimiter);
  let c = a.addQueryPrefix === !0 ? "?" : "";
  return a.charsetSentinel && (a.charset === "iso-8859-1" ? c += "utf8=%26%2310003%3B&" : c += "utf8=%E2%9C%93&"), u.length > 0 ? c + u : "";
}
var KP = {}, fp = {};
fp.byteLength = dE;
fp.toByteArray = hE;
fp.fromByteArray = bE;
var ia = [], Jn = [], cE = typeof Uint8Array < "u" ? Uint8Array : Array, sm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var du = 0, lE = sm.length; du < lE; ++du)
  ia[du] = sm[du], Jn[sm.charCodeAt(du)] = du;
Jn[45] = 62;
Jn[95] = 63;
function HP(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = t.indexOf("=");
  n === -1 && (n = e);
  var a = n === e ? 0 : 4 - n % 4;
  return [n, a];
}
function dE(t) {
  var e = HP(t), n = e[0], a = e[1];
  return (n + a) * 3 / 4 - a;
}
function fE(t, e, n) {
  return (e + n) * 3 / 4 - n;
}
function hE(t) {
  var e, n = HP(t), a = n[0], r = n[1], i = new cE(fE(t, a, r)), s = 0, o = r > 0 ? a - 4 : a, l;
  for (l = 0; l < o; l += 4)
    e = Jn[t.charCodeAt(l)] << 18 | Jn[t.charCodeAt(l + 1)] << 12 | Jn[t.charCodeAt(l + 2)] << 6 | Jn[t.charCodeAt(l + 3)], i[s++] = e >> 16 & 255, i[s++] = e >> 8 & 255, i[s++] = e & 255;
  return r === 2 && (e = Jn[t.charCodeAt(l)] << 2 | Jn[t.charCodeAt(l + 1)] >> 4, i[s++] = e & 255), r === 1 && (e = Jn[t.charCodeAt(l)] << 10 | Jn[t.charCodeAt(l + 1)] << 4 | Jn[t.charCodeAt(l + 2)] >> 2, i[s++] = e >> 8 & 255, i[s++] = e & 255), i;
}
function pE(t) {
  return ia[t >> 18 & 63] + ia[t >> 12 & 63] + ia[t >> 6 & 63] + ia[t & 63];
}
function mE(t, e, n) {
  for (var a, r = [], i = e; i < n; i += 3)
    a = (t[i] << 16 & 16711680) + (t[i + 1] << 8 & 65280) + (t[i + 2] & 255), r.push(pE(a));
  return r.join("");
}
function bE(t) {
  for (var e, n = t.length, a = n % 3, r = [], i = 16383, s = 0, o = n - a; s < o; s += i)
    r.push(mE(t, s, s + i > o ? o : s + i));
  return a === 1 ? (e = t[n - 1], r.push(
    ia[e >> 2] + ia[e << 4 & 63] + "=="
  )) : a === 2 && (e = (t[n - 2] << 8) + t[n - 1], r.push(
    ia[e >> 10] + ia[e >> 4 & 63] + ia[e << 2 & 63] + "="
  )), r.join("");
}
var Ag = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Ag.read = function(t, e, n, a, r) {
  var i, s, o = r * 8 - a - 1, l = (1 << o) - 1, f = l >> 1, u = -7, c = n ? r - 1 : 0, h = n ? -1 : 1, p = t[e + c];
  for (c += h, i = p & (1 << -u) - 1, p >>= -u, u += o; u > 0; i = i * 256 + t[e + c], c += h, u -= 8)
    ;
  for (s = i & (1 << -u) - 1, i >>= -u, u += a; u > 0; s = s * 256 + t[e + c], c += h, u -= 8)
    ;
  if (i === 0)
    i = 1 - f;
  else {
    if (i === l)
      return s ? NaN : (p ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, a), i = i - f;
  }
  return (p ? -1 : 1) * s * Math.pow(2, i - a);
};
Ag.write = function(t, e, n, a, r, i) {
  var s, o, l, f = i * 8 - r - 1, u = (1 << f) - 1, c = u >> 1, h = r === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = a ? 0 : i - 1, d = a ? 1 : -1, m = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, s = u) : (s = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), s + c >= 1 ? e += h / l : e += h * Math.pow(2, 1 - c), e * l >= 2 && (s++, l /= 2), s + c >= u ? (o = 0, s = u) : s + c >= 1 ? (o = (e * l - 1) * Math.pow(2, r), s = s + c) : (o = e * Math.pow(2, c - 1) * Math.pow(2, r), s = 0)); r >= 8; t[n + p] = o & 255, p += d, o /= 256, r -= 8)
    ;
  for (s = s << r | o, f += r; f > 0; t[n + p] = s & 255, p += d, s /= 256, f -= 8)
    ;
  t[n + p - d] |= m * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
  const e = fp, n = Ag, a = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = u, t.SlowBuffer = R, t.INSPECT_MAX_BYTES = 50;
  const r = 2147483647;
  t.kMaxLength = r;
  const { Uint8Array: i, ArrayBuffer: s, SharedArrayBuffer: o } = globalThis;
  u.TYPED_ARRAY_SUPPORT = l(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function l() {
    try {
      const $ = new i(1), v = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(v, i.prototype), Object.setPrototypeOf($, v), $.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function f($) {
    if ($ > r)
      throw new RangeError('The value "' + $ + '" is invalid for option "size"');
    const v = new i($);
    return Object.setPrototypeOf(v, u.prototype), v;
  }
  function u($, v, S) {
    if (typeof $ == "number") {
      if (typeof v == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return d($);
    }
    return c($, v, S);
  }
  u.poolSize = 8192;
  function c($, v, S) {
    if (typeof $ == "string")
      return m($, v);
    if (s.isView($))
      return g($);
    if ($ == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $
      );
    if (St($, s) || $ && St($.buffer, s) || typeof o < "u" && (St($, o) || $ && St($.buffer, o)))
      return _($, v, S);
    if (typeof $ == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const F = $.valueOf && $.valueOf();
    if (F != null && F !== $)
      return u.from(F, v, S);
    const U = P($);
    if (U) return U;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof $[Symbol.toPrimitive] == "function")
      return u.from($[Symbol.toPrimitive]("string"), v, S);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $
    );
  }
  u.from = function($, v, S) {
    return c($, v, S);
  }, Object.setPrototypeOf(u.prototype, i.prototype), Object.setPrototypeOf(u, i);
  function h($) {
    if (typeof $ != "number")
      throw new TypeError('"size" argument must be of type number');
    if ($ < 0)
      throw new RangeError('The value "' + $ + '" is invalid for option "size"');
  }
  function p($, v, S) {
    return h($), $ <= 0 ? f($) : v !== void 0 ? typeof S == "string" ? f($).fill(v, S) : f($).fill(v) : f($);
  }
  u.alloc = function($, v, S) {
    return p($, v, S);
  };
  function d($) {
    return h($), f($ < 0 ? 0 : C($) | 0);
  }
  u.allocUnsafe = function($) {
    return d($);
  }, u.allocUnsafeSlow = function($) {
    return d($);
  };
  function m($, v) {
    if ((typeof v != "string" || v === "") && (v = "utf8"), !u.isEncoding(v))
      throw new TypeError("Unknown encoding: " + v);
    const S = T($, v) | 0;
    let F = f(S);
    const U = F.write($, v);
    return U !== S && (F = F.slice(0, U)), F;
  }
  function b($) {
    const v = $.length < 0 ? 0 : C($.length) | 0, S = f(v);
    for (let F = 0; F < v; F += 1)
      S[F] = $[F] & 255;
    return S;
  }
  function g($) {
    if (St($, i)) {
      const v = new i($);
      return _(v.buffer, v.byteOffset, v.byteLength);
    }
    return b($);
  }
  function _($, v, S) {
    if (v < 0 || $.byteLength < v)
      throw new RangeError('"offset" is outside of buffer bounds');
    if ($.byteLength < v + (S || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let F;
    return v === void 0 && S === void 0 ? F = new i($) : S === void 0 ? F = new i($, v) : F = new i($, v, S), Object.setPrototypeOf(F, u.prototype), F;
  }
  function P($) {
    if (u.isBuffer($)) {
      const v = C($.length) | 0, S = f(v);
      return S.length === 0 || $.copy(S, 0, 0, v), S;
    }
    if ($.length !== void 0)
      return typeof $.length != "number" || vr($.length) ? f(0) : b($);
    if ($.type === "Buffer" && Array.isArray($.data))
      return b($.data);
  }
  function C($) {
    if ($ >= r)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + r.toString(16) + " bytes");
    return $ | 0;
  }
  function R($) {
    return +$ != $ && ($ = 0), u.alloc(+$);
  }
  u.isBuffer = function(v) {
    return v != null && v._isBuffer === !0 && v !== u.prototype;
  }, u.compare = function(v, S) {
    if (St(v, i) && (v = u.from(v, v.offset, v.byteLength)), St(S, i) && (S = u.from(S, S.offset, S.byteLength)), !u.isBuffer(v) || !u.isBuffer(S))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (v === S) return 0;
    let F = v.length, U = S.length;
    for (let z = 0, G = Math.min(F, U); z < G; ++z)
      if (v[z] !== S[z]) {
        F = v[z], U = S[z];
        break;
      }
    return F < U ? -1 : U < F ? 1 : 0;
  }, u.isEncoding = function(v) {
    switch (String(v).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, u.concat = function(v, S) {
    if (!Array.isArray(v))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (v.length === 0)
      return u.alloc(0);
    let F;
    if (S === void 0)
      for (S = 0, F = 0; F < v.length; ++F)
        S += v[F].length;
    const U = u.allocUnsafe(S);
    let z = 0;
    for (F = 0; F < v.length; ++F) {
      let G = v[F];
      if (St(G, i))
        z + G.length > U.length ? (u.isBuffer(G) || (G = u.from(G)), G.copy(U, z)) : i.prototype.set.call(
          U,
          G,
          z
        );
      else if (u.isBuffer(G))
        G.copy(U, z);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      z += G.length;
    }
    return U;
  };
  function T($, v) {
    if (u.isBuffer($))
      return $.length;
    if (s.isView($) || St($, s))
      return $.byteLength;
    if (typeof $ != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof $
      );
    const S = $.length, F = arguments.length > 2 && arguments[2] === !0;
    if (!F && S === 0) return 0;
    let U = !1;
    for (; ; )
      switch (v) {
        case "ascii":
        case "latin1":
        case "binary":
          return S;
        case "utf8":
        case "utf-8":
          return Oo($).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return S * 2;
        case "hex":
          return S >>> 1;
        case "base64":
          return Hs($).length;
        default:
          if (U)
            return F ? -1 : Oo($).length;
          v = ("" + v).toLowerCase(), U = !0;
      }
  }
  u.byteLength = T;
  function O($, v, S) {
    let F = !1;
    if ((v === void 0 || v < 0) && (v = 0), v > this.length || ((S === void 0 || S > this.length) && (S = this.length), S <= 0) || (S >>>= 0, v >>>= 0, S <= v))
      return "";
    for ($ || ($ = "utf8"); ; )
      switch ($) {
        case "hex":
          return wc(this, v, S);
        case "utf8":
        case "utf-8":
          return ce(this, v, S);
        case "ascii":
          return ba(this, v, S);
        case "latin1":
        case "binary":
          return Ft(this, v, S);
        case "base64":
          return V(this, v, S);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return At(this, v, S);
        default:
          if (F) throw new TypeError("Unknown encoding: " + $);
          $ = ($ + "").toLowerCase(), F = !0;
      }
  }
  u.prototype._isBuffer = !0;
  function A($, v, S) {
    const F = $[v];
    $[v] = $[S], $[S] = F;
  }
  u.prototype.swap16 = function() {
    const v = this.length;
    if (v % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let S = 0; S < v; S += 2)
      A(this, S, S + 1);
    return this;
  }, u.prototype.swap32 = function() {
    const v = this.length;
    if (v % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let S = 0; S < v; S += 4)
      A(this, S, S + 3), A(this, S + 1, S + 2);
    return this;
  }, u.prototype.swap64 = function() {
    const v = this.length;
    if (v % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let S = 0; S < v; S += 8)
      A(this, S, S + 7), A(this, S + 1, S + 6), A(this, S + 2, S + 5), A(this, S + 3, S + 4);
    return this;
  }, u.prototype.toString = function() {
    const v = this.length;
    return v === 0 ? "" : arguments.length === 0 ? ce(this, 0, v) : O.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(v) {
    if (!u.isBuffer(v)) throw new TypeError("Argument must be a Buffer");
    return this === v ? !0 : u.compare(this, v) === 0;
  }, u.prototype.inspect = function() {
    let v = "";
    const S = t.INSPECT_MAX_BYTES;
    return v = this.toString("hex", 0, S).replace(/(.{2})/g, "$1 ").trim(), this.length > S && (v += " ... "), "<Buffer " + v + ">";
  }, a && (u.prototype[a] = u.prototype.inspect), u.prototype.compare = function(v, S, F, U, z) {
    if (St(v, i) && (v = u.from(v, v.offset, v.byteLength)), !u.isBuffer(v))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof v
      );
    if (S === void 0 && (S = 0), F === void 0 && (F = v ? v.length : 0), U === void 0 && (U = 0), z === void 0 && (z = this.length), S < 0 || F > v.length || U < 0 || z > this.length)
      throw new RangeError("out of range index");
    if (U >= z && S >= F)
      return 0;
    if (U >= z)
      return -1;
    if (S >= F)
      return 1;
    if (S >>>= 0, F >>>= 0, U >>>= 0, z >>>= 0, this === v) return 0;
    let G = z - U, pe = F - S;
    const He = Math.min(G, pe), xe = this.slice(U, z), Ve = v.slice(S, F);
    for (let $e = 0; $e < He; ++$e)
      if (xe[$e] !== Ve[$e]) {
        G = xe[$e], pe = Ve[$e];
        break;
      }
    return G < pe ? -1 : pe < G ? 1 : 0;
  };
  function M($, v, S, F, U) {
    if ($.length === 0) return -1;
    if (typeof S == "string" ? (F = S, S = 0) : S > 2147483647 ? S = 2147483647 : S < -2147483648 && (S = -2147483648), S = +S, vr(S) && (S = U ? 0 : $.length - 1), S < 0 && (S = $.length + S), S >= $.length) {
      if (U) return -1;
      S = $.length - 1;
    } else if (S < 0)
      if (U) S = 0;
      else return -1;
    if (typeof v == "string" && (v = u.from(v, F)), u.isBuffer(v))
      return v.length === 0 ? -1 : I($, v, S, F, U);
    if (typeof v == "number")
      return v = v & 255, typeof i.prototype.indexOf == "function" ? U ? i.prototype.indexOf.call($, v, S) : i.prototype.lastIndexOf.call($, v, S) : I($, [v], S, F, U);
    throw new TypeError("val must be string, number or Buffer");
  }
  function I($, v, S, F, U) {
    let z = 1, G = $.length, pe = v.length;
    if (F !== void 0 && (F = String(F).toLowerCase(), F === "ucs2" || F === "ucs-2" || F === "utf16le" || F === "utf-16le")) {
      if ($.length < 2 || v.length < 2)
        return -1;
      z = 2, G /= 2, pe /= 2, S /= 2;
    }
    function He(Ve, $e) {
      return z === 1 ? Ve[$e] : Ve.readUInt16BE($e * z);
    }
    let xe;
    if (U) {
      let Ve = -1;
      for (xe = S; xe < G; xe++)
        if (He($, xe) === He(v, Ve === -1 ? 0 : xe - Ve)) {
          if (Ve === -1 && (Ve = xe), xe - Ve + 1 === pe) return Ve * z;
        } else
          Ve !== -1 && (xe -= xe - Ve), Ve = -1;
    } else
      for (S + pe > G && (S = G - pe), xe = S; xe >= 0; xe--) {
        let Ve = !0;
        for (let $e = 0; $e < pe; $e++)
          if (He($, xe + $e) !== He(v, $e)) {
            Ve = !1;
            break;
          }
        if (Ve) return xe;
      }
    return -1;
  }
  u.prototype.includes = function(v, S, F) {
    return this.indexOf(v, S, F) !== -1;
  }, u.prototype.indexOf = function(v, S, F) {
    return M(this, v, S, F, !0);
  }, u.prototype.lastIndexOf = function(v, S, F) {
    return M(this, v, S, F, !1);
  };
  function N($, v, S, F) {
    S = Number(S) || 0;
    const U = $.length - S;
    F ? (F = Number(F), F > U && (F = U)) : F = U;
    const z = v.length;
    F > z / 2 && (F = z / 2);
    let G;
    for (G = 0; G < F; ++G) {
      const pe = parseInt(v.substr(G * 2, 2), 16);
      if (vr(pe)) return G;
      $[S + G] = pe;
    }
    return G;
  }
  function w($, v, S, F) {
    return ya(Oo(v, $.length - S), $, S, F);
  }
  function k($, v, S, F) {
    return ya(jo(v), $, S, F);
  }
  function L($, v, S, F) {
    return ya(Hs(v), $, S, F);
  }
  function B($, v, S, F) {
    return ya(In(v, $.length - S), $, S, F);
  }
  u.prototype.write = function(v, S, F, U) {
    if (S === void 0)
      U = "utf8", F = this.length, S = 0;
    else if (F === void 0 && typeof S == "string")
      U = S, F = this.length, S = 0;
    else if (isFinite(S))
      S = S >>> 0, isFinite(F) ? (F = F >>> 0, U === void 0 && (U = "utf8")) : (U = F, F = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const z = this.length - S;
    if ((F === void 0 || F > z) && (F = z), v.length > 0 && (F < 0 || S < 0) || S > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    U || (U = "utf8");
    let G = !1;
    for (; ; )
      switch (U) {
        case "hex":
          return N(this, v, S, F);
        case "utf8":
        case "utf-8":
          return w(this, v, S, F);
        case "ascii":
        case "latin1":
        case "binary":
          return k(this, v, S, F);
        case "base64":
          return L(this, v, S, F);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return B(this, v, S, F);
        default:
          if (G) throw new TypeError("Unknown encoding: " + U);
          U = ("" + U).toLowerCase(), G = !0;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function V($, v, S) {
    return v === 0 && S === $.length ? e.fromByteArray($) : e.fromByteArray($.slice(v, S));
  }
  function ce($, v, S) {
    S = Math.min($.length, S);
    const F = [];
    let U = v;
    for (; U < S; ) {
      const z = $[U];
      let G = null, pe = z > 239 ? 4 : z > 223 ? 3 : z > 191 ? 2 : 1;
      if (U + pe <= S) {
        let He, xe, Ve, $e;
        switch (pe) {
          case 1:
            z < 128 && (G = z);
            break;
          case 2:
            He = $[U + 1], (He & 192) === 128 && ($e = (z & 31) << 6 | He & 63, $e > 127 && (G = $e));
            break;
          case 3:
            He = $[U + 1], xe = $[U + 2], (He & 192) === 128 && (xe & 192) === 128 && ($e = (z & 15) << 12 | (He & 63) << 6 | xe & 63, $e > 2047 && ($e < 55296 || $e > 57343) && (G = $e));
            break;
          case 4:
            He = $[U + 1], xe = $[U + 2], Ve = $[U + 3], (He & 192) === 128 && (xe & 192) === 128 && (Ve & 192) === 128 && ($e = (z & 15) << 18 | (He & 63) << 12 | (xe & 63) << 6 | Ve & 63, $e > 65535 && $e < 1114112 && (G = $e));
        }
      }
      G === null ? (G = 65533, pe = 1) : G > 65535 && (G -= 65536, F.push(G >>> 10 & 1023 | 55296), G = 56320 | G & 1023), F.push(G), U += pe;
    }
    return ut(F);
  }
  const ie = 4096;
  function ut($) {
    const v = $.length;
    if (v <= ie)
      return String.fromCharCode.apply(String, $);
    let S = "", F = 0;
    for (; F < v; )
      S += String.fromCharCode.apply(
        String,
        $.slice(F, F += ie)
      );
    return S;
  }
  function ba($, v, S) {
    let F = "";
    S = Math.min($.length, S);
    for (let U = v; U < S; ++U)
      F += String.fromCharCode($[U] & 127);
    return F;
  }
  function Ft($, v, S) {
    let F = "";
    S = Math.min($.length, S);
    for (let U = v; U < S; ++U)
      F += String.fromCharCode($[U]);
    return F;
  }
  function wc($, v, S) {
    const F = $.length;
    (!v || v < 0) && (v = 0), (!S || S < 0 || S > F) && (S = F);
    let U = "";
    for (let z = v; z < S; ++z)
      U += Po[$[z]];
    return U;
  }
  function At($, v, S) {
    const F = $.slice(v, S);
    let U = "";
    for (let z = 0; z < F.length - 1; z += 2)
      U += String.fromCharCode(F[z] + F[z + 1] * 256);
    return U;
  }
  u.prototype.slice = function(v, S) {
    const F = this.length;
    v = ~~v, S = S === void 0 ? F : ~~S, v < 0 ? (v += F, v < 0 && (v = 0)) : v > F && (v = F), S < 0 ? (S += F, S < 0 && (S = 0)) : S > F && (S = F), S < v && (S = v);
    const U = this.subarray(v, S);
    return Object.setPrototypeOf(U, u.prototype), U;
  };
  function Je($, v, S) {
    if ($ % 1 !== 0 || $ < 0) throw new RangeError("offset is not uint");
    if ($ + v > S) throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(v, S, F) {
    v = v >>> 0, S = S >>> 0, F || Je(v, S, this.length);
    let U = this[v], z = 1, G = 0;
    for (; ++G < S && (z *= 256); )
      U += this[v + G] * z;
    return U;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(v, S, F) {
    v = v >>> 0, S = S >>> 0, F || Je(v, S, this.length);
    let U = this[v + --S], z = 1;
    for (; S > 0 && (z *= 256); )
      U += this[v + --S] * z;
    return U;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(v, S) {
    return v = v >>> 0, S || Je(v, 1, this.length), this[v];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(v, S) {
    return v = v >>> 0, S || Je(v, 2, this.length), this[v] | this[v + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(v, S) {
    return v = v >>> 0, S || Je(v, 2, this.length), this[v] << 8 | this[v + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(v, S) {
    return v = v >>> 0, S || Je(v, 4, this.length), (this[v] | this[v + 1] << 8 | this[v + 2] << 16) + this[v + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(v, S) {
    return v = v >>> 0, S || Je(v, 4, this.length), this[v] * 16777216 + (this[v + 1] << 16 | this[v + 2] << 8 | this[v + 3]);
  }, u.prototype.readBigUInt64LE = tn(function(v) {
    v = v >>> 0, qe(v, "offset");
    const S = this[v], F = this[v + 7];
    (S === void 0 || F === void 0) && Hn(v, this.length - 8);
    const U = S + this[++v] * 2 ** 8 + this[++v] * 2 ** 16 + this[++v] * 2 ** 24, z = this[++v] + this[++v] * 2 ** 8 + this[++v] * 2 ** 16 + F * 2 ** 24;
    return BigInt(U) + (BigInt(z) << BigInt(32));
  }), u.prototype.readBigUInt64BE = tn(function(v) {
    v = v >>> 0, qe(v, "offset");
    const S = this[v], F = this[v + 7];
    (S === void 0 || F === void 0) && Hn(v, this.length - 8);
    const U = S * 2 ** 24 + this[++v] * 2 ** 16 + this[++v] * 2 ** 8 + this[++v], z = this[++v] * 2 ** 24 + this[++v] * 2 ** 16 + this[++v] * 2 ** 8 + F;
    return (BigInt(U) << BigInt(32)) + BigInt(z);
  }), u.prototype.readIntLE = function(v, S, F) {
    v = v >>> 0, S = S >>> 0, F || Je(v, S, this.length);
    let U = this[v], z = 1, G = 0;
    for (; ++G < S && (z *= 256); )
      U += this[v + G] * z;
    return z *= 128, U >= z && (U -= Math.pow(2, 8 * S)), U;
  }, u.prototype.readIntBE = function(v, S, F) {
    v = v >>> 0, S = S >>> 0, F || Je(v, S, this.length);
    let U = S, z = 1, G = this[v + --U];
    for (; U > 0 && (z *= 256); )
      G += this[v + --U] * z;
    return z *= 128, G >= z && (G -= Math.pow(2, 8 * S)), G;
  }, u.prototype.readInt8 = function(v, S) {
    return v = v >>> 0, S || Je(v, 1, this.length), this[v] & 128 ? (255 - this[v] + 1) * -1 : this[v];
  }, u.prototype.readInt16LE = function(v, S) {
    v = v >>> 0, S || Je(v, 2, this.length);
    const F = this[v] | this[v + 1] << 8;
    return F & 32768 ? F | 4294901760 : F;
  }, u.prototype.readInt16BE = function(v, S) {
    v = v >>> 0, S || Je(v, 2, this.length);
    const F = this[v + 1] | this[v] << 8;
    return F & 32768 ? F | 4294901760 : F;
  }, u.prototype.readInt32LE = function(v, S) {
    return v = v >>> 0, S || Je(v, 4, this.length), this[v] | this[v + 1] << 8 | this[v + 2] << 16 | this[v + 3] << 24;
  }, u.prototype.readInt32BE = function(v, S) {
    return v = v >>> 0, S || Je(v, 4, this.length), this[v] << 24 | this[v + 1] << 16 | this[v + 2] << 8 | this[v + 3];
  }, u.prototype.readBigInt64LE = tn(function(v) {
    v = v >>> 0, qe(v, "offset");
    const S = this[v], F = this[v + 7];
    (S === void 0 || F === void 0) && Hn(v, this.length - 8);
    const U = this[v + 4] + this[v + 5] * 2 ** 8 + this[v + 6] * 2 ** 16 + (F << 24);
    return (BigInt(U) << BigInt(32)) + BigInt(S + this[++v] * 2 ** 8 + this[++v] * 2 ** 16 + this[++v] * 2 ** 24);
  }), u.prototype.readBigInt64BE = tn(function(v) {
    v = v >>> 0, qe(v, "offset");
    const S = this[v], F = this[v + 7];
    (S === void 0 || F === void 0) && Hn(v, this.length - 8);
    const U = (S << 24) + // Overflow
    this[++v] * 2 ** 16 + this[++v] * 2 ** 8 + this[++v];
    return (BigInt(U) << BigInt(32)) + BigInt(this[++v] * 2 ** 24 + this[++v] * 2 ** 16 + this[++v] * 2 ** 8 + F);
  }), u.prototype.readFloatLE = function(v, S) {
    return v = v >>> 0, S || Je(v, 4, this.length), n.read(this, v, !0, 23, 4);
  }, u.prototype.readFloatBE = function(v, S) {
    return v = v >>> 0, S || Je(v, 4, this.length), n.read(this, v, !1, 23, 4);
  }, u.prototype.readDoubleLE = function(v, S) {
    return v = v >>> 0, S || Je(v, 8, this.length), n.read(this, v, !0, 52, 8);
  }, u.prototype.readDoubleBE = function(v, S) {
    return v = v >>> 0, S || Je(v, 8, this.length), n.read(this, v, !1, 52, 8);
  };
  function Le($, v, S, F, U, z) {
    if (!u.isBuffer($)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (v > U || v < z) throw new RangeError('"value" argument is out of bounds');
    if (S + F > $.length) throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(v, S, F, U) {
    if (v = +v, S = S >>> 0, F = F >>> 0, !U) {
      const pe = Math.pow(2, 8 * F) - 1;
      Le(this, v, S, F, pe, 0);
    }
    let z = 1, G = 0;
    for (this[S] = v & 255; ++G < F && (z *= 256); )
      this[S + G] = v / z & 255;
    return S + F;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(v, S, F, U) {
    if (v = +v, S = S >>> 0, F = F >>> 0, !U) {
      const pe = Math.pow(2, 8 * F) - 1;
      Le(this, v, S, F, pe, 0);
    }
    let z = F - 1, G = 1;
    for (this[S + z] = v & 255; --z >= 0 && (G *= 256); )
      this[S + z] = v / G & 255;
    return S + F;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(v, S, F) {
    return v = +v, S = S >>> 0, F || Le(this, v, S, 1, 255, 0), this[S] = v & 255, S + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(v, S, F) {
    return v = +v, S = S >>> 0, F || Le(this, v, S, 2, 65535, 0), this[S] = v & 255, this[S + 1] = v >>> 8, S + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(v, S, F) {
    return v = +v, S = S >>> 0, F || Le(this, v, S, 2, 65535, 0), this[S] = v >>> 8, this[S + 1] = v & 255, S + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(v, S, F) {
    return v = +v, S = S >>> 0, F || Le(this, v, S, 4, 4294967295, 0), this[S + 3] = v >>> 24, this[S + 2] = v >>> 16, this[S + 1] = v >>> 8, this[S] = v & 255, S + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(v, S, F) {
    return v = +v, S = S >>> 0, F || Le(this, v, S, 4, 4294967295, 0), this[S] = v >>> 24, this[S + 1] = v >>> 16, this[S + 2] = v >>> 8, this[S + 3] = v & 255, S + 4;
  };
  function Yt($, v, S, F, U) {
    _a(v, F, U, $, S, 7);
    let z = Number(v & BigInt(4294967295));
    $[S++] = z, z = z >> 8, $[S++] = z, z = z >> 8, $[S++] = z, z = z >> 8, $[S++] = z;
    let G = Number(v >> BigInt(32) & BigInt(4294967295));
    return $[S++] = G, G = G >> 8, $[S++] = G, G = G >> 8, $[S++] = G, G = G >> 8, $[S++] = G, S;
  }
  function Qe($, v, S, F, U) {
    _a(v, F, U, $, S, 7);
    let z = Number(v & BigInt(4294967295));
    $[S + 7] = z, z = z >> 8, $[S + 6] = z, z = z >> 8, $[S + 5] = z, z = z >> 8, $[S + 4] = z;
    let G = Number(v >> BigInt(32) & BigInt(4294967295));
    return $[S + 3] = G, G = G >> 8, $[S + 2] = G, G = G >> 8, $[S + 1] = G, G = G >> 8, $[S] = G, S + 8;
  }
  u.prototype.writeBigUInt64LE = tn(function(v, S = 0) {
    return Yt(this, v, S, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeBigUInt64BE = tn(function(v, S = 0) {
    return Qe(this, v, S, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeIntLE = function(v, S, F, U) {
    if (v = +v, S = S >>> 0, !U) {
      const He = Math.pow(2, 8 * F - 1);
      Le(this, v, S, F, He - 1, -He);
    }
    let z = 0, G = 1, pe = 0;
    for (this[S] = v & 255; ++z < F && (G *= 256); )
      v < 0 && pe === 0 && this[S + z - 1] !== 0 && (pe = 1), this[S + z] = (v / G >> 0) - pe & 255;
    return S + F;
  }, u.prototype.writeIntBE = function(v, S, F, U) {
    if (v = +v, S = S >>> 0, !U) {
      const He = Math.pow(2, 8 * F - 1);
      Le(this, v, S, F, He - 1, -He);
    }
    let z = F - 1, G = 1, pe = 0;
    for (this[S + z] = v & 255; --z >= 0 && (G *= 256); )
      v < 0 && pe === 0 && this[S + z + 1] !== 0 && (pe = 1), this[S + z] = (v / G >> 0) - pe & 255;
    return S + F;
  }, u.prototype.writeInt8 = function(v, S, F) {
    return v = +v, S = S >>> 0, F || Le(this, v, S, 1, 127, -128), v < 0 && (v = 255 + v + 1), this[S] = v & 255, S + 1;
  }, u.prototype.writeInt16LE = function(v, S, F) {
    return v = +v, S = S >>> 0, F || Le(this, v, S, 2, 32767, -32768), this[S] = v & 255, this[S + 1] = v >>> 8, S + 2;
  }, u.prototype.writeInt16BE = function(v, S, F) {
    return v = +v, S = S >>> 0, F || Le(this, v, S, 2, 32767, -32768), this[S] = v >>> 8, this[S + 1] = v & 255, S + 2;
  }, u.prototype.writeInt32LE = function(v, S, F) {
    return v = +v, S = S >>> 0, F || Le(this, v, S, 4, 2147483647, -2147483648), this[S] = v & 255, this[S + 1] = v >>> 8, this[S + 2] = v >>> 16, this[S + 3] = v >>> 24, S + 4;
  }, u.prototype.writeInt32BE = function(v, S, F) {
    return v = +v, S = S >>> 0, F || Le(this, v, S, 4, 2147483647, -2147483648), v < 0 && (v = 4294967295 + v + 1), this[S] = v >>> 24, this[S + 1] = v >>> 16, this[S + 2] = v >>> 8, this[S + 3] = v & 255, S + 4;
  }, u.prototype.writeBigInt64LE = tn(function(v, S = 0) {
    return Yt(this, v, S, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), u.prototype.writeBigInt64BE = tn(function(v, S = 0) {
    return Qe(this, v, S, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Dt($, v, S, F, U, z) {
    if (S + F > $.length) throw new RangeError("Index out of range");
    if (S < 0) throw new RangeError("Index out of range");
  }
  function Kn($, v, S, F, U) {
    return v = +v, S = S >>> 0, U || Dt($, v, S, 4), n.write($, v, S, F, 23, 4), S + 4;
  }
  u.prototype.writeFloatLE = function(v, S, F) {
    return Kn(this, v, S, !0, F);
  }, u.prototype.writeFloatBE = function(v, S, F) {
    return Kn(this, v, S, !1, F);
  };
  function ga($, v, S, F, U) {
    return v = +v, S = S >>> 0, U || Dt($, v, S, 8), n.write($, v, S, F, 52, 8), S + 8;
  }
  u.prototype.writeDoubleLE = function(v, S, F) {
    return ga(this, v, S, !0, F);
  }, u.prototype.writeDoubleBE = function(v, S, F) {
    return ga(this, v, S, !1, F);
  }, u.prototype.copy = function(v, S, F, U) {
    if (!u.isBuffer(v)) throw new TypeError("argument should be a Buffer");
    if (F || (F = 0), !U && U !== 0 && (U = this.length), S >= v.length && (S = v.length), S || (S = 0), U > 0 && U < F && (U = F), U === F || v.length === 0 || this.length === 0) return 0;
    if (S < 0)
      throw new RangeError("targetStart out of bounds");
    if (F < 0 || F >= this.length) throw new RangeError("Index out of range");
    if (U < 0) throw new RangeError("sourceEnd out of bounds");
    U > this.length && (U = this.length), v.length - S < U - F && (U = v.length - S + F);
    const z = U - F;
    return this === v && typeof i.prototype.copyWithin == "function" ? this.copyWithin(S, F, U) : i.prototype.set.call(
      v,
      this.subarray(F, U),
      S
    ), z;
  }, u.prototype.fill = function(v, S, F, U) {
    if (typeof v == "string") {
      if (typeof S == "string" ? (U = S, S = 0, F = this.length) : typeof F == "string" && (U = F, F = this.length), U !== void 0 && typeof U != "string")
        throw new TypeError("encoding must be a string");
      if (typeof U == "string" && !u.isEncoding(U))
        throw new TypeError("Unknown encoding: " + U);
      if (v.length === 1) {
        const G = v.charCodeAt(0);
        (U === "utf8" && G < 128 || U === "latin1") && (v = G);
      }
    } else typeof v == "number" ? v = v & 255 : typeof v == "boolean" && (v = Number(v));
    if (S < 0 || this.length < S || this.length < F)
      throw new RangeError("Out of range index");
    if (F <= S)
      return this;
    S = S >>> 0, F = F === void 0 ? this.length : F >>> 0, v || (v = 0);
    let z;
    if (typeof v == "number")
      for (z = S; z < F; ++z)
        this[z] = v;
    else {
      const G = u.isBuffer(v) ? v : u.from(v, U), pe = G.length;
      if (pe === 0)
        throw new TypeError('The value "' + v + '" is invalid for argument "value"');
      for (z = 0; z < F - S; ++z)
        this[z + S] = G[z % pe];
    }
    return this;
  };
  const en = {};
  function hn($, v, S) {
    en[$] = class extends S {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: v.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${$}]`, delete this.name;
      }
      get code() {
        return $;
      }
      set code(U) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: U,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${$}]: ${this.message}`;
      }
    };
  }
  hn(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function($) {
      return $ ? `${$} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), hn(
    "ERR_INVALID_ARG_TYPE",
    function($, v) {
      return `The "${$}" argument must be of type number. Received type ${typeof v}`;
    },
    TypeError
  ), hn(
    "ERR_OUT_OF_RANGE",
    function($, v, S) {
      let F = `The value of "${$}" is out of range.`, U = S;
      return Number.isInteger(S) && Math.abs(S) > 2 ** 32 ? U = So(String(S)) : typeof S == "bigint" && (U = String(S), (S > BigInt(2) ** BigInt(32) || S < -(BigInt(2) ** BigInt(32))) && (U = So(U)), U += "n"), F += ` It must be ${v}. Received ${U}`, F;
    },
    RangeError
  );
  function So($) {
    let v = "", S = $.length;
    const F = $[0] === "-" ? 1 : 0;
    for (; S >= F + 4; S -= 3)
      v = `_${$.slice(S - 3, S)}${v}`;
    return `${$.slice(0, S)}${v}`;
  }
  function pn($, v, S) {
    qe(v, "offset"), ($[v] === void 0 || $[v + S] === void 0) && Hn(v, $.length - (S + 1));
  }
  function _a($, v, S, F, U, z) {
    if ($ > S || $ < v) {
      const G = typeof v == "bigint" ? "n" : "";
      let pe;
      throw v === 0 || v === BigInt(0) ? pe = `>= 0${G} and < 2${G} ** ${(z + 1) * 8}${G}` : pe = `>= -(2${G} ** ${(z + 1) * 8 - 1}${G}) and < 2 ** ${(z + 1) * 8 - 1}${G}`, new en.ERR_OUT_OF_RANGE("value", pe, $);
    }
    pn(F, U, z);
  }
  function qe($, v) {
    if (typeof $ != "number")
      throw new en.ERR_INVALID_ARG_TYPE(v, "number", $);
  }
  function Hn($, v, S) {
    throw Math.floor($) !== $ ? (qe($, S), new en.ERR_OUT_OF_RANGE("offset", "an integer", $)) : v < 0 ? new en.ERR_BUFFER_OUT_OF_BOUNDS() : new en.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${v}`,
      $
    );
  }
  const Gn = /[^+/0-9A-Za-z-_]/g;
  function lu($) {
    if ($ = $.split("=")[0], $ = $.trim().replace(Gn, ""), $.length < 2) return "";
    for (; $.length % 4 !== 0; )
      $ = $ + "=";
    return $;
  }
  function Oo($, v) {
    v = v || 1 / 0;
    let S;
    const F = $.length;
    let U = null;
    const z = [];
    for (let G = 0; G < F; ++G) {
      if (S = $.charCodeAt(G), S > 55295 && S < 57344) {
        if (!U) {
          if (S > 56319) {
            (v -= 3) > -1 && z.push(239, 191, 189);
            continue;
          } else if (G + 1 === F) {
            (v -= 3) > -1 && z.push(239, 191, 189);
            continue;
          }
          U = S;
          continue;
        }
        if (S < 56320) {
          (v -= 3) > -1 && z.push(239, 191, 189), U = S;
          continue;
        }
        S = (U - 55296 << 10 | S - 56320) + 65536;
      } else U && (v -= 3) > -1 && z.push(239, 191, 189);
      if (U = null, S < 128) {
        if ((v -= 1) < 0) break;
        z.push(S);
      } else if (S < 2048) {
        if ((v -= 2) < 0) break;
        z.push(
          S >> 6 | 192,
          S & 63 | 128
        );
      } else if (S < 65536) {
        if ((v -= 3) < 0) break;
        z.push(
          S >> 12 | 224,
          S >> 6 & 63 | 128,
          S & 63 | 128
        );
      } else if (S < 1114112) {
        if ((v -= 4) < 0) break;
        z.push(
          S >> 18 | 240,
          S >> 12 & 63 | 128,
          S >> 6 & 63 | 128,
          S & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return z;
  }
  function jo($) {
    const v = [];
    for (let S = 0; S < $.length; ++S)
      v.push($.charCodeAt(S) & 255);
    return v;
  }
  function In($, v) {
    let S, F, U;
    const z = [];
    for (let G = 0; G < $.length && !((v -= 2) < 0); ++G)
      S = $.charCodeAt(G), F = S >> 8, U = S % 256, z.push(U), z.push(F);
    return z;
  }
  function Hs($) {
    return e.toByteArray(lu($));
  }
  function ya($, v, S, F) {
    let U;
    for (U = 0; U < F && !(U + S >= v.length || U >= $.length); ++U)
      v[U + S] = $[U];
    return U;
  }
  function St($, v) {
    return $ instanceof v || $ != null && $.constructor != null && $.constructor.name != null && $.constructor.name === v.name;
  }
  function vr($) {
    return $ !== $;
  }
  const Po = function() {
    const $ = "0123456789abcdef", v = new Array(256);
    for (let S = 0; S < 16; ++S) {
      const F = S * 16;
      for (let U = 0; U < 16; ++U)
        v[F + U] = $[S] + $[U];
    }
    return v;
  }();
  function tn($) {
    return typeof BigInt > "u" ? uf : $;
  }
  function uf() {
    throw new Error("BigInt not supported");
  }
})(KP);
const Ke = KP.Buffer, Ru = "4.89.1";
let Iy = !1, Hl, GP, WP, Nb, XP, QP, YP, eR, tR;
function gE(t, e = { auto: !1 }) {
  if (Iy)
    throw new Error(`you must \`import 'openai/shims/${t.kind}'\` before importing anything else from openai`);
  if (Hl)
    throw new Error(`can't \`import 'openai/shims/${t.kind}'\` after \`import 'openai/shims/${Hl}'\``);
  Iy = e.auto, Hl = t.kind, GP = t.fetch, WP = t.FormData, Nb = t.File, XP = t.ReadableStream, QP = t.getMultipartRequestOptions, YP = t.getDefaultAgent, eR = t.fileFromPath, tR = t.isFsReadStream;
}
let _E = class {
  constructor(e) {
    this.body = e;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};
function yE({ manuallyImported: t } = {}) {
  const e = t ? "You may need to use polyfills" : "Add one of these imports before your first `import  from 'openai'`:\n- `import 'openai/shims/node'` (if you're running on Node)\n- `import 'openai/shims/web'` (otherwise)\n";
  let n, a, r, i;
  try {
    n = fetch, a = Request, r = Response, i = Headers;
  } catch (s) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${s.message}. ${e}`);
  }
  return {
    kind: "web",
    fetch: n,
    Request: a,
    Response: r,
    Headers: i,
    FormData: (
      // @ts-ignore
      typeof FormData < "u" ? FormData : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`);
        }
      }
    ),
    Blob: typeof Blob < "u" ? Blob : class {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File < "u" ? File : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream < "u" ? ReadableStream : class {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`);
        }
      }
    ),
    getMultipartRequestOptions: async (s, o) => ({
      ...o,
      body: new _E(s)
    }),
    getDefaultAgent: (s) => {
    },
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (s) => !1
  };
}
Hl || gE(yE(), { auto: !0 });
class de extends Error {
}
let cn = class kb extends de {
  constructor(e, n, a, r) {
    super(`${kb.makeMessage(e, n, a)}`), this.status = e, this.headers = r, this.request_id = r?.["x-request-id"], this.error = n;
    const i = n;
    this.code = i?.code, this.param = i?.param, this.type = i?.type;
  }
  static makeMessage(e, n, a) {
    const r = n?.message ? typeof n.message == "string" ? n.message : JSON.stringify(n.message) : n ? JSON.stringify(n) : a;
    return e && r ? `${e} ${r}` : e ? `${e} status code (no body)` : r || "(no status code or body)";
  }
  static generate(e, n, a, r) {
    if (!e || !r)
      return new hp({ message: a, cause: Db(n) });
    const i = n?.error;
    return e === 400 ? new nR(e, i, a, r) : e === 401 ? new rR(e, i, a, r) : e === 403 ? new aR(e, i, a, r) : e === 404 ? new iR(e, i, a, r) : e === 409 ? new sR(e, i, a, r) : e === 422 ? new oR(e, i, a, r) : e === 429 ? new uR(e, i, a, r) : e >= 500 ? new cR(e, i, a, r) : new kb(e, i, a, r);
  }
}, On = class extends cn {
  constructor({ message: e } = {}) {
    super(void 0, void 0, e || "Request was aborted.", void 0);
  }
}, hp = class extends cn {
  constructor({ message: e, cause: n }) {
    super(void 0, void 0, e || "Connection error.", void 0), n && (this.cause = n);
  }
}, pp = class extends hp {
  constructor({ message: e } = {}) {
    super({ message: e ?? "Request timed out." });
  }
}, nR = class extends cn {
}, rR = class extends cn {
}, aR = class extends cn {
}, iR = class extends cn {
}, sR = class extends cn {
}, oR = class extends cn {
}, uR = class extends cn {
}, cR = class extends cn {
};
class lR extends de {
  constructor() {
    super("Could not parse response content as the length limit was reached");
  }
}
class dR extends de {
  constructor() {
    super("Could not parse response content as the request was rejected by the content filter");
  }
}
var lf = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, Ro = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, bn;
let mp = class {
  constructor() {
    bn.set(this, void 0), this.buffer = new Uint8Array(), lf(this, bn, null, "f");
  }
  decode(e) {
    if (e == null)
      return [];
    const n = e instanceof ArrayBuffer ? new Uint8Array(e) : typeof e == "string" ? new TextEncoder().encode(e) : e;
    let a = new Uint8Array(this.buffer.length + n.length);
    a.set(this.buffer), a.set(n, this.buffer.length), this.buffer = a;
    const r = [];
    let i;
    for (; (i = wE(this.buffer, Ro(this, bn, "f"))) != null; ) {
      if (i.carriage && Ro(this, bn, "f") == null) {
        lf(this, bn, i.index, "f");
        continue;
      }
      if (Ro(this, bn, "f") != null && (i.index !== Ro(this, bn, "f") + 1 || i.carriage)) {
        r.push(this.decodeText(this.buffer.slice(0, Ro(this, bn, "f") - 1))), this.buffer = this.buffer.slice(Ro(this, bn, "f")), lf(this, bn, null, "f");
        continue;
      }
      const s = Ro(this, bn, "f") !== null ? i.preceding - 1 : i.preceding, o = this.decodeText(this.buffer.slice(0, s));
      r.push(o), this.buffer = this.buffer.slice(i.index), lf(this, bn, null, "f");
    }
    return r;
  }
  decodeText(e) {
    if (e == null)
      return "";
    if (typeof e == "string")
      return e;
    if (typeof Ke < "u") {
      if (e instanceof Ke)
        return e.toString();
      if (e instanceof Uint8Array)
        return Ke.from(e).toString();
      throw new de(`Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder < "u") {
      if (e instanceof Uint8Array || e instanceof ArrayBuffer)
        return this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8")), this.textDecoder.decode(e);
      throw new de(`Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new de("Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.");
  }
  flush() {
    return this.buffer.length ? this.decode(`
`) : [];
  }
};
bn = /* @__PURE__ */ new WeakMap();
mp.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r"]);
mp.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function wE(t, e) {
  for (let r = e ?? 0; r < t.length; r++) {
    if (t[r] === 10)
      return { preceding: r, index: r + 1, carriage: !1 };
    if (t[r] === 13)
      return { preceding: r, index: r + 1, carriage: !0 };
  }
  return null;
}
function vE(t) {
  for (let a = 0; a < t.length - 1; a++) {
    if (t[a] === 10 && t[a + 1] === 10 || t[a] === 13 && t[a + 1] === 13)
      return a + 2;
    if (t[a] === 13 && t[a + 1] === 10 && a + 3 < t.length && t[a + 2] === 13 && t[a + 3] === 10)
      return a + 4;
  }
  return -1;
}
function fR(t) {
  if (t[Symbol.asyncIterator])
    return t;
  const e = t.getReader();
  return {
    async next() {
      try {
        const n = await e.read();
        return n?.done && e.releaseLock(), n;
      } catch (n) {
        throw e.releaseLock(), n;
      }
    },
    async return() {
      const n = e.cancel();
      return e.releaseLock(), await n, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
let od = class kl {
  constructor(e, n) {
    this.iterator = e, this.controller = n;
  }
  static fromSSEResponse(e, n) {
    let a = !1;
    async function* r() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let i = !1;
      try {
        for await (const s of SE(e, n))
          if (!i) {
            if (s.data.startsWith("[DONE]")) {
              i = !0;
              continue;
            }
            if (s.event === null || s.event.startsWith("response.")) {
              let o;
              try {
                o = JSON.parse(s.data);
              } catch (l) {
                throw console.error("Could not parse message into JSON:", s.data), console.error("From chunk:", s.raw), l;
              }
              if (o && o.error)
                throw new cn(void 0, o.error, void 0, void 0);
              yield o;
            } else {
              let o;
              try {
                o = JSON.parse(s.data);
              } catch (l) {
                throw console.error("Could not parse message into JSON:", s.data), console.error("From chunk:", s.raw), l;
              }
              if (s.event == "error")
                throw new cn(void 0, o.error, o.message, void 0);
              yield { event: s.event, data: o };
            }
          }
        i = !0;
      } catch (s) {
        if (s instanceof Error && s.name === "AbortError")
          return;
        throw s;
      } finally {
        i || n.abort();
      }
    }
    return new kl(r, n);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(e, n) {
    let a = !1;
    async function* r() {
      const s = new mp(), o = fR(e);
      for await (const l of o)
        for (const f of s.decode(l))
          yield f;
      for (const l of s.flush())
        yield l;
    }
    async function* i() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let s = !1;
      try {
        for await (const o of r())
          s || o && (yield JSON.parse(o));
        s = !0;
      } catch (o) {
        if (o instanceof Error && o.name === "AbortError")
          return;
        throw o;
      } finally {
        s || n.abort();
      }
    }
    return new kl(i, n);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const e = [], n = [], a = this.iterator(), r = (i) => ({
      next: () => {
        if (i.length === 0) {
          const s = a.next();
          e.push(s), n.push(s);
        }
        return i.shift();
      }
    });
    return [
      new kl(() => r(e), this.controller),
      new kl(() => r(n), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const e = this;
    let n;
    const a = new TextEncoder();
    return new XP({
      async start() {
        n = e[Symbol.asyncIterator]();
      },
      async pull(r) {
        try {
          const { value: i, done: s } = await n.next();
          if (s)
            return r.close();
          const o = a.encode(JSON.stringify(i) + `
`);
          r.enqueue(o);
        } catch (i) {
          r.error(i);
        }
      },
      async cancel() {
        await n.return?.();
      }
    });
  }
};
async function* SE(t, e) {
  if (!t.body)
    throw e.abort(), new de("Attempted to iterate over a response with no body");
  const n = new jE(), a = new mp(), r = fR(t.body);
  for await (const i of OE(r))
    for (const s of a.decode(i)) {
      const o = n.decode(s);
      o && (yield o);
    }
  for (const i of a.flush()) {
    const s = n.decode(i);
    s && (yield s);
  }
}
async function* OE(t) {
  let e = new Uint8Array();
  for await (const n of t) {
    if (n == null)
      continue;
    const a = n instanceof ArrayBuffer ? new Uint8Array(n) : typeof n == "string" ? new TextEncoder().encode(n) : n;
    let r = new Uint8Array(e.length + a.length);
    r.set(e), r.set(a, e.length), e = r;
    let i;
    for (; (i = vE(e)) !== -1; )
      yield e.slice(0, i), e = e.slice(i);
  }
  e.length > 0 && (yield e);
}
let jE = class {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(e) {
    if (e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e) {
      if (!this.event && !this.data.length)
        return null;
      const i = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], i;
    }
    if (this.chunks.push(e), e.startsWith(":"))
      return null;
    let [n, a, r] = PE(e, ":");
    return r.startsWith(" ") && (r = r.substring(1)), n === "event" ? this.event = r : n === "data" && this.data.push(r), null;
  }
};
function PE(t, e) {
  const n = t.indexOf(e);
  return n !== -1 ? [t.substring(0, n), e, t.substring(n + e.length)] : [t, "", ""];
}
const hR = (t) => t != null && typeof t == "object" && typeof t.url == "string" && typeof t.blob == "function", pR = (t) => t != null && typeof t == "object" && typeof t.name == "string" && typeof t.lastModified == "number" && bp(t), bp = (t) => t != null && typeof t == "object" && typeof t.size == "number" && typeof t.type == "string" && typeof t.text == "function" && typeof t.slice == "function" && typeof t.arrayBuffer == "function", RE = (t) => pR(t) || hR(t) || tR(t);
async function mR(t, e, n) {
  if (t = await t, pR(t))
    return t;
  if (hR(t)) {
    const r = await t.blob();
    e || (e = new URL(t.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const i = bp(r) ? [await r.arrayBuffer()] : [r];
    return new Nb(i, e, n);
  }
  const a = await CE(t);
  if (e || (e = $E(t) ?? "unknown_file"), !n?.type) {
    const r = a[0]?.type;
    typeof r == "string" && (n = { ...n, type: r });
  }
  return new Nb(a, e, n);
}
async function CE(t) {
  let e = [];
  if (typeof t == "string" || ArrayBuffer.isView(t) || // includes Uint8Array, Buffer, etc.
  t instanceof ArrayBuffer)
    e.push(t);
  else if (bp(t))
    e.push(await t.arrayBuffer());
  else if (ME(t))
    for await (const n of t)
      e.push(n);
  else
    throw new Error(`Unexpected data type: ${typeof t}; constructor: ${t?.constructor?.name}; props: ${TE(t)}`);
  return e;
}
function TE(t) {
  return `[${Object.getOwnPropertyNames(t).map((n) => `"${n}"`).join(", ")}]`;
}
function $E(t) {
  return om(t.name) || om(t.filename) || // For fs.ReadStream
  om(t.path)?.split(/[\\/]/).pop();
}
const om = (t) => {
  if (typeof t == "string")
    return t;
  if (typeof Ke < "u" && t instanceof Ke)
    return String(t);
}, ME = (t) => t != null && typeof t == "object" && typeof t[Symbol.asyncIterator] == "function", Ny = (t) => t && typeof t == "object" && t.body && t[Symbol.toStringTag] === "MultipartBody", Ku = async (t) => {
  const e = await AE(t.body);
  return QP(e, t);
}, AE = async (t) => {
  const e = new WP();
  return await Promise.all(Object.entries(t || {}).map(([n, a]) => Fb(e, n, a))), e;
}, Fb = async (t, e, n) => {
  if (n !== void 0) {
    if (n == null)
      throw new TypeError(`Received null for "${e}"; to pass null in FormData, you must use the string 'null'`);
    if (typeof n == "string" || typeof n == "number" || typeof n == "boolean")
      t.append(e, String(n));
    else if (RE(n)) {
      const a = await mR(n);
      t.append(e, a);
    } else if (Array.isArray(n))
      await Promise.all(n.map((a) => Fb(t, e + "[]", a)));
    else if (typeof n == "object")
      await Promise.all(Object.entries(n).map(([a, r]) => Fb(t, `${e}[${a}]`, r)));
    else
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${n} instead`);
  }
};
var EE = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, IE = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, df;
async function bR(t) {
  const { response: e } = t;
  if (t.options.stream)
    return Uu("response", e.status, e.url, e.headers, e.body), t.options.__streamClass ? t.options.__streamClass.fromSSEResponse(e, t.controller) : od.fromSSEResponse(e, t.controller);
  if (e.status === 204)
    return null;
  if (t.options.__binaryResponse)
    return e;
  const a = e.headers.get("content-type")?.split(";")[0]?.trim();
  if (a?.includes("application/json") || a?.endsWith("+json")) {
    const s = await e.json();
    return Uu("response", e.status, e.url, e.headers, s), gR(s, e);
  }
  const i = await e.text();
  return Uu("response", e.status, e.url, e.headers, i), i;
}
function gR(t, e) {
  return !t || typeof t != "object" || Array.isArray(t) ? t : Object.defineProperty(t, "_request_id", {
    value: e.headers.get("x-request-id"),
    enumerable: !1
  });
}
let _R = class yR extends Promise {
  constructor(e, n = bR) {
    super((a) => {
      a(null);
    }), this.responsePromise = e, this.parseResponse = n;
  }
  _thenUnwrap(e) {
    return new yR(this.responsePromise, async (n) => gR(e(await this.parseResponse(n), n), n.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((e) => e.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [e, n] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: e, response: n, request_id: n.headers.get("x-request-id") };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)), this.parsedPromise;
  }
  then(e, n) {
    return this.parse().then(e, n);
  }
  catch(e) {
    return this.parse().catch(e);
  }
  finally(e) {
    return this.parse().finally(e);
  }
}, NE = class {
  constructor({
    baseURL: e,
    maxRetries: n = 2,
    timeout: a = 6e5,
    // 10 minutes
    httpAgent: r,
    fetch: i
  }) {
    this.baseURL = e, this.maxRetries = um("maxRetries", n), this.timeout = um("timeout", a), this.httpAgent = r, this.fetch = i ?? GP;
  }
  authHeaders(e) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(e) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...LE(),
      ...this.authHeaders(e)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(e, n) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${VE()}`;
  }
  get(e, n) {
    return this.methodRequest("get", e, n);
  }
  post(e, n) {
    return this.methodRequest("post", e, n);
  }
  patch(e, n) {
    return this.methodRequest("patch", e, n);
  }
  put(e, n) {
    return this.methodRequest("put", e, n);
  }
  delete(e, n) {
    return this.methodRequest("delete", e, n);
  }
  methodRequest(e, n, a) {
    return this.request(Promise.resolve(a).then(async (r) => {
      const i = r && bp(r?.body) ? new DataView(await r.body.arrayBuffer()) : r?.body instanceof DataView ? r.body : r?.body instanceof ArrayBuffer ? new DataView(r.body) : r && ArrayBuffer.isView(r?.body) ? new DataView(r.body.buffer) : r?.body;
      return { method: e, path: n, ...r, body: i };
    }));
  }
  getAPIList(e, n, a) {
    return this.requestAPIList(n, { method: "get", path: e, ...a });
  }
  calculateContentLength(e) {
    if (typeof e == "string") {
      if (typeof Ke < "u")
        return Ke.byteLength(e, "utf8").toString();
      if (typeof TextEncoder < "u")
        return new TextEncoder().encode(e).length.toString();
    } else if (ArrayBuffer.isView(e))
      return e.byteLength.toString();
    return null;
  }
  buildRequest(e, { retryCount: n = 0 } = {}) {
    e = { ...e };
    const { method: a, path: r, query: i, headers: s = {} } = e, o = ArrayBuffer.isView(e.body) || e.__binaryRequest && typeof e.body == "string" ? e.body : Ny(e.body) ? e.body.body : e.body ? JSON.stringify(e.body, null, 2) : null, l = this.calculateContentLength(o), f = this.buildURL(r, i);
    "timeout" in e && um("timeout", e.timeout), e.timeout = e.timeout ?? this.timeout;
    const u = e.httpAgent ?? this.httpAgent ?? YP(f), c = e.timeout + 1e3;
    typeof u?.options?.timeout == "number" && c > (u.options.timeout ?? 0) && (u.options.timeout = c), this.idempotencyHeader && a !== "get" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()), s[this.idempotencyHeader] = e.idempotencyKey);
    const h = this.buildHeaders({ options: e, headers: s, contentLength: l, retryCount: n });
    return { req: {
      method: a,
      ...o && { body: o },
      headers: h,
      ...u && { agent: u },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: e.signal ?? null
    }, url: f, timeout: e.timeout };
  }
  buildHeaders({ options: e, headers: n, contentLength: a, retryCount: r }) {
    const i = {};
    a && (i["content-length"] = a);
    const s = this.defaultHeaders(e);
    return qy(i, s), qy(i, n), Ny(e.body) && Hl !== "node" && delete i["content-type"], hf(s, "x-stainless-retry-count") === void 0 && hf(n, "x-stainless-retry-count") === void 0 && (i["x-stainless-retry-count"] = String(r)), hf(s, "x-stainless-timeout") === void 0 && hf(n, "x-stainless-timeout") === void 0 && e.timeout && (i["x-stainless-timeout"] = String(e.timeout)), this.validateHeaders(i, n), i;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(e) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(e, { url: n, options: a }) {
  }
  parseHeaders(e) {
    return e ? Symbol.iterator in e ? Object.fromEntries(Array.from(e).map((n) => [...n])) : { ...e } : {};
  }
  makeStatusError(e, n, a, r) {
    return cn.generate(e, n, a, r);
  }
  request(e, n = null) {
    return new _R(this.makeRequest(e, n));
  }
  async makeRequest(e, n) {
    const a = await e, r = a.maxRetries ?? this.maxRetries;
    n == null && (n = r), await this.prepareOptions(a);
    const { req: i, url: s, timeout: o } = this.buildRequest(a, { retryCount: r - n });
    if (await this.prepareRequest(i, { url: s, options: a }), Uu("request", s, a, i.headers), a.signal?.aborted)
      throw new On();
    const l = new AbortController(), f = await this.fetchWithTimeout(s, i, o, l).catch(Db);
    if (f instanceof Error) {
      if (a.signal?.aborted)
        throw new On();
      if (n)
        return this.retryRequest(a, n);
      throw f.name === "AbortError" ? new pp() : new hp({ cause: f });
    }
    const u = FE(f.headers);
    if (!f.ok) {
      if (n && this.shouldRetry(f)) {
        const b = `retrying, ${n} attempts remaining`;
        return Uu(`response (error; ${b})`, f.status, s, u), this.retryRequest(a, n, u);
      }
      const c = await f.text().catch((b) => Db(b).message), h = UE(c), p = h ? void 0 : c;
      throw Uu(`response (error; ${n ? "(error; no more retries left)" : "(error; not retryable)"})`, f.status, s, u, p), this.makeStatusError(f.status, h, p, u);
    }
    return { response: f, options: a, controller: l };
  }
  requestAPIList(e, n) {
    const a = this.makeRequest(n, null);
    return new kE(this, a, e);
  }
  buildURL(e, n) {
    const a = xE(e) ? new URL(e) : new URL(this.baseURL + (this.baseURL.endsWith("/") && e.startsWith("/") ? e.slice(1) : e)), r = this.defaultQuery();
    return vR(r) || (n = { ...r, ...n }), typeof n == "object" && n && !Array.isArray(n) && (a.search = this.stringifyQuery(n)), a.toString();
  }
  stringifyQuery(e) {
    return Object.entries(e).filter(([n, a]) => typeof a < "u").map(([n, a]) => {
      if (typeof a == "string" || typeof a == "number" || typeof a == "boolean")
        return `${encodeURIComponent(n)}=${encodeURIComponent(a)}`;
      if (a === null)
        return `${encodeURIComponent(n)}=`;
      throw new de(`Cannot stringify type ${typeof a}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(e, n, a, r) {
    const { signal: i, ...s } = n || {};
    i && i.addEventListener("abort", () => r.abort());
    const o = setTimeout(() => r.abort(), a), l = {
      signal: r.signal,
      ...s
    };
    return l.method && (l.method = l.method.toUpperCase()), // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
    this.fetch.call(void 0, e, l).finally(() => {
      clearTimeout(o);
    });
  }
  shouldRetry(e) {
    const n = e.headers.get("x-should-retry");
    return n === "true" ? !0 : n === "false" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500;
  }
  async retryRequest(e, n, a) {
    let r;
    const i = a?.["retry-after-ms"];
    if (i) {
      const o = parseFloat(i);
      Number.isNaN(o) || (r = o);
    }
    const s = a?.["retry-after"];
    if (s && !r) {
      const o = parseFloat(s);
      Number.isNaN(o) ? r = Date.parse(s) - Date.now() : r = o * 1e3;
    }
    if (!(r && 0 <= r && r < 60 * 1e3)) {
      const o = e.maxRetries ?? this.maxRetries;
      r = this.calculateDefaultRetryTimeoutMillis(n, o);
    }
    return await Dd(r), this.makeRequest(e, n - 1);
  }
  calculateDefaultRetryTimeoutMillis(e, n) {
    const i = n - e, s = Math.min(0.5 * Math.pow(2, i), 8), o = 1 - Math.random() * 0.25;
    return s * o * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${Ru}`;
  }
}, wR = class {
  constructor(e, n, a, r) {
    df.set(this, void 0), EE(this, df, e, "f"), this.options = r, this.response = n, this.body = a;
  }
  hasNextPage() {
    return this.getPaginatedItems().length ? this.nextPageInfo() != null : !1;
  }
  async getNextPage() {
    const e = this.nextPageInfo();
    if (!e)
      throw new de("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    const n = { ...this.options };
    if ("params" in e && typeof n.query == "object")
      n.query = { ...n.query, ...e.params };
    else if ("url" in e) {
      const a = [...Object.entries(n.query || {}), ...e.url.searchParams.entries()];
      for (const [r, i] of a)
        e.url.searchParams.set(r, i);
      n.query = void 0, n.path = e.url.toString();
    }
    return await IE(this, df, "f").requestAPIList(this.constructor, n);
  }
  async *iterPages() {
    let e = this;
    for (yield e; e.hasNextPage(); )
      e = await e.getNextPage(), yield e;
  }
  async *[(df = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const e of this.iterPages())
      for (const n of e.getPaginatedItems())
        yield n;
  }
}, kE = class extends _R {
  constructor(e, n, a) {
    super(n, async (r) => new a(e, r.response, await bR(r), r.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const e = await this;
    for await (const n of e)
      yield n;
  }
};
const FE = (t) => new Proxy(Object.fromEntries(
  // @ts-ignore
  t.entries()
), {
  get(e, n) {
    const a = n.toString();
    return e[a.toLowerCase()] || e[a];
  }
}), DE = {
  method: !0,
  path: !0,
  query: !0,
  body: !0,
  headers: !0,
  maxRetries: !0,
  stream: !0,
  timeout: !0,
  httpAgent: !0,
  signal: !0,
  idempotencyKey: !0,
  __metadata: !0,
  __binaryRequest: !0,
  __binaryResponse: !0,
  __streamClass: !0
}, Tt = (t) => typeof t == "object" && t !== null && !vR(t) && Object.keys(t).every((e) => SR(DE, e)), qE = () => {
  if (typeof Deno < "u" && Deno.build != null)
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Ru,
      "X-Stainless-OS": Fy(Deno.build.os),
      "X-Stainless-Arch": ky(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Ru,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": ue.version
    };
  if (Object.prototype.toString.call(typeof ue < "u" ? ue : 0) === "[object process]")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Ru,
      "X-Stainless-OS": Fy(ue.platform),
      "X-Stainless-Arch": ky(ue.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": ue.version
    };
  const t = JE();
  return t ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Ru,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${t.browser}`,
    "X-Stainless-Runtime-Version": t.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Ru,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function JE() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const t = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: e, pattern: n } of t) {
    const a = n.exec(navigator.userAgent);
    if (a) {
      const r = a[1] || 0, i = a[2] || 0, s = a[3] || 0;
      return { browser: e, version: `${r}.${i}.${s}` };
    }
  }
  return null;
}
const ky = (t) => t === "x32" ? "x32" : t === "x86_64" || t === "x64" ? "x64" : t === "arm" ? "arm" : t === "aarch64" || t === "arm64" ? "arm64" : t ? `other:${t}` : "unknown", Fy = (t) => (t = t.toLowerCase(), t.includes("ios") ? "iOS" : t === "android" ? "Android" : t === "darwin" ? "MacOS" : t === "win32" ? "Windows" : t === "freebsd" ? "FreeBSD" : t === "openbsd" ? "OpenBSD" : t === "linux" ? "Linux" : t ? `Other:${t}` : "Unknown");
let Dy;
const LE = () => Dy ?? (Dy = qE()), UE = (t) => {
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}, BE = /^[a-z][a-z0-9+.-]*:/i, xE = (t) => BE.test(t), Dd = (t) => new Promise((e) => setTimeout(e, t)), um = (t, e) => {
  if (typeof e != "number" || !Number.isInteger(e))
    throw new de(`${t} must be an integer`);
  if (e < 0)
    throw new de(`${t} must be a positive integer`);
  return e;
}, Db = (t) => {
  if (t instanceof Error)
    return t;
  if (typeof t == "object" && t !== null)
    try {
      return new Error(JSON.stringify(t));
    } catch {
    }
  return new Error(t);
}, ff = (t) => {
  if (typeof ue < "u")
    return ue.env?.[t]?.trim() ?? void 0;
  if (typeof Deno < "u")
    return Deno.env?.get?.(t)?.trim();
};
function vR(t) {
  if (!t)
    return !0;
  for (const e in t)
    return !1;
  return !0;
}
function SR(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function qy(t, e) {
  for (const n in e) {
    if (!SR(e, n))
      continue;
    const a = n.toLowerCase();
    if (!a)
      continue;
    const r = e[n];
    r === null ? delete t[a] : r !== void 0 && (t[a] = r);
  }
}
const Jy = /* @__PURE__ */ new Set(["authorization", "api-key"]);
function Uu(t, ...e) {
  if (typeof ue < "u" && ue?.env?.DEBUG === "true") {
    const n = e.map((a) => {
      if (!a)
        return a;
      if (a.headers) {
        const i = { ...a, headers: { ...a.headers } };
        for (const s in a.headers)
          Jy.has(s.toLowerCase()) && (i.headers[s] = "REDACTED");
        return i;
      }
      let r = null;
      for (const i in a)
        Jy.has(i.toLowerCase()) && (r ?? (r = { ...a }), r[i] = "REDACTED");
      return r ?? a;
    });
    console.log(`OpenAI:DEBUG:${t}`, ...n);
  }
}
const VE = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
  const e = Math.random() * 16 | 0;
  return (t === "x" ? e : e & 3 | 8).toString(16);
}), zE = () => (
  // @ts-ignore
  typeof window < "u" && // @ts-ignore
  typeof window.document < "u" && // @ts-ignore
  typeof navigator < "u"
), ZE = (t) => typeof t?.get == "function", hf = (t, e) => {
  const n = e.toLowerCase();
  if (ZE(t)) {
    const a = e[0]?.toUpperCase() + e.substring(1).replace(/([^\w])(\w)/g, (r, i, s) => i + s.toUpperCase());
    for (const r of [e, n, e.toUpperCase(), a]) {
      const i = t.get(r);
      if (i)
        return i;
    }
  }
  for (const [a, r] of Object.entries(t))
    if (a.toLowerCase() === n)
      return Array.isArray(r) ? (r.length <= 1 || console.warn(`Received ${r.length} entries for the ${e} header, using the first entry.`), r[0]) : r;
};
function cm(t) {
  return t != null && typeof t == "object" && !Array.isArray(t);
}
let Eg = class extends wR {
  constructor(e, n, a, r) {
    super(e, n, a, r), this.data = a.data || [], this.object = a.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
class fn extends wR {
  constructor(e, n, a, r) {
    super(e, n, a, r), this.data = a.data || [], this.has_more = a.has_more || !1;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const e = this.nextPageInfo();
    if (!e)
      return null;
    if ("params" in e)
      return e.params;
    const n = Object.fromEntries(e.url.searchParams);
    return Object.keys(n).length ? n : null;
  }
  nextPageInfo() {
    const e = this.getPaginatedItems();
    if (!e.length)
      return null;
    const n = e[e.length - 1]?.id;
    return n ? { params: { after: n } } : null;
  }
}
let Pe = class {
  constructor(e) {
    this._client = e;
  }
}, OR = class extends Pe {
  list(e, n = {}, a) {
    return Tt(n) ? this.list(e, {}, n) : this._client.getAPIList(`/chat/completions/${e}/messages`, KE, { query: n, ...a });
  }
}, gp = class extends Pe {
  constructor() {
    super(...arguments), this.messages = new OR(this._client);
  }
  create(e, n) {
    return this._client.post("/chat/completions", { body: e, ...n, stream: e.stream ?? !1 });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   */
  retrieve(e, n) {
    return this._client.get(`/chat/completions/${e}`, n);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   */
  update(e, n, a) {
    return this._client.post(`/chat/completions/${e}`, { body: n, ...a });
  }
  list(e = {}, n) {
    return Tt(e) ? this.list({}, e) : this._client.getAPIList("/chat/completions", _p, { query: e, ...n });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   */
  del(e, n) {
    return this._client.delete(`/chat/completions/${e}`, n);
  }
};
class _p extends fn {
}
class KE extends fn {
}
gp.ChatCompletionsPage = _p;
gp.Messages = OR;
let yp = class extends Pe {
  constructor() {
    super(...arguments), this.completions = new gp(this._client);
  }
};
yp.Completions = gp;
yp.ChatCompletionsPage = _p;
class jR extends Pe {
  /**
   * Generates audio from the input text.
   */
  create(e, n) {
    return this._client.post("/audio/speech", {
      body: e,
      ...n,
      headers: { Accept: "application/octet-stream", ...n?.headers },
      __binaryResponse: !0
    });
  }
}
let PR = class extends Pe {
  create(e, n) {
    return this._client.post("/audio/transcriptions", Ku({ body: e, ...n, __metadata: { model: e.model } }));
  }
}, RR = class extends Pe {
  create(e, n) {
    return this._client.post("/audio/translations", Ku({ body: e, ...n, __metadata: { model: e.model } }));
  }
}, qd = class extends Pe {
  constructor() {
    super(...arguments), this.transcriptions = new PR(this._client), this.translations = new RR(this._client), this.speech = new jR(this._client);
  }
};
qd.Transcriptions = PR;
qd.Translations = RR;
qd.Speech = jR;
let Ig = class extends Pe {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(e, n) {
    return this._client.post("/batches", { body: e, ...n });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(e, n) {
    return this._client.get(`/batches/${e}`, n);
  }
  list(e = {}, n) {
    return Tt(e) ? this.list({}, e) : this._client.getAPIList("/batches", Ng, { query: e, ...n });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(e, n) {
    return this._client.post(`/batches/${e}/cancel`, n);
  }
};
class Ng extends fn {
}
Ig.BatchesPage = Ng;
class kg extends Pe {
  /**
   * Create an assistant with a model and instructions.
   */
  create(e, n) {
    return this._client.post("/assistants", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Retrieves an assistant.
   */
  retrieve(e, n) {
    return this._client.get(`/assistants/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Modifies an assistant.
   */
  update(e, n, a) {
    return this._client.post(`/assistants/${e}`, {
      body: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  list(e = {}, n) {
    return Tt(e) ? this.list({}, e) : this._client.getAPIList("/assistants", Fg, {
      query: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Delete an assistant.
   */
  del(e, n) {
    return this._client.delete(`/assistants/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
}
class Fg extends fn {
}
kg.AssistantsPage = Fg;
function Ly(t) {
  return typeof t.parse == "function";
}
const Bu = (t) => t?.role === "assistant", CR = (t) => t?.role === "function", TR = (t) => t?.role === "tool";
var ir = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, et = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, qb, ih, sh, Fl, Dl, oh, ql, Ns, Jl, wh, vh, Cu, $R;
class Dg {
  constructor() {
    qb.add(this), this.controller = new AbortController(), ih.set(this, void 0), sh.set(this, () => {
    }), Fl.set(this, () => {
    }), Dl.set(this, void 0), oh.set(this, () => {
    }), ql.set(this, () => {
    }), Ns.set(this, {}), Jl.set(this, !1), wh.set(this, !1), vh.set(this, !1), Cu.set(this, !1), ir(this, ih, new Promise((e, n) => {
      ir(this, sh, e, "f"), ir(this, Fl, n, "f");
    }), "f"), ir(this, Dl, new Promise((e, n) => {
      ir(this, oh, e, "f"), ir(this, ql, n, "f");
    }), "f"), et(this, ih, "f").catch(() => {
    }), et(this, Dl, "f").catch(() => {
    });
  }
  _run(e) {
    setTimeout(() => {
      e().then(() => {
        this._emitFinal(), this._emit("end");
      }, et(this, qb, "m", $R).bind(this));
    }, 0);
  }
  _connected() {
    this.ended || (et(this, sh, "f").call(this), this._emit("connect"));
  }
  get ended() {
    return et(this, Jl, "f");
  }
  get errored() {
    return et(this, wh, "f");
  }
  get aborted() {
    return et(this, vh, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(e, n) {
    return (et(this, Ns, "f")[e] || (et(this, Ns, "f")[e] = [])).push({ listener: n }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(e, n) {
    const a = et(this, Ns, "f")[e];
    if (!a)
      return this;
    const r = a.findIndex((i) => i.listener === n);
    return r >= 0 && a.splice(r, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(e, n) {
    return (et(this, Ns, "f")[e] || (et(this, Ns, "f")[e] = [])).push({ listener: n, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(e) {
    return new Promise((n, a) => {
      ir(this, Cu, !0, "f"), e !== "error" && this.once("error", a), this.once(e, n);
    });
  }
  async done() {
    ir(this, Cu, !0, "f"), await et(this, Dl, "f");
  }
  _emit(e, ...n) {
    if (et(this, Jl, "f"))
      return;
    e === "end" && (ir(this, Jl, !0, "f"), et(this, oh, "f").call(this));
    const a = et(this, Ns, "f")[e];
    if (a && (et(this, Ns, "f")[e] = a.filter((r) => !r.once), a.forEach(({ listener: r }) => r(...n))), e === "abort") {
      const r = n[0];
      !et(this, Cu, "f") && !a?.length && Promise.reject(r), et(this, Fl, "f").call(this, r), et(this, ql, "f").call(this, r), this._emit("end");
      return;
    }
    if (e === "error") {
      const r = n[0];
      !et(this, Cu, "f") && !a?.length && Promise.reject(r), et(this, Fl, "f").call(this, r), et(this, ql, "f").call(this, r), this._emit("end");
    }
  }
  _emitFinal() {
  }
}
ih = /* @__PURE__ */ new WeakMap(), sh = /* @__PURE__ */ new WeakMap(), Fl = /* @__PURE__ */ new WeakMap(), Dl = /* @__PURE__ */ new WeakMap(), oh = /* @__PURE__ */ new WeakMap(), ql = /* @__PURE__ */ new WeakMap(), Ns = /* @__PURE__ */ new WeakMap(), Jl = /* @__PURE__ */ new WeakMap(), wh = /* @__PURE__ */ new WeakMap(), vh = /* @__PURE__ */ new WeakMap(), Cu = /* @__PURE__ */ new WeakMap(), qb = /* @__PURE__ */ new WeakSet(), $R = function(e) {
  if (ir(this, wh, !0, "f"), e instanceof Error && e.name === "AbortError" && (e = new On()), e instanceof On)
    return ir(this, vh, !0, "f"), this._emit("abort", e);
  if (e instanceof de)
    return this._emit("error", e);
  if (e instanceof Error) {
    const n = new de(e.message);
    return n.cause = e, this._emit("error", n);
  }
  return this._emit("error", new de(String(e)));
};
function HE(t, e) {
  const n = { ...t };
  return Object.defineProperties(n, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: !1
    },
    $parseRaw: {
      value: e,
      enumerable: !1
    }
  }), n;
}
function qg(t) {
  return t?.$brand === "auto-parseable-response-format";
}
function GE(t, { parser: e, callback: n }) {
  const a = { ...t };
  return Object.defineProperties(a, {
    $brand: {
      value: "auto-parseable-tool",
      enumerable: !1
    },
    $parseRaw: {
      value: e,
      enumerable: !1
    },
    $callback: {
      value: n,
      enumerable: !1
    }
  }), a;
}
function Jd(t) {
  return t?.$brand === "auto-parseable-tool";
}
function WE(t, e) {
  return !e || !MR(e) ? {
    ...t,
    choices: t.choices.map((n) => ({
      ...n,
      message: {
        ...n.message,
        parsed: null,
        ...n.message.tool_calls ? {
          tool_calls: n.message.tool_calls
        } : void 0
      }
    }))
  } : Jg(t, e);
}
function Jg(t, e) {
  const n = t.choices.map((a) => {
    if (a.finish_reason === "length")
      throw new lR();
    if (a.finish_reason === "content_filter")
      throw new dR();
    return {
      ...a,
      message: {
        ...a.message,
        ...a.message.tool_calls ? {
          tool_calls: a.message.tool_calls?.map((r) => QE(e, r)) ?? void 0
        } : void 0,
        parsed: a.message.content && !a.message.refusal ? XE(e, a.message.content) : null
      }
    };
  });
  return { ...t, choices: n };
}
function XE(t, e) {
  return t.response_format?.type !== "json_schema" ? null : t.response_format?.type === "json_schema" ? "$parseRaw" in t.response_format ? t.response_format.$parseRaw(e) : JSON.parse(e) : null;
}
function QE(t, e) {
  const n = t.tools?.find((a) => a.function?.name === e.function.name);
  return {
    ...e,
    function: {
      ...e.function,
      parsed_arguments: Jd(n) ? n.$parseRaw(e.function.arguments) : n?.function.strict ? JSON.parse(e.function.arguments) : null
    }
  };
}
function YE(t, e) {
  if (!t)
    return !1;
  const n = t.tools?.find((a) => a.function?.name === e.function.name);
  return Jd(n) || n?.function.strict || !1;
}
function MR(t) {
  return qg(t.response_format) ? !0 : t.tools?.some((e) => Jd(e) || e.type === "function" && e.function.strict === !0) ?? !1;
}
function eI(t) {
  for (const e of t ?? []) {
    if (e.type !== "function")
      throw new de(`Currently only \`function\` tool types support auto-parsing; Received \`${e.type}\``);
    if (e.function.strict !== !0)
      throw new de(`The \`${e.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
  }
}
var rn = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, Ut, Jb, Sh, Lb, Ub, Bb, AR, xb;
const Uy = 10;
class ER extends Dg {
  constructor() {
    super(...arguments), Ut.add(this), this._chatCompletions = [], this.messages = [];
  }
  _addChatCompletion(e) {
    this._chatCompletions.push(e), this._emit("chatCompletion", e);
    const n = e.choices[0]?.message;
    return n && this._addMessage(n), e;
  }
  _addMessage(e, n = !0) {
    if ("content" in e || (e.content = null), this.messages.push(e), n) {
      if (this._emit("message", e), (CR(e) || TR(e)) && e.content)
        this._emit("functionCallResult", e.content);
      else if (Bu(e) && e.function_call)
        this._emit("functionCall", e.function_call);
      else if (Bu(e) && e.tool_calls)
        for (const a of e.tool_calls)
          a.type === "function" && this._emit("functionCall", a.function);
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const e = this._chatCompletions[this._chatCompletions.length - 1];
    if (!e)
      throw new de("stream ended without producing a ChatCompletion");
    return e;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    return await this.done(), rn(this, Ut, "m", Jb).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    return await this.done(), rn(this, Ut, "m", Sh).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    return await this.done(), rn(this, Ut, "m", Lb).call(this);
  }
  async finalFunctionCallResult() {
    return await this.done(), rn(this, Ut, "m", Ub).call(this);
  }
  async totalUsage() {
    return await this.done(), rn(this, Ut, "m", Bb).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const e = this._chatCompletions[this._chatCompletions.length - 1];
    e && this._emit("finalChatCompletion", e);
    const n = rn(this, Ut, "m", Sh).call(this);
    n && this._emit("finalMessage", n);
    const a = rn(this, Ut, "m", Jb).call(this);
    a && this._emit("finalContent", a);
    const r = rn(this, Ut, "m", Lb).call(this);
    r && this._emit("finalFunctionCall", r);
    const i = rn(this, Ut, "m", Ub).call(this);
    i != null && this._emit("finalFunctionCallResult", i), this._chatCompletions.some((s) => s.usage) && this._emit("totalUsage", rn(this, Ut, "m", Bb).call(this));
  }
  async _createChatCompletion(e, n, a) {
    const r = a?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), rn(this, Ut, "m", AR).call(this, n);
    const i = await e.chat.completions.create({ ...n, stream: !1 }, { ...a, signal: this.controller.signal });
    return this._connected(), this._addChatCompletion(Jg(i, n));
  }
  async _runChatCompletion(e, n, a) {
    for (const r of n.messages)
      this._addMessage(r, !1);
    return await this._createChatCompletion(e, n, a);
  }
  async _runFunctions(e, n, a) {
    const r = "function", { function_call: i = "auto", stream: s, ...o } = n, l = typeof i != "string" && i?.name, { maxChatCompletions: f = Uy } = a || {}, u = {};
    for (const h of n.functions)
      u[h.name || h.function.name] = h;
    const c = n.functions.map((h) => ({
      name: h.name || h.function.name,
      parameters: h.parameters,
      description: h.description
    }));
    for (const h of n.messages)
      this._addMessage(h, !1);
    for (let h = 0; h < f; ++h) {
      const d = (await this._createChatCompletion(e, {
        ...o,
        function_call: i,
        functions: c,
        messages: [...this.messages]
      }, a)).choices[0]?.message;
      if (!d)
        throw new de("missing message in ChatCompletion response");
      if (!d.function_call)
        return;
      const { name: m, arguments: b } = d.function_call, g = u[m];
      if (g) {
        if (l && l !== m) {
          const R = `Invalid function_call: ${JSON.stringify(m)}. ${JSON.stringify(l)} requested. Please try again`;
          this._addMessage({ role: r, name: m, content: R });
          continue;
        }
      } else {
        const R = `Invalid function_call: ${JSON.stringify(m)}. Available options are: ${c.map((T) => JSON.stringify(T.name)).join(", ")}. Please try again`;
        this._addMessage({ role: r, name: m, content: R });
        continue;
      }
      let _;
      try {
        _ = Ly(g) ? await g.parse(b) : b;
      } catch (R) {
        this._addMessage({
          role: r,
          name: m,
          content: R instanceof Error ? R.message : String(R)
        });
        continue;
      }
      const P = await g.function(_, this), C = rn(this, Ut, "m", xb).call(this, P);
      if (this._addMessage({ role: r, name: m, content: C }), l)
        return;
    }
  }
  async _runTools(e, n, a) {
    const r = "tool", { tool_choice: i = "auto", stream: s, ...o } = n, l = typeof i != "string" && i?.function?.name, { maxChatCompletions: f = Uy } = a || {}, u = n.tools.map((p) => {
      if (Jd(p)) {
        if (!p.$callback)
          throw new de("Tool given to `.runTools()` that does not have an associated function");
        return {
          type: "function",
          function: {
            function: p.$callback,
            name: p.function.name,
            description: p.function.description || "",
            parameters: p.function.parameters,
            parse: p.$parseRaw,
            strict: !0
          }
        };
      }
      return p;
    }), c = {};
    for (const p of u)
      p.type === "function" && (c[p.function.name || p.function.function.name] = p.function);
    const h = "tools" in n ? u.map((p) => p.type === "function" ? {
      type: "function",
      function: {
        name: p.function.name || p.function.function.name,
        parameters: p.function.parameters,
        description: p.function.description,
        strict: p.function.strict
      }
    } : p) : void 0;
    for (const p of n.messages)
      this._addMessage(p, !1);
    for (let p = 0; p < f; ++p) {
      const m = (await this._createChatCompletion(e, {
        ...o,
        tool_choice: i,
        tools: h,
        messages: [...this.messages]
      }, a)).choices[0]?.message;
      if (!m)
        throw new de("missing message in ChatCompletion response");
      if (!m.tool_calls?.length)
        return;
      for (const b of m.tool_calls) {
        if (b.type !== "function")
          continue;
        const g = b.id, { name: _, arguments: P } = b.function, C = c[_];
        if (C) {
          if (l && l !== _) {
            const A = `Invalid tool_call: ${JSON.stringify(_)}. ${JSON.stringify(l)} requested. Please try again`;
            this._addMessage({ role: r, tool_call_id: g, content: A });
            continue;
          }
        } else {
          const A = `Invalid tool_call: ${JSON.stringify(_)}. Available options are: ${Object.keys(c).map((M) => JSON.stringify(M)).join(", ")}. Please try again`;
          this._addMessage({ role: r, tool_call_id: g, content: A });
          continue;
        }
        let R;
        try {
          R = Ly(C) ? await C.parse(P) : P;
        } catch (A) {
          const M = A instanceof Error ? A.message : String(A);
          this._addMessage({ role: r, tool_call_id: g, content: M });
          continue;
        }
        const T = await C.function(R, this), O = rn(this, Ut, "m", xb).call(this, T);
        if (this._addMessage({ role: r, tool_call_id: g, content: O }), l)
          return;
      }
    }
  }
}
Ut = /* @__PURE__ */ new WeakSet(), Jb = function() {
  return rn(this, Ut, "m", Sh).call(this).content ?? null;
}, Sh = function() {
  let e = this.messages.length;
  for (; e-- > 0; ) {
    const n = this.messages[e];
    if (Bu(n)) {
      const { function_call: a, ...r } = n, i = {
        ...r,
        content: n.content ?? null,
        refusal: n.refusal ?? null
      };
      return a && (i.function_call = a), i;
    }
  }
  throw new de("stream ended without producing a ChatCompletionMessage with role=assistant");
}, Lb = function() {
  for (let e = this.messages.length - 1; e >= 0; e--) {
    const n = this.messages[e];
    if (Bu(n) && n?.function_call)
      return n.function_call;
    if (Bu(n) && n?.tool_calls?.length)
      return n.tool_calls.at(-1)?.function;
  }
}, Ub = function() {
  for (let e = this.messages.length - 1; e >= 0; e--) {
    const n = this.messages[e];
    if (CR(n) && n.content != null || TR(n) && n.content != null && typeof n.content == "string" && this.messages.some((a) => a.role === "assistant" && a.tool_calls?.some((r) => r.type === "function" && r.id === n.tool_call_id)))
      return n.content;
  }
}, Bb = function() {
  const e = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage: n } of this._chatCompletions)
    n && (e.completion_tokens += n.completion_tokens, e.prompt_tokens += n.prompt_tokens, e.total_tokens += n.total_tokens);
  return e;
}, AR = function(e) {
  if (e.n != null && e.n > 1)
    throw new de("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
}, xb = function(e) {
  return typeof e == "string" ? e : e === void 0 ? "undefined" : JSON.stringify(e);
};
class ud extends ER {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(e, n, a) {
    const r = new ud(), i = {
      ...a,
      headers: { ...a?.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    return r._run(() => r._runFunctions(e, n, i)), r;
  }
  static runTools(e, n, a) {
    const r = new ud(), i = {
      ...a,
      headers: { ...a?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return r._run(() => r._runTools(e, n, i)), r;
  }
  _addMessage(e, n = !0) {
    super._addMessage(e, n), Bu(e) && e.content && this._emit("content", e.content);
  }
}
const IR = 1, NR = 2, kR = 4, FR = 8, DR = 16, qR = 32, JR = 64, LR = 128, UR = 256, BR = LR | UR, xR = DR | qR | BR | JR, VR = IR | NR | xR, zR = kR | FR, tI = VR | zR, jt = {
  STR: IR,
  NUM: NR,
  ARR: kR,
  OBJ: FR,
  NULL: DR,
  BOOL: qR,
  NAN: JR,
  INFINITY: LR,
  MINUS_INFINITY: UR,
  INF: BR,
  SPECIAL: xR,
  ATOM: VR,
  COLLECTION: zR,
  ALL: tI
};
class nI extends Error {
}
class rI extends Error {
}
function aI(t, e = jt.ALL) {
  if (typeof t != "string")
    throw new TypeError(`expecting str, got ${typeof t}`);
  if (!t.trim())
    throw new Error(`${t} is empty`);
  return iI(t.trim(), e);
}
const iI = (t, e) => {
  const n = t.length;
  let a = 0;
  const r = (h) => {
    throw new nI(`${h} at position ${a}`);
  }, i = (h) => {
    throw new rI(`${h} at position ${a}`);
  }, s = () => (c(), a >= n && r("Unexpected end of input"), t[a] === '"' ? o() : t[a] === "{" ? l() : t[a] === "[" ? f() : t.substring(a, a + 4) === "null" || jt.NULL & e && n - a < 4 && "null".startsWith(t.substring(a)) ? (a += 4, null) : t.substring(a, a + 4) === "true" || jt.BOOL & e && n - a < 4 && "true".startsWith(t.substring(a)) ? (a += 4, !0) : t.substring(a, a + 5) === "false" || jt.BOOL & e && n - a < 5 && "false".startsWith(t.substring(a)) ? (a += 5, !1) : t.substring(a, a + 8) === "Infinity" || jt.INFINITY & e && n - a < 8 && "Infinity".startsWith(t.substring(a)) ? (a += 8, 1 / 0) : t.substring(a, a + 9) === "-Infinity" || jt.MINUS_INFINITY & e && 1 < n - a && n - a < 9 && "-Infinity".startsWith(t.substring(a)) ? (a += 9, -1 / 0) : t.substring(a, a + 3) === "NaN" || jt.NAN & e && n - a < 3 && "NaN".startsWith(t.substring(a)) ? (a += 3, NaN) : u()), o = () => {
    const h = a;
    let p = !1;
    for (a++; a < n && (t[a] !== '"' || p && t[a - 1] === "\\"); )
      p = t[a] === "\\" ? !p : !1, a++;
    if (t.charAt(a) == '"')
      try {
        return JSON.parse(t.substring(h, ++a - Number(p)));
      } catch (d) {
        i(String(d));
      }
    else if (jt.STR & e)
      try {
        return JSON.parse(t.substring(h, a - Number(p)) + '"');
      } catch {
        return JSON.parse(t.substring(h, t.lastIndexOf("\\")) + '"');
      }
    r("Unterminated string literal");
  }, l = () => {
    a++, c();
    const h = {};
    try {
      for (; t[a] !== "}"; ) {
        if (c(), a >= n && jt.OBJ & e)
          return h;
        const p = o();
        c(), a++;
        try {
          const d = s();
          Object.defineProperty(h, p, { value: d, writable: !0, enumerable: !0, configurable: !0 });
        } catch (d) {
          if (jt.OBJ & e)
            return h;
          throw d;
        }
        c(), t[a] === "," && a++;
      }
    } catch {
      if (jt.OBJ & e)
        return h;
      r("Expected '}' at end of object");
    }
    return a++, h;
  }, f = () => {
    a++;
    const h = [];
    try {
      for (; t[a] !== "]"; )
        h.push(s()), c(), t[a] === "," && a++;
    } catch {
      if (jt.ARR & e)
        return h;
      r("Expected ']' at end of array");
    }
    return a++, h;
  }, u = () => {
    if (a === 0) {
      t === "-" && jt.NUM & e && r("Not sure what '-' is");
      try {
        return JSON.parse(t);
      } catch (p) {
        if (jt.NUM & e)
          try {
            return t[t.length - 1] === "." ? JSON.parse(t.substring(0, t.lastIndexOf("."))) : JSON.parse(t.substring(0, t.lastIndexOf("e")));
          } catch {
          }
        i(String(p));
      }
    }
    const h = a;
    for (t[a] === "-" && a++; t[a] && !",]}".includes(t[a]); )
      a++;
    a == n && !(jt.NUM & e) && r("Unterminated number literal");
    try {
      return JSON.parse(t.substring(h, a));
    } catch {
      t.substring(h, a) === "-" && jt.NUM & e && r("Not sure what '-' is");
      try {
        return JSON.parse(t.substring(h, t.lastIndexOf("e")));
      } catch (d) {
        i(String(d));
      }
    }
  }, c = () => {
    for (; a < n && ` 
\r	`.includes(t[a]); )
      a++;
  };
  return s();
}, By = (t) => aI(t, jt.ALL ^ jt.NUM);
var fu = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, ze = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, pt, wa, hu, Gs, lm, pf, dm, fm, hm, mf, pm, xy;
class cd extends ER {
  constructor(e) {
    super(), pt.add(this), wa.set(this, void 0), hu.set(this, void 0), Gs.set(this, void 0), fu(this, wa, e, "f"), fu(this, hu, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return ze(this, Gs, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(e) {
    const n = new cd(null);
    return n._run(() => n._fromReadableStream(e)), n;
  }
  static createChatCompletion(e, n, a) {
    const r = new cd(n);
    return r._run(() => r._runChatCompletion(e, { ...n, stream: !0 }, { ...a, headers: { ...a?.headers, "X-Stainless-Helper-Method": "stream" } })), r;
  }
  async _createChatCompletion(e, n, a) {
    const r = a?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), ze(this, pt, "m", lm).call(this);
    const i = await e.chat.completions.create({ ...n, stream: !0 }, { ...a, signal: this.controller.signal });
    this._connected();
    for await (const s of i)
      ze(this, pt, "m", dm).call(this, s);
    if (i.controller.signal?.aborted)
      throw new On();
    return this._addChatCompletion(ze(this, pt, "m", mf).call(this));
  }
  async _fromReadableStream(e, n) {
    const a = n?.signal;
    a && (a.aborted && this.controller.abort(), a.addEventListener("abort", () => this.controller.abort())), ze(this, pt, "m", lm).call(this), this._connected();
    const r = od.fromReadableStream(e, this.controller);
    let i;
    for await (const s of r)
      i && i !== s.id && this._addChatCompletion(ze(this, pt, "m", mf).call(this)), ze(this, pt, "m", dm).call(this, s), i = s.id;
    if (r.controller.signal?.aborted)
      throw new On();
    return this._addChatCompletion(ze(this, pt, "m", mf).call(this));
  }
  [(wa = /* @__PURE__ */ new WeakMap(), hu = /* @__PURE__ */ new WeakMap(), Gs = /* @__PURE__ */ new WeakMap(), pt = /* @__PURE__ */ new WeakSet(), lm = function() {
    this.ended || fu(this, Gs, void 0, "f");
  }, pf = function(n) {
    let a = ze(this, hu, "f")[n.index];
    return a || (a = {
      content_done: !1,
      refusal_done: !1,
      logprobs_content_done: !1,
      logprobs_refusal_done: !1,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    }, ze(this, hu, "f")[n.index] = a, a);
  }, dm = function(n) {
    if (this.ended)
      return;
    const a = ze(this, pt, "m", xy).call(this, n);
    this._emit("chunk", n, a);
    for (const r of n.choices) {
      const i = a.choices[r.index];
      r.delta.content != null && i.message?.role === "assistant" && i.message?.content && (this._emit("content", r.delta.content, i.message.content), this._emit("content.delta", {
        delta: r.delta.content,
        snapshot: i.message.content,
        parsed: i.message.parsed
      })), r.delta.refusal != null && i.message?.role === "assistant" && i.message?.refusal && this._emit("refusal.delta", {
        delta: r.delta.refusal,
        snapshot: i.message.refusal
      }), r.logprobs?.content != null && i.message?.role === "assistant" && this._emit("logprobs.content.delta", {
        content: r.logprobs?.content,
        snapshot: i.logprobs?.content ?? []
      }), r.logprobs?.refusal != null && i.message?.role === "assistant" && this._emit("logprobs.refusal.delta", {
        refusal: r.logprobs?.refusal,
        snapshot: i.logprobs?.refusal ?? []
      });
      const s = ze(this, pt, "m", pf).call(this, i);
      i.finish_reason && (ze(this, pt, "m", hm).call(this, i), s.current_tool_call_index != null && ze(this, pt, "m", fm).call(this, i, s.current_tool_call_index));
      for (const o of r.delta.tool_calls ?? [])
        s.current_tool_call_index !== o.index && (ze(this, pt, "m", hm).call(this, i), s.current_tool_call_index != null && ze(this, pt, "m", fm).call(this, i, s.current_tool_call_index)), s.current_tool_call_index = o.index;
      for (const o of r.delta.tool_calls ?? []) {
        const l = i.message.tool_calls?.[o.index];
        l?.type && l?.type === "function" && this._emit("tool_calls.function.arguments.delta", {
          name: l.function?.name,
          index: o.index,
          arguments: l.function.arguments,
          parsed_arguments: l.function.parsed_arguments,
          arguments_delta: o.function?.arguments ?? ""
        });
      }
    }
  }, fm = function(n, a) {
    if (ze(this, pt, "m", pf).call(this, n).done_tool_calls.has(a))
      return;
    const i = n.message.tool_calls?.[a];
    if (!i)
      throw new Error("no tool call snapshot");
    if (!i.type)
      throw new Error("tool call snapshot missing `type`");
    if (i.type === "function") {
      const s = ze(this, wa, "f")?.tools?.find((o) => o.type === "function" && o.function.name === i.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: i.function.name,
        index: a,
        arguments: i.function.arguments,
        parsed_arguments: Jd(s) ? s.$parseRaw(i.function.arguments) : s?.function.strict ? JSON.parse(i.function.arguments) : null
      });
    }
  }, hm = function(n) {
    const a = ze(this, pt, "m", pf).call(this, n);
    if (n.message.content && !a.content_done) {
      a.content_done = !0;
      const r = ze(this, pt, "m", pm).call(this);
      this._emit("content.done", {
        content: n.message.content,
        parsed: r ? r.$parseRaw(n.message.content) : null
      });
    }
    n.message.refusal && !a.refusal_done && (a.refusal_done = !0, this._emit("refusal.done", { refusal: n.message.refusal })), n.logprobs?.content && !a.logprobs_content_done && (a.logprobs_content_done = !0, this._emit("logprobs.content.done", { content: n.logprobs.content })), n.logprobs?.refusal && !a.logprobs_refusal_done && (a.logprobs_refusal_done = !0, this._emit("logprobs.refusal.done", { refusal: n.logprobs.refusal }));
  }, mf = function() {
    if (this.ended)
      throw new de("stream has ended, this shouldn't happen");
    const n = ze(this, Gs, "f");
    if (!n)
      throw new de("request ended without sending any chunks");
    return fu(this, Gs, void 0, "f"), fu(this, hu, [], "f"), sI(n, ze(this, wa, "f"));
  }, pm = function() {
    const n = ze(this, wa, "f")?.response_format;
    return qg(n) ? n : null;
  }, xy = function(n) {
    var a, r, i, s;
    let o = ze(this, Gs, "f");
    const { choices: l, ...f } = n;
    o ? Object.assign(o, f) : o = fu(this, Gs, {
      ...f,
      choices: []
    }, "f");
    for (const { delta: u, finish_reason: c, index: h, logprobs: p = null, ...d } of n.choices) {
      let m = o.choices[h];
      if (m || (m = o.choices[h] = { finish_reason: c, index: h, message: {}, logprobs: p, ...d }), p)
        if (!m.logprobs)
          m.logprobs = Object.assign({}, p);
        else {
          const { content: T, refusal: O, ...A } = p;
          Object.assign(m.logprobs, A), T && ((a = m.logprobs).content ?? (a.content = []), m.logprobs.content.push(...T)), O && ((r = m.logprobs).refusal ?? (r.refusal = []), m.logprobs.refusal.push(...O));
        }
      if (c && (m.finish_reason = c, ze(this, wa, "f") && MR(ze(this, wa, "f")))) {
        if (c === "length")
          throw new lR();
        if (c === "content_filter")
          throw new dR();
      }
      if (Object.assign(m, d), !u)
        continue;
      const { content: b, refusal: g, function_call: _, role: P, tool_calls: C, ...R } = u;
      if (Object.assign(m.message, R), g && (m.message.refusal = (m.message.refusal || "") + g), P && (m.message.role = P), _ && (m.message.function_call ? (_.name && (m.message.function_call.name = _.name), _.arguments && ((i = m.message.function_call).arguments ?? (i.arguments = ""), m.message.function_call.arguments += _.arguments)) : m.message.function_call = _), b && (m.message.content = (m.message.content || "") + b, !m.message.refusal && ze(this, pt, "m", pm).call(this) && (m.message.parsed = By(m.message.content))), C) {
        m.message.tool_calls || (m.message.tool_calls = []);
        for (const { index: T, id: O, type: A, function: M, ...I } of C) {
          const N = (s = m.message.tool_calls)[T] ?? (s[T] = {});
          Object.assign(N, I), O && (N.id = O), A && (N.type = A), M && (N.function ?? (N.function = { name: M.name ?? "", arguments: "" })), M?.name && (N.function.name = M.name), M?.arguments && (N.function.arguments += M.arguments, YE(ze(this, wa, "f"), N) && (N.function.parsed_arguments = By(N.function.arguments)));
        }
      }
    }
    return o;
  }, Symbol.asyncIterator)]() {
    const e = [], n = [];
    let a = !1;
    return this.on("chunk", (r) => {
      const i = n.shift();
      i ? i.resolve(r) : e.push(r);
    }), this.on("end", () => {
      a = !0;
      for (const r of n)
        r.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), this.on("error", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : a ? { value: void 0, done: !0 } : new Promise((i, s) => n.push({ resolve: i, reject: s })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new od(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
function sI(t, e) {
  const { id: n, choices: a, created: r, model: i, system_fingerprint: s, ...o } = t, l = {
    ...o,
    id: n,
    choices: a.map(({ message: f, finish_reason: u, index: c, logprobs: h, ...p }) => {
      if (!u)
        throw new de(`missing finish_reason for choice ${c}`);
      const { content: d = null, function_call: m, tool_calls: b, ...g } = f, _ = f.role;
      if (!_)
        throw new de(`missing role for choice ${c}`);
      if (m) {
        const { arguments: P, name: C } = m;
        if (P == null)
          throw new de(`missing function_call.arguments for choice ${c}`);
        if (!C)
          throw new de(`missing function_call.name for choice ${c}`);
        return {
          ...p,
          message: {
            content: d,
            function_call: { arguments: P, name: C },
            role: _,
            refusal: f.refusal ?? null
          },
          finish_reason: u,
          index: c,
          logprobs: h
        };
      }
      return b ? {
        ...p,
        index: c,
        finish_reason: u,
        logprobs: h,
        message: {
          ...g,
          role: _,
          content: d,
          refusal: f.refusal ?? null,
          tool_calls: b.map((P, C) => {
            const { function: R, type: T, id: O, ...A } = P, { arguments: M, name: I, ...N } = R || {};
            if (O == null)
              throw new de(`missing choices[${c}].tool_calls[${C}].id
${bf(t)}`);
            if (T == null)
              throw new de(`missing choices[${c}].tool_calls[${C}].type
${bf(t)}`);
            if (I == null)
              throw new de(`missing choices[${c}].tool_calls[${C}].function.name
${bf(t)}`);
            if (M == null)
              throw new de(`missing choices[${c}].tool_calls[${C}].function.arguments
${bf(t)}`);
            return { ...A, id: O, type: T, function: { ...N, name: I, arguments: M } };
          })
        }
      } : {
        ...p,
        message: { ...g, content: d, role: _, refusal: f.refusal ?? null },
        finish_reason: u,
        index: c,
        logprobs: h
      };
    }),
    created: r,
    model: i,
    object: "chat.completion",
    ...s ? { system_fingerprint: s } : {}
  };
  return WE(l, e);
}
function bf(t) {
  return JSON.stringify(t);
}
class xu extends cd {
  static fromReadableStream(e) {
    const n = new xu(null);
    return n._run(() => n._fromReadableStream(e)), n;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(e, n, a) {
    const r = new xu(null), i = {
      ...a,
      headers: { ...a?.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    return r._run(() => r._runFunctions(e, n, i)), r;
  }
  static runTools(e, n, a) {
    const r = new xu(
      // @ts-expect-error TODO these types are incompatible
      n
    ), i = {
      ...a,
      headers: { ...a?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return r._run(() => r._runTools(e, n, i)), r;
  }
}
let ZR = class extends Pe {
  parse(e, n) {
    return eI(e.tools), this._client.chat.completions.create(e, {
      ...n,
      headers: {
        ...n?.headers,
        "X-Stainless-Helper-Method": "beta.chat.completions.parse"
      }
    })._thenUnwrap((a) => Jg(a, e));
  }
  runFunctions(e, n) {
    return e.stream ? xu.runFunctions(this._client, e, n) : ud.runFunctions(this._client, e, n);
  }
  runTools(e, n) {
    return e.stream ? xu.runTools(this._client, e, n) : ud.runTools(this._client, e, n);
  }
  /**
   * Creates a chat completion stream
   */
  stream(e, n) {
    return cd.createChatCompletion(this._client, e, n);
  }
}, Vb = class extends Pe {
  constructor() {
    super(...arguments), this.completions = new ZR(this._client);
  }
};
(function(t) {
  t.Completions = ZR;
})(Vb || (Vb = {}));
class KR extends Pe {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   */
  create(e, n) {
    return this._client.post("/realtime/sessions", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
}
class HR extends Pe {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   */
  create(e, n) {
    return this._client.post("/realtime/transcription_sessions", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
}
class wp extends Pe {
  constructor() {
    super(...arguments), this.sessions = new KR(this._client), this.transcriptionSessions = new HR(this._client);
  }
}
wp.Sessions = KR;
wp.TranscriptionSessions = HR;
var se = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, mn = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, It, zb, aa, uh, sr, Jo, Nu, Fo, Oh, yn, ch, lh, Gl, Ll, Ul, Vy, zy, Zy, Ky, Hy, Gy, Wy;
class or extends Dg {
  constructor() {
    super(...arguments), It.add(this), zb.set(this, []), aa.set(this, {}), uh.set(this, {}), sr.set(this, void 0), Jo.set(this, void 0), Nu.set(this, void 0), Fo.set(this, void 0), Oh.set(this, void 0), yn.set(this, void 0), ch.set(this, void 0), lh.set(this, void 0), Gl.set(this, void 0);
  }
  [(zb = /* @__PURE__ */ new WeakMap(), aa = /* @__PURE__ */ new WeakMap(), uh = /* @__PURE__ */ new WeakMap(), sr = /* @__PURE__ */ new WeakMap(), Jo = /* @__PURE__ */ new WeakMap(), Nu = /* @__PURE__ */ new WeakMap(), Fo = /* @__PURE__ */ new WeakMap(), Oh = /* @__PURE__ */ new WeakMap(), yn = /* @__PURE__ */ new WeakMap(), ch = /* @__PURE__ */ new WeakMap(), lh = /* @__PURE__ */ new WeakMap(), Gl = /* @__PURE__ */ new WeakMap(), It = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const e = [], n = [];
    let a = !1;
    return this.on("event", (r) => {
      const i = n.shift();
      i ? i.resolve(r) : e.push(r);
    }), this.on("end", () => {
      a = !0;
      for (const r of n)
        r.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), this.on("error", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : a ? { value: void 0, done: !0 } : new Promise((i, s) => n.push({ resolve: i, reject: s })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  static fromReadableStream(e) {
    const n = new or();
    return n._run(() => n._fromReadableStream(e)), n;
  }
  async _fromReadableStream(e, n) {
    const a = n?.signal;
    a && (a.aborted && this.controller.abort(), a.addEventListener("abort", () => this.controller.abort())), this._connected();
    const r = od.fromReadableStream(e, this.controller);
    for await (const i of r)
      se(this, It, "m", Ll).call(this, i);
    if (r.controller.signal?.aborted)
      throw new On();
    return this._addRun(se(this, It, "m", Ul).call(this));
  }
  toReadableStream() {
    return new od(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
  static createToolAssistantStream(e, n, a, r, i) {
    const s = new or();
    return s._run(() => s._runToolAssistantStream(e, n, a, r, {
      ...i,
      headers: { ...i?.headers, "X-Stainless-Helper-Method": "stream" }
    })), s;
  }
  async _createToolAssistantStream(e, n, a, r, i) {
    const s = i?.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort()));
    const o = { ...r, stream: !0 }, l = await e.submitToolOutputs(n, a, o, {
      ...i,
      signal: this.controller.signal
    });
    this._connected();
    for await (const f of l)
      se(this, It, "m", Ll).call(this, f);
    if (l.controller.signal?.aborted)
      throw new On();
    return this._addRun(se(this, It, "m", Ul).call(this));
  }
  static createThreadAssistantStream(e, n, a) {
    const r = new or();
    return r._run(() => r._threadAssistantStream(e, n, {
      ...a,
      headers: { ...a?.headers, "X-Stainless-Helper-Method": "stream" }
    })), r;
  }
  static createAssistantStream(e, n, a, r) {
    const i = new or();
    return i._run(() => i._runAssistantStream(e, n, a, {
      ...r,
      headers: { ...r?.headers, "X-Stainless-Helper-Method": "stream" }
    })), i;
  }
  currentEvent() {
    return se(this, ch, "f");
  }
  currentRun() {
    return se(this, lh, "f");
  }
  currentMessageSnapshot() {
    return se(this, sr, "f");
  }
  currentRunStepSnapshot() {
    return se(this, Gl, "f");
  }
  async finalRunSteps() {
    return await this.done(), Object.values(se(this, aa, "f"));
  }
  async finalMessages() {
    return await this.done(), Object.values(se(this, uh, "f"));
  }
  async finalRun() {
    if (await this.done(), !se(this, Jo, "f"))
      throw Error("Final run was not received.");
    return se(this, Jo, "f");
  }
  async _createThreadAssistantStream(e, n, a) {
    const r = a?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort()));
    const i = { ...n, stream: !0 }, s = await e.createAndRun(i, { ...a, signal: this.controller.signal });
    this._connected();
    for await (const o of s)
      se(this, It, "m", Ll).call(this, o);
    if (s.controller.signal?.aborted)
      throw new On();
    return this._addRun(se(this, It, "m", Ul).call(this));
  }
  async _createAssistantStream(e, n, a, r) {
    const i = r?.signal;
    i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort()));
    const s = { ...a, stream: !0 }, o = await e.create(n, s, { ...r, signal: this.controller.signal });
    this._connected();
    for await (const l of o)
      se(this, It, "m", Ll).call(this, l);
    if (o.controller.signal?.aborted)
      throw new On();
    return this._addRun(se(this, It, "m", Ul).call(this));
  }
  static accumulateDelta(e, n) {
    for (const [a, r] of Object.entries(n)) {
      if (!e.hasOwnProperty(a)) {
        e[a] = r;
        continue;
      }
      let i = e[a];
      if (i == null) {
        e[a] = r;
        continue;
      }
      if (a === "index" || a === "type") {
        e[a] = r;
        continue;
      }
      if (typeof i == "string" && typeof r == "string")
        i += r;
      else if (typeof i == "number" && typeof r == "number")
        i += r;
      else if (cm(i) && cm(r))
        i = this.accumulateDelta(i, r);
      else if (Array.isArray(i) && Array.isArray(r)) {
        if (i.every((s) => typeof s == "string" || typeof s == "number")) {
          i.push(...r);
          continue;
        }
        for (const s of r) {
          if (!cm(s))
            throw new Error(`Expected array delta entry to be an object but got: ${s}`);
          const o = s.index;
          if (o == null)
            throw console.error(s), new Error("Expected array delta entry to have an `index` property");
          if (typeof o != "number")
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${o}`);
          const l = i[o];
          l == null ? i.push(s) : i[o] = this.accumulateDelta(l, s);
        }
        continue;
      } else
        throw Error(`Unhandled record type: ${a}, deltaValue: ${r}, accValue: ${i}`);
      e[a] = i;
    }
    return e;
  }
  _addRun(e) {
    return e;
  }
  async _threadAssistantStream(e, n, a) {
    return await this._createThreadAssistantStream(n, e, a);
  }
  async _runAssistantStream(e, n, a, r) {
    return await this._createAssistantStream(n, e, a, r);
  }
  async _runToolAssistantStream(e, n, a, r, i) {
    return await this._createToolAssistantStream(a, e, n, r, i);
  }
}
Ll = function(e) {
  if (!this.ended)
    switch (mn(this, ch, e, "f"), se(this, It, "m", Zy).call(this, e), e.event) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.incomplete":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        se(this, It, "m", Wy).call(this, e);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        se(this, It, "m", zy).call(this, e);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        se(this, It, "m", Vy).call(this, e);
        break;
      case "error":
        throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    }
}, Ul = function() {
  if (this.ended)
    throw new de("stream has ended, this shouldn't happen");
  if (!se(this, Jo, "f"))
    throw Error("Final run has not been received");
  return se(this, Jo, "f");
}, Vy = function(e) {
  const [n, a] = se(this, It, "m", Hy).call(this, e, se(this, sr, "f"));
  mn(this, sr, n, "f"), se(this, uh, "f")[n.id] = n;
  for (const r of a) {
    const i = n.content[r.index];
    i?.type == "text" && this._emit("textCreated", i.text);
  }
  switch (e.event) {
    case "thread.message.created":
      this._emit("messageCreated", e.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      if (this._emit("messageDelta", e.data.delta, n), e.data.delta.content)
        for (const r of e.data.delta.content) {
          if (r.type == "text" && r.text) {
            let i = r.text, s = n.content[r.index];
            if (s && s.type == "text")
              this._emit("textDelta", i, s.text);
            else
              throw Error("The snapshot associated with this text delta is not text or missing");
          }
          if (r.index != se(this, Nu, "f")) {
            if (se(this, Fo, "f"))
              switch (se(this, Fo, "f").type) {
                case "text":
                  this._emit("textDone", se(this, Fo, "f").text, se(this, sr, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", se(this, Fo, "f").image_file, se(this, sr, "f"));
                  break;
              }
            mn(this, Nu, r.index, "f");
          }
          mn(this, Fo, n.content[r.index], "f");
        }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (se(this, Nu, "f") !== void 0) {
        const r = e.data.content[se(this, Nu, "f")];
        if (r)
          switch (r.type) {
            case "image_file":
              this._emit("imageFileDone", r.image_file, se(this, sr, "f"));
              break;
            case "text":
              this._emit("textDone", r.text, se(this, sr, "f"));
              break;
          }
      }
      se(this, sr, "f") && this._emit("messageDone", e.data), mn(this, sr, void 0, "f");
  }
}, zy = function(e) {
  const n = se(this, It, "m", Ky).call(this, e);
  switch (mn(this, Gl, n, "f"), e.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", e.data);
      break;
    case "thread.run.step.delta":
      const a = e.data.delta;
      if (a.step_details && a.step_details.type == "tool_calls" && a.step_details.tool_calls && n.step_details.type == "tool_calls")
        for (const i of a.step_details.tool_calls)
          i.index == se(this, Oh, "f") ? this._emit("toolCallDelta", i, n.step_details.tool_calls[i.index]) : (se(this, yn, "f") && this._emit("toolCallDone", se(this, yn, "f")), mn(this, Oh, i.index, "f"), mn(this, yn, n.step_details.tool_calls[i.index], "f"), se(this, yn, "f") && this._emit("toolCallCreated", se(this, yn, "f")));
      this._emit("runStepDelta", e.data.delta, n);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      mn(this, Gl, void 0, "f"), e.data.step_details.type == "tool_calls" && se(this, yn, "f") && (this._emit("toolCallDone", se(this, yn, "f")), mn(this, yn, void 0, "f")), this._emit("runStepDone", e.data, n);
      break;
  }
}, Zy = function(e) {
  se(this, zb, "f").push(e), this._emit("event", e);
}, Ky = function(e) {
  switch (e.event) {
    case "thread.run.step.created":
      return se(this, aa, "f")[e.data.id] = e.data, e.data;
    case "thread.run.step.delta":
      let n = se(this, aa, "f")[e.data.id];
      if (!n)
        throw Error("Received a RunStepDelta before creation of a snapshot");
      let a = e.data;
      if (a.delta) {
        const r = or.accumulateDelta(n, a.delta);
        se(this, aa, "f")[e.data.id] = r;
      }
      return se(this, aa, "f")[e.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      se(this, aa, "f")[e.data.id] = e.data;
      break;
  }
  if (se(this, aa, "f")[e.data.id])
    return se(this, aa, "f")[e.data.id];
  throw new Error("No snapshot available");
}, Hy = function(e, n) {
  let a = [];
  switch (e.event) {
    case "thread.message.created":
      return [e.data, a];
    case "thread.message.delta":
      if (!n)
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      let r = e.data;
      if (r.delta.content)
        for (const i of r.delta.content)
          if (i.index in n.content) {
            let s = n.content[i.index];
            n.content[i.index] = se(this, It, "m", Gy).call(this, i, s);
          } else
            n.content[i.index] = i, a.push(i);
      return [n, a];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (n)
        return [n, a];
      throw Error("Received thread message event with no existing snapshot");
  }
  throw Error("Tried to accumulate a non-message event");
}, Gy = function(e, n) {
  return or.accumulateDelta(n, e);
}, Wy = function(e) {
  switch (mn(this, lh, e.data, "f"), e.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
      mn(this, Jo, e.data, "f"), se(this, yn, "f") && (this._emit("toolCallDone", se(this, yn, "f")), mn(this, yn, void 0, "f"));
      break;
  }
};
let Lg = class extends Pe {
  /**
   * Create a message.
   */
  create(e, n, a) {
    return this._client.post(`/threads/${e}/messages`, {
      body: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Retrieve a message.
   */
  retrieve(e, n, a) {
    return this._client.get(`/threads/${e}/messages/${n}`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Modifies a message.
   */
  update(e, n, a, r) {
    return this._client.post(`/threads/${e}/messages/${n}`, {
      body: a,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r?.headers }
    });
  }
  list(e, n = {}, a) {
    return Tt(n) ? this.list(e, {}, n) : this._client.getAPIList(`/threads/${e}/messages`, Ug, {
      query: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Deletes a message.
   */
  del(e, n, a) {
    return this._client.delete(`/threads/${e}/messages/${n}`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
};
class Ug extends fn {
}
Lg.MessagesPage = Ug;
class Bg extends Pe {
  retrieve(e, n, a, r = {}, i) {
    return Tt(r) ? this.retrieve(e, n, a, {}, r) : this._client.get(`/threads/${e}/runs/${n}/steps/${a}`, {
      query: r,
      ...i,
      headers: { "OpenAI-Beta": "assistants=v2", ...i?.headers }
    });
  }
  list(e, n, a = {}, r) {
    return Tt(a) ? this.list(e, n, {}, a) : this._client.getAPIList(`/threads/${e}/runs/${n}/steps`, xg, {
      query: a,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r?.headers }
    });
  }
}
class xg extends fn {
}
Bg.RunStepsPage = xg;
class Ld extends Pe {
  constructor() {
    super(...arguments), this.steps = new Bg(this._client);
  }
  create(e, n, a) {
    const { include: r, ...i } = n;
    return this._client.post(`/threads/${e}/runs`, {
      query: { include: r },
      body: i,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers },
      stream: n.stream ?? !1
    });
  }
  /**
   * Retrieves a run.
   */
  retrieve(e, n, a) {
    return this._client.get(`/threads/${e}/runs/${n}`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Modifies a run.
   */
  update(e, n, a, r) {
    return this._client.post(`/threads/${e}/runs/${n}`, {
      body: a,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r?.headers }
    });
  }
  list(e, n = {}, a) {
    return Tt(n) ? this.list(e, {}, n) : this._client.getAPIList(`/threads/${e}/runs`, Vg, {
      query: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   */
  cancel(e, n, a) {
    return this._client.post(`/threads/${e}/runs/${n}/cancel`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(e, n, a) {
    const r = await this.create(e, n, a);
    return await this.poll(e, r.id, a);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(e, n, a) {
    return or.createAssistantStream(e, this._client.beta.threads.runs, n, a);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(e, n, a) {
    const r = { ...a?.headers, "X-Stainless-Poll-Helper": "true" };
    for (a?.pollIntervalMs && (r["X-Stainless-Custom-Poll-Interval"] = a.pollIntervalMs.toString()); ; ) {
      const { data: i, response: s } = await this.retrieve(e, n, {
        ...a,
        headers: { ...a?.headers, ...r }
      }).withResponse();
      switch (i.status) {
        //If we are in any sort of intermediate state we poll
        case "queued":
        case "in_progress":
        case "cancelling":
          let o = 5e3;
          if (a?.pollIntervalMs)
            o = a.pollIntervalMs;
          else {
            const l = s.headers.get("openai-poll-after-ms");
            if (l) {
              const f = parseInt(l);
              isNaN(f) || (o = f);
            }
          }
          await Dd(o);
          break;
        //We return the run in any terminal state.
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return i;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(e, n, a) {
    return or.createAssistantStream(e, this._client.beta.threads.runs, n, a);
  }
  submitToolOutputs(e, n, a, r) {
    return this._client.post(`/threads/${e}/runs/${n}/submit_tool_outputs`, {
      body: a,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r?.headers },
      stream: a.stream ?? !1
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(e, n, a, r) {
    const i = await this.submitToolOutputs(e, n, a, r);
    return await this.poll(e, i.id, r);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(e, n, a, r) {
    return or.createToolAssistantStream(e, n, this._client.beta.threads.runs, a, r);
  }
}
class Vg extends fn {
}
Ld.RunsPage = Vg;
Ld.Steps = Bg;
Ld.RunStepsPage = xg;
class nc extends Pe {
  constructor() {
    super(...arguments), this.runs = new Ld(this._client), this.messages = new Lg(this._client);
  }
  create(e = {}, n) {
    return Tt(e) ? this.create({}, e) : this._client.post("/threads", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Retrieves a thread.
   */
  retrieve(e, n) {
    return this._client.get(`/threads/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Modifies a thread.
   */
  update(e, n, a) {
    return this._client.post(`/threads/${e}`, {
      body: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Delete a thread.
   */
  del(e, n) {
    return this._client.delete(`/threads/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  createAndRun(e, n) {
    return this._client.post("/threads/runs", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers },
      stream: e.stream ?? !1
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(e, n) {
    const a = await this.createAndRun(e, n);
    return await this.runs.poll(a.thread_id, a.id, n);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(e, n) {
    return or.createThreadAssistantStream(e, this._client.beta.threads, n);
  }
}
nc.Runs = Ld;
nc.RunsPage = Vg;
nc.Messages = Lg;
nc.MessagesPage = Ug;
let rc = class extends Pe {
  constructor() {
    super(...arguments), this.realtime = new wp(this._client), this.chat = new Vb(this._client), this.assistants = new kg(this._client), this.threads = new nc(this._client);
  }
};
rc.Realtime = wp;
rc.Assistants = kg;
rc.AssistantsPage = Fg;
rc.Threads = nc;
let GR = class extends Pe {
  create(e, n) {
    return this._client.post("/completions", { body: e, ...n, stream: e.stream ?? !1 });
  }
}, WR = class extends Pe {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(e, n) {
    return this._client.post("/embeddings", { body: e, ...n });
  }
}, zg = class extends Pe {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 100 GB.
   *
   * The Assistants API supports files up to 2 million tokens and of specific file
   * types. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
   * details.
   *
   * The Fine-tuning API only supports `.jsonl` files. The input also has certain
   * required formats for fine-tuning
   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   * models.
   *
   * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
   * has a specific required
   * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(e, n) {
    return this._client.post("/files", Ku({ body: e, ...n }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(e, n) {
    return this._client.get(`/files/${e}`, n);
  }
  list(e = {}, n) {
    return Tt(e) ? this.list({}, e) : this._client.getAPIList("/files", Zg, { query: e, ...n });
  }
  /**
   * Delete a file.
   */
  del(e, n) {
    return this._client.delete(`/files/${e}`, n);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(e, n) {
    return this._client.get(`/files/${e}/content`, {
      ...n,
      headers: { Accept: "application/binary", ...n?.headers },
      __binaryResponse: !0
    });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(e, n) {
    return this._client.get(`/files/${e}/content`, n);
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(e, { pollInterval: n = 5e3, maxWait: a = 30 * 60 * 1e3 } = {}) {
    const r = /* @__PURE__ */ new Set(["processed", "error", "deleted"]), i = Date.now();
    let s = await this.retrieve(e);
    for (; !s.status || !r.has(s.status); )
      if (await Dd(n), s = await this.retrieve(e), Date.now() - i > a)
        throw new pp({
          message: `Giving up on waiting for file ${e} to finish processing after ${a} milliseconds.`
        });
    return s;
  }
};
class Zg extends fn {
}
zg.FileObjectsPage = Zg;
class Kg extends Pe {
  list(e, n = {}, a) {
    return Tt(n) ? this.list(e, {}, n) : this._client.getAPIList(`/fine_tuning/jobs/${e}/checkpoints`, Hg, { query: n, ...a });
  }
}
class Hg extends fn {
}
Kg.FineTuningJobCheckpointsPage = Hg;
class ac extends Pe {
  constructor() {
    super(...arguments), this.checkpoints = new Kg(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  create(e, n) {
    return this._client.post("/fine_tuning/jobs", { body: e, ...n });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  retrieve(e, n) {
    return this._client.get(`/fine_tuning/jobs/${e}`, n);
  }
  list(e = {}, n) {
    return Tt(e) ? this.list({}, e) : this._client.getAPIList("/fine_tuning/jobs", Gg, { query: e, ...n });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(e, n) {
    return this._client.post(`/fine_tuning/jobs/${e}/cancel`, n);
  }
  listEvents(e, n = {}, a) {
    return Tt(n) ? this.listEvents(e, {}, n) : this._client.getAPIList(`/fine_tuning/jobs/${e}/events`, Wg, {
      query: n,
      ...a
    });
  }
}
class Gg extends fn {
}
class Wg extends fn {
}
ac.FineTuningJobsPage = Gg;
ac.FineTuningJobEventsPage = Wg;
ac.Checkpoints = Kg;
ac.FineTuningJobCheckpointsPage = Hg;
class Ud extends Pe {
  constructor() {
    super(...arguments), this.jobs = new ac(this._client);
  }
}
Ud.Jobs = ac;
Ud.FineTuningJobsPage = Gg;
Ud.FineTuningJobEventsPage = Wg;
class XR extends Pe {
  /**
   * Creates a variation of a given image.
   */
  createVariation(e, n) {
    return this._client.post("/images/variations", Ku({ body: e, ...n }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(e, n) {
    return this._client.post("/images/edits", Ku({ body: e, ...n }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(e, n) {
    return this._client.post("/images/generations", { body: e, ...n });
  }
}
let Xg = class extends Pe {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(e, n) {
    return this._client.get(`/models/${e}`, n);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(e) {
    return this._client.getAPIList("/models", Qg, e);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(e, n) {
    return this._client.delete(`/models/${e}`, n);
  }
};
class Qg extends Eg {
}
Xg.ModelsPage = Qg;
class QR extends Pe {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(e, n) {
    return this._client.post("/moderations", { body: e, ...n });
  }
}
function oI(t, e) {
  return !e || !cI(e) ? {
    ...t,
    output_parsed: null,
    output: t.output.map((n) => n.type === "function_call" ? {
      ...n,
      parsed_arguments: null
    } : n.type === "message" ? {
      ...n,
      content: n.content.map((a) => ({
        ...a,
        parsed: null
      }))
    } : n)
  } : YR(t, e);
}
function YR(t, e) {
  const n = t.output.map((r) => {
    if (r.type === "function_call")
      return {
        ...r,
        parsed_arguments: fI(e, r)
      };
    if (r.type === "message") {
      const i = r.content.map((s) => s.type === "output_text" ? {
        ...s,
        parsed: uI(e, s.text)
      } : s);
      return {
        ...r,
        content: i
      };
    }
    return r;
  }), a = Object.assign({}, t, { output: n });
  return Object.getOwnPropertyDescriptor(t, "output_text") || eC(a), Object.defineProperty(a, "output_parsed", {
    enumerable: !0,
    get() {
      for (const r of a.output)
        if (r.type === "message") {
          for (const i of r.content)
            if (i.type === "output_text" && i.parsed !== null)
              return i.parsed;
        }
      return null;
    }
  }), a;
}
function uI(t, e) {
  return t.text?.format?.type !== "json_schema" ? null : "$parseRaw" in t.text?.format ? (t.text?.format).$parseRaw(e) : JSON.parse(e);
}
function cI(t) {
  return !!qg(t.text?.format);
}
function lI(t) {
  return t?.$brand === "auto-parseable-tool";
}
function dI(t, e) {
  return t.find((n) => n.type === "function" && n.name === e);
}
function fI(t, e) {
  const n = dI(t.tools ?? [], e.name);
  return {
    ...e,
    ...e,
    parsed_arguments: lI(n) ? n.$parseRaw(e.arguments) : n?.strict ? JSON.parse(e.arguments) : null
  };
}
function eC(t) {
  const e = [];
  for (const n of t.output)
    if (n.type === "message")
      for (const a of n.content)
        a.type === "output_text" && e.push(a.text);
  t.output_text = e.join("");
}
class tC extends Pe {
  list(e, n = {}, a) {
    return Tt(n) ? this.list(e, {}, n) : this._client.getAPIList(`/responses/${e}/input_items`, pI, {
      query: n,
      ...a
    });
  }
}
var pu = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, Ws = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, mu, gf, Xs, _f, Xy, Qy, Yy, ew;
class Yg extends Dg {
  constructor(e) {
    super(), mu.add(this), gf.set(this, void 0), Xs.set(this, void 0), _f.set(this, void 0), pu(this, gf, e, "f");
  }
  static createResponse(e, n, a) {
    const r = new Yg(n);
    return r._run(() => r._createResponse(e, n, {
      ...a,
      headers: { ...a?.headers, "X-Stainless-Helper-Method": "stream" }
    })), r;
  }
  async _createResponse(e, n, a) {
    const r = a?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), Ws(this, mu, "m", Xy).call(this);
    const i = await e.responses.create({ ...n, stream: !0 }, { ...a, signal: this.controller.signal });
    this._connected();
    for await (const s of i)
      Ws(this, mu, "m", Qy).call(this, s);
    if (i.controller.signal?.aborted)
      throw new On();
    return Ws(this, mu, "m", Yy).call(this);
  }
  [(gf = /* @__PURE__ */ new WeakMap(), Xs = /* @__PURE__ */ new WeakMap(), _f = /* @__PURE__ */ new WeakMap(), mu = /* @__PURE__ */ new WeakSet(), Xy = function() {
    this.ended || pu(this, Xs, void 0, "f");
  }, Qy = function(n) {
    if (this.ended)
      return;
    const a = Ws(this, mu, "m", ew).call(this, n);
    switch (this._emit("event", n), n.type) {
      case "response.output_text.delta": {
        const r = a.output[n.output_index];
        if (!r)
          throw new de(`missing output at index ${n.output_index}`);
        if (r.type === "message") {
          const i = r.content[n.content_index];
          if (!i)
            throw new de(`missing content at index ${n.content_index}`);
          if (i.type !== "output_text")
            throw new de(`expected content to be 'output_text', got ${i.type}`);
          this._emit("response.output_text.delta", {
            ...n,
            snapshot: i.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const r = a.output[n.output_index];
        if (!r)
          throw new de(`missing output at index ${n.output_index}`);
        r.type === "function_call" && this._emit("response.function_call_arguments.delta", {
          ...n,
          snapshot: r.arguments
        });
        break;
      }
      default:
        this._emit(n.type, n);
        break;
    }
  }, Yy = function() {
    if (this.ended)
      throw new de("stream has ended, this shouldn't happen");
    const n = Ws(this, Xs, "f");
    if (!n)
      throw new de("request ended without sending any events");
    pu(this, Xs, void 0, "f");
    const a = hI(n, Ws(this, gf, "f"));
    return pu(this, _f, a, "f"), a;
  }, ew = function(n) {
    let a = Ws(this, Xs, "f");
    if (!a) {
      if (n.type !== "response.created")
        throw new de(`When snapshot hasn't been set yet, expected 'response.created' event, got ${n.type}`);
      return a = pu(this, Xs, n.response, "f"), a;
    }
    switch (n.type) {
      case "response.output_item.added": {
        a.output.push(n.item);
        break;
      }
      case "response.content_part.added": {
        const r = a.output[n.output_index];
        if (!r)
          throw new de(`missing output at index ${n.output_index}`);
        r.type === "message" && r.content.push(n.part);
        break;
      }
      case "response.output_text.delta": {
        const r = a.output[n.output_index];
        if (!r)
          throw new de(`missing output at index ${n.output_index}`);
        if (r.type === "message") {
          const i = r.content[n.content_index];
          if (!i)
            throw new de(`missing content at index ${n.content_index}`);
          if (i.type !== "output_text")
            throw new de(`expected content to be 'output_text', got ${i.type}`);
          i.text += n.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const r = a.output[n.output_index];
        if (!r)
          throw new de(`missing output at index ${n.output_index}`);
        r.type === "function_call" && (r.arguments += n.delta);
        break;
      }
      case "response.completed": {
        pu(this, Xs, n.response, "f");
        break;
      }
    }
    return a;
  }, Symbol.asyncIterator)]() {
    const e = [], n = [];
    let a = !1;
    return this.on("event", (r) => {
      const i = n.shift();
      i ? i.resolve(r) : e.push(r);
    }), this.on("end", () => {
      a = !0;
      for (const r of n)
        r.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), this.on("error", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : a ? { value: void 0, done: !0 } : new Promise((i, s) => n.push({ resolve: i, reject: s })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const e = Ws(this, _f, "f");
    if (!e)
      throw new de("stream ended without producing a ChatCompletion");
    return e;
  }
}
function hI(t, e) {
  return oI(t, e);
}
class e_ extends Pe {
  constructor() {
    super(...arguments), this.inputItems = new tC(this._client);
  }
  create(e, n) {
    return this._client.post("/responses", { body: e, ...n, stream: e.stream ?? !1 })._thenUnwrap((a) => ("object" in a && a.object === "response" && eC(a), a));
  }
  retrieve(e, n = {}, a) {
    return Tt(n) ? this.retrieve(e, {}, n) : this._client.get(`/responses/${e}`, { query: n, ...a });
  }
  /**
   * Deletes a model response with the given ID.
   */
  del(e, n) {
    return this._client.delete(`/responses/${e}`, {
      ...n,
      headers: { Accept: "*/*", ...n?.headers }
    });
  }
  parse(e, n) {
    return this._client.responses.create(e, n)._thenUnwrap((a) => YR(a, e));
  }
  /**
   * Creates a chat completion stream
   */
  stream(e, n) {
    return Yg.createResponse(this._client, e, n);
  }
}
class pI extends fn {
}
e_.InputItems = tC;
class nC extends Pe {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(e, n, a) {
    return this._client.post(`/uploads/${e}/parts`, Ku({ body: n, ...a }));
  }
}
class t_ extends Pe {
  constructor() {
    super(...arguments), this.parts = new nC(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(e, n) {
    return this._client.post("/uploads", { body: e, ...n });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(e, n) {
    return this._client.post(`/uploads/${e}/cancel`, n);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(e, n, a) {
    return this._client.post(`/uploads/${e}/complete`, { body: n, ...a });
  }
}
t_.Parts = nC;
const mI = async (t) => {
  const e = await Promise.allSettled(t), n = e.filter((r) => r.status === "rejected");
  if (n.length) {
    for (const r of n)
      console.error(r.reason);
    throw new Error(`${n.length} promise(s) failed - see the above errors`);
  }
  const a = [];
  for (const r of e)
    r.status === "fulfilled" && a.push(r.value);
  return a;
};
class vp extends Pe {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(e, n, a) {
    return this._client.post(`/vector_stores/${e}/files`, {
      body: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(e, n, a) {
    return this._client.get(`/vector_stores/${e}/files/${n}`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(e, n, a, r) {
    return this._client.post(`/vector_stores/${e}/files/${n}`, {
      body: a,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r?.headers }
    });
  }
  list(e, n = {}, a) {
    return Tt(n) ? this.list(e, {}, n) : this._client.getAPIList(`/vector_stores/${e}/files`, Sp, {
      query: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  del(e, n, a) {
    return this._client.delete(`/vector_stores/${e}/files/${n}`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(e, n, a) {
    const r = await this.create(e, n, a);
    return await this.poll(e, r.id, a);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(e, n, a) {
    const r = { ...a?.headers, "X-Stainless-Poll-Helper": "true" };
    for (a?.pollIntervalMs && (r["X-Stainless-Custom-Poll-Interval"] = a.pollIntervalMs.toString()); ; ) {
      const i = await this.retrieve(e, n, {
        ...a,
        headers: r
      }).withResponse(), s = i.data;
      switch (s.status) {
        case "in_progress":
          let o = 5e3;
          if (a?.pollIntervalMs)
            o = a.pollIntervalMs;
          else {
            const l = i.response.headers.get("openai-poll-after-ms");
            if (l) {
              const f = parseInt(l);
              isNaN(f) || (o = f);
            }
          }
          await Dd(o);
          break;
        case "failed":
        case "completed":
          return s;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(e, n, a) {
    const r = await this._client.files.create({ file: n, purpose: "assistants" }, a);
    return this.create(e, { file_id: r.id }, a);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(e, n, a) {
    const r = await this.upload(e, n, a);
    return await this.poll(e, r.id, a);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(e, n, a) {
    return this._client.getAPIList(`/vector_stores/${e}/files/${n}/content`, n_, { ...a, headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers } });
  }
}
class Sp extends fn {
}
class n_ extends Eg {
}
vp.VectorStoreFilesPage = Sp;
vp.FileContentResponsesPage = n_;
class rC extends Pe {
  /**
   * Create a vector store file batch.
   */
  create(e, n, a) {
    return this._client.post(`/vector_stores/${e}/file_batches`, {
      body: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(e, n, a) {
    return this._client.get(`/vector_stores/${e}/file_batches/${n}`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(e, n, a) {
    return this._client.post(`/vector_stores/${e}/file_batches/${n}/cancel`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(e, n, a) {
    const r = await this.create(e, n);
    return await this.poll(e, r.id, a);
  }
  listFiles(e, n, a = {}, r) {
    return Tt(a) ? this.listFiles(e, n, {}, a) : this._client.getAPIList(`/vector_stores/${e}/file_batches/${n}/files`, Sp, { query: a, ...r, headers: { "OpenAI-Beta": "assistants=v2", ...r?.headers } });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(e, n, a) {
    const r = { ...a?.headers, "X-Stainless-Poll-Helper": "true" };
    for (a?.pollIntervalMs && (r["X-Stainless-Custom-Poll-Interval"] = a.pollIntervalMs.toString()); ; ) {
      const { data: i, response: s } = await this.retrieve(e, n, {
        ...a,
        headers: r
      }).withResponse();
      switch (i.status) {
        case "in_progress":
          let o = 5e3;
          if (a?.pollIntervalMs)
            o = a.pollIntervalMs;
          else {
            const l = s.headers.get("openai-poll-after-ms");
            if (l) {
              const f = parseInt(l);
              isNaN(f) || (o = f);
            }
          }
          await Dd(o);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return i;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(e, { files: n, fileIds: a = [] }, r) {
    if (n == null || n.length == 0)
      throw new Error("No `files` provided to process. If you've already uploaded files you should use `.createAndPoll()` instead");
    const i = r?.maxConcurrency ?? 5, s = Math.min(i, n.length), o = this._client, l = n.values(), f = [...a];
    async function u(h) {
      for (let p of h) {
        const d = await o.files.create({ file: p, purpose: "assistants" }, r);
        f.push(d.id);
      }
    }
    const c = Array(s).fill(l).map(u);
    return await mI(c), await this.createAndPoll(e, {
      file_ids: f
    });
  }
}
class _o extends Pe {
  constructor() {
    super(...arguments), this.files = new vp(this._client), this.fileBatches = new rC(this._client);
  }
  /**
   * Create a vector store.
   */
  create(e, n) {
    return this._client.post("/vector_stores", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(e, n) {
    return this._client.get(`/vector_stores/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Modifies a vector store.
   */
  update(e, n, a) {
    return this._client.post(`/vector_stores/${e}`, {
      body: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  list(e = {}, n) {
    return Tt(e) ? this.list({}, e) : this._client.getAPIList("/vector_stores", r_, {
      query: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Delete a vector store.
   */
  del(e, n) {
    return this._client.delete(`/vector_stores/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(e, n, a) {
    return this._client.getAPIList(`/vector_stores/${e}/search`, a_, {
      body: n,
      method: "post",
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
}
class r_ extends fn {
}
class a_ extends Eg {
}
_o.VectorStoresPage = r_;
_o.VectorStoreSearchResponsesPage = a_;
_o.Files = vp;
_o.VectorStoreFilesPage = Sp;
_o.FileContentResponsesPage = n_;
_o.FileBatches = rC;
var aC;
let ge = class extends NE {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL: e = ff("OPENAI_BASE_URL"), apiKey: n = ff("OPENAI_API_KEY"), organization: a = ff("OPENAI_ORG_ID") ?? null, project: r = ff("OPENAI_PROJECT_ID") ?? null, ...i } = {}) {
    if (n === void 0)
      throw new de("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    const s = {
      apiKey: n,
      organization: a,
      project: r,
      ...i,
      baseURL: e || "https://api.openai.com/v1"
    };
    if (!s.dangerouslyAllowBrowser && zE())
      throw new de(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

https://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety
`);
    super({
      baseURL: s.baseURL,
      timeout: s.timeout ?? 6e5,
      httpAgent: s.httpAgent,
      maxRetries: s.maxRetries,
      fetch: s.fetch
    }), this.completions = new GR(this), this.chat = new yp(this), this.embeddings = new WR(this), this.files = new zg(this), this.images = new XR(this), this.audio = new qd(this), this.moderations = new QR(this), this.models = new Xg(this), this.fineTuning = new Ud(this), this.vectorStores = new _o(this), this.beta = new rc(this), this.batches = new Ig(this), this.uploads = new t_(this), this.responses = new e_(this), this._options = s, this.apiKey = n, this.organization = a, this.project = r;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(e) {
    return {
      ...super.defaultHeaders(e),
      "OpenAI-Organization": this.organization,
      "OpenAI-Project": this.project,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(e) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
  stringifyQuery(e) {
    return uE(e, { arrayFormat: "brackets" });
  }
};
aC = ge;
ge.OpenAI = aC;
ge.DEFAULT_TIMEOUT = 6e5;
ge.OpenAIError = de;
ge.APIError = cn;
ge.APIConnectionError = hp;
ge.APIConnectionTimeoutError = pp;
ge.APIUserAbortError = On;
ge.NotFoundError = iR;
ge.ConflictError = sR;
ge.RateLimitError = uR;
ge.BadRequestError = nR;
ge.AuthenticationError = rR;
ge.InternalServerError = cR;
ge.PermissionDeniedError = aR;
ge.UnprocessableEntityError = oR;
ge.toFile = mR;
ge.fileFromPath = eR;
ge.Completions = GR;
ge.Chat = yp;
ge.ChatCompletionsPage = _p;
ge.Embeddings = WR;
ge.Files = zg;
ge.FileObjectsPage = Zg;
ge.Images = XR;
ge.Audio = qd;
ge.Moderations = QR;
ge.Models = Xg;
ge.ModelsPage = Qg;
ge.FineTuning = Ud;
ge.VectorStores = _o;
ge.VectorStoresPage = r_;
ge.VectorStoreSearchResponsesPage = a_;
ge.Beta = rc;
ge.Batches = Ig;
ge.BatchesPage = Ng;
ge.Uploads = t_;
ge.Responses = e_;
function tw(t, e = i_) {
  t = t.trim();
  const n = /```(json)?(.*)```/s.exec(t);
  return e(n ? n[2] : t);
}
function i_(t) {
  if (typeof t > "u")
    return null;
  try {
    return JSON.parse(t);
  } catch {
  }
  let e = "";
  const n = [];
  let a = !1, r = !1;
  for (let i of t) {
    if (a)
      i === '"' && !r ? a = !1 : i === `
` && !r ? i = "\\n" : i === "\\" ? r = !r : r = !1;
    else if (i === '"')
      a = !0, r = !1;
    else if (i === "{")
      n.push("}");
    else if (i === "[")
      n.push("]");
    else if (i === "}" || i === "]")
      if (n && n[n.length - 1] === i)
        n.pop();
      else
        return null;
    e += i;
  }
  a && (e += '"');
  for (let i = n.length - 1; i >= 0; i -= 1)
    e += n[i];
  try {
    return JSON.parse(e);
  } catch {
    return null;
  }
}
function Bd(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var mm, nw;
function bI() {
  return nw || (nw = 1, mm = function(t, e) {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    return e = typeof e > "u" ? "_" : e, t.replace(/([a-z\d])([A-Z])/g, "$1" + e + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + e + "$2").toLowerCase();
  }), mm;
}
var gI = /* @__PURE__ */ bI();
const _I = /* @__PURE__ */ Bd(gI);
function yI(t, e) {
  return e?.[t] || _I(t);
}
function wI(t, e, n) {
  const a = {};
  for (const r in t)
    Object.hasOwn(t, r) && (a[e(r, n)] = t[r]);
  return a;
}
function rw(t) {
  return Array.isArray(t) ? [...t] : { ...t };
}
function vI(t, e) {
  const n = rw(t);
  for (const [a, r] of Object.entries(e)) {
    const [i, ...s] = a.split(".").reverse();
    let o = n;
    for (const l of s.reverse()) {
      if (o[l] === void 0)
        break;
      o[l] = rw(o[l]), o = o[l];
    }
    o[i] !== void 0 && (o[i] = {
      lc: 1,
      type: "secret",
      id: [r]
    });
  }
  return n;
}
function iC(t) {
  const e = Object.getPrototypeOf(t);
  return typeof t.lc_name == "function" && (typeof e.lc_name != "function" || t.lc_name() !== e.lc_name()) ? t.lc_name() : t.name;
}
class gr {
  /**
   * The name of the serializable. Override to provide an alias or
   * to preserve the serialized module name in minified environments.
   *
   * Implemented as a static method to support loading logic.
   */
  static lc_name() {
    return this.name;
  }
  /**
   * The final serialized identifier for the module.
   */
  get lc_id() {
    return [
      ...this.lc_namespace,
      iC(this.constructor)
    ];
  }
  /**
   * A map of secrets, which will be omitted from serialization.
   * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
   * Values are the secret ids, which will be used when deserializing.
   */
  get lc_secrets() {
  }
  /**
   * A map of additional attributes to merge with constructor args.
   * Keys are the attribute names, e.g. "foo".
   * Values are the attribute values, which will be serialized.
   * These attributes need to be accepted by the constructor as arguments.
   */
  get lc_attributes() {
  }
  /**
   * A map of aliases for constructor args.
   * Keys are the attribute names, e.g. "foo".
   * Values are the alias that will replace the key in serialization.
   * This is used to eg. make argument names match Python.
   */
  get lc_aliases() {
  }
  /**
   * A manual list of keys that should be serialized.
   * If not overridden, all fields passed into the constructor will be serialized.
   */
  get lc_serializable_keys() {
  }
  constructor(e, ...n) {
    Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "lc_kwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.lc_serializable_keys !== void 0 ? this.lc_kwargs = Object.fromEntries(Object.entries(e || {}).filter(([a]) => this.lc_serializable_keys?.includes(a))) : this.lc_kwargs = e ?? {};
  }
  toJSON() {
    if (!this.lc_serializable)
      return this.toJSONNotImplemented();
    if (
      // eslint-disable-next-line no-instanceof/no-instanceof
      this.lc_kwargs instanceof gr || typeof this.lc_kwargs != "object" || Array.isArray(this.lc_kwargs)
    )
      return this.toJSONNotImplemented();
    const e = {}, n = {}, a = Object.keys(this.lc_kwargs).reduce((r, i) => (r[i] = i in this ? this[i] : this.lc_kwargs[i], r), {});
    for (let r = Object.getPrototypeOf(this); r; r = Object.getPrototypeOf(r))
      Object.assign(e, Reflect.get(r, "lc_aliases", this)), Object.assign(n, Reflect.get(r, "lc_secrets", this)), Object.assign(a, Reflect.get(r, "lc_attributes", this));
    return Object.keys(n).forEach((r) => {
      let i = this, s = a;
      const [o, ...l] = r.split(".").reverse();
      for (const f of l.reverse()) {
        if (!(f in i) || i[f] === void 0)
          return;
        (!(f in s) || s[f] === void 0) && (typeof i[f] == "object" && i[f] != null ? s[f] = {} : Array.isArray(i[f]) && (s[f] = [])), i = i[f], s = s[f];
      }
      o in i && i[o] !== void 0 && (s[o] = s[o] || i[o]);
    }), {
      lc: 1,
      type: "constructor",
      id: this.lc_id,
      kwargs: wI(Object.keys(n).length ? vI(a, n) : a, yI, e)
    };
  }
  toJSONNotImplemented() {
    return {
      lc: 1,
      type: "not_implemented",
      id: this.lc_id
    };
  }
}
function ic(t, e) {
  return typeof t == "string" ? t === "" ? e : typeof e == "string" ? t + e : [{ type: "text", text: t }, ...e] : Array.isArray(e) ? Op(t, e) ?? [
    ...t,
    ...e
  ] : e === "" ? t : [...t, { type: "text", text: e }];
}
function SI(t, e) {
  return t === "error" || e === "error" ? "error" : "success";
}
function OI(t, e) {
  function n(a, r) {
    if (typeof a != "object" || a === null || a === void 0)
      return a;
    if (r >= e)
      return Array.isArray(a) ? "[Array]" : "[Object]";
    if (Array.isArray(a))
      return a.map((s) => n(s, r + 1));
    const i = {};
    for (const s of Object.keys(a))
      i[s] = n(a[s], r + 1);
    return i;
  }
  return JSON.stringify(n(t, 0), null, 2);
}
class ca extends gr {
  get lc_aliases() {
    return {
      additional_kwargs: "additional_kwargs",
      response_metadata: "response_metadata"
    };
  }
  /**
   * Get text content of the message.
   */
  get text() {
    return typeof this.content == "string" ? this.content : Array.isArray(this.content) ? this.content.map((e) => typeof e == "string" ? e : e.type === "text" ? e.text : "").join("") : "";
  }
  /** The type of the message. */
  getType() {
    return this._getType();
  }
  constructor(e, n) {
    typeof e == "string" && (e = {
      content: e,
      additional_kwargs: n,
      response_metadata: {}
    }), e.additional_kwargs || (e.additional_kwargs = {}), e.response_metadata || (e.response_metadata = {}), super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "messages"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "content", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "additional_kwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "response_metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = e.name, this.content = e.content, this.additional_kwargs = e.additional_kwargs, this.response_metadata = e.response_metadata, this.id = e.id;
  }
  toDict() {
    return {
      type: this._getType(),
      data: this.toJSON().kwargs
    };
  }
  static lc_name() {
    return "BaseMessage";
  }
  // Can't be protected for silly reasons
  get _printableFields() {
    return {
      id: this.id,
      content: this.content,
      name: this.name,
      additional_kwargs: this.additional_kwargs,
      response_metadata: this.response_metadata
    };
  }
  // this private method is used to update the ID for the runtime
  // value as well as in lc_kwargs for serialisation
  _updateId(e) {
    this.id = e, this.lc_kwargs.id = e;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.lc_name();
  }
  // Override the default behavior of console.log
  [Symbol.for("nodejs.util.inspect.custom")](e) {
    if (e === null)
      return this;
    const n = OI(this._printableFields, Math.max(4, e));
    return `${this.constructor.lc_name()} ${n}`;
  }
}
function Wt(t, e) {
  const n = { ...t };
  for (const [a, r] of Object.entries(e))
    if (n[a] == null)
      n[a] = r;
    else {
      if (r == null)
        continue;
      if (typeof n[a] != typeof r || Array.isArray(n[a]) !== Array.isArray(r))
        throw new Error(`field[${a}] already exists in the message chunk, but with a different type.`);
      if (typeof n[a] == "string") {
        if (a === "type")
          continue;
        n[a] += r;
      } else if (typeof n[a] == "object" && !Array.isArray(n[a]))
        n[a] = Wt(n[a], r);
      else if (Array.isArray(n[a]))
        n[a] = Op(n[a], r);
      else {
        if (n[a] === r)
          continue;
        console.warn(`field[${a}] already exists in this message chunk and value has unsupported type.`);
      }
    }
  return n;
}
function Op(t, e) {
  if (!(t === void 0 && e === void 0)) {
    if (t === void 0 || e === void 0)
      return t || e;
    {
      const n = [...t];
      for (const a of e)
        if (typeof a == "object" && "index" in a && typeof a.index == "number") {
          const r = n.findIndex((i) => i.index === a.index);
          r !== -1 ? n[r] = Wt(n[r], a) : n.push(a);
        } else {
          if (typeof a == "object" && "text" in a && a.text === "")
            continue;
          n.push(a);
        }
      return n;
    }
  }
}
function jI(t, e) {
  if (!t && !e)
    throw new Error("Cannot merge two undefined objects.");
  if (!t || !e)
    return t || e;
  if (typeof t != typeof e)
    throw new Error(`Cannot merge objects of different types.
Left ${typeof t}
Right ${typeof e}`);
  if (typeof t == "string" && typeof e == "string")
    return t + e;
  if (Array.isArray(t) && Array.isArray(e))
    return Op(t, e);
  if (typeof t == "object" && typeof e == "object")
    return Wt(t, e);
  if (t === e)
    return t;
  throw new Error(`Can not merge objects of different types.
Left ${t}
Right ${e}`);
}
class sc extends ca {
}
function PI(t) {
  return typeof t.role == "string";
}
function an(t) {
  return typeof t?._getType == "function";
}
function Zb(t) {
  return an(t) && typeof t.concat == "function";
}
function RI(t) {
  return t != null && typeof t == "object" && "lc_direct_tool_output" in t && t.lc_direct_tool_output === !0;
}
class Kb extends ca {
  static lc_name() {
    return "ToolMessage";
  }
  get lc_aliases() {
    return { tool_call_id: "tool_call_id" };
  }
  constructor(e, n, a) {
    typeof e == "string" && (e = { content: e, name: a, tool_call_id: n }), super(e), Object.defineProperty(this, "lc_direct_tool_output", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tool_call_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "artifact", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.tool_call_id = e.tool_call_id, this.artifact = e.artifact, this.status = e.status;
  }
  _getType() {
    return "tool";
  }
  static isInstance(e) {
    return e._getType() === "tool";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
}
class jp extends sc {
  constructor(e) {
    super(e), Object.defineProperty(this, "tool_call_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "artifact", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.tool_call_id = e.tool_call_id, this.artifact = e.artifact, this.status = e.status;
  }
  static lc_name() {
    return "ToolMessageChunk";
  }
  _getType() {
    return "tool";
  }
  concat(e) {
    return new jp({
      content: ic(this.content, e.content),
      additional_kwargs: Wt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Wt(this.response_metadata, e.response_metadata),
      artifact: jI(this.artifact, e.artifact),
      tool_call_id: this.tool_call_id,
      id: this.id ?? e.id,
      status: SI(this.status, e.status)
    });
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
}
function CI(t) {
  const e = [], n = [];
  for (const a of t)
    if (a.function) {
      const r = a.function.name;
      try {
        const i = JSON.parse(a.function.arguments), s = {
          name: r || "",
          args: i || {},
          id: a.id
        };
        e.push(s);
      } catch {
        n.push({
          name: r,
          args: a.function.arguments,
          id: a.id,
          error: "Malformed args."
        });
      }
    } else
      continue;
  return [e, n];
}
function TI(t) {
  return t._getType() === "tool";
}
class $t extends ca {
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls"
    };
  }
  constructor(e, n) {
    let a;
    if (typeof e == "string")
      a = {
        content: e,
        tool_calls: [],
        invalid_tool_calls: [],
        additional_kwargs: n ?? {}
      };
    else {
      a = e;
      const r = a.additional_kwargs?.tool_calls, i = a.tool_calls;
      r != null && r.length > 0 && (i === void 0 || i.length === 0) && console.warn([
        "New LangChain packages are available that more efficiently handle",
        `tool calling.

Please upgrade your packages to versions that set`,
        "message tool calls. e.g., `yarn add @langchain/anthropic`,",
        "yarn add @langchain/openai`, etc."
      ].join(" "));
      try {
        if (r != null && i === void 0) {
          const [s, o] = CI(r);
          a.tool_calls = s ?? [], a.invalid_tool_calls = o ?? [];
        } else
          a.tool_calls = a.tool_calls ?? [], a.invalid_tool_calls = a.invalid_tool_calls ?? [];
      } catch {
        a.tool_calls = [], a.invalid_tool_calls = [];
      }
    }
    super(a), Object.defineProperty(this, "tool_calls", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "invalid_tool_calls", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "usage_metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), typeof a != "string" && (this.tool_calls = a.tool_calls ?? this.tool_calls, this.invalid_tool_calls = a.invalid_tool_calls ?? this.invalid_tool_calls), this.usage_metadata = a.usage_metadata;
  }
  static lc_name() {
    return "AIMessage";
  }
  _getType() {
    return "ai";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
}
function Vs(t) {
  return t._getType() === "ai";
}
function aw(t) {
  return t._getType() === "ai";
}
class Ze extends sc {
  constructor(e) {
    let n;
    if (typeof e == "string")
      n = {
        content: e,
        tool_calls: [],
        invalid_tool_calls: [],
        tool_call_chunks: []
      };
    else if (e.tool_call_chunks === void 0)
      n = {
        ...e,
        tool_calls: e.tool_calls ?? [],
        invalid_tool_calls: [],
        tool_call_chunks: [],
        usage_metadata: e.usage_metadata !== void 0 ? e.usage_metadata : void 0
      };
    else {
      const a = [], r = [];
      for (const i of e.tool_call_chunks) {
        let s = {};
        try {
          if (s = i_(i.args || "{}"), s === null || typeof s != "object" || Array.isArray(s))
            throw new Error("Malformed tool call chunk args.");
          a.push({
            name: i.name ?? "",
            args: s,
            id: i.id,
            type: "tool_call"
          });
        } catch {
          r.push({
            name: i.name,
            args: i.args,
            id: i.id,
            error: "Malformed args.",
            type: "invalid_tool_call"
          });
        }
      }
      n = {
        ...e,
        tool_calls: a,
        invalid_tool_calls: r,
        usage_metadata: e.usage_metadata !== void 0 ? e.usage_metadata : void 0
      };
    }
    super(n), Object.defineProperty(this, "tool_calls", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "invalid_tool_calls", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "tool_call_chunks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "usage_metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.tool_call_chunks = n.tool_call_chunks ?? this.tool_call_chunks, this.tool_calls = n.tool_calls ?? this.tool_calls, this.invalid_tool_calls = n.invalid_tool_calls ?? this.invalid_tool_calls, this.usage_metadata = n.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls",
      tool_call_chunks: "tool_call_chunks"
    };
  }
  static lc_name() {
    return "AIMessageChunk";
  }
  _getType() {
    return "ai";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      tool_call_chunks: this.tool_call_chunks,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  concat(e) {
    const n = {
      content: ic(this.content, e.content),
      additional_kwargs: Wt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Wt(this.response_metadata, e.response_metadata),
      tool_call_chunks: [],
      id: this.id ?? e.id
    };
    if (this.tool_call_chunks !== void 0 || e.tool_call_chunks !== void 0) {
      const a = Op(this.tool_call_chunks, e.tool_call_chunks);
      a !== void 0 && a.length > 0 && (n.tool_call_chunks = a);
    }
    if (this.usage_metadata !== void 0 || e.usage_metadata !== void 0) {
      const a = {
        ...(this.usage_metadata?.input_token_details?.audio !== void 0 || e.usage_metadata?.input_token_details?.audio !== void 0) && {
          audio: (this.usage_metadata?.input_token_details?.audio ?? 0) + (e.usage_metadata?.input_token_details?.audio ?? 0)
        },
        ...(this.usage_metadata?.input_token_details?.cache_read !== void 0 || e.usage_metadata?.input_token_details?.cache_read !== void 0) && {
          cache_read: (this.usage_metadata?.input_token_details?.cache_read ?? 0) + (e.usage_metadata?.input_token_details?.cache_read ?? 0)
        },
        ...(this.usage_metadata?.input_token_details?.cache_creation !== void 0 || e.usage_metadata?.input_token_details?.cache_creation !== void 0) && {
          cache_creation: (this.usage_metadata?.input_token_details?.cache_creation ?? 0) + (e.usage_metadata?.input_token_details?.cache_creation ?? 0)
        }
      }, r = {
        ...(this.usage_metadata?.output_token_details?.audio !== void 0 || e.usage_metadata?.output_token_details?.audio !== void 0) && {
          audio: (this.usage_metadata?.output_token_details?.audio ?? 0) + (e.usage_metadata?.output_token_details?.audio ?? 0)
        },
        ...(this.usage_metadata?.output_token_details?.reasoning !== void 0 || e.usage_metadata?.output_token_details?.reasoning !== void 0) && {
          reasoning: (this.usage_metadata?.output_token_details?.reasoning ?? 0) + (e.usage_metadata?.output_token_details?.reasoning ?? 0)
        }
      }, i = this.usage_metadata ?? {
        input_tokens: 0,
        output_tokens: 0,
        total_tokens: 0
      }, s = e.usage_metadata ?? {
        input_tokens: 0,
        output_tokens: 0,
        total_tokens: 0
      }, o = {
        input_tokens: i.input_tokens + s.input_tokens,
        output_tokens: i.output_tokens + s.output_tokens,
        total_tokens: i.total_tokens + s.total_tokens,
        // Do not include `input_token_details` / `output_token_details` keys in combined fields
        // unless their values are defined.
        ...Object.keys(a).length > 0 && {
          input_token_details: a
        },
        ...Object.keys(r).length > 0 && {
          output_token_details: r
        }
      };
      n.usage_metadata = o;
    }
    return new Ze(n);
  }
}
class yo extends ca {
  static lc_name() {
    return "ChatMessage";
  }
  static _chatMessageClass() {
    return yo;
  }
  constructor(e, n) {
    typeof e == "string" && (e = { content: e, role: n }), super(e), Object.defineProperty(this, "role", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.role = e.role;
  }
  _getType() {
    return "generic";
  }
  static isInstance(e) {
    return e._getType() === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
}
class oc extends sc {
  static lc_name() {
    return "ChatMessageChunk";
  }
  constructor(e, n) {
    typeof e == "string" && (e = { content: e, role: n }), super(e), Object.defineProperty(this, "role", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.role = e.role;
  }
  _getType() {
    return "generic";
  }
  concat(e) {
    return new oc({
      content: ic(this.content, e.content),
      additional_kwargs: Wt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Wt(this.response_metadata, e.response_metadata),
      role: this.role,
      id: this.id ?? e.id
    });
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
}
class $I extends ca {
  static lc_name() {
    return "FunctionMessage";
  }
  constructor(e, n) {
    typeof e == "string" && (e = { content: e, name: n }), super(e);
  }
  _getType() {
    return "function";
  }
}
class xd extends sc {
  static lc_name() {
    return "FunctionMessageChunk";
  }
  _getType() {
    return "function";
  }
  concat(e) {
    return new xd({
      content: ic(this.content, e.content),
      additional_kwargs: Wt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Wt(this.response_metadata, e.response_metadata),
      name: this.name ?? "",
      id: this.id ?? e.id
    });
  }
}
class _r extends ca {
  static lc_name() {
    return "HumanMessage";
  }
  _getType() {
    return "human";
  }
}
class uc extends sc {
  static lc_name() {
    return "HumanMessageChunk";
  }
  _getType() {
    return "human";
  }
  concat(e) {
    return new uc({
      content: ic(this.content, e.content),
      additional_kwargs: Wt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Wt(this.response_metadata, e.response_metadata),
      id: this.id ?? e.id
    });
  }
}
class jh extends ca {
  static lc_name() {
    return "SystemMessage";
  }
  _getType() {
    return "system";
  }
}
class Hu extends sc {
  static lc_name() {
    return "SystemMessageChunk";
  }
  _getType() {
    return "system";
  }
  concat(e) {
    return new Hu({
      content: ic(this.content, e.content),
      additional_kwargs: Wt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Wt(this.response_metadata, e.response_metadata),
      id: this.id ?? e.id
    });
  }
}
function Pp(t, e) {
  return t.lc_error_code = e, t.message = `${t.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${e}/
`, t;
}
function s_(t) {
  return !!(t && typeof t == "object" && "type" in t && t.type === "tool_call");
}
class Ph extends Error {
  constructor(e, n) {
    super(e), Object.defineProperty(this, "output", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.output = n;
  }
}
function MI(t) {
  return s_(t) ? t : typeof t.id == "string" && t.type === "function" && typeof t.function == "object" && t.function !== null && "arguments" in t.function && typeof t.function.arguments == "string" && "name" in t.function && typeof t.function.name == "string" ? {
    id: t.id,
    args: JSON.parse(t.function.arguments),
    name: t.function.name,
    type: "tool_call"
  } : t;
}
function AI(t) {
  return typeof t == "object" && t != null && t.lc === 1 && Array.isArray(t.id) && t.kwargs != null && typeof t.kwargs == "object";
}
function bm(t) {
  let e, n;
  if (AI(t)) {
    const a = t.id.at(-1);
    a === "HumanMessage" || a === "HumanMessageChunk" ? e = "user" : a === "AIMessage" || a === "AIMessageChunk" ? e = "assistant" : a === "SystemMessage" || a === "SystemMessageChunk" ? e = "system" : a === "FunctionMessage" || a === "FunctionMessageChunk" ? e = "function" : a === "ToolMessage" || a === "ToolMessageChunk" ? e = "tool" : e = "unknown", n = t.kwargs;
  } else {
    const { type: a, ...r } = t;
    e = a, n = r;
  }
  if (e === "human" || e === "user")
    return new _r(n);
  if (e === "ai" || e === "assistant") {
    const { tool_calls: a, ...r } = n;
    if (!Array.isArray(a))
      return new $t(n);
    const i = a.map(MI);
    return new $t({ ...r, tool_calls: i });
  } else {
    if (e === "system")
      return new jh(n);
    if (e === "developer")
      return new jh({
        ...n,
        additional_kwargs: {
          ...n.additional_kwargs,
          __openai_role__: "developer"
        }
      });
    if (e === "tool" && "tool_call_id" in n)
      return new Kb({
        ...n,
        content: n.content,
        tool_call_id: n.tool_call_id,
        name: n.name
      });
    throw Pp(new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(t, null, 2)}`), "MESSAGE_COERCION_FAILURE");
  }
}
function co(t) {
  if (typeof t == "string")
    return new _r(t);
  if (an(t))
    return t;
  if (Array.isArray(t)) {
    const [e, n] = t;
    return bm({ type: e, content: n });
  } else if (PI(t)) {
    const { role: e, ...n } = t;
    return bm({ ...n, type: e });
  } else
    return bm(t);
}
function lo(t, e = "Human", n = "AI") {
  const a = [];
  for (const r of t) {
    let i;
    if (r._getType() === "human")
      i = e;
    else if (r._getType() === "ai")
      i = n;
    else if (r._getType() === "system")
      i = "System";
    else if (r._getType() === "function")
      i = "Function";
    else if (r._getType() === "tool")
      i = "Tool";
    else if (r._getType() === "generic")
      i = r.role;
    else
      throw new Error(`Got unsupported message type: ${r._getType()}`);
    const s = r.name ? `${r.name}, ` : "", o = typeof r.content == "string" ? r.content : JSON.stringify(r.content, null, 2);
    a.push(`${i}: ${s}${o}`);
  }
  return a.join(`
`);
}
function EI(t) {
  const e = t._getType();
  if (e === "human")
    return new uc({ ...t });
  if (e === "ai") {
    let n = {
      ...t
    };
    return "tool_calls" in n && (n = {
      ...n,
      tool_call_chunks: n.tool_calls?.map((a) => ({
        ...a,
        type: "tool_call_chunk",
        index: void 0,
        args: JSON.stringify(a.args)
      }))
    }), new Ze({ ...n });
  } else {
    if (e === "system")
      return new Hu({ ...t });
    if (e === "function")
      return new xd({ ...t });
    if (yo.isInstance(t))
      return new oc({ ...t });
    throw new Error("Unknown message type.");
  }
}
var Ce;
(function(t) {
  t.assertEqual = (r) => r;
  function e(r) {
  }
  t.assertIs = e;
  function n(r) {
    throw new Error();
  }
  t.assertNever = n, t.arrayToEnum = (r) => {
    const i = {};
    for (const s of r)
      i[s] = s;
    return i;
  }, t.getValidEnumValues = (r) => {
    const i = t.objectKeys(r).filter((o) => typeof r[r[o]] != "number"), s = {};
    for (const o of i)
      s[o] = r[o];
    return t.objectValues(s);
  }, t.objectValues = (r) => t.objectKeys(r).map(function(i) {
    return r[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (r) => Object.keys(r) : (r) => {
    const i = [];
    for (const s in r)
      Object.prototype.hasOwnProperty.call(r, s) && i.push(s);
    return i;
  }, t.find = (r, i) => {
    for (const s of r)
      if (i(s))
        return s;
  }, t.isInteger = typeof Number.isInteger == "function" ? (r) => Number.isInteger(r) : (r) => typeof r == "number" && isFinite(r) && Math.floor(r) === r;
  function a(r, i = " | ") {
    return r.map((s) => typeof s == "string" ? `'${s}'` : s).join(i);
  }
  t.joinValues = a, t.jsonStringifyReplacer = (r, i) => typeof i == "bigint" ? i.toString() : i;
})(Ce || (Ce = {}));
var Hb;
(function(t) {
  t.mergeShapes = (e, n) => ({
    ...e,
    ...n
    // second overwrites first
  });
})(Hb || (Hb = {}));
const te = Ce.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Ds = (t) => {
  switch (typeof t) {
    case "undefined":
      return te.undefined;
    case "string":
      return te.string;
    case "number":
      return isNaN(t) ? te.nan : te.number;
    case "boolean":
      return te.boolean;
    case "function":
      return te.function;
    case "bigint":
      return te.bigint;
    case "symbol":
      return te.symbol;
    case "object":
      return Array.isArray(t) ? te.array : t === null ? te.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? te.promise : typeof Map < "u" && t instanceof Map ? te.map : typeof Set < "u" && t instanceof Set ? te.set : typeof Date < "u" && t instanceof Date ? te.date : te.object;
    default:
      return te.unknown;
  }
}, Y = Ce.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), II = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
let hr = class sC extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (a) => {
      this.issues = [...this.issues, a];
    }, this.addIssues = (a = []) => {
      this.issues = [...this.issues, ...a];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const n = e || function(i) {
      return i.message;
    }, a = { _errors: [] }, r = (i) => {
      for (const s of i.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(r);
        else if (s.code === "invalid_return_type")
          r(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          r(s.argumentsError);
        else if (s.path.length === 0)
          a._errors.push(n(s));
        else {
          let o = a, l = 0;
          for (; l < s.path.length; ) {
            const f = s.path[l];
            l === s.path.length - 1 ? (o[f] = o[f] || { _errors: [] }, o[f]._errors.push(n(s))) : o[f] = o[f] || { _errors: [] }, o = o[f], l++;
          }
        }
    };
    return r(this), a;
  }
  static assert(e) {
    if (!(e instanceof sC))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Ce.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (n) => n.message) {
    const n = {}, a = [];
    for (const r of this.issues)
      r.path.length > 0 ? (n[r.path[0]] = n[r.path[0]] || [], n[r.path[0]].push(e(r))) : a.push(e(r));
    return { formErrors: a, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
};
hr.create = (t) => new hr(t);
const Gu = (t, e) => {
  let n;
  switch (t.code) {
    case Y.invalid_type:
      t.received === te.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
      break;
    case Y.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected, Ce.jsonStringifyReplacer)}`;
      break;
    case Y.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${Ce.joinValues(t.keys, ", ")}`;
      break;
    case Y.invalid_union:
      n = "Invalid input";
      break;
    case Y.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${Ce.joinValues(t.options)}`;
      break;
    case Y.invalid_enum_value:
      n = `Invalid enum value. Expected ${Ce.joinValues(t.options)}, received '${t.received}'`;
      break;
    case Y.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case Y.invalid_return_type:
      n = "Invalid function return type";
      break;
    case Y.invalid_date:
      n = "Invalid date";
      break;
    case Y.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (n = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : Ce.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
      break;
    case Y.too_small:
      t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : n = "Invalid input";
      break;
    case Y.too_big:
      t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? n = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : n = "Invalid input";
      break;
    case Y.custom:
      n = "Invalid input";
      break;
    case Y.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case Y.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case Y.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = e.defaultError, Ce.assertNever(t);
  }
  return { message: n };
};
let oC = Gu;
function NI(t) {
  oC = t;
}
function Rh() {
  return oC;
}
const Ch = (t) => {
  const { data: e, path: n, errorMaps: a, issueData: r } = t, i = [...n, ...r.path || []], s = {
    ...r,
    path: i
  };
  if (r.message !== void 0)
    return {
      ...r,
      path: i,
      message: r.message
    };
  let o = "";
  const l = a.filter((f) => !!f).slice().reverse();
  for (const f of l)
    o = f(s, { data: e, defaultError: o }).message;
  return {
    ...r,
    path: i,
    message: o
  };
}, kI = [];
function ee(t, e) {
  const n = Rh(), a = Ch({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      // contextual error map is first priority
      t.schemaErrorMap,
      // then schema-bound map if available
      n,
      // then global override map
      n === Gu ? void 0 : Gu
      // then global default map
    ].filter((r) => !!r)
  });
  t.common.issues.push(a);
}
class xt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, n) {
    const a = [];
    for (const r of n) {
      if (r.status === "aborted")
        return he;
      r.status === "dirty" && e.dirty(), a.push(r.value);
    }
    return { status: e.value, value: a };
  }
  static async mergeObjectAsync(e, n) {
    const a = [];
    for (const r of n) {
      const i = await r.key, s = await r.value;
      a.push({
        key: i,
        value: s
      });
    }
    return xt.mergeObjectSync(e, a);
  }
  static mergeObjectSync(e, n) {
    const a = {};
    for (const r of n) {
      const { key: i, value: s } = r;
      if (i.status === "aborted" || s.status === "aborted")
        return he;
      i.status === "dirty" && e.dirty(), s.status === "dirty" && e.dirty(), i.value !== "__proto__" && (typeof s.value < "u" || r.alwaysSet) && (a[i.value] = s.value);
    }
    return { status: e.value, value: a };
  }
}
const he = Object.freeze({
  status: "aborted"
}), ku = (t) => ({ status: "dirty", value: t }), Xt = (t) => ({ status: "valid", value: t }), Gb = (t) => t.status === "aborted", Wb = (t) => t.status === "dirty", Xo = (t) => t.status === "valid", ld = (t) => typeof Promise < "u" && t instanceof Promise;
function Th(t, e, n, a) {
  if (typeof e == "function" ? t !== e || !0 : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e.get(t);
}
function uC(t, e, n, a, r) {
  if (typeof e == "function" ? t !== e || !0 : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return e.set(t, n), n;
}
var ae;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e?.message;
})(ae || (ae = {}));
var Bl, xl;
class ha {
  constructor(e, n, a, r) {
    this._cachedPath = [], this.parent = e, this.data = n, this._path = a, this._key = r;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const iw = (t, e) => {
  if (Xo(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new hr(t.common.issues);
      return this._error = n, this._error;
    }
  };
};
function me(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: n, required_error: a, description: r } = t;
  if (e && (n || a))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: r } : { errorMap: (s, o) => {
    var l, f;
    const { message: u } = t;
    return s.code === "invalid_enum_value" ? { message: u ?? o.defaultError } : typeof o.data > "u" ? { message: (l = u ?? a) !== null && l !== void 0 ? l : o.defaultError } : s.code !== "invalid_type" ? { message: o.defaultError } : { message: (f = u ?? n) !== null && f !== void 0 ? f : o.defaultError };
  }, description: r };
}
class ye {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return Ds(e.data);
  }
  _getOrReturnCtx(e, n) {
    return n || {
      common: e.parent.common,
      data: e.data,
      parsedType: Ds(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new xt(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: Ds(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (ld(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n);
  }
  parse(e, n) {
    const a = this.safeParse(e, n);
    if (a.success)
      return a.data;
    throw a.error;
  }
  safeParse(e, n) {
    var a;
    const r = {
      common: {
        issues: [],
        async: (a = n?.async) !== null && a !== void 0 ? a : !1,
        contextualErrorMap: n?.errorMap
      },
      path: n?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Ds(e)
    }, i = this._parseSync({ data: e, path: r.path, parent: r });
    return iw(r, i);
  }
  "~validate"(e) {
    var n, a;
    const r = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Ds(e)
    };
    if (!this["~standard"].async)
      try {
        const i = this._parseSync({ data: e, path: [], parent: r });
        return Xo(i) ? {
          value: i.value
        } : {
          issues: r.common.issues
        };
      } catch (i) {
        !((a = (n = i?.message) === null || n === void 0 ? void 0 : n.toLowerCase()) === null || a === void 0) && a.includes("encountered") && (this["~standard"].async = !0), r.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: e, path: [], parent: r }).then((i) => Xo(i) ? {
      value: i.value
    } : {
      issues: r.common.issues
    });
  }
  async parseAsync(e, n) {
    const a = await this.safeParseAsync(e, n);
    if (a.success)
      return a.data;
    throw a.error;
  }
  async safeParseAsync(e, n) {
    const a = {
      common: {
        issues: [],
        contextualErrorMap: n?.errorMap,
        async: !0
      },
      path: n?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Ds(e)
    }, r = this._parse({ data: e, path: a.path, parent: a }), i = await (ld(r) ? r : Promise.resolve(r));
    return iw(a, i);
  }
  refine(e, n) {
    const a = (r) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(r) : n;
    return this._refinement((r, i) => {
      const s = e(r), o = () => i.addIssue({
        code: Y.custom,
        ...a(r)
      });
      return typeof Promise < "u" && s instanceof Promise ? s.then((l) => l ? !0 : (o(), !1)) : s ? !0 : (o(), !1);
    });
  }
  refinement(e, n) {
    return this._refinement((a, r) => e(a) ? !0 : (r.addIssue(typeof n == "function" ? n(a, r) : n), !1));
  }
  _refinement(e) {
    return new yr({
      schema: this,
      typeName: K.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (n) => this["~validate"](n)
    };
  }
  optional() {
    return mr.create(this, this._def);
  }
  nullable() {
    return bo.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return pr.create(this);
  }
  promise() {
    return Xu.create(this, this._def);
  }
  or(e) {
    return pd.create([this, e], this._def);
  }
  and(e) {
    return md.create(this, e, this._def);
  }
  transform(e) {
    return new yr({
      ...me(this._def),
      schema: this,
      typeName: K.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const n = typeof e == "function" ? e : () => e;
    return new wd({
      ...me(this._def),
      innerType: this,
      defaultValue: n,
      typeName: K.ZodDefault
    });
  }
  brand() {
    return new o_({
      typeName: K.ZodBranded,
      type: this,
      ...me(this._def)
    });
  }
  catch(e) {
    const n = typeof e == "function" ? e : () => e;
    return new vd({
      ...me(this._def),
      innerType: this,
      catchValue: n,
      typeName: K.ZodCatch
    });
  }
  describe(e) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Vd.create(this, e);
  }
  readonly() {
    return Sd.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const FI = /^c[^\s-]{8,}$/i, DI = /^[0-9a-z]+$/, qI = /^[0-9A-HJKMNP-TV-Z]{26}$/i, JI = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, LI = /^[a-z0-9_-]{21}$/i, UI = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, BI = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, xI = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, VI = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let gm;
const zI = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ZI = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, KI = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, HI = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, GI = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, WI = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, cC = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", XI = new RegExp(`^${cC}$`);
function lC(t) {
  let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`), e;
}
function QI(t) {
  return new RegExp(`^${lC(t)}$`);
}
function dC(t) {
  let e = `${cC}T${lC(t)}`;
  const n = [];
  return n.push(t.local ? "Z?" : "Z"), t.offset && n.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${n.join("|")})`, new RegExp(`^${e}$`);
}
function YI(t, e) {
  return !!((e === "v4" || !e) && zI.test(t) || (e === "v6" || !e) && KI.test(t));
}
function e1(t, e) {
  if (!UI.test(t))
    return !1;
  try {
    const [n] = t.split("."), a = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "="), r = JSON.parse(atob(a));
    return !(typeof r != "object" || r === null || !r.typ || !r.alg || e && r.alg !== e);
  } catch {
    return !1;
  }
}
function t1(t, e) {
  return !!((e === "v4" || !e) && ZI.test(t) || (e === "v6" || !e) && HI.test(t));
}
class ur extends ye {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== te.string) {
      const i = this._getOrReturnCtx(e);
      return ee(i, {
        code: Y.invalid_type,
        expected: te.string,
        received: i.parsedType
      }), he;
    }
    const a = new xt();
    let r;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (r = this._getOrReturnCtx(e, r), ee(r, {
          code: Y.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), a.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (r = this._getOrReturnCtx(e, r), ee(r, {
          code: Y.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), a.dirty());
      else if (i.kind === "length") {
        const s = e.data.length > i.value, o = e.data.length < i.value;
        (s || o) && (r = this._getOrReturnCtx(e, r), s ? ee(r, {
          code: Y.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : o && ee(r, {
          code: Y.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), a.dirty());
      } else if (i.kind === "email")
        xI.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "email",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "emoji")
        gm || (gm = new RegExp(VI, "u")), gm.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "emoji",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "uuid")
        JI.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "uuid",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "nanoid")
        LI.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "nanoid",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "cuid")
        FI.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "cuid",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "cuid2")
        DI.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "cuid2",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "ulid")
        qI.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "ulid",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          r = this._getOrReturnCtx(e, r), ee(r, {
            validation: "url",
            code: Y.invalid_string,
            message: i.message
          }), a.dirty();
        }
      else i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "regex",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.invalid_string,
        validation: { includes: i.value, position: i.position },
        message: i.message
      }), a.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.invalid_string,
        validation: { startsWith: i.value },
        message: i.message
      }), a.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.invalid_string,
        validation: { endsWith: i.value },
        message: i.message
      }), a.dirty()) : i.kind === "datetime" ? dC(i).test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.invalid_string,
        validation: "datetime",
        message: i.message
      }), a.dirty()) : i.kind === "date" ? XI.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.invalid_string,
        validation: "date",
        message: i.message
      }), a.dirty()) : i.kind === "time" ? QI(i).test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.invalid_string,
        validation: "time",
        message: i.message
      }), a.dirty()) : i.kind === "duration" ? BI.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "duration",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty()) : i.kind === "ip" ? YI(e.data, i.version) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "ip",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty()) : i.kind === "jwt" ? e1(e.data, i.alg) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "jwt",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty()) : i.kind === "cidr" ? t1(e.data, i.version) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "cidr",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty()) : i.kind === "base64" ? GI.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "base64",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty()) : i.kind === "base64url" ? WI.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "base64url",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty()) : Ce.assertNever(i);
    return { status: a.value, value: e.data };
  }
  _regex(e, n, a) {
    return this.refinement((r) => e.test(r), {
      validation: n,
      code: Y.invalid_string,
      ...ae.errToObj(a)
    });
  }
  _addCheck(e) {
    return new ur({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...ae.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...ae.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...ae.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...ae.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...ae.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...ae.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...ae.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...ae.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...ae.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...ae.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...ae.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...ae.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...ae.errToObj(e) });
  }
  datetime(e) {
    var n, a;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      offset: (n = e?.offset) !== null && n !== void 0 ? n : !1,
      local: (a = e?.local) !== null && a !== void 0 ? a : !1,
      ...ae.errToObj(e?.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      ...ae.errToObj(e?.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...ae.errToObj(e) });
  }
  regex(e, n) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...ae.errToObj(n)
    });
  }
  includes(e, n) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: n?.position,
      ...ae.errToObj(n?.message)
    });
  }
  startsWith(e, n) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...ae.errToObj(n)
    });
  }
  endsWith(e, n) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...ae.errToObj(n)
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...ae.errToObj(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...ae.errToObj(n)
    });
  }
  length(e, n) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...ae.errToObj(n)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, ae.errToObj(e));
  }
  trim() {
    return new ur({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ur({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ur({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
ur.create = (t) => {
  var e;
  return new ur({
    checks: [],
    typeName: K.ZodString,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...me(t)
  });
};
function n1(t, e) {
  const n = (t.toString().split(".")[1] || "").length, a = (e.toString().split(".")[1] || "").length, r = n > a ? n : a, i = parseInt(t.toFixed(r).replace(".", "")), s = parseInt(e.toFixed(r).replace(".", ""));
  return i % s / Math.pow(10, r);
}
class ho extends ye {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== te.number) {
      const i = this._getOrReturnCtx(e);
      return ee(i, {
        code: Y.invalid_type,
        expected: te.number,
        received: i.parsedType
      }), he;
    }
    let a;
    const r = new xt();
    for (const i of this._def.checks)
      i.kind === "int" ? Ce.isInteger(e.data) || (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), r.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), r.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), r.dirty()) : i.kind === "multipleOf" ? n1(e.data, i.value) !== 0 && (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), r.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.not_finite,
        message: i.message
      }), r.dirty()) : Ce.assertNever(i);
    return { status: r.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, ae.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, ae.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, ae.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, ae.toString(n));
  }
  setLimit(e, n, a, r) {
    return new ho({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: a,
          message: ae.toString(r)
        }
      ]
    });
  }
  _addCheck(e) {
    return new ho({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: ae.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: ae.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: ae.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: ae.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: ae.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ae.toString(n)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: ae.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: ae.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: ae.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && Ce.isInteger(e.value));
  }
  get isFinite() {
    let e = null, n = null;
    for (const a of this._def.checks) {
      if (a.kind === "finite" || a.kind === "int" || a.kind === "multipleOf")
        return !0;
      a.kind === "min" ? (n === null || a.value > n) && (n = a.value) : a.kind === "max" && (e === null || a.value < e) && (e = a.value);
    }
    return Number.isFinite(n) && Number.isFinite(e);
  }
}
ho.create = (t) => new ho({
  checks: [],
  typeName: K.ZodNumber,
  coerce: t?.coerce || !1,
  ...me(t)
});
class po extends ye {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== te.bigint)
      return this._getInvalidInput(e);
    let a;
    const r = new xt();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), r.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), r.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), r.dirty()) : Ce.assertNever(i);
    return { status: r.value, value: e.data };
  }
  _getInvalidInput(e) {
    const n = this._getOrReturnCtx(e);
    return ee(n, {
      code: Y.invalid_type,
      expected: te.bigint,
      received: n.parsedType
    }), he;
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, ae.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, ae.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, ae.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, ae.toString(n));
  }
  setLimit(e, n, a, r) {
    return new po({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: a,
          message: ae.toString(r)
        }
      ]
    });
  }
  _addCheck(e) {
    return new po({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: ae.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: ae.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: ae.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: ae.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ae.toString(n)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
po.create = (t) => {
  var e;
  return new po({
    checks: [],
    typeName: K.ZodBigInt,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...me(t)
  });
};
class dd extends ye {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== te.boolean) {
      const a = this._getOrReturnCtx(e);
      return ee(a, {
        code: Y.invalid_type,
        expected: te.boolean,
        received: a.parsedType
      }), he;
    }
    return Xt(e.data);
  }
}
dd.create = (t) => new dd({
  typeName: K.ZodBoolean,
  coerce: t?.coerce || !1,
  ...me(t)
});
class Qo extends ye {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== te.date) {
      const i = this._getOrReturnCtx(e);
      return ee(i, {
        code: Y.invalid_type,
        expected: te.date,
        received: i.parsedType
      }), he;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return ee(i, {
        code: Y.invalid_date
      }), he;
    }
    const a = new xt();
    let r;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), a.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), a.dirty()) : Ce.assertNever(i);
    return {
      status: a.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Qo({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: ae.toString(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: ae.toString(n)
    });
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
}
Qo.create = (t) => new Qo({
  checks: [],
  coerce: t?.coerce || !1,
  typeName: K.ZodDate,
  ...me(t)
});
class $h extends ye {
  _parse(e) {
    if (this._getType(e) !== te.symbol) {
      const a = this._getOrReturnCtx(e);
      return ee(a, {
        code: Y.invalid_type,
        expected: te.symbol,
        received: a.parsedType
      }), he;
    }
    return Xt(e.data);
  }
}
$h.create = (t) => new $h({
  typeName: K.ZodSymbol,
  ...me(t)
});
class fd extends ye {
  _parse(e) {
    if (this._getType(e) !== te.undefined) {
      const a = this._getOrReturnCtx(e);
      return ee(a, {
        code: Y.invalid_type,
        expected: te.undefined,
        received: a.parsedType
      }), he;
    }
    return Xt(e.data);
  }
}
fd.create = (t) => new fd({
  typeName: K.ZodUndefined,
  ...me(t)
});
class hd extends ye {
  _parse(e) {
    if (this._getType(e) !== te.null) {
      const a = this._getOrReturnCtx(e);
      return ee(a, {
        code: Y.invalid_type,
        expected: te.null,
        received: a.parsedType
      }), he;
    }
    return Xt(e.data);
  }
}
hd.create = (t) => new hd({
  typeName: K.ZodNull,
  ...me(t)
});
class Wu extends ye {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return Xt(e.data);
  }
}
Wu.create = (t) => new Wu({
  typeName: K.ZodAny,
  ...me(t)
});
class Bo extends ye {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return Xt(e.data);
  }
}
Bo.create = (t) => new Bo({
  typeName: K.ZodUnknown,
  ...me(t)
});
class zs extends ye {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return ee(n, {
      code: Y.invalid_type,
      expected: te.never,
      received: n.parsedType
    }), he;
  }
}
zs.create = (t) => new zs({
  typeName: K.ZodNever,
  ...me(t)
});
class Mh extends ye {
  _parse(e) {
    if (this._getType(e) !== te.undefined) {
      const a = this._getOrReturnCtx(e);
      return ee(a, {
        code: Y.invalid_type,
        expected: te.void,
        received: a.parsedType
      }), he;
    }
    return Xt(e.data);
  }
}
Mh.create = (t) => new Mh({
  typeName: K.ZodVoid,
  ...me(t)
});
class pr extends ye {
  _parse(e) {
    const { ctx: n, status: a } = this._processInputParams(e), r = this._def;
    if (n.parsedType !== te.array)
      return ee(n, {
        code: Y.invalid_type,
        expected: te.array,
        received: n.parsedType
      }), he;
    if (r.exactLength !== null) {
      const s = n.data.length > r.exactLength.value, o = n.data.length < r.exactLength.value;
      (s || o) && (ee(n, {
        code: s ? Y.too_big : Y.too_small,
        minimum: o ? r.exactLength.value : void 0,
        maximum: s ? r.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: r.exactLength.message
      }), a.dirty());
    }
    if (r.minLength !== null && n.data.length < r.minLength.value && (ee(n, {
      code: Y.too_small,
      minimum: r.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: r.minLength.message
    }), a.dirty()), r.maxLength !== null && n.data.length > r.maxLength.value && (ee(n, {
      code: Y.too_big,
      maximum: r.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: r.maxLength.message
    }), a.dirty()), n.common.async)
      return Promise.all([...n.data].map((s, o) => r.type._parseAsync(new ha(n, s, n.path, o)))).then((s) => xt.mergeArray(a, s));
    const i = [...n.data].map((s, o) => r.type._parseSync(new ha(n, s, n.path, o)));
    return xt.mergeArray(a, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, n) {
    return new pr({
      ...this._def,
      minLength: { value: e, message: ae.toString(n) }
    });
  }
  max(e, n) {
    return new pr({
      ...this._def,
      maxLength: { value: e, message: ae.toString(n) }
    });
  }
  length(e, n) {
    return new pr({
      ...this._def,
      exactLength: { value: e, message: ae.toString(n) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
pr.create = (t, e) => new pr({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: K.ZodArray,
  ...me(e)
});
function Tu(t) {
  if (t instanceof tt) {
    const e = {};
    for (const n in t.shape) {
      const a = t.shape[n];
      e[n] = mr.create(Tu(a));
    }
    return new tt({
      ...t._def,
      shape: () => e
    });
  } else return t instanceof pr ? new pr({
    ...t._def,
    type: Tu(t.element)
  }) : t instanceof mr ? mr.create(Tu(t.unwrap())) : t instanceof bo ? bo.create(Tu(t.unwrap())) : t instanceof pa ? pa.create(t.items.map((e) => Tu(e))) : t;
}
class tt extends ye {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), n = Ce.objectKeys(e);
    return this._cached = { shape: e, keys: n };
  }
  _parse(e) {
    if (this._getType(e) !== te.object) {
      const f = this._getOrReturnCtx(e);
      return ee(f, {
        code: Y.invalid_type,
        expected: te.object,
        received: f.parsedType
      }), he;
    }
    const { status: a, ctx: r } = this._processInputParams(e), { shape: i, keys: s } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof zs && this._def.unknownKeys === "strip"))
      for (const f in r.data)
        s.includes(f) || o.push(f);
    const l = [];
    for (const f of s) {
      const u = i[f], c = r.data[f];
      l.push({
        key: { status: "valid", value: f },
        value: u._parse(new ha(r, c, r.path, f)),
        alwaysSet: f in r.data
      });
    }
    if (this._def.catchall instanceof zs) {
      const f = this._def.unknownKeys;
      if (f === "passthrough")
        for (const u of o)
          l.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: r.data[u] }
          });
      else if (f === "strict")
        o.length > 0 && (ee(r, {
          code: Y.unrecognized_keys,
          keys: o
        }), a.dirty());
      else if (f !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const f = this._def.catchall;
      for (const u of o) {
        const c = r.data[u];
        l.push({
          key: { status: "valid", value: u },
          value: f._parse(
            new ha(r, c, r.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in r.data
        });
      }
    }
    return r.common.async ? Promise.resolve().then(async () => {
      const f = [];
      for (const u of l) {
        const c = await u.key, h = await u.value;
        f.push({
          key: c,
          value: h,
          alwaysSet: u.alwaysSet
        });
      }
      return f;
    }).then((f) => xt.mergeObjectSync(a, f)) : xt.mergeObjectSync(a, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return new tt({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (n, a) => {
          var r, i, s, o;
          const l = (s = (i = (r = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(r, n, a).message) !== null && s !== void 0 ? s : a.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (o = ae.errToObj(e).message) !== null && o !== void 0 ? o : l
          } : {
            message: l
          };
        }
      } : {}
    });
  }
  strip() {
    return new tt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new tt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new tt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new tt({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: K.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, n) {
    return this.augment({ [e]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new tt({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const n = {};
    return Ce.objectKeys(e).forEach((a) => {
      e[a] && this.shape[a] && (n[a] = this.shape[a]);
    }), new tt({
      ...this._def,
      shape: () => n
    });
  }
  omit(e) {
    const n = {};
    return Ce.objectKeys(this.shape).forEach((a) => {
      e[a] || (n[a] = this.shape[a]);
    }), new tt({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Tu(this);
  }
  partial(e) {
    const n = {};
    return Ce.objectKeys(this.shape).forEach((a) => {
      const r = this.shape[a];
      e && !e[a] ? n[a] = r : n[a] = r.optional();
    }), new tt({
      ...this._def,
      shape: () => n
    });
  }
  required(e) {
    const n = {};
    return Ce.objectKeys(this.shape).forEach((a) => {
      if (e && !e[a])
        n[a] = this.shape[a];
      else {
        let i = this.shape[a];
        for (; i instanceof mr; )
          i = i._def.innerType;
        n[a] = i;
      }
    }), new tt({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return fC(Ce.objectKeys(this.shape));
  }
}
tt.create = (t, e) => new tt({
  shape: () => t,
  unknownKeys: "strip",
  catchall: zs.create(),
  typeName: K.ZodObject,
  ...me(e)
});
tt.strictCreate = (t, e) => new tt({
  shape: () => t,
  unknownKeys: "strict",
  catchall: zs.create(),
  typeName: K.ZodObject,
  ...me(e)
});
tt.lazycreate = (t, e) => new tt({
  shape: t,
  unknownKeys: "strip",
  catchall: zs.create(),
  typeName: K.ZodObject,
  ...me(e)
});
class pd extends ye {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), a = this._def.options;
    function r(i) {
      for (const o of i)
        if (o.result.status === "valid")
          return o.result;
      for (const o of i)
        if (o.result.status === "dirty")
          return n.common.issues.push(...o.ctx.common.issues), o.result;
      const s = i.map((o) => new hr(o.ctx.common.issues));
      return ee(n, {
        code: Y.invalid_union,
        unionErrors: s
      }), he;
    }
    if (n.common.async)
      return Promise.all(a.map(async (i) => {
        const s = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: n.data,
            path: n.path,
            parent: s
          }),
          ctx: s
        };
      })).then(r);
    {
      let i;
      const s = [];
      for (const l of a) {
        const f = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, u = l._parseSync({
          data: n.data,
          path: n.path,
          parent: f
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !i && (i = { result: u, ctx: f }), f.common.issues.length && s.push(f.common.issues);
      }
      if (i)
        return n.common.issues.push(...i.ctx.common.issues), i.result;
      const o = s.map((l) => new hr(l));
      return ee(n, {
        code: Y.invalid_union,
        unionErrors: o
      }), he;
    }
  }
  get options() {
    return this._def.options;
  }
}
pd.create = (t, e) => new pd({
  options: t,
  typeName: K.ZodUnion,
  ...me(e)
});
const ks = (t) => t instanceof gd ? ks(t.schema) : t instanceof yr ? ks(t.innerType()) : t instanceof _d ? [t.value] : t instanceof mo ? t.options : t instanceof yd ? Ce.objectValues(t.enum) : t instanceof wd ? ks(t._def.innerType) : t instanceof fd ? [void 0] : t instanceof hd ? [null] : t instanceof mr ? [void 0, ...ks(t.unwrap())] : t instanceof bo ? [null, ...ks(t.unwrap())] : t instanceof o_ || t instanceof Sd ? ks(t.unwrap()) : t instanceof vd ? ks(t._def.innerType) : [];
class Rp extends ye {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== te.object)
      return ee(n, {
        code: Y.invalid_type,
        expected: te.object,
        received: n.parsedType
      }), he;
    const a = this.discriminator, r = n.data[a], i = this.optionsMap.get(r);
    return i ? n.common.async ? i._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : i._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (ee(n, {
      code: Y.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [a]
    }), he);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, n, a) {
    const r = /* @__PURE__ */ new Map();
    for (const i of n) {
      const s = ks(i.shape[e]);
      if (!s.length)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o of s) {
        if (r.has(o))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);
        r.set(o, i);
      }
    }
    return new Rp({
      typeName: K.ZodDiscriminatedUnion,
      discriminator: e,
      options: n,
      optionsMap: r,
      ...me(a)
    });
  }
}
function Xb(t, e) {
  const n = Ds(t), a = Ds(e);
  if (t === e)
    return { valid: !0, data: t };
  if (n === te.object && a === te.object) {
    const r = Ce.objectKeys(e), i = Ce.objectKeys(t).filter((o) => r.indexOf(o) !== -1), s = { ...t, ...e };
    for (const o of i) {
      const l = Xb(t[o], e[o]);
      if (!l.valid)
        return { valid: !1 };
      s[o] = l.data;
    }
    return { valid: !0, data: s };
  } else if (n === te.array && a === te.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const r = [];
    for (let i = 0; i < t.length; i++) {
      const s = t[i], o = e[i], l = Xb(s, o);
      if (!l.valid)
        return { valid: !1 };
      r.push(l.data);
    }
    return { valid: !0, data: r };
  } else return n === te.date && a === te.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class md extends ye {
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e), r = (i, s) => {
      if (Gb(i) || Gb(s))
        return he;
      const o = Xb(i.value, s.value);
      return o.valid ? ((Wb(i) || Wb(s)) && n.dirty(), { status: n.value, value: o.data }) : (ee(a, {
        code: Y.invalid_intersection_types
      }), he);
    };
    return a.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: a.data,
        path: a.path,
        parent: a
      }),
      this._def.right._parseAsync({
        data: a.data,
        path: a.path,
        parent: a
      })
    ]).then(([i, s]) => r(i, s)) : r(this._def.left._parseSync({
      data: a.data,
      path: a.path,
      parent: a
    }), this._def.right._parseSync({
      data: a.data,
      path: a.path,
      parent: a
    }));
  }
}
md.create = (t, e, n) => new md({
  left: t,
  right: e,
  typeName: K.ZodIntersection,
  ...me(n)
});
class pa extends ye {
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e);
    if (a.parsedType !== te.array)
      return ee(a, {
        code: Y.invalid_type,
        expected: te.array,
        received: a.parsedType
      }), he;
    if (a.data.length < this._def.items.length)
      return ee(a, {
        code: Y.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), he;
    !this._def.rest && a.data.length > this._def.items.length && (ee(a, {
      code: Y.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const i = [...a.data].map((s, o) => {
      const l = this._def.items[o] || this._def.rest;
      return l ? l._parse(new ha(a, s, a.path, o)) : null;
    }).filter((s) => !!s);
    return a.common.async ? Promise.all(i).then((s) => xt.mergeArray(n, s)) : xt.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new pa({
      ...this._def,
      rest: e
    });
  }
}
pa.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new pa({
    items: t,
    typeName: K.ZodTuple,
    rest: null,
    ...me(e)
  });
};
class bd extends ye {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e);
    if (a.parsedType !== te.object)
      return ee(a, {
        code: Y.invalid_type,
        expected: te.object,
        received: a.parsedType
      }), he;
    const r = [], i = this._def.keyType, s = this._def.valueType;
    for (const o in a.data)
      r.push({
        key: i._parse(new ha(a, o, a.path, o)),
        value: s._parse(new ha(a, a.data[o], a.path, o)),
        alwaysSet: o in a.data
      });
    return a.common.async ? xt.mergeObjectAsync(n, r) : xt.mergeObjectSync(n, r);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, n, a) {
    return n instanceof ye ? new bd({
      keyType: e,
      valueType: n,
      typeName: K.ZodRecord,
      ...me(a)
    }) : new bd({
      keyType: ur.create(),
      valueType: e,
      typeName: K.ZodRecord,
      ...me(n)
    });
  }
}
class Ah extends ye {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e);
    if (a.parsedType !== te.map)
      return ee(a, {
        code: Y.invalid_type,
        expected: te.map,
        received: a.parsedType
      }), he;
    const r = this._def.keyType, i = this._def.valueType, s = [...a.data.entries()].map(([o, l], f) => ({
      key: r._parse(new ha(a, o, a.path, [f, "key"])),
      value: i._parse(new ha(a, l, a.path, [f, "value"]))
    }));
    if (a.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of s) {
          const f = await l.key, u = await l.value;
          if (f.status === "aborted" || u.status === "aborted")
            return he;
          (f.status === "dirty" || u.status === "dirty") && n.dirty(), o.set(f.value, u.value);
        }
        return { status: n.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const l of s) {
        const f = l.key, u = l.value;
        if (f.status === "aborted" || u.status === "aborted")
          return he;
        (f.status === "dirty" || u.status === "dirty") && n.dirty(), o.set(f.value, u.value);
      }
      return { status: n.value, value: o };
    }
  }
}
Ah.create = (t, e, n) => new Ah({
  valueType: e,
  keyType: t,
  typeName: K.ZodMap,
  ...me(n)
});
class Yo extends ye {
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e);
    if (a.parsedType !== te.set)
      return ee(a, {
        code: Y.invalid_type,
        expected: te.set,
        received: a.parsedType
      }), he;
    const r = this._def;
    r.minSize !== null && a.data.size < r.minSize.value && (ee(a, {
      code: Y.too_small,
      minimum: r.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: r.minSize.message
    }), n.dirty()), r.maxSize !== null && a.data.size > r.maxSize.value && (ee(a, {
      code: Y.too_big,
      maximum: r.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: r.maxSize.message
    }), n.dirty());
    const i = this._def.valueType;
    function s(l) {
      const f = /* @__PURE__ */ new Set();
      for (const u of l) {
        if (u.status === "aborted")
          return he;
        u.status === "dirty" && n.dirty(), f.add(u.value);
      }
      return { status: n.value, value: f };
    }
    const o = [...a.data.values()].map((l, f) => i._parse(new ha(a, l, a.path, f)));
    return a.common.async ? Promise.all(o).then((l) => s(l)) : s(o);
  }
  min(e, n) {
    return new Yo({
      ...this._def,
      minSize: { value: e, message: ae.toString(n) }
    });
  }
  max(e, n) {
    return new Yo({
      ...this._def,
      maxSize: { value: e, message: ae.toString(n) }
    });
  }
  size(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Yo.create = (t, e) => new Yo({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: K.ZodSet,
  ...me(e)
});
class Vu extends ye {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== te.function)
      return ee(n, {
        code: Y.invalid_type,
        expected: te.function,
        received: n.parsedType
      }), he;
    function a(o, l) {
      return Ch({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Rh(),
          Gu
        ].filter((f) => !!f),
        issueData: {
          code: Y.invalid_arguments,
          argumentsError: l
        }
      });
    }
    function r(o, l) {
      return Ch({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Rh(),
          Gu
        ].filter((f) => !!f),
        issueData: {
          code: Y.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    const i = { errorMap: n.common.contextualErrorMap }, s = n.data;
    if (this._def.returns instanceof Xu) {
      const o = this;
      return Xt(async function(...l) {
        const f = new hr([]), u = await o._def.args.parseAsync(l, i).catch((p) => {
          throw f.addIssue(a(l, p)), f;
        }), c = await Reflect.apply(s, this, u);
        return await o._def.returns._def.type.parseAsync(c, i).catch((p) => {
          throw f.addIssue(r(c, p)), f;
        });
      });
    } else {
      const o = this;
      return Xt(function(...l) {
        const f = o._def.args.safeParse(l, i);
        if (!f.success)
          throw new hr([a(l, f.error)]);
        const u = Reflect.apply(s, this, f.data), c = o._def.returns.safeParse(u, i);
        if (!c.success)
          throw new hr([r(u, c.error)]);
        return c.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new Vu({
      ...this._def,
      args: pa.create(e).rest(Bo.create())
    });
  }
  returns(e) {
    return new Vu({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, n, a) {
    return new Vu({
      args: e || pa.create([]).rest(Bo.create()),
      returns: n || Bo.create(),
      typeName: K.ZodFunction,
      ...me(a)
    });
  }
}
class gd extends ye {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
gd.create = (t, e) => new gd({
  getter: t,
  typeName: K.ZodLazy,
  ...me(e)
});
class _d extends ye {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return ee(n, {
        received: n.data,
        code: Y.invalid_literal,
        expected: this._def.value
      }), he;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
_d.create = (t, e) => new _d({
  value: t,
  typeName: K.ZodLiteral,
  ...me(e)
});
function fC(t, e) {
  return new mo({
    values: t,
    typeName: K.ZodEnum,
    ...me(e)
  });
}
class mo extends ye {
  constructor() {
    super(...arguments), Bl.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e), a = this._def.values;
      return ee(n, {
        expected: Ce.joinValues(a),
        received: n.parsedType,
        code: Y.invalid_type
      }), he;
    }
    if (Th(this, Bl) || uC(this, Bl, new Set(this._def.values)), !Th(this, Bl).has(e.data)) {
      const n = this._getOrReturnCtx(e), a = this._def.values;
      return ee(n, {
        received: n.data,
        code: Y.invalid_enum_value,
        options: a
      }), he;
    }
    return Xt(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Values() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  extract(e, n = this._def) {
    return mo.create(e, {
      ...this._def,
      ...n
    });
  }
  exclude(e, n = this._def) {
    return mo.create(this.options.filter((a) => !e.includes(a)), {
      ...this._def,
      ...n
    });
  }
}
Bl = /* @__PURE__ */ new WeakMap();
mo.create = fC;
class yd extends ye {
  constructor() {
    super(...arguments), xl.set(this, void 0);
  }
  _parse(e) {
    const n = Ce.getValidEnumValues(this._def.values), a = this._getOrReturnCtx(e);
    if (a.parsedType !== te.string && a.parsedType !== te.number) {
      const r = Ce.objectValues(n);
      return ee(a, {
        expected: Ce.joinValues(r),
        received: a.parsedType,
        code: Y.invalid_type
      }), he;
    }
    if (Th(this, xl) || uC(this, xl, new Set(Ce.getValidEnumValues(this._def.values))), !Th(this, xl).has(e.data)) {
      const r = Ce.objectValues(n);
      return ee(a, {
        received: a.data,
        code: Y.invalid_enum_value,
        options: r
      }), he;
    }
    return Xt(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
xl = /* @__PURE__ */ new WeakMap();
yd.create = (t, e) => new yd({
  values: t,
  typeName: K.ZodNativeEnum,
  ...me(e)
});
class Xu extends ye {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== te.promise && n.common.async === !1)
      return ee(n, {
        code: Y.invalid_type,
        expected: te.promise,
        received: n.parsedType
      }), he;
    const a = n.parsedType === te.promise ? n.data : Promise.resolve(n.data);
    return Xt(a.then((r) => this._def.type.parseAsync(r, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
Xu.create = (t, e) => new Xu({
  type: t,
  typeName: K.ZodPromise,
  ...me(e)
});
class yr extends ye {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === K.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e), r = this._def.effect || null, i = {
      addIssue: (s) => {
        ee(a, s), s.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return a.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), r.type === "preprocess") {
      const s = r.transform(a.data, i);
      if (a.common.async)
        return Promise.resolve(s).then(async (o) => {
          if (n.value === "aborted")
            return he;
          const l = await this._def.schema._parseAsync({
            data: o,
            path: a.path,
            parent: a
          });
          return l.status === "aborted" ? he : l.status === "dirty" || n.value === "dirty" ? ku(l.value) : l;
        });
      {
        if (n.value === "aborted")
          return he;
        const o = this._def.schema._parseSync({
          data: s,
          path: a.path,
          parent: a
        });
        return o.status === "aborted" ? he : o.status === "dirty" || n.value === "dirty" ? ku(o.value) : o;
      }
    }
    if (r.type === "refinement") {
      const s = (o) => {
        const l = r.refinement(o, i);
        if (a.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (a.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: a.data,
          path: a.path,
          parent: a
        });
        return o.status === "aborted" ? he : (o.status === "dirty" && n.dirty(), s(o.value), { status: n.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: a.data, path: a.path, parent: a }).then((o) => o.status === "aborted" ? he : (o.status === "dirty" && n.dirty(), s(o.value).then(() => ({ status: n.value, value: o.value }))));
    }
    if (r.type === "transform")
      if (a.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: a.data,
          path: a.path,
          parent: a
        });
        if (!Xo(s))
          return s;
        const o = r.transform(s.value, i);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: a.data, path: a.path, parent: a }).then((s) => Xo(s) ? Promise.resolve(r.transform(s.value, i)).then((o) => ({ status: n.value, value: o })) : s);
    Ce.assertNever(r);
  }
}
yr.create = (t, e, n) => new yr({
  schema: t,
  typeName: K.ZodEffects,
  effect: e,
  ...me(n)
});
yr.createWithPreprocess = (t, e, n) => new yr({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: K.ZodEffects,
  ...me(n)
});
class mr extends ye {
  _parse(e) {
    return this._getType(e) === te.undefined ? Xt(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
mr.create = (t, e) => new mr({
  innerType: t,
  typeName: K.ZodOptional,
  ...me(e)
});
class bo extends ye {
  _parse(e) {
    return this._getType(e) === te.null ? Xt(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
bo.create = (t, e) => new bo({
  innerType: t,
  typeName: K.ZodNullable,
  ...me(e)
});
class wd extends ye {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    let a = n.data;
    return n.parsedType === te.undefined && (a = this._def.defaultValue()), this._def.innerType._parse({
      data: a,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
wd.create = (t, e) => new wd({
  innerType: t,
  typeName: K.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...me(e)
});
class vd extends ye {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), a = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, r = this._def.innerType._parse({
      data: a.data,
      path: a.path,
      parent: {
        ...a
      }
    });
    return ld(r) ? r.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new hr(a.common.issues);
        },
        input: a.data
      })
    })) : {
      status: "valid",
      value: r.status === "valid" ? r.value : this._def.catchValue({
        get error() {
          return new hr(a.common.issues);
        },
        input: a.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
vd.create = (t, e) => new vd({
  innerType: t,
  typeName: K.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...me(e)
});
class Eh extends ye {
  _parse(e) {
    if (this._getType(e) !== te.nan) {
      const a = this._getOrReturnCtx(e);
      return ee(a, {
        code: Y.invalid_type,
        expected: te.nan,
        received: a.parsedType
      }), he;
    }
    return { status: "valid", value: e.data };
  }
}
Eh.create = (t) => new Eh({
  typeName: K.ZodNaN,
  ...me(t)
});
const r1 = Symbol("zod_brand");
class o_ extends ye {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), a = n.data;
    return this._def.type._parse({
      data: a,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Vd extends ye {
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e);
    if (a.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: a.data,
          path: a.path,
          parent: a
        });
        return i.status === "aborted" ? he : i.status === "dirty" ? (n.dirty(), ku(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: a.path,
          parent: a
        });
      })();
    {
      const r = this._def.in._parseSync({
        data: a.data,
        path: a.path,
        parent: a
      });
      return r.status === "aborted" ? he : r.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: r.value
      }) : this._def.out._parseSync({
        data: r.value,
        path: a.path,
        parent: a
      });
    }
  }
  static create(e, n) {
    return new Vd({
      in: e,
      out: n,
      typeName: K.ZodPipeline
    });
  }
}
class Sd extends ye {
  _parse(e) {
    const n = this._def.innerType._parse(e), a = (r) => (Xo(r) && (r.value = Object.freeze(r.value)), r);
    return ld(n) ? n.then((r) => a(r)) : a(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Sd.create = (t, e) => new Sd({
  innerType: t,
  typeName: K.ZodReadonly,
  ...me(e)
});
function sw(t, e) {
  const n = typeof t == "function" ? t(e) : typeof t == "string" ? { message: t } : t;
  return typeof n == "string" ? { message: n } : n;
}
function hC(t, e = {}, n) {
  return t ? Wu.create().superRefine((a, r) => {
    var i, s;
    const o = t(a);
    if (o instanceof Promise)
      return o.then((l) => {
        var f, u;
        if (!l) {
          const c = sw(e, a), h = (u = (f = c.fatal) !== null && f !== void 0 ? f : n) !== null && u !== void 0 ? u : !0;
          r.addIssue({ code: "custom", ...c, fatal: h });
        }
      });
    if (!o) {
      const l = sw(e, a), f = (s = (i = l.fatal) !== null && i !== void 0 ? i : n) !== null && s !== void 0 ? s : !0;
      r.addIssue({ code: "custom", ...l, fatal: f });
    }
  }) : Wu.create();
}
const a1 = {
  object: tt.lazycreate
};
var K;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(K || (K = {}));
const i1 = (t, e = {
  message: `Input not instance of ${t.name}`
}) => hC((n) => n instanceof t, e), pC = ur.create, mC = ho.create, s1 = Eh.create, o1 = po.create, bC = dd.create, u1 = Qo.create, c1 = $h.create, l1 = fd.create, d1 = hd.create, f1 = Wu.create, h1 = Bo.create, p1 = zs.create, m1 = Mh.create, b1 = pr.create, g1 = tt.create, _1 = tt.strictCreate, y1 = pd.create, w1 = Rp.create, v1 = md.create, S1 = pa.create, O1 = bd.create, j1 = Ah.create, P1 = Yo.create, R1 = Vu.create, C1 = gd.create, T1 = _d.create, $1 = mo.create, M1 = yd.create, A1 = Xu.create, ow = yr.create, E1 = mr.create, I1 = bo.create, N1 = yr.createWithPreprocess, k1 = Vd.create, F1 = () => pC().optional(), D1 = () => mC().optional(), q1 = () => bC().optional(), J1 = {
  string: (t) => ur.create({ ...t, coerce: !0 }),
  number: (t) => ho.create({ ...t, coerce: !0 }),
  boolean: (t) => dd.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => po.create({ ...t, coerce: !0 }),
  date: (t) => Qo.create({ ...t, coerce: !0 })
}, L1 = he;
var jn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Gu,
  setErrorMap: NI,
  getErrorMap: Rh,
  makeIssue: Ch,
  EMPTY_PATH: kI,
  addIssueToContext: ee,
  ParseStatus: xt,
  INVALID: he,
  DIRTY: ku,
  OK: Xt,
  isAborted: Gb,
  isDirty: Wb,
  isValid: Xo,
  isAsync: ld,
  get util() {
    return Ce;
  },
  get objectUtil() {
    return Hb;
  },
  ZodParsedType: te,
  getParsedType: Ds,
  ZodType: ye,
  datetimeRegex: dC,
  ZodString: ur,
  ZodNumber: ho,
  ZodBigInt: po,
  ZodBoolean: dd,
  ZodDate: Qo,
  ZodSymbol: $h,
  ZodUndefined: fd,
  ZodNull: hd,
  ZodAny: Wu,
  ZodUnknown: Bo,
  ZodNever: zs,
  ZodVoid: Mh,
  ZodArray: pr,
  ZodObject: tt,
  ZodUnion: pd,
  ZodDiscriminatedUnion: Rp,
  ZodIntersection: md,
  ZodTuple: pa,
  ZodRecord: bd,
  ZodMap: Ah,
  ZodSet: Yo,
  ZodFunction: Vu,
  ZodLazy: gd,
  ZodLiteral: _d,
  ZodEnum: mo,
  ZodNativeEnum: yd,
  ZodPromise: Xu,
  ZodEffects: yr,
  ZodTransformer: yr,
  ZodOptional: mr,
  ZodNullable: bo,
  ZodDefault: wd,
  ZodCatch: vd,
  ZodNaN: Eh,
  BRAND: r1,
  ZodBranded: o_,
  ZodPipeline: Vd,
  ZodReadonly: Sd,
  custom: hC,
  Schema: ye,
  ZodSchema: ye,
  late: a1,
  get ZodFirstPartyTypeKind() {
    return K;
  },
  coerce: J1,
  any: f1,
  array: b1,
  bigint: o1,
  boolean: bC,
  date: u1,
  discriminatedUnion: w1,
  effect: ow,
  enum: $1,
  function: R1,
  instanceof: i1,
  intersection: v1,
  lazy: C1,
  literal: T1,
  map: j1,
  nan: s1,
  nativeEnum: M1,
  never: p1,
  null: d1,
  nullable: I1,
  number: mC,
  object: g1,
  oboolean: q1,
  onumber: D1,
  optional: E1,
  ostring: F1,
  pipeline: k1,
  preprocess: N1,
  promise: A1,
  record: O1,
  set: P1,
  strictObject: _1,
  string: pC,
  symbol: c1,
  transformer: ow,
  tuple: S1,
  undefined: l1,
  union: y1,
  unknown: h1,
  void: m1,
  NEVER: L1,
  ZodIssueCode: Y,
  quotelessJson: II,
  ZodError: hr
}), vc = { exports: {} }, _m = {}, ym, uw;
function U1() {
  if (uw) return ym;
  uw = 1;
  function t(e, n) {
    typeof n == "boolean" && (n = { forever: n }), this._originalTimeouts = JSON.parse(JSON.stringify(e)), this._timeouts = e, this._options = n || {}, this._maxRetryTime = n && n.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
  }
  return ym = t, t.prototype.reset = function() {
    this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
  }, t.prototype.stop = function() {
    this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null;
  }, t.prototype.retry = function(e) {
    if (this._timeout && clearTimeout(this._timeout), !e)
      return !1;
    var n = (/* @__PURE__ */ new Date()).getTime();
    if (e && n - this._operationStart >= this._maxRetryTime)
      return this._errors.push(e), this._errors.unshift(new Error("RetryOperation timeout occurred")), !1;
    this._errors.push(e);
    var a = this._timeouts.shift();
    if (a === void 0)
      if (this._cachedTimeouts)
        this._errors.splice(0, this._errors.length - 1), a = this._cachedTimeouts.slice(-1);
      else
        return !1;
    var r = this;
    return this._timer = setTimeout(function() {
      r._attempts++, r._operationTimeoutCb && (r._timeout = setTimeout(function() {
        r._operationTimeoutCb(r._attempts);
      }, r._operationTimeout), r._options.unref && r._timeout.unref()), r._fn(r._attempts);
    }, a), this._options.unref && this._timer.unref(), !0;
  }, t.prototype.attempt = function(e, n) {
    this._fn = e, n && (n.timeout && (this._operationTimeout = n.timeout), n.cb && (this._operationTimeoutCb = n.cb));
    var a = this;
    this._operationTimeoutCb && (this._timeout = setTimeout(function() {
      a._operationTimeoutCb();
    }, a._operationTimeout)), this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
  }, t.prototype.try = function(e) {
    console.log("Using RetryOperation.try() is deprecated"), this.attempt(e);
  }, t.prototype.start = function(e) {
    console.log("Using RetryOperation.start() is deprecated"), this.attempt(e);
  }, t.prototype.start = t.prototype.try, t.prototype.errors = function() {
    return this._errors;
  }, t.prototype.attempts = function() {
    return this._attempts;
  }, t.prototype.mainError = function() {
    if (this._errors.length === 0)
      return null;
    for (var e = {}, n = null, a = 0, r = 0; r < this._errors.length; r++) {
      var i = this._errors[r], s = i.message, o = (e[s] || 0) + 1;
      e[s] = o, o >= a && (n = i, a = o);
    }
    return n;
  }, ym;
}
var cw;
function B1() {
  return cw || (cw = 1, function(t) {
    var e = /* @__PURE__ */ U1();
    t.operation = function(n) {
      var a = t.timeouts(n);
      return new e(a, {
        forever: n && (n.forever || n.retries === 1 / 0),
        unref: n && n.unref,
        maxRetryTime: n && n.maxRetryTime
      });
    }, t.timeouts = function(n) {
      if (n instanceof Array)
        return [].concat(n);
      var a = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: 1 / 0,
        randomize: !1
      };
      for (var r in n)
        a[r] = n[r];
      if (a.minTimeout > a.maxTimeout)
        throw new Error("minTimeout is greater than maxTimeout");
      for (var i = [], s = 0; s < a.retries; s++)
        i.push(this.createTimeout(s, a));
      return n && n.forever && !i.length && i.push(this.createTimeout(s, a)), i.sort(function(o, l) {
        return o - l;
      }), i;
    }, t.createTimeout = function(n, a) {
      var r = a.randomize ? Math.random() + 1 : 1, i = Math.round(r * Math.max(a.minTimeout, 1) * Math.pow(a.factor, n));
      return i = Math.min(i, a.maxTimeout), i;
    }, t.wrap = function(n, a, r) {
      if (a instanceof Array && (r = a, a = null), !r) {
        r = [];
        for (var i in n)
          typeof n[i] == "function" && r.push(i);
      }
      for (var s = 0; s < r.length; s++) {
        var o = r[s], l = n[o];
        n[o] = function(u) {
          var c = t.operation(a), h = Array.prototype.slice.call(arguments, 1), p = h.pop();
          h.push(function(d) {
            c.retry(d) || (d && (arguments[0] = c.mainError()), p.apply(this, arguments));
          }), c.attempt(function() {
            u.apply(n, h);
          });
        }.bind(n, l), n[o].options = a;
      }
    };
  }(_m)), _m;
}
var wm, lw;
function x1() {
  return lw || (lw = 1, wm = /* @__PURE__ */ B1()), wm;
}
var dw;
function V1() {
  if (dw) return vc.exports;
  dw = 1;
  const t = /* @__PURE__ */ x1(), e = [
    "Failed to fetch",
    // Chrome
    "NetworkError when attempting to fetch resource.",
    // Firefox
    "The Internet connection appears to be offline.",
    // Safari
    "Network request failed"
    // `cross-fetch`
  ];
  class n extends Error {
    constructor(o) {
      super(), o instanceof Error ? (this.originalError = o, { message: o } = o) : (this.originalError = new Error(o), this.originalError.stack = this.stack), this.name = "AbortError", this.message = o;
    }
  }
  const a = (s, o, l) => {
    const f = l.retries - (o - 1);
    return s.attemptNumber = o, s.retriesLeft = f, s;
  }, r = (s) => e.includes(s), i = (s, o) => new Promise((l, f) => {
    o = {
      onFailedAttempt: () => {
      },
      retries: 10,
      ...o
    };
    const u = t.operation(o);
    u.attempt(async (c) => {
      try {
        l(await s(c));
      } catch (h) {
        if (!(h instanceof Error)) {
          f(new TypeError(`Non-error was thrown: "${h}". You should only throw errors.`));
          return;
        }
        if (h instanceof n)
          u.stop(), f(h.originalError);
        else if (h instanceof TypeError && !r(h.message))
          u.stop(), f(h);
        else {
          a(h, c, o);
          try {
            await o.onFailedAttempt(h);
          } catch (p) {
            f(p);
            return;
          }
          u.retry(h) || f(u.mainError());
        }
      }
    });
  });
  return vc.exports = i, vc.exports.default = i, vc.exports.AbortError = n, vc.exports;
}
var z1 = /* @__PURE__ */ V1();
const Ih = /* @__PURE__ */ Bd(z1), Z1 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function Us(t) {
  return typeof t == "string" && Z1.test(t);
}
function gC(t) {
  if (!Us(t))
    throw TypeError("Invalid UUID");
  var e, n = new Uint8Array(16);
  return n[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24, n[1] = e >>> 16 & 255, n[2] = e >>> 8 & 255, n[3] = e & 255, n[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8, n[5] = e & 255, n[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8, n[7] = e & 255, n[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8, n[9] = e & 255, n[10] = (e = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255, n[11] = e / 4294967296 & 255, n[12] = e >>> 24 & 255, n[13] = e >>> 16 & 255, n[14] = e >>> 8 & 255, n[15] = e & 255, n;
}
var Et = [];
for (var vm = 0; vm < 256; ++vm)
  Et.push((vm + 256).toString(16).slice(1));
function zd(t, e = 0) {
  return (Et[t[e + 0]] + Et[t[e + 1]] + Et[t[e + 2]] + Et[t[e + 3]] + "-" + Et[t[e + 4]] + Et[t[e + 5]] + "-" + Et[t[e + 6]] + Et[t[e + 7]] + "-" + Et[t[e + 8]] + Et[t[e + 9]] + "-" + Et[t[e + 10]] + Et[t[e + 11]] + Et[t[e + 12]] + Et[t[e + 13]] + Et[t[e + 14]] + Et[t[e + 15]]).toLowerCase();
}
var yf, K1 = new Uint8Array(16);
function _C() {
  if (!yf && (yf = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !yf))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return yf(K1);
}
var Sm, wf, Om = 0, jm = 0;
function H1(t, e, n) {
  var a = 0, r = e || new Array(16);
  t = t || {};
  var i = t.node, s = t.clockseq;
  if (t._v6 || (i || (i = Sm), s == null && (s = wf)), i == null || s == null) {
    var o = t.random || (t.rng || _C)();
    i == null && (i = [o[0], o[1], o[2], o[3], o[4], o[5]], !Sm && !t._v6 && (i[0] |= 1, Sm = i)), s == null && (s = (o[6] << 8 | o[7]) & 16383, wf === void 0 && !t._v6 && (wf = s));
  }
  var l = t.msecs !== void 0 ? t.msecs : Date.now(), f = t.nsecs !== void 0 ? t.nsecs : jm + 1, u = l - Om + (f - jm) / 1e4;
  if (u < 0 && t.clockseq === void 0 && (s = s + 1 & 16383), (u < 0 || l > Om) && t.nsecs === void 0 && (f = 0), f >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  Om = l, jm = f, wf = s, l += 122192928e5;
  var c = ((l & 268435455) * 1e4 + f) % 4294967296;
  r[a++] = c >>> 24 & 255, r[a++] = c >>> 16 & 255, r[a++] = c >>> 8 & 255, r[a++] = c & 255;
  var h = l / 4294967296 * 1e4 & 268435455;
  r[a++] = h >>> 8 & 255, r[a++] = h & 255, r[a++] = h >>> 24 & 15 | 16, r[a++] = h >>> 16 & 255, r[a++] = s >>> 8 | 128, r[a++] = s & 255;
  for (var p = 0; p < 6; ++p)
    r[a + p] = i[p];
  return e || zd(r);
}
function G1(t) {
  var e = typeof t == "string" ? gC(t) : t, n = W1(e);
  return typeof t == "string" ? zd(n) : n;
}
function W1(t, e = !1) {
  return Uint8Array.of((t[6] & 15) << 4 | t[7] >> 4 & 15, (t[7] & 15) << 4 | (t[4] & 240) >> 4, (t[4] & 15) << 4 | (t[5] & 240) >> 4, (t[5] & 15) << 4 | (t[0] & 240) >> 4, (t[0] & 15) << 4 | (t[1] & 240) >> 4, (t[1] & 15) << 4 | (t[2] & 240) >> 4, 96 | t[2] & 15, t[3], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
}
function X1(t) {
  t = unescape(encodeURIComponent(t));
  for (var e = [], n = 0; n < t.length; ++n)
    e.push(t.charCodeAt(n));
  return e;
}
var Q1 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", Y1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function eN(t, e, n) {
  function a(r, i, s, o) {
    var l;
    if (typeof r == "string" && (r = X1(r)), typeof i == "string" && (i = gC(i)), ((l = i) === null || l === void 0 ? void 0 : l.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var f = new Uint8Array(16 + r.length);
    if (f.set(i), f.set(r, i.length), f = n(f), f[6] = f[6] & 15 | e, f[8] = f[8] & 63 | 128, s) {
      o = o || 0;
      for (var u = 0; u < 16; ++u)
        s[o + u] = f[u];
      return s;
    }
    return zd(f);
  }
  try {
    a.name = t;
  } catch {
  }
  return a.DNS = Q1, a.URL = Y1, a;
}
var tN = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const fw = {
  randomUUID: tN
};
function Pt(t, e, n) {
  if (fw.randomUUID && !t)
    return fw.randomUUID();
  t = t || {};
  var a = t.random || (t.rng || _C)();
  return a[6] = a[6] & 15 | 64, a[8] = a[8] & 63 | 128, zd(a);
}
function nN(t, e, n, a) {
  switch (t) {
    case 0:
      return e & n ^ ~e & a;
    case 1:
      return e ^ n ^ a;
    case 2:
      return e & n ^ e & a ^ n & a;
    case 3:
      return e ^ n ^ a;
  }
}
function Pm(t, e) {
  return t << e | t >>> 32 - e;
}
function rN(t) {
  var e = [1518500249, 1859775393, 2400959708, 3395469782], n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof t == "string") {
    var a = unescape(encodeURIComponent(t));
    t = [];
    for (var r = 0; r < a.length; ++r)
      t.push(a.charCodeAt(r));
  } else Array.isArray(t) || (t = Array.prototype.slice.call(t));
  t.push(128);
  for (var i = t.length / 4 + 2, s = Math.ceil(i / 16), o = new Array(s), l = 0; l < s; ++l) {
    for (var f = new Uint32Array(16), u = 0; u < 16; ++u)
      f[u] = t[l * 64 + u * 4] << 24 | t[l * 64 + u * 4 + 1] << 16 | t[l * 64 + u * 4 + 2] << 8 | t[l * 64 + u * 4 + 3];
    o[l] = f;
  }
  o[s - 1][14] = (t.length - 1) * 8 / Math.pow(2, 32), o[s - 1][14] = Math.floor(o[s - 1][14]), o[s - 1][15] = (t.length - 1) * 8 & 4294967295;
  for (var c = 0; c < s; ++c) {
    for (var h = new Uint32Array(80), p = 0; p < 16; ++p)
      h[p] = o[c][p];
    for (var d = 16; d < 80; ++d)
      h[d] = Pm(h[d - 3] ^ h[d - 8] ^ h[d - 14] ^ h[d - 16], 1);
    for (var m = n[0], b = n[1], g = n[2], _ = n[3], P = n[4], C = 0; C < 80; ++C) {
      var R = Math.floor(C / 20), T = Pm(m, 5) + nN(R, b, g, _) + P + e[R] + h[C] >>> 0;
      P = _, _ = g, g = Pm(b, 30) >>> 0, b = m, m = T;
    }
    n[0] = n[0] + m >>> 0, n[1] = n[1] + b >>> 0, n[2] = n[2] + g >>> 0, n[3] = n[3] + _ >>> 0, n[4] = n[4] + P >>> 0;
  }
  return [n[0] >> 24 & 255, n[0] >> 16 & 255, n[0] >> 8 & 255, n[0] & 255, n[1] >> 24 & 255, n[1] >> 16 & 255, n[1] >> 8 & 255, n[1] & 255, n[2] >> 24 & 255, n[2] >> 16 & 255, n[2] >> 8 & 255, n[2] & 255, n[3] >> 24 & 255, n[3] >> 16 & 255, n[3] >> 8 & 255, n[3] & 255, n[4] >> 24 & 255, n[4] >> 16 & 255, n[4] >> 8 & 255, n[4] & 255];
}
var aN = eN("v5", 80, rN);
function hw(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t, r).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function pw(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? hw(Object(n), !0).forEach(function(a) {
      iN(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : hw(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function iN(t, e, n) {
  return (e = sN(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function sN(t) {
  var e = oN(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
function oN(t, e) {
  if (typeof t != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var a = n.call(t, e);
    if (typeof a != "object") return a;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function uN(t = {}, e, n = 0) {
  var a = H1(pw(pw({}, t), {}, {
    _v6: !0
  }), new Uint8Array(16));
  return a = G1(a), zd(a);
}
var vf = {}, Rm = { exports: {} }, mw;
function cN() {
  return mw || (mw = 1, function(t) {
    var e = Object.prototype.hasOwnProperty, n = "~";
    function a() {
    }
    Object.create && (a.prototype = /* @__PURE__ */ Object.create(null), new a().__proto__ || (n = !1));
    function r(l, f, u) {
      this.fn = l, this.context = f, this.once = u || !1;
    }
    function i(l, f, u, c, h) {
      if (typeof u != "function")
        throw new TypeError("The listener must be a function");
      var p = new r(u, c || l, h), d = n ? n + f : f;
      return l._events[d] ? l._events[d].fn ? l._events[d] = [l._events[d], p] : l._events[d].push(p) : (l._events[d] = p, l._eventsCount++), l;
    }
    function s(l, f) {
      --l._eventsCount === 0 ? l._events = new a() : delete l._events[f];
    }
    function o() {
      this._events = new a(), this._eventsCount = 0;
    }
    o.prototype.eventNames = function() {
      var f = [], u, c;
      if (this._eventsCount === 0) return f;
      for (c in u = this._events)
        e.call(u, c) && f.push(n ? c.slice(1) : c);
      return Object.getOwnPropertySymbols ? f.concat(Object.getOwnPropertySymbols(u)) : f;
    }, o.prototype.listeners = function(f) {
      var u = n ? n + f : f, c = this._events[u];
      if (!c) return [];
      if (c.fn) return [c.fn];
      for (var h = 0, p = c.length, d = new Array(p); h < p; h++)
        d[h] = c[h].fn;
      return d;
    }, o.prototype.listenerCount = function(f) {
      var u = n ? n + f : f, c = this._events[u];
      return c ? c.fn ? 1 : c.length : 0;
    }, o.prototype.emit = function(f, u, c, h, p, d) {
      var m = n ? n + f : f;
      if (!this._events[m]) return !1;
      var b = this._events[m], g = arguments.length, _, P;
      if (b.fn) {
        switch (b.once && this.removeListener(f, b.fn, void 0, !0), g) {
          case 1:
            return b.fn.call(b.context), !0;
          case 2:
            return b.fn.call(b.context, u), !0;
          case 3:
            return b.fn.call(b.context, u, c), !0;
          case 4:
            return b.fn.call(b.context, u, c, h), !0;
          case 5:
            return b.fn.call(b.context, u, c, h, p), !0;
          case 6:
            return b.fn.call(b.context, u, c, h, p, d), !0;
        }
        for (P = 1, _ = new Array(g - 1); P < g; P++)
          _[P - 1] = arguments[P];
        b.fn.apply(b.context, _);
      } else {
        var C = b.length, R;
        for (P = 0; P < C; P++)
          switch (b[P].once && this.removeListener(f, b[P].fn, void 0, !0), g) {
            case 1:
              b[P].fn.call(b[P].context);
              break;
            case 2:
              b[P].fn.call(b[P].context, u);
              break;
            case 3:
              b[P].fn.call(b[P].context, u, c);
              break;
            case 4:
              b[P].fn.call(b[P].context, u, c, h);
              break;
            default:
              if (!_) for (R = 1, _ = new Array(g - 1); R < g; R++)
                _[R - 1] = arguments[R];
              b[P].fn.apply(b[P].context, _);
          }
      }
      return !0;
    }, o.prototype.on = function(f, u, c) {
      return i(this, f, u, c, !1);
    }, o.prototype.once = function(f, u, c) {
      return i(this, f, u, c, !0);
    }, o.prototype.removeListener = function(f, u, c, h) {
      var p = n ? n + f : f;
      if (!this._events[p]) return this;
      if (!u)
        return s(this, p), this;
      var d = this._events[p];
      if (d.fn)
        d.fn === u && (!h || d.once) && (!c || d.context === c) && s(this, p);
      else {
        for (var m = 0, b = [], g = d.length; m < g; m++)
          (d[m].fn !== u || h && !d[m].once || c && d[m].context !== c) && b.push(d[m]);
        b.length ? this._events[p] = b.length === 1 ? b[0] : b : s(this, p);
      }
      return this;
    }, o.prototype.removeAllListeners = function(f) {
      var u;
      return f ? (u = n ? n + f : f, this._events[u] && s(this, u)) : (this._events = new a(), this._eventsCount = 0), this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = n, o.EventEmitter = o, t.exports = o;
  }(Rm)), Rm.exports;
}
var Sc = { exports: {} }, Cm, bw;
function lN() {
  return bw || (bw = 1, Cm = (t, e) => (e = e || (() => {
  }), t.then(
    (n) => new Promise((a) => {
      a(e());
    }).then(() => n),
    (n) => new Promise((a) => {
      a(e());
    }).then(() => {
      throw n;
    })
  ))), Cm;
}
var gw;
function dN() {
  if (gw) return Sc.exports;
  gw = 1;
  const t = /* @__PURE__ */ lN();
  class e extends Error {
    constructor(r) {
      super(r), this.name = "TimeoutError";
    }
  }
  const n = (a, r, i) => new Promise((s, o) => {
    if (typeof r != "number" || r < 0)
      throw new TypeError("Expected `milliseconds` to be a positive number");
    if (r === 1 / 0) {
      s(a);
      return;
    }
    const l = setTimeout(() => {
      if (typeof i == "function") {
        try {
          s(i());
        } catch (c) {
          o(c);
        }
        return;
      }
      const f = typeof i == "string" ? i : `Promise timed out after ${r} milliseconds`, u = i instanceof Error ? i : new e(f);
      typeof a.cancel == "function" && a.cancel(), o(u);
    }, r);
    t(
      // eslint-disable-next-line promise/prefer-await-to-then
      a.then(s, o),
      () => {
        clearTimeout(l);
      }
    );
  });
  return Sc.exports = n, Sc.exports.default = n, Sc.exports.TimeoutError = e, Sc.exports;
}
var Sf = {}, Of = {}, _w;
function fN() {
  if (_w) return Of;
  _w = 1, Object.defineProperty(Of, "__esModule", { value: !0 });
  function t(e, n, a) {
    let r = 0, i = e.length;
    for (; i > 0; ) {
      const s = i / 2 | 0;
      let o = r + s;
      a(e[o], n) <= 0 ? (r = ++o, i -= s + 1) : i = s;
    }
    return r;
  }
  return Of.default = t, Of;
}
var yw;
function hN() {
  if (yw) return Sf;
  yw = 1, Object.defineProperty(Sf, "__esModule", { value: !0 });
  const t = /* @__PURE__ */ fN();
  class e {
    constructor() {
      this._queue = [];
    }
    enqueue(a, r) {
      r = Object.assign({ priority: 0 }, r);
      const i = {
        priority: r.priority,
        run: a
      };
      if (this.size && this._queue[this.size - 1].priority >= r.priority) {
        this._queue.push(i);
        return;
      }
      const s = t.default(this._queue, i, (o, l) => l.priority - o.priority);
      this._queue.splice(s, 0, i);
    }
    dequeue() {
      const a = this._queue.shift();
      return a?.run;
    }
    filter(a) {
      return this._queue.filter((r) => r.priority === a.priority).map((r) => r.run);
    }
    get size() {
      return this._queue.length;
    }
  }
  return Sf.default = e, Sf;
}
var ww;
function pN() {
  if (ww) return vf;
  ww = 1, Object.defineProperty(vf, "__esModule", { value: !0 });
  const t = /* @__PURE__ */ cN(), e = /* @__PURE__ */ dN(), n = /* @__PURE__ */ hN(), a = () => {
  }, r = new e.TimeoutError();
  class i extends t {
    constructor(o) {
      var l, f, u, c;
      if (super(), this._intervalCount = 0, this._intervalEnd = 0, this._pendingCount = 0, this._resolveEmpty = a, this._resolveIdle = a, o = Object.assign({ carryoverConcurrencyCount: !1, intervalCap: 1 / 0, interval: 0, concurrency: 1 / 0, autoStart: !0, queueClass: n.default }, o), !(typeof o.intervalCap == "number" && o.intervalCap >= 1))
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(f = (l = o.intervalCap) === null || l === void 0 ? void 0 : l.toString()) !== null && f !== void 0 ? f : ""}\` (${typeof o.intervalCap})`);
      if (o.interval === void 0 || !(Number.isFinite(o.interval) && o.interval >= 0))
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(c = (u = o.interval) === null || u === void 0 ? void 0 : u.toString()) !== null && c !== void 0 ? c : ""}\` (${typeof o.interval})`);
      this._carryoverConcurrencyCount = o.carryoverConcurrencyCount, this._isIntervalIgnored = o.intervalCap === 1 / 0 || o.interval === 0, this._intervalCap = o.intervalCap, this._interval = o.interval, this._queue = new o.queueClass(), this._queueClass = o.queueClass, this.concurrency = o.concurrency, this._timeout = o.timeout, this._throwOnTimeout = o.throwOnTimeout === !0, this._isPaused = o.autoStart === !1;
    }
    get _doesIntervalAllowAnother() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
    get _doesConcurrentAllowAnother() {
      return this._pendingCount < this._concurrency;
    }
    _next() {
      this._pendingCount--, this._tryToStartAnother(), this.emit("next");
    }
    _resolvePromises() {
      this._resolveEmpty(), this._resolveEmpty = a, this._pendingCount === 0 && (this._resolveIdle(), this._resolveIdle = a, this.emit("idle"));
    }
    _onResumeInterval() {
      this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0;
    }
    _isIntervalPaused() {
      const o = Date.now();
      if (this._intervalId === void 0) {
        const l = this._intervalEnd - o;
        if (l < 0)
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        else
          return this._timeoutId === void 0 && (this._timeoutId = setTimeout(() => {
            this._onResumeInterval();
          }, l)), !0;
      }
      return !1;
    }
    _tryToStartAnother() {
      if (this._queue.size === 0)
        return this._intervalId && clearInterval(this._intervalId), this._intervalId = void 0, this._resolvePromises(), !1;
      if (!this._isPaused) {
        const o = !this._isIntervalPaused();
        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          const l = this._queue.dequeue();
          return l ? (this.emit("active"), l(), o && this._initializeIntervalIfNeeded(), !0) : !1;
        }
      }
      return !1;
    }
    _initializeIntervalIfNeeded() {
      this._isIntervalIgnored || this._intervalId !== void 0 || (this._intervalId = setInterval(() => {
        this._onInterval();
      }, this._interval), this._intervalEnd = Date.now() + this._interval);
    }
    _onInterval() {
      this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId && (clearInterval(this._intervalId), this._intervalId = void 0), this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
    _processQueue() {
      for (; this._tryToStartAnother(); )
        ;
    }
    get concurrency() {
      return this._concurrency;
    }
    set concurrency(o) {
      if (!(typeof o == "number" && o >= 1))
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${o}\` (${typeof o})`);
      this._concurrency = o, this._processQueue();
    }
    /**
    Adds a sync or async task to the queue. Always returns a promise.
    */
    async add(o, l = {}) {
      return new Promise((f, u) => {
        const c = async () => {
          this._pendingCount++, this._intervalCount++;
          try {
            const h = this._timeout === void 0 && l.timeout === void 0 ? o() : e.default(Promise.resolve(o()), l.timeout === void 0 ? this._timeout : l.timeout, () => {
              (l.throwOnTimeout === void 0 ? this._throwOnTimeout : l.throwOnTimeout) && u(r);
            });
            f(await h);
          } catch (h) {
            u(h);
          }
          this._next();
        };
        this._queue.enqueue(c, l), this._tryToStartAnother(), this.emit("add");
      });
    }
    /**
    	    Same as `.add()`, but accepts an array of sync or async functions.
    
    	    @returns A promise that resolves when all functions are resolved.
    	    */
    async addAll(o, l) {
      return Promise.all(o.map(async (f) => this.add(f, l)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
      return this._isPaused ? (this._isPaused = !1, this._processQueue(), this) : this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
      this._isPaused = !0;
    }
    /**
    Clear the queue.
    */
    clear() {
      this._queue = new this._queueClass();
    }
    /**
    	    Can be called multiple times. Useful if you for example add additional items at a later time.
    
    	    @returns A promise that settles when the queue becomes empty.
    	    */
    async onEmpty() {
      if (this._queue.size !== 0)
        return new Promise((o) => {
          const l = this._resolveEmpty;
          this._resolveEmpty = () => {
            l(), o();
          };
        });
    }
    /**
    	    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
    
    	    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    	    */
    async onIdle() {
      if (!(this._pendingCount === 0 && this._queue.size === 0))
        return new Promise((o) => {
          const l = this._resolveIdle;
          this._resolveIdle = () => {
            l(), o();
          };
        });
    }
    /**
    Size of the queue.
    */
    get size() {
      return this._queue.size;
    }
    /**
    	    Size of the queue, filtered by the given options.
    
    	    For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    	    */
    sizeBy(o) {
      return this._queue.filter(o).length;
    }
    /**
    Number of pending promises.
    */
    get pending() {
      return this._pendingCount;
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
      return this._isPaused;
    }
    get timeout() {
      return this._timeout;
    }
    /**
    Set the timeout for future operations.
    */
    set timeout(o) {
      this._timeout = o;
    }
  }
  return vf.default = i, vf;
}
var mN = /* @__PURE__ */ pN();
const Bs = /* @__PURE__ */ Bd(mN), bN = (...t) => fetch(...t), gN = Symbol.for("ls:fetch_implementation"), oe = () => globalThis[gN] ?? bN, _N = [
  400,
  // Bad Request
  401,
  // Unauthorized
  403,
  // Forbidden
  404,
  // Not Found
  405,
  // Method Not Allowed
  406,
  // Not Acceptable
  407,
  // Proxy Authentication Required
  408
  // Request Timeout
], yN = [
  409
  // Conflict
];
let vw = class {
  constructor(e) {
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxRetries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onFailedResponseHook", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxConcurrency = e.maxConcurrency ?? 1 / 0, this.maxRetries = e.maxRetries ?? 6, "default" in Bs ? this.queue = new Bs.default({
      concurrency: this.maxConcurrency
    }) : this.queue = new Bs({ concurrency: this.maxConcurrency }), this.onFailedResponseHook = e?.onFailedResponseHook;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(e, ...n) {
    const a = this.onFailedResponseHook;
    return this.queue.add(() => Ih(() => e(...n).catch((r) => {
      throw r instanceof Error ? r : new Error(r);
    }), {
      async onFailedAttempt(r) {
        if (r.message.startsWith("Cancel") || r.message.startsWith("TimeoutError") || r.message.startsWith("AbortError") || r?.code === "ECONNABORTED")
          throw r;
        const i = r?.response, s = i?.status;
        if (s) {
          if (_N.includes(+s))
            throw r;
          if (yN.includes(+s))
            return;
          a && await a(i);
        }
      },
      // If needed we can change some of the defaults here,
      // but they're quite sensible.
      retries: this.maxRetries,
      randomize: !0
    }), { throwOnTimeout: !0 });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(e, n, ...a) {
    return e.signal ? Promise.race([
      this.call(n, ...a),
      new Promise((r, i) => {
        e.signal?.addEventListener("abort", () => {
          i(new Error("AbortError"));
        });
      })
    ]) : this.call(n, ...a);
  }
  fetch(...e) {
    return this.call(() => oe()(...e).then((n) => n.ok ? n : Promise.reject(n)));
  }
};
function Sw(t) {
  return typeof t?._getType == "function";
}
function Ow(t) {
  const e = {
    type: t._getType(),
    data: { content: t.content }
  };
  return t?.additional_kwargs && Object.keys(t.additional_kwargs).length > 0 && (e.data.additional_kwargs = { ...t.additional_kwargs }), e;
}
function be(t, e) {
  if (!Us(t)) {
    const n = e !== void 0 ? `Invalid UUID for ${e}: ${t}` : `Invalid UUID: ${t}`;
    throw new Error(n);
  }
  return t;
}
const jw = {};
function yC(t) {
  jw[t] || (console.warn(t), jw[t] = !0);
}
function Qs(t) {
  if (!t || t.split("/").length > 2 || t.startsWith("/") || t.endsWith("/") || t.split(":").length > 2)
    throw new Error(`Invalid identifier format: ${t}`);
  const [e, n] = t.split(":"), a = n || "latest";
  if (e.includes("/")) {
    const [r, i] = e.split("/", 2);
    if (!r || !i)
      throw new Error(`Invalid identifier format: ${t}`);
    return [r, i, a];
  } else {
    if (!e)
      throw new Error(`Invalid identifier format: ${t}`);
    return ["-", e, a];
  }
}
class wN extends Error {
  constructor(e) {
    super(e), this.name = "LangSmithConflictError";
  }
}
async function Se(t, e, n) {
  let a;
  if (t.ok) {
    n && (a = await t.text());
    return;
  }
  a = await t.text();
  const r = `Failed to ${e}. Received status [${t.status}]: ${t.statusText}. Server response: ${a}`;
  throw t.status === 409 ? new wN(r) : new Error(r);
}
var Pw = "[...]", vN = { result: "[Circular]" }, Nh = [], Fu = [];
const SN = new TextEncoder();
function ON() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function jf(t) {
  return SN.encode(t);
}
function gn(t, e, n, a) {
  try {
    const r = JSON.stringify(t, e, n);
    return jf(r);
  } catch (r) {
    if (!r.message?.includes("Converting circular structure to JSON"))
      return console.warn("[WARNING]: LangSmith received unserializable value."), jf("[Unserializable]");
    console.warn("[WARNING]: LangSmith received circular JSON. This will decrease tracer performance."), typeof a > "u" && (a = ON()), Qb(t, "", 0, [], void 0, 0, a);
    let i;
    try {
      Fu.length === 0 ? i = JSON.stringify(t, e, n) : i = JSON.stringify(t, jN(e), n);
    } catch {
      return jf("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; Nh.length !== 0; ) {
        const s = Nh.pop();
        s.length === 4 ? Object.defineProperty(s[0], s[1], s[3]) : s[0][s[1]] = s[2];
      }
    }
    return jf(i);
  }
}
function Tm(t, e, n, a) {
  var r = Object.getOwnPropertyDescriptor(a, n);
  r.get !== void 0 ? r.configurable ? (Object.defineProperty(a, n, { value: t }), Nh.push([a, n, e, r])) : Fu.push([e, n, t]) : (a[n] = t, Nh.push([a, n, e]));
}
function Qb(t, e, n, a, r, i, s) {
  i += 1;
  var o;
  if (typeof t == "object" && t !== null) {
    for (o = 0; o < a.length; o++)
      if (a[o] === t) {
        Tm(vN, t, e, r);
        return;
      }
    if (typeof s.depthLimit < "u" && i > s.depthLimit) {
      Tm(Pw, t, e, r);
      return;
    }
    if (typeof s.edgesLimit < "u" && n + 1 > s.edgesLimit) {
      Tm(Pw, t, e, r);
      return;
    }
    if (a.push(t), Array.isArray(t))
      for (o = 0; o < t.length; o++)
        Qb(t[o], o, o, a, t, i, s);
    else {
      var l = Object.keys(t);
      for (o = 0; o < l.length; o++) {
        var f = l[o];
        Qb(t[f], f, o, a, t, i, s);
      }
    }
    a.pop();
  }
}
function jN(t) {
  return t = typeof t < "u" ? t : function(e, n) {
    return n;
  }, function(e, n) {
    if (Fu.length > 0)
      for (var a = 0; a < Fu.length; a++) {
        var r = Fu[a];
        if (r[1] === e && r[0] === n) {
          n = r[2], Fu.splice(a, 1);
          break;
        }
      }
    return t.call(this, e, n);
  };
}
function Rw(t) {
  const e = SC(), n = qN(), a = t.extra ?? {}, r = a.metadata;
  return t.extra = {
    ...a,
    runtime: {
      ...e,
      ...a?.runtime
    },
    metadata: {
      ...n,
      ...n.revision_id || t.revision_id ? { revision_id: t.revision_id ?? n.revision_id } : {},
      ...r
    }
  }, t;
}
const PN = (t) => {
  const e = t?.toString() ?? so("TRACING_SAMPLING_RATE");
  if (e === void 0)
    return;
  const n = parseFloat(e);
  if (n < 0 || n > 1)
    throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${n}`);
  return n;
}, RN = (t) => {
  const n = t.replace("http://", "").replace("https://", "").split("/")[0].split(":")[0];
  return n === "localhost" || n === "127.0.0.1" || n === "::1";
};
async function CN(t) {
  const e = [];
  for await (const n of t)
    e.push(n);
  return e;
}
function $m(t) {
  if (t !== void 0)
    return t.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
const TN = async (t) => {
  if (t?.status === 429) {
    const e = parseInt(t.headers.get("retry-after") ?? "30", 10) * 1e3;
    if (e > 0)
      return await new Promise((n) => setTimeout(n, e)), !0;
  }
  return !1;
};
function Cw(t) {
  return typeof t == "number" ? Number(t.toFixed(4)) : t;
}
class $N {
  constructor() {
    Object.defineProperty(this, "items", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "sizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  peek() {
    return this.items[0];
  }
  push(e) {
    let n;
    const a = new Promise((i) => {
      n = i;
    }), r = gn(e.item).length;
    return this.items.push({
      action: e.action,
      payload: e.item,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      itemPromiseResolve: n,
      itemPromise: a,
      size: r
    }), this.sizeBytes += r, a;
  }
  pop(e) {
    if (e < 1)
      throw new Error("Number of bytes to pop off may not be less than 1.");
    const n = [];
    let a = 0;
    for (; a + (this.peek()?.size ?? 0) < e && this.items.length > 0; ) {
      const r = this.items.shift();
      r && (n.push(r), a += r.size, this.sizeBytes -= r.size);
    }
    if (n.length === 0 && this.items.length > 0) {
      const r = this.items.shift();
      n.push(r), a += r.size, this.sizeBytes -= r.size;
    }
    return [
      n.map((r) => ({ action: r.action, item: r.payload })),
      () => n.forEach((r) => r.itemPromiseResolve())
    ];
  }
}
const MN = 20971520, AN = 2500;
class Od {
  constructor(e = {}) {
    Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "webUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchIngestCaller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "timeout_ms", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tenantId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "hideInputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "hideOutputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tracingSampleRate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "filteredPostUuids", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "autoBatchTracing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "autoBatchQueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $N()
    }), Object.defineProperty(this, "autoBatchTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "autoBatchAggregationDelayMs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 250
    }), Object.defineProperty(this, "batchSizeBytesLimit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fetchOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "blockOnRootRunFinalization", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: xo("LANGSMITH_TRACING_BACKGROUND") === "false"
    }), Object.defineProperty(this, "traceBatchConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5
    }), Object.defineProperty(this, "_serverInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_getServerInfoPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "manualFlushMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
    const n = Od.getDefaultClientConfig();
    if (this.tracingSampleRate = PN(e.tracingSamplingRate), this.apiUrl = $m(e.apiUrl ?? n.apiUrl) ?? "", this.apiUrl.endsWith("/") && (this.apiUrl = this.apiUrl.slice(0, -1)), this.apiKey = $m(e.apiKey ?? n.apiKey), this.webUrl = $m(e.webUrl ?? n.webUrl), this.webUrl?.endsWith("/") && (this.webUrl = this.webUrl.slice(0, -1)), this.timeout_ms = e.timeout_ms ?? 9e4, this.caller = new vw(e.callerOptions ?? {}), this.traceBatchConcurrency = e.traceBatchConcurrency ?? this.traceBatchConcurrency, this.traceBatchConcurrency < 1)
      throw new Error("Trace batch concurrency must be positive.");
    this.batchIngestCaller = new vw({
      maxRetries: 2,
      maxConcurrency: this.traceBatchConcurrency,
      ...e.callerOptions ?? {},
      onFailedResponseHook: TN
    }), this.hideInputs = e.hideInputs ?? e.anonymizer ?? n.hideInputs, this.hideOutputs = e.hideOutputs ?? e.anonymizer ?? n.hideOutputs, this.autoBatchTracing = e.autoBatchTracing ?? this.autoBatchTracing, this.blockOnRootRunFinalization = e.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization, this.batchSizeBytesLimit = e.batchSizeBytesLimit, this.fetchOptions = e.fetchOptions || {}, this.manualFlushMode = e.manualFlushMode ?? this.manualFlushMode;
  }
  static getDefaultClientConfig() {
    const e = so("API_KEY"), n = so("ENDPOINT") ?? "https://api.smith.langchain.com", a = so("HIDE_INPUTS") === "true", r = so("HIDE_OUTPUTS") === "true";
    return {
      apiUrl: n,
      apiKey: e,
      webUrl: void 0,
      hideInputs: a,
      hideOutputs: r
    };
  }
  getHostUrl() {
    return this.webUrl ? this.webUrl : RN(this.apiUrl) ? (this.webUrl = "http://localhost:3000", this.webUrl) : this.apiUrl.endsWith("/api/v1") ? (this.webUrl = this.apiUrl.replace("/api/v1", ""), this.webUrl) : this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api") ? (this.webUrl = this.apiUrl.replace("/api", ""), this.webUrl) : this.apiUrl.split(".", 1)[0].includes("dev") ? (this.webUrl = "https://dev.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("eu") ? (this.webUrl = "https://eu.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("beta") ? (this.webUrl = "https://beta.smith.langchain.com", this.webUrl) : (this.webUrl = "https://smith.langchain.com", this.webUrl);
  }
  get headers() {
    const e = {
      "User-Agent": `langsmith-js/${wC}`
    };
    return this.apiKey && (e["x-api-key"] = `${this.apiKey}`), e;
  }
  processInputs(e) {
    return this.hideInputs === !1 ? e : this.hideInputs === !0 ? {} : typeof this.hideInputs == "function" ? this.hideInputs(e) : e;
  }
  processOutputs(e) {
    return this.hideOutputs === !1 ? e : this.hideOutputs === !0 ? {} : typeof this.hideOutputs == "function" ? this.hideOutputs(e) : e;
  }
  prepareRunCreateOrUpdateInputs(e) {
    const n = { ...e };
    return n.inputs !== void 0 && (n.inputs = this.processInputs(n.inputs)), n.outputs !== void 0 && (n.outputs = this.processOutputs(n.outputs)), n;
  }
  async _getResponse(e, n) {
    const a = n?.toString() ?? "", r = `${this.apiUrl}${e}?${a}`, i = await this.caller.call(oe(), r, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(i, `Failed to fetch ${e}`), i;
  }
  async _get(e, n) {
    return (await this._getResponse(e, n)).json();
  }
  async *_getPaginated(e, n = new URLSearchParams(), a) {
    let r = Number(n.get("offset")) || 0;
    const i = Number(n.get("limit")) || 100;
    for (; ; ) {
      n.set("offset", String(r)), n.set("limit", String(i));
      const s = `${this.apiUrl}${e}?${n}`, o = await this.caller.call(oe(), s, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await Se(o, `Failed to fetch ${e}`);
      const l = a ? a(await o.json()) : await o.json();
      if (l.length === 0 || (yield l, l.length < i))
        break;
      r += l.length;
    }
  }
  async *_getCursorPaginatedList(e, n = null, a = "POST", r = "runs") {
    const i = n ? { ...n } : {};
    for (; ; ) {
      const o = await (await this.caller.call(oe(), `${this.apiUrl}${e}`, {
        method: a,
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: JSON.stringify(i)
      })).json();
      if (!o || !o[r])
        break;
      yield o[r];
      const l = o.cursors;
      if (!l || !l.next)
        break;
      i.cursor = l.next;
    }
  }
  // Allows mocking for tests
  _shouldSample() {
    return this.tracingSampleRate === void 0 ? !0 : Math.random() < this.tracingSampleRate;
  }
  _filterForSampling(e, n = !1) {
    if (this.tracingSampleRate === void 0)
      return e;
    if (n) {
      const a = [];
      for (const r of e)
        this.filteredPostUuids.has(r.id) ? this.filteredPostUuids.delete(r.id) : a.push(r);
      return a;
    } else {
      const a = [];
      for (const r of e) {
        const i = r.trace_id ?? r.id;
        this.filteredPostUuids.has(i) || (r.id === i ? this._shouldSample() ? a.push(r) : this.filteredPostUuids.add(i) : a.push(r));
      }
      return a;
    }
  }
  async _getBatchSizeLimitBytes() {
    const e = await this._ensureServerInfo();
    return this.batchSizeBytesLimit ?? e.batch_ingest_config?.size_limit_bytes ?? MN;
  }
  async _getMultiPartSupport() {
    return (await this._ensureServerInfo()).instance_flags?.dataset_examples_multipart_enabled ?? !1;
  }
  drainAutoBatchQueue(e) {
    const n = [];
    for (; this.autoBatchQueue.items.length > 0; ) {
      const [a, r] = this.autoBatchQueue.pop(e);
      if (!a.length) {
        r();
        break;
      }
      const i = this._processBatch(a, r).catch(console.error);
      n.push(i);
    }
    return Promise.all(n);
  }
  async _processBatch(e, n) {
    if (!e.length) {
      n();
      return;
    }
    try {
      const a = {
        runCreates: e.filter((i) => i.action === "create").map((i) => i.item),
        runUpdates: e.filter((i) => i.action === "update").map((i) => i.item)
      };
      (await this._ensureServerInfo())?.batch_ingest_config?.use_multipart_endpoint ? await this.multipartIngestRuns(a) : await this.batchIngestRuns(a);
    } finally {
      n();
    }
  }
  async processRunOperation(e) {
    clearTimeout(this.autoBatchTimeout), this.autoBatchTimeout = void 0, e.action === "create" && (e.item = Rw(e.item));
    const n = this.autoBatchQueue.push(e);
    if (this.manualFlushMode)
      return n;
    const a = await this._getBatchSizeLimitBytes();
    return this.autoBatchQueue.sizeBytes > a && this.drainAutoBatchQueue(a), this.autoBatchQueue.items.length > 0 && (this.autoBatchTimeout = setTimeout(() => {
      this.autoBatchTimeout = void 0, this.drainAutoBatchQueue(a);
    }, this.autoBatchAggregationDelayMs)), n;
  }
  async _getServerInfo() {
    const e = await oe()(`${this.apiUrl}/info`, {
      method: "GET",
      headers: { Accept: "application/json" },
      signal: AbortSignal.timeout(AN),
      ...this.fetchOptions
    });
    return await Se(e, "get server info"), e.json();
  }
  async _ensureServerInfo() {
    return this._getServerInfoPromise === void 0 && (this._getServerInfoPromise = (async () => {
      if (this._serverInfo === void 0)
        try {
          this._serverInfo = await this._getServerInfo();
        } catch {
          console.warn("[WARNING]: LangSmith failed to fetch info on supported operations. Falling back to batch operations and default limits.");
        }
      return this._serverInfo ?? {};
    })()), this._getServerInfoPromise.then((e) => (this._serverInfo === void 0 && (this._getServerInfoPromise = void 0), e));
  }
  async _getSettings() {
    return this.settings || (this.settings = this._get("/settings")), await this.settings;
  }
  /**
   * Flushes current queued traces.
   */
  async flush() {
    const e = await this._getBatchSizeLimitBytes();
    await this.drainAutoBatchQueue(e);
  }
  async createRun(e) {
    if (!this._filterForSampling([e]).length)
      return;
    const n = { ...this.headers, "Content-Type": "application/json" }, a = e.project_name;
    delete e.project_name;
    const r = this.prepareRunCreateOrUpdateInputs({
      session_name: a,
      ...e,
      start_time: e.start_time ?? Date.now()
    });
    if (this.autoBatchTracing && r.trace_id !== void 0 && r.dotted_order !== void 0) {
      this.processRunOperation({
        action: "create",
        item: r
      }).catch(console.error);
      return;
    }
    const i = Rw(r), s = await this.caller.call(oe(), `${this.apiUrl}/runs`, {
      method: "POST",
      headers: n,
      body: gn(i),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(s, "create run", !0);
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async batchIngestRuns({ runCreates: e, runUpdates: n }) {
    if (e === void 0 && n === void 0)
      return;
    let a = e?.map((o) => this.prepareRunCreateOrUpdateInputs(o)) ?? [], r = n?.map((o) => this.prepareRunCreateOrUpdateInputs(o)) ?? [];
    if (a.length > 0 && r.length > 0) {
      const o = a.reduce((f, u) => (u.id && (f[u.id] = u), f), {}), l = [];
      for (const f of r)
        f.id !== void 0 && o[f.id] ? o[f.id] = {
          ...o[f.id],
          ...f
        } : l.push(f);
      a = Object.values(o), r = l;
    }
    const i = {
      post: a,
      patch: r
    };
    if (!i.post.length && !i.patch.length)
      return;
    const s = {
      post: [],
      patch: []
    };
    for (const o of ["post", "patch"]) {
      const l = o, f = i[l].reverse();
      let u = f.pop();
      for (; u !== void 0; )
        s[l].push(u), u = f.pop();
    }
    (s.post.length > 0 || s.patch.length > 0) && await this._postBatchIngestRuns(gn(s));
  }
  async _postBatchIngestRuns(e) {
    const n = {
      ...this.headers,
      "Content-Type": "application/json",
      Accept: "application/json"
    }, a = await this.batchIngestCaller.call(oe(), `${this.apiUrl}/runs/batch`, {
      method: "POST",
      headers: n,
      body: e,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(a, "batch create run", !0);
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async multipartIngestRuns({ runCreates: e, runUpdates: n }) {
    if (e === void 0 && n === void 0)
      return;
    const a = {};
    let r = [];
    for (const u of e ?? []) {
      const c = this.prepareRunCreateOrUpdateInputs(u);
      c.id !== void 0 && c.attachments !== void 0 && (a[c.id] = c.attachments), delete c.attachments, r.push(c);
    }
    let i = [];
    for (const u of n ?? [])
      i.push(this.prepareRunCreateOrUpdateInputs(u));
    if (r.find((u) => u.trace_id === void 0 || u.dotted_order === void 0) !== void 0)
      throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run');
    if (i.find((u) => u.trace_id === void 0 || u.dotted_order === void 0) !== void 0)
      throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run');
    if (r.length > 0 && i.length > 0) {
      const u = r.reduce((h, p) => (p.id && (h[p.id] = p), h), {}), c = [];
      for (const h of i)
        h.id !== void 0 && u[h.id] ? u[h.id] = {
          ...u[h.id],
          ...h
        } : c.push(h);
      r = Object.values(u), i = c;
    }
    if (r.length === 0 && i.length === 0)
      return;
    const l = [], f = [];
    for (const [u, c] of [
      ["post", r],
      ["patch", i]
    ])
      for (const h of c) {
        const { inputs: p, outputs: d, events: m, attachments: b, ...g } = h, _ = { inputs: p, outputs: d, events: m }, P = gn(g);
        f.push({
          name: `${u}.${g.id}`,
          payload: new Blob([P], {
            type: `application/json; length=${P.length}`
            // encoding=gzip
          })
        });
        for (const [C, R] of Object.entries(_)) {
          if (R === void 0)
            continue;
          const T = gn(R);
          f.push({
            name: `${u}.${g.id}.${C}`,
            payload: new Blob([T], {
              type: `application/json; length=${T.length}`
            })
          });
        }
        if (g.id !== void 0) {
          const C = a[g.id];
          if (C) {
            delete a[g.id];
            for (const [R, T] of Object.entries(C)) {
              let O, A;
              if (Array.isArray(T) ? [O, A] = T : (O = T.mimeType, A = T.data), R.includes(".")) {
                console.warn(`Skipping attachment '${R}' for run ${g.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                continue;
              }
              f.push({
                name: `attachment.${g.id}.${R}`,
                payload: new Blob([A], {
                  type: `${O}; length=${A.byteLength}`
                })
              });
            }
          }
        }
        l.push(`trace=${g.trace_id},id=${g.id}`);
      }
    await this._sendMultipartRequest(f, l.join("; "));
  }
  async _sendMultipartRequest(e, n) {
    try {
      const a = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2), r = [];
      for (const l of e)
        r.push(new Blob([`--${a}\r
`])), r.push(new Blob([
          `Content-Disposition: form-data; name="${l.name}"\r
`,
          `Content-Type: ${l.payload.type}\r
\r
`
        ])), r.push(l.payload), r.push(new Blob([`\r
`]));
      r.push(new Blob([`--${a}--\r
`]));
      const s = await new Blob(r).arrayBuffer(), o = await this.batchIngestCaller.call(oe(), `${this.apiUrl}/runs/multipart`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": `multipart/form-data; boundary=${a}`
        },
        body: s,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await Se(o, "ingest multipart runs", !0);
    } catch (a) {
      console.warn(`${a.message.trim()}

Context: ${n}`);
    }
  }
  async updateRun(e, n) {
    be(e), n.inputs && (n.inputs = this.processInputs(n.inputs)), n.outputs && (n.outputs = this.processOutputs(n.outputs));
    const a = { ...n, id: e };
    if (!this._filterForSampling([a], !0).length)
      return;
    if (this.autoBatchTracing && a.trace_id !== void 0 && a.dotted_order !== void 0) {
      if (n.end_time !== void 0 && a.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
        await this.processRunOperation({ action: "update", item: a }).catch(console.error);
        return;
      } else
        this.processRunOperation({ action: "update", item: a }).catch(console.error);
      return;
    }
    const r = { ...this.headers, "Content-Type": "application/json" }, i = await this.caller.call(oe(), `${this.apiUrl}/runs/${e}`, {
      method: "PATCH",
      headers: r,
      body: gn(n),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(i, "update run", !0);
  }
  async readRun(e, { loadChildRuns: n } = { loadChildRuns: !1 }) {
    be(e);
    let a = await this._get(`/runs/${e}`);
    return n && a.child_run_ids && (a = await this._loadChildRuns(a)), a;
  }
  async getRunUrl({ runId: e, run: n, projectOpts: a }) {
    if (n !== void 0) {
      let r;
      n.session_id ? r = n.session_id : a?.projectName ? r = (await this.readProject({ projectName: a?.projectName })).id : a?.projectId ? r = a?.projectId : r = (await this.readProject({
        projectName: so("PROJECT") || "default"
      })).id;
      const i = await this._getTenantId();
      return `${this.getHostUrl()}/o/${i}/projects/p/${r}/r/${n.id}?poll=true`;
    } else if (e !== void 0) {
      const r = await this.readRun(e);
      if (!r.app_path)
        throw new Error(`Run ${e} has no app_path`);
      return `${this.getHostUrl()}${r.app_path}`;
    } else
      throw new Error("Must provide either runId or run");
  }
  async _loadChildRuns(e) {
    const n = await CN(this.listRuns({ id: e.child_run_ids })), a = {}, r = {};
    n.sort((i, s) => (i?.dotted_order ?? "").localeCompare(s?.dotted_order ?? ""));
    for (const i of n) {
      if (i.parent_run_id === null || i.parent_run_id === void 0)
        throw new Error(`Child run ${i.id} has no parent`);
      i.parent_run_id in a || (a[i.parent_run_id] = []), a[i.parent_run_id].push(i), r[i.id] = i;
    }
    e.child_runs = a[e.id] || [];
    for (const i in a)
      i !== e.id && (r[i].child_runs = a[i]);
    return e;
  }
  /**
   * List runs from the LangSmith server.
   * @param projectId - The ID of the project to filter by.
   * @param projectName - The name of the project to filter by.
   * @param parentRunId - The ID of the parent run to filter by.
   * @param traceId - The ID of the trace to filter by.
   * @param referenceExampleId - The ID of the reference example to filter by.
   * @param startTime - The start time to filter by.
   * @param isRoot - Indicates whether to only return root runs.
   * @param runType - The run type to filter by.
   * @param error - Indicates whether to filter by error runs.
   * @param id - The ID of the run to filter by.
   * @param query - The query string to filter by.
   * @param filter - The filter string to apply to the run spans.
   * @param traceFilter - The filter string to apply on the root run of the trace.
   * @param treeFilter - The filter string to apply on other runs in the trace.
   * @param limit - The maximum number of runs to retrieve.
   * @returns {AsyncIterable<Run>} - The runs.
   *
   * @example
   * // List all runs in a project
   * const projectRuns = client.listRuns({ projectName: "<your_project>" });
   *
   * @example
   * // List LLM and Chat runs in the last 24 hours
   * const todaysLLMRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
   *   run_type: "llm",
   * });
   *
   * @example
   * // List traces in a project
   * const rootRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   execution_order: 1,
   * });
   *
   * @example
   * // List runs without errors
   * const correctRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   error: false,
   * });
   *
   * @example
   * // List runs by run ID
   * const runIds = [
   *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
   *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
   * ];
   * const selectedRuns = client.listRuns({ run_ids: runIds });
   *
   * @example
   * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
   * const chainRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
   * });
   *
   * @example
   * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
   * const goodExtractorRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'eq(name, "extractor")',
   *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
   * });
   *
   * @example
   * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
   * const complexRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
   * });
   *
   * @example
   * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
   * const taggedRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
   * });
   */
  async *listRuns(e) {
    const { projectId: n, projectName: a, parentRunId: r, traceId: i, referenceExampleId: s, startTime: o, executionOrder: l, isRoot: f, runType: u, error: c, id: h, query: p, filter: d, traceFilter: m, treeFilter: b, limit: g, select: _ } = e;
    let P = [];
    if (n && (P = Array.isArray(n) ? n : [n]), a) {
      const O = Array.isArray(a) ? a : [a], A = await Promise.all(O.map((M) => this.readProject({ projectName: M }).then((I) => I.id)));
      P.push(...A);
    }
    const C = [
      "app_path",
      "child_run_ids",
      "completion_cost",
      "completion_tokens",
      "dotted_order",
      "end_time",
      "error",
      "events",
      "extra",
      "feedback_stats",
      "first_token_time",
      "id",
      "inputs",
      "name",
      "outputs",
      "parent_run_id",
      "parent_run_ids",
      "prompt_cost",
      "prompt_tokens",
      "reference_example_id",
      "run_type",
      "session_id",
      "start_time",
      "status",
      "tags",
      "total_cost",
      "total_tokens",
      "trace_id"
    ], R = {
      session: P.length ? P : null,
      run_type: u,
      reference_example: s,
      query: p,
      filter: d,
      trace_filter: m,
      tree_filter: b,
      execution_order: l,
      parent_run: r,
      start_time: o ? o.toISOString() : null,
      error: c,
      id: h,
      limit: g,
      trace: i,
      select: _ || C,
      is_root: f
    };
    let T = 0;
    for await (const O of this._getCursorPaginatedList("/runs/query", R))
      if (g) {
        if (T >= g)
          break;
        if (O.length + T > g) {
          yield* O.slice(0, g - T);
          break;
        }
        T += O.length, yield* O;
      } else
        yield* O;
  }
  async getRunStats({ id: e, trace: n, parentRun: a, runType: r, projectNames: i, projectIds: s, referenceExampleIds: o, startTime: l, endTime: f, error: u, query: c, filter: h, traceFilter: p, treeFilter: d, isRoot: m, dataSourceType: b }) {
    let g = s || [];
    i && (g = [
      ...s || [],
      ...await Promise.all(i.map((T) => this.readProject({ projectName: T }).then((O) => O.id)))
    ]);
    const P = Object.fromEntries(Object.entries({
      id: e,
      trace: n,
      parent_run: a,
      run_type: r,
      session: g,
      reference_example: o,
      start_time: l,
      end_time: f,
      error: u,
      query: c,
      filter: h,
      trace_filter: p,
      tree_filter: d,
      is_root: m,
      data_source_type: b
    }).filter(([T, O]) => O !== void 0));
    return await (await this.caller.call(oe(), `${this.apiUrl}/runs/stats`, {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify(P),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
  }
  async shareRun(e, { shareId: n } = {}) {
    const a = {
      run_id: e,
      share_token: n || Pt()
    };
    be(e);
    const i = await (await this.caller.call(oe(), `${this.apiUrl}/runs/${e}/share`, {
      method: "PUT",
      headers: this.headers,
      body: JSON.stringify(a),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
    if (i === null || !("share_token" in i))
      throw new Error("Invalid response from server");
    return `${this.getHostUrl()}/public/${i.share_token}/r`;
  }
  async unshareRun(e) {
    be(e);
    const n = await this.caller.call(oe(), `${this.apiUrl}/runs/${e}/share`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(n, "unshare run", !0);
  }
  async readRunSharedLink(e) {
    be(e);
    const a = await (await this.caller.call(oe(), `${this.apiUrl}/runs/${e}/share`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
    if (!(a === null || !("share_token" in a)))
      return `${this.getHostUrl()}/public/${a.share_token}/r`;
  }
  async listSharedRuns(e, { runIds: n } = {}) {
    const a = new URLSearchParams({
      share_token: e
    });
    if (n !== void 0)
      for (const s of n)
        a.append("id", s);
    return be(e), await (await this.caller.call(oe(), `${this.apiUrl}/public/${e}/runs${a}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
  }
  async readDatasetSharedSchema(e, n) {
    if (!e && !n)
      throw new Error("Either datasetId or datasetName must be given");
    e || (e = (await this.readDataset({ datasetName: n })).id), be(e);
    const r = await (await this.caller.call(oe(), `${this.apiUrl}/datasets/${e}/share`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
    return r.url = `${this.getHostUrl()}/public/${r.share_token}/d`, r;
  }
  async shareDataset(e, n) {
    if (!e && !n)
      throw new Error("Either datasetId or datasetName must be given");
    e || (e = (await this.readDataset({ datasetName: n })).id);
    const a = {
      dataset_id: e
    };
    be(e);
    const i = await (await this.caller.call(oe(), `${this.apiUrl}/datasets/${e}/share`, {
      method: "PUT",
      headers: this.headers,
      body: JSON.stringify(a),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
    return i.url = `${this.getHostUrl()}/public/${i.share_token}/d`, i;
  }
  async unshareDataset(e) {
    be(e);
    const n = await this.caller.call(oe(), `${this.apiUrl}/datasets/${e}/share`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(n, "unshare dataset", !0);
  }
  async readSharedDataset(e) {
    return be(e), await (await this.caller.call(oe(), `${this.apiUrl}/public/${e}/datasets`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
  }
  /**
   * Get shared examples.
   *
   * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
   * @param {Object} [options] Additional options for listing the examples.
   * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
   * @returns {Promise<Example[]>} The shared examples.
   */
  async listSharedExamples(e, n) {
    const a = {};
    n?.exampleIds && (a.id = n.exampleIds);
    const r = new URLSearchParams();
    Object.entries(a).forEach(([o, l]) => {
      Array.isArray(l) ? l.forEach((f) => r.append(o, f)) : r.append(o, l);
    });
    const i = await this.caller.call(oe(), `${this.apiUrl}/public/${e}/examples?${r.toString()}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    }), s = await i.json();
    if (!i.ok)
      throw "detail" in s ? new Error(`Failed to list shared examples.
Status: ${i.status}
Message: ${s.detail.join(`
`)}`) : new Error(`Failed to list shared examples: ${i.status} ${i.statusText}`);
    return s.map((o) => ({
      ...o,
      _hostUrl: this.getHostUrl()
    }));
  }
  async createProject({ projectName: e, description: n = null, metadata: a = null, upsert: r = !1, projectExtra: i = null, referenceDatasetId: s = null }) {
    const o = r ? "?upsert=true" : "", l = `${this.apiUrl}/sessions${o}`, f = i || {};
    a && (f.metadata = a);
    const u = {
      name: e,
      extra: f,
      description: n
    };
    s !== null && (u.reference_dataset_id = s);
    const c = await this.caller.call(oe(), l, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(u),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(c, "create project"), await c.json();
  }
  async updateProject(e, { name: n = null, description: a = null, metadata: r = null, projectExtra: i = null, endTime: s = null }) {
    const o = `${this.apiUrl}/sessions/${e}`;
    let l = i;
    r && (l = { ...l || {}, metadata: r });
    const f = {
      name: n,
      extra: l,
      description: a,
      end_time: s ? new Date(s).toISOString() : null
    }, u = await this.caller.call(oe(), o, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(f),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(u, "update project"), await u.json();
  }
  async hasProject({ projectId: e, projectName: n }) {
    let a = "/sessions";
    const r = new URLSearchParams();
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    if (e !== void 0)
      be(e), a += `/${e}`;
    else if (n !== void 0)
      r.append("name", n);
    else
      throw new Error("Must provide projectName or projectId");
    const i = await this.caller.call(oe(), `${this.apiUrl}${a}?${r}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    try {
      const s = await i.json();
      return i.ok ? Array.isArray(s) ? s.length > 0 : !0 : !1;
    } catch {
      return !1;
    }
  }
  async readProject({ projectId: e, projectName: n, includeStats: a }) {
    let r = "/sessions";
    const i = new URLSearchParams();
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    if (e !== void 0)
      be(e), r += `/${e}`;
    else if (n !== void 0)
      i.append("name", n);
    else
      throw new Error("Must provide projectName or projectId");
    a !== void 0 && i.append("include_stats", a.toString());
    const s = await this._get(r, i);
    let o;
    if (Array.isArray(s)) {
      if (s.length === 0)
        throw new Error(`Project[id=${e}, name=${n}] not found`);
      o = s[0];
    } else
      o = s;
    return o;
  }
  async getProjectUrl({ projectId: e, projectName: n }) {
    if (e === void 0 && n === void 0)
      throw new Error("Must provide either projectName or projectId");
    const a = await this.readProject({ projectId: e, projectName: n }), r = await this._getTenantId();
    return `${this.getHostUrl()}/o/${r}/projects/p/${a.id}`;
  }
  async getDatasetUrl({ datasetId: e, datasetName: n }) {
    if (e === void 0 && n === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    const a = await this.readDataset({ datasetId: e, datasetName: n }), r = await this._getTenantId();
    return `${this.getHostUrl()}/o/${r}/datasets/${a.id}`;
  }
  async _getTenantId() {
    if (this._tenantId !== null)
      return this._tenantId;
    const e = new URLSearchParams({ limit: "1" });
    for await (const n of this._getPaginated("/sessions", e))
      return this._tenantId = n[0].tenant_id, n[0].tenant_id;
    throw new Error("No projects found to resolve tenant.");
  }
  async *listProjects({ projectIds: e, name: n, nameContains: a, referenceDatasetId: r, referenceDatasetName: i, referenceFree: s, metadata: o } = {}) {
    const l = new URLSearchParams();
    if (e !== void 0)
      for (const f of e)
        l.append("id", f);
    if (n !== void 0 && l.append("name", n), a !== void 0 && l.append("name_contains", a), r !== void 0)
      l.append("reference_dataset", r);
    else if (i !== void 0) {
      const f = await this.readDataset({
        datasetName: i
      });
      l.append("reference_dataset", f.id);
    }
    s !== void 0 && l.append("reference_free", s.toString()), o !== void 0 && l.append("metadata", JSON.stringify(o));
    for await (const f of this._getPaginated("/sessions", l))
      yield* f;
  }
  async deleteProject({ projectId: e, projectName: n }) {
    let a;
    if (e === void 0 && n === void 0)
      throw new Error("Must provide projectName or projectId");
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    e === void 0 ? a = (await this.readProject({ projectName: n })).id : a = e, be(a);
    const r = await this.caller.call(oe(), `${this.apiUrl}/sessions/${a}`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(r, `delete session ${a} (${n})`, !0);
  }
  async uploadCsv({ csvFile: e, fileName: n, inputKeys: a, outputKeys: r, description: i, dataType: s, name: o }) {
    const l = `${this.apiUrl}/datasets/upload`, f = new FormData();
    f.append("file", e, n), a.forEach((h) => {
      f.append("input_keys", h);
    }), r.forEach((h) => {
      f.append("output_keys", h);
    }), i && f.append("description", i), s && f.append("data_type", s), o && f.append("name", o);
    const u = await this.caller.call(oe(), l, {
      method: "POST",
      headers: this.headers,
      body: f,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(u, "upload CSV"), await u.json();
  }
  async createDataset(e, { description: n, dataType: a, inputsSchema: r, outputsSchema: i, metadata: s } = {}) {
    const o = {
      name: e,
      description: n,
      extra: s ? { metadata: s } : void 0
    };
    a && (o.data_type = a), r && (o.inputs_schema_definition = r), i && (o.outputs_schema_definition = i);
    const l = await this.caller.call(oe(), `${this.apiUrl}/datasets`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(o),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(l, "create dataset"), await l.json();
  }
  async readDataset({ datasetId: e, datasetName: n }) {
    let a = "/datasets";
    const r = new URLSearchParams({ limit: "1" });
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (e !== void 0)
      be(e), a += `/${e}`;
    else if (n !== void 0)
      r.append("name", n);
    else
      throw new Error("Must provide datasetName or datasetId");
    const i = await this._get(a, r);
    let s;
    if (Array.isArray(i)) {
      if (i.length === 0)
        throw new Error(`Dataset[id=${e}, name=${n}] not found`);
      s = i[0];
    } else
      s = i;
    return s;
  }
  async hasDataset({ datasetId: e, datasetName: n }) {
    try {
      return await this.readDataset({ datasetId: e, datasetName: n }), !0;
    } catch (a) {
      if (
        // eslint-disable-next-line no-instanceof/no-instanceof
        a instanceof Error && a.message.toLocaleLowerCase().includes("not found")
      )
        return !1;
      throw a;
    }
  }
  async diffDatasetVersions({ datasetId: e, datasetName: n, fromVersion: a, toVersion: r }) {
    let i = e;
    if (i === void 0 && n === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (i !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    i === void 0 && (i = (await this.readDataset({ datasetName: n })).id);
    const s = new URLSearchParams({
      from_version: typeof a == "string" ? a : a.toISOString(),
      to_version: typeof r == "string" ? r : r.toISOString()
    });
    return await this._get(`/datasets/${i}/versions/diff`, s);
  }
  async readDatasetOpenaiFinetuning({ datasetId: e, datasetName: n }) {
    const a = "/datasets";
    if (e === void 0) if (n !== void 0)
      e = (await this.readDataset({ datasetName: n })).id;
    else
      throw new Error("Must provide either datasetName or datasetId");
    return (await (await this._getResponse(`${a}/${e}/openai_ft`)).text()).trim().split(`
`).map((o) => JSON.parse(o));
  }
  async *listDatasets({ limit: e = 100, offset: n = 0, datasetIds: a, datasetName: r, datasetNameContains: i, metadata: s } = {}) {
    const o = "/datasets", l = new URLSearchParams({
      limit: e.toString(),
      offset: n.toString()
    });
    if (a !== void 0)
      for (const f of a)
        l.append("id", f);
    r !== void 0 && l.append("name", r), i !== void 0 && l.append("name_contains", i), s !== void 0 && l.append("metadata", JSON.stringify(s));
    for await (const f of this._getPaginated(o, l))
      yield* f;
  }
  /**
   * Update a dataset
   * @param props The dataset details to update
   * @returns The updated dataset
   */
  async updateDataset(e) {
    const { datasetId: n, datasetName: a, ...r } = e;
    if (!n && !a)
      throw new Error("Must provide either datasetName or datasetId");
    const i = n ?? (await this.readDataset({ datasetName: a })).id;
    be(i);
    const s = await this.caller.call(oe(), `${this.apiUrl}/datasets/${i}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(r),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(s, "update dataset"), await s.json();
  }
  /**
   * Updates a tag on a dataset.
   *
   * If the tag is already assigned to a different version of this dataset,
   * the tag will be moved to the new version. The as_of parameter is used to
   * determine which version of the dataset to apply the new tags to.
   *
   * It must be an exact version of the dataset to succeed. You can
   * use the "readDatasetVersion" method to find the exact version
   * to apply the tags to.
   * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
   * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
   * @param params.asOf The timestamp of the dataset to apply the new tags to.
   * @param params.tag The new tag to apply to the dataset.
   */
  async updateDatasetTag(e) {
    const { datasetId: n, datasetName: a, asOf: r, tag: i } = e;
    if (!n && !a)
      throw new Error("Must provide either datasetName or datasetId");
    const s = n ?? (await this.readDataset({ datasetName: a })).id;
    be(s);
    const o = await this.caller.call(oe(), `${this.apiUrl}/datasets/${s}/tags`, {
      method: "PUT",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify({
        as_of: typeof r == "string" ? r : r.toISOString(),
        tag: i
      }),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(o, "update dataset tags");
  }
  async deleteDataset({ datasetId: e, datasetName: n }) {
    let a = "/datasets", r = e;
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (n !== void 0 && (r = (await this.readDataset({ datasetName: n })).id), r !== void 0)
      be(r), a += `/${r}`;
    else
      throw new Error("Must provide datasetName or datasetId");
    const i = await this.caller.call(oe(), this.apiUrl + a, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(i, `delete ${a}`), await i.json();
  }
  async indexDataset({ datasetId: e, datasetName: n, tag: a }) {
    let r = e;
    if (!r && !n)
      throw new Error("Must provide either datasetName or datasetId");
    if (r && n)
      throw new Error("Must provide either datasetName or datasetId, not both");
    r || (r = (await this.readDataset({ datasetName: n })).id), be(r);
    const i = {
      tag: a
    }, s = await this.caller.call(oe(), `${this.apiUrl}/datasets/${r}/index`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(i),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(s, "index dataset"), await s.json();
  }
  /**
   * Lets you run a similarity search query on a dataset.
   *
   * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
   *
   * @param inputs      The input on which to run the similarity search. Must have the
   *                    same schema as the dataset.
   *
   * @param datasetId   The dataset to search for similar examples.
   *
   * @param limit       The maximum number of examples to return. Will return the top `limit` most
   *                    similar examples in order of most similar to least similar. If no similar
   *                    examples are found, random examples will be returned.
   *
   * @param filter      A filter string to apply to the search. Only examples will be returned that
   *                    match the filter string. Some examples of filters
   *
   *                    - eq(metadata.mykey, "value")
   *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
   *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
   *
   * @returns           A list of similar examples.
   *
   *
   * @example
   * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
   * inputs = {"text": "How many people live in Berlin?"}
   * limit = 5
   * examples = await client.similarExamples(inputs, dataset_id, limit)
   */
  async similarExamples(e, n, a, { filter: r } = {}) {
    const i = {
      limit: a,
      inputs: e
    };
    r !== void 0 && (i.filter = r), be(n);
    const s = await this.caller.call(oe(), `${this.apiUrl}/datasets/${n}/search`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(i),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(s, "fetch similar examples"), (await s.json()).examples;
  }
  async createExample(e, n, a) {
    if (Tw(e) && (n !== void 0 || a !== void 0))
      throw new Error("Cannot provide outputs or options when using ExampleCreate object");
    let r = n ? a?.datasetId : e.dataset_id;
    const i = n ? a?.datasetName : e.dataset_name;
    if (r === void 0 && i === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (r !== void 0 && i !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    r === void 0 && (r = (await this.readDataset({ datasetName: i })).id);
    const s = (n ? a?.createdAt : e.created_at) || /* @__PURE__ */ new Date();
    let o;
    Tw(e) ? o = e : o = {
      inputs: e,
      outputs: n,
      created_at: s?.toISOString(),
      id: a?.exampleId,
      metadata: a?.metadata,
      split: a?.split,
      source_run_id: a?.sourceRunId,
      use_source_run_io: a?.useSourceRunIO,
      use_source_run_attachments: a?.useSourceRunAttachments,
      attachments: a?.attachments
    };
    const l = await this._uploadExamplesMultipart(r, [o]);
    return await this.readExample(l.example_ids?.[0] ?? Pt());
  }
  async createExamples(e) {
    if (Array.isArray(e)) {
      if (e.length === 0)
        return [];
      const _ = e;
      let P = _[0].dataset_id;
      const C = _[0].dataset_name;
      if (P === void 0 && C === void 0)
        throw new Error("Must provide either datasetName or datasetId");
      if (P !== void 0 && C !== void 0)
        throw new Error("Must provide either datasetName or datasetId, not both");
      P === void 0 && (P = (await this.readDataset({ datasetName: C })).id);
      const R = await this._uploadExamplesMultipart(P, _);
      return await Promise.all(R.example_ids.map((O) => this.readExample(O)));
    }
    const { inputs: n, outputs: a, metadata: r, splits: i, sourceRunIds: s, useSourceRunIOs: o, useSourceRunAttachments: l, attachments: f, exampleIds: u, datasetId: c, datasetName: h } = e;
    if (n === void 0)
      throw new Error("Must provide inputs when using legacy parameters");
    let p = c;
    const d = h;
    if (p === void 0 && d === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (p !== void 0 && d !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    p === void 0 && (p = (await this.readDataset({ datasetName: d })).id);
    const m = n.map((_, P) => ({
      dataset_id: p,
      inputs: _,
      outputs: a?.[P],
      metadata: r?.[P],
      split: i?.[P],
      id: u?.[P],
      attachments: f?.[P],
      source_run_id: s?.[P],
      use_source_run_io: o?.[P],
      use_source_run_attachments: l?.[P]
    })), b = await this._uploadExamplesMultipart(p, m);
    return await Promise.all(b.example_ids.map((_) => this.readExample(_)));
  }
  async createLLMExample(e, n, a) {
    return this.createExample({ input: e }, { output: n }, a);
  }
  async createChatExample(e, n, a) {
    const r = e.map((s) => Sw(s) ? Ow(s) : s), i = Sw(n) ? Ow(n) : n;
    return this.createExample({ input: r }, { output: i }, a);
  }
  async readExample(e) {
    be(e);
    const n = `/examples/${e}`, a = await this._get(n), { attachment_urls: r, ...i } = a, s = i;
    return r && (s.attachments = Object.entries(r).reduce((o, [l, f]) => (o[l.slice(11)] = {
      presigned_url: f.presigned_url,
      mime_type: f.mime_type
    }, o), {})), s;
  }
  async *listExamples({ datasetId: e, datasetName: n, exampleIds: a, asOf: r, splits: i, inlineS3Urls: s, metadata: o, limit: l, offset: f, filter: u, includeAttachments: c } = {}) {
    let h;
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (e !== void 0)
      h = e;
    else if (n !== void 0)
      h = (await this.readDataset({ datasetName: n })).id;
    else
      throw new Error("Must provide a datasetName or datasetId");
    const p = new URLSearchParams({ dataset: h }), d = r ? typeof r == "string" ? r : r?.toISOString() : void 0;
    d && p.append("as_of", d);
    const m = s ?? !0;
    if (p.append("inline_s3_urls", m.toString()), a !== void 0)
      for (const g of a)
        p.append("id", g);
    if (i !== void 0)
      for (const g of i)
        p.append("splits", g);
    if (o !== void 0) {
      const g = JSON.stringify(o);
      p.append("metadata", g);
    }
    l !== void 0 && p.append("limit", l.toString()), f !== void 0 && p.append("offset", f.toString()), u !== void 0 && p.append("filter", u), c === !0 && ["attachment_urls", "outputs", "metadata"].forEach((g) => p.append("select", g));
    let b = 0;
    for await (const g of this._getPaginated("/examples", p)) {
      for (const _ of g) {
        const { attachment_urls: P, ...C } = _, R = C;
        P && (R.attachments = Object.entries(P).reduce((T, [O, A]) => (T[O.slice(11)] = {
          presigned_url: A.presigned_url,
          mime_type: A.mime_type || void 0
        }, T), {})), yield R, b++;
      }
      if (l !== void 0 && b >= l)
        break;
    }
  }
  async deleteExample(e) {
    be(e);
    const n = `/examples/${e}`, a = await this.caller.call(oe(), this.apiUrl + n, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(a, `delete ${n}`), await a.json();
  }
  async updateExample(e, n) {
    let a;
    n ? a = e : a = e.id, be(a);
    let r;
    n ? r = { id: a, ...n } : r = e;
    let i;
    return r.dataset_id !== void 0 ? i = r.dataset_id : i = (await this.readExample(a)).dataset_id, this._updateExamplesMultipart(i, [r]);
  }
  async updateExamples(e) {
    let n;
    return e[0].dataset_id === void 0 ? n = (await this.readExample(e[0].id)).dataset_id : n = e[0].dataset_id, this._updateExamplesMultipart(n, e);
  }
  /**
   * Get dataset version by closest date or exact tag.
   *
   * Use this to resolve the nearest version to a given timestamp or for a given tag.
   *
   * @param options The options for getting the dataset version
   * @param options.datasetId The ID of the dataset
   * @param options.datasetName The name of the dataset
   * @param options.asOf The timestamp of the dataset to retrieve
   * @param options.tag The tag of the dataset to retrieve
   * @returns The dataset version
   */
  async readDatasetVersion({ datasetId: e, datasetName: n, asOf: a, tag: r }) {
    let i;
    if (e ? i = e : i = (await this.readDataset({ datasetName: n })).id, be(i), a && r || !a && !r)
      throw new Error("Exactly one of asOf and tag must be specified.");
    const s = new URLSearchParams();
    a !== void 0 && s.append("as_of", typeof a == "string" ? a : a.toISOString()), r !== void 0 && s.append("tag", r);
    const o = await this.caller.call(oe(), `${this.apiUrl}/datasets/${i}/version?${s.toString()}`, {
      method: "GET",
      headers: { ...this.headers },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(o, "read dataset version"), await o.json();
  }
  async listDatasetSplits({ datasetId: e, datasetName: n, asOf: a }) {
    let r;
    if (e === void 0 && n === void 0)
      throw new Error("Must provide dataset name or ID");
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    e === void 0 ? r = (await this.readDataset({ datasetName: n })).id : r = e, be(r);
    const i = new URLSearchParams(), s = a ? typeof a == "string" ? a : a?.toISOString() : void 0;
    return s && i.append("as_of", s), await this._get(`/datasets/${r}/splits`, i);
  }
  async updateDatasetSplits({ datasetId: e, datasetName: n, splitName: a, exampleIds: r, remove: i = !1 }) {
    let s;
    if (e === void 0 && n === void 0)
      throw new Error("Must provide dataset name or ID");
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    e === void 0 ? s = (await this.readDataset({ datasetName: n })).id : s = e, be(s);
    const o = {
      split_name: a,
      examples: r.map((f) => (be(f), f)),
      remove: i
    }, l = await this.caller.call(oe(), `${this.apiUrl}/datasets/${s}/splits`, {
      method: "PUT",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(o),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(l, "update dataset splits", !0);
  }
  /**
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.
   */
  async evaluateRun(e, n, { sourceInfo: a, loadChildRuns: r, referenceExample: i } = { loadChildRuns: !1 }) {
    yC("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
    let s;
    if (typeof e == "string")
      s = await this.readRun(e, { loadChildRuns: r });
    else if (typeof e == "object" && "id" in e)
      s = e;
    else
      throw new Error(`Invalid run type: ${typeof e}`);
    s.reference_example_id !== null && s.reference_example_id !== void 0 && (i = await this.readExample(s.reference_example_id));
    const o = await n.evaluateRun(s, i), [l, f] = await this._logEvaluationFeedback(o, s, a);
    return f[0];
  }
  async createFeedback(e, n, { score: a, value: r, correction: i, comment: s, sourceInfo: o, feedbackSourceType: l = "api", sourceRunId: f, feedbackId: u, feedbackConfig: c, projectId: h, comparativeExperimentId: p }) {
    if (!e && !h)
      throw new Error("One of runId or projectId must be provided");
    if (e && h)
      throw new Error("Only one of runId or projectId can be provided");
    const d = {
      type: l ?? "api",
      metadata: o ?? {}
    };
    f !== void 0 && d?.metadata !== void 0 && !d.metadata.__run && (d.metadata.__run = { run_id: f }), d?.metadata !== void 0 && d.metadata.__run?.run_id !== void 0 && be(d.metadata.__run.run_id);
    const m = {
      id: u ?? Pt(),
      run_id: e,
      key: n,
      score: Cw(a),
      value: r,
      correction: i,
      comment: s,
      feedback_source: d,
      comparative_experiment_id: p,
      feedbackConfig: c,
      session_id: h
    }, b = `${this.apiUrl}/feedback`, g = await this.caller.call(oe(), b, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(m),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(g, "create feedback", !0), m;
  }
  async updateFeedback(e, { score: n, value: a, correction: r, comment: i }) {
    const s = {};
    n != null && (s.score = Cw(n)), a != null && (s.value = a), r != null && (s.correction = r), i != null && (s.comment = i), be(e);
    const o = await this.caller.call(oe(), `${this.apiUrl}/feedback/${e}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(s),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(o, "update feedback", !0);
  }
  async readFeedback(e) {
    be(e);
    const n = `/feedback/${e}`;
    return await this._get(n);
  }
  async deleteFeedback(e) {
    be(e);
    const n = `/feedback/${e}`, a = await this.caller.call(oe(), this.apiUrl + n, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(a, `delete ${n}`), await a.json();
  }
  async *listFeedback({ runIds: e, feedbackKeys: n, feedbackSourceTypes: a } = {}) {
    const r = new URLSearchParams();
    if (e && r.append("run", e.join(",")), n)
      for (const i of n)
        r.append("key", i);
    if (a)
      for (const i of a)
        r.append("source", i);
    for await (const i of this._getPaginated("/feedback", r))
      yield* i;
  }
  /**
   * Creates a presigned feedback token and URL.
   *
   * The token can be used to authorize feedback metrics without
   * needing an API key. This is useful for giving browser-based
   * applications the ability to submit feedback without needing
   * to expose an API key.
   *
   * @param runId The ID of the run.
   * @param feedbackKey The feedback key.
   * @param options Additional options for the token.
   * @param options.expiration The expiration time for the token.
   *
   * @returns A promise that resolves to a FeedbackIngestToken.
   */
  async createPresignedFeedbackToken(e, n, { expiration: a, feedbackConfig: r } = {}) {
    const i = {
      run_id: e,
      feedback_key: n,
      feedback_config: r
    };
    return a ? typeof a == "string" ? i.expires_at = a : (a?.hours || a?.minutes || a?.days) && (i.expires_in = a) : i.expires_in = {
      hours: 3
    }, await (await this.caller.call(oe(), `${this.apiUrl}/feedback/tokens`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(i),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
  }
  async createComparativeExperiment({ name: e, experimentIds: n, referenceDatasetId: a, createdAt: r, description: i, metadata: s, id: o }) {
    if (n.length === 0)
      throw new Error("At least one experiment is required");
    if (a || (a = (await this.readProject({
      projectId: n[0]
    })).reference_dataset_id), !a == null)
      throw new Error("A reference dataset is required");
    const l = {
      id: o,
      name: e,
      experiment_ids: n,
      reference_dataset_id: a,
      description: i,
      created_at: (r ?? /* @__PURE__ */ new Date())?.toISOString(),
      extra: {}
    };
    return s && (l.extra.metadata = s), await (await this.caller.call(oe(), `${this.apiUrl}/datasets/comparative`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(l),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
  }
  /**
   * Retrieves a list of presigned feedback tokens for a given run ID.
   * @param runId The ID of the run.
   * @returns An async iterable of FeedbackIngestToken objects.
   */
  async *listPresignedFeedbackTokens(e) {
    be(e);
    const n = new URLSearchParams({ run_id: e });
    for await (const a of this._getPaginated("/feedback/tokens", n))
      yield* a;
  }
  _selectEvalResults(e) {
    let n;
    return "results" in e ? n = e.results : Array.isArray(e) ? n = e : n = [e], n;
  }
  async _logEvaluationFeedback(e, n, a) {
    const r = this._selectEvalResults(e), i = [];
    for (const s of r) {
      let o = a || {};
      s.evaluatorInfo && (o = { ...s.evaluatorInfo, ...o });
      let l = null;
      s.targetRunId ? l = s.targetRunId : n && (l = n.id), i.push(await this.createFeedback(l, s.key, {
        score: s.score,
        value: s.value,
        comment: s.comment,
        correction: s.correction,
        sourceInfo: o,
        sourceRunId: s.sourceRunId,
        feedbackConfig: s.feedbackConfig,
        feedbackSourceType: "model"
      }));
    }
    return [r, i];
  }
  async logEvaluationFeedback(e, n, a) {
    const [r] = await this._logEvaluationFeedback(e, n, a);
    return r;
  }
  /**
   * API for managing annotation queues
   */
  /**
   * List the annotation queues on the LangSmith API.
   * @param options - The options for listing annotation queues
   * @param options.queueIds - The IDs of the queues to filter by
   * @param options.name - The name of the queue to filter by
   * @param options.nameContains - The substring that the queue name should contain
   * @param options.limit - The maximum number of queues to return
   * @returns An iterator of AnnotationQueue objects
   */
  async *listAnnotationQueues(e = {}) {
    const { queueIds: n, name: a, nameContains: r, limit: i } = e, s = new URLSearchParams();
    n && n.forEach((l, f) => {
      be(l, `queueIds[${f}]`), s.append("ids", l);
    }), a && s.append("name", a), r && s.append("name_contains", r), s.append("limit", (i !== void 0 ? Math.min(i, 100) : 100).toString());
    let o = 0;
    for await (const l of this._getPaginated("/annotation-queues", s))
      if (yield* l, o++, i !== void 0 && o >= i)
        break;
  }
  /**
   * Create an annotation queue on the LangSmith API.
   * @param options - The options for creating an annotation queue
   * @param options.name - The name of the annotation queue
   * @param options.description - The description of the annotation queue
   * @param options.queueId - The ID of the annotation queue
   * @returns The created AnnotationQueue object
   */
  async createAnnotationQueue(e) {
    const { name: n, description: a, queueId: r } = e, i = {
      name: n,
      description: a,
      id: r || Pt()
    }, s = await this.caller.call(oe(), `${this.apiUrl}/annotation-queues`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(Object.fromEntries(Object.entries(i).filter(([l, f]) => f !== void 0))),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(s, "create annotation queue"), await s.json();
  }
  /**
   * Read an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to read
   * @returns The AnnotationQueue object
   */
  async readAnnotationQueue(e) {
    const n = await this.listAnnotationQueues({
      queueIds: [e]
    }).next();
    if (n.done)
      throw new Error(`Annotation queue with ID ${e} not found`);
    return n.value;
  }
  /**
   * Update an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to update
   * @param options - The options for updating the annotation queue
   * @param options.name - The new name for the annotation queue
   * @param options.description - The new description for the annotation queue
   */
  async updateAnnotationQueue(e, n) {
    const { name: a, description: r } = n, i = await this.caller.call(oe(), `${this.apiUrl}/annotation-queues/${be(e, "queueId")}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify({ name: a, description: r }),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(i, "update annotation queue");
  }
  /**
   * Delete an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to delete
   */
  async deleteAnnotationQueue(e) {
    const n = await this.caller.call(oe(), `${this.apiUrl}/annotation-queues/${be(e, "queueId")}`, {
      method: "DELETE",
      headers: { ...this.headers, Accept: "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(n, "delete annotation queue");
  }
  /**
   * Add runs to an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue
   * @param runIds - The IDs of the runs to be added to the annotation queue
   */
  async addRunsToAnnotationQueue(e, n) {
    const a = await this.caller.call(oe(), `${this.apiUrl}/annotation-queues/${be(e, "queueId")}/runs`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(n.map((r, i) => be(r, `runIds[${i}]`).toString())),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(a, "add runs to annotation queue");
  }
  /**
   * Get a run from an annotation queue at the specified index.
   * @param queueId - The ID of the annotation queue
   * @param index - The index of the run to retrieve
   * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
   * @throws {Error} If the run is not found at the given index or for other API-related errors
   */
  async getRunFromAnnotationQueue(e, n) {
    const a = `/annotation-queues/${be(e, "queueId")}/run`, r = await this.caller.call(oe(), `${this.apiUrl}${a}/${n}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(r, "get run from annotation queue"), await r.json();
  }
  /**
   * Delete a run from an an annotation queue.
   * @param queueId - The ID of the annotation queue to delete the run from
   * @param queueRunId - The ID of the run to delete from the annotation queue
   */
  async deleteRunFromAnnotationQueue(e, n) {
    const a = await this.caller.call(oe(), `${this.apiUrl}/annotation-queues/${be(e, "queueId")}/runs/${be(n, "queueRunId")}`, {
      method: "DELETE",
      headers: { ...this.headers, Accept: "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(a, "delete run from annotation queue");
  }
  /**
   * Get the size of an annotation queue.
   * @param queueId - The ID of the annotation queue
   */
  async getSizeFromAnnotationQueue(e) {
    const n = await this.caller.call(oe(), `${this.apiUrl}/annotation-queues/${be(e, "queueId")}/size`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(n, "get size from annotation queue"), await n.json();
  }
  async _currentTenantIsOwner(e) {
    const n = await this._getSettings();
    return e == "-" || n.tenant_handle === e;
  }
  async _ownerConflictError(e, n) {
    const a = await this._getSettings();
    return new Error(`Cannot ${e} for another tenant.

      Current tenant: ${a.tenant_handle}

      Requested tenant: ${n}`);
  }
  async _getLatestCommitHash(e) {
    const n = await this.caller.call(oe(), `${this.apiUrl}/commits/${e}/?limit=1&offset=0`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    }), a = await n.json();
    if (!n.ok) {
      const r = typeof a.detail == "string" ? a.detail : JSON.stringify(a.detail), i = new Error(`Error ${n.status}: ${n.statusText}
${r}`);
      throw i.statusCode = n.status, i;
    }
    if (a.commits.length !== 0)
      return a.commits[0].commit_hash;
  }
  async _likeOrUnlikePrompt(e, n) {
    const [a, r, i] = Qs(e), s = await this.caller.call(oe(), `${this.apiUrl}/likes/${a}/${r}`, {
      method: "POST",
      body: JSON.stringify({ like: n }),
      headers: { ...this.headers, "Content-Type": "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(s, `${n ? "like" : "unlike"} prompt`), await s.json();
  }
  async _getPromptUrl(e) {
    const [n, a, r] = Qs(e);
    if (await this._currentTenantIsOwner(n)) {
      const i = await this._getSettings();
      return r !== "latest" ? `${this.getHostUrl()}/prompts/${a}/${r.substring(0, 8)}?organizationId=${i.id}` : `${this.getHostUrl()}/prompts/${a}?organizationId=${i.id}`;
    } else
      return r !== "latest" ? `${this.getHostUrl()}/hub/${n}/${a}/${r.substring(0, 8)}` : `${this.getHostUrl()}/hub/${n}/${a}`;
  }
  async promptExists(e) {
    return !!await this.getPrompt(e);
  }
  async likePrompt(e) {
    return this._likeOrUnlikePrompt(e, !0);
  }
  async unlikePrompt(e) {
    return this._likeOrUnlikePrompt(e, !1);
  }
  async *listCommits(e) {
    for await (const n of this._getPaginated(`/commits/${e}/`, new URLSearchParams(), (a) => a.commits))
      yield* n;
  }
  async *listPrompts(e) {
    const n = new URLSearchParams();
    n.append("sort_field", e?.sortField ?? "updated_at"), n.append("sort_direction", "desc"), n.append("is_archived", (!!e?.isArchived).toString()), e?.isPublic !== void 0 && n.append("is_public", e.isPublic.toString()), e?.query && n.append("query", e.query);
    for await (const a of this._getPaginated("/repos", n, (r) => r.repos))
      yield* a;
  }
  async getPrompt(e) {
    const [n, a, r] = Qs(e), i = await this.caller.call(oe(), `${this.apiUrl}/repos/${n}/${a}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    if (i.status === 404)
      return null;
    await Se(i, "get prompt");
    const s = await i.json();
    return s.repo ? s.repo : null;
  }
  async createPrompt(e, n) {
    const a = await this._getSettings();
    if (n?.isPublic && !a.tenant_handle)
      throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle. 
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
    const [r, i, s] = Qs(e);
    if (!await this._currentTenantIsOwner(r))
      throw await this._ownerConflictError("create a prompt", r);
    const o = {
      repo_handle: i,
      ...n?.description && { description: n.description },
      ...n?.readme && { readme: n.readme },
      ...n?.tags && { tags: n.tags },
      is_public: !!n?.isPublic
    }, l = await this.caller.call(oe(), `${this.apiUrl}/repos/`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(o),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(l, "create prompt");
    const { repo: f } = await l.json();
    return f;
  }
  async createCommit(e, n, a) {
    if (!await this.promptExists(e))
      throw new Error("Prompt does not exist, you must create it first.");
    const [r, i, s] = Qs(e), o = a?.parentCommitHash === "latest" || !a?.parentCommitHash ? await this._getLatestCommitHash(`${r}/${i}`) : a?.parentCommitHash, l = {
      manifest: JSON.parse(JSON.stringify(n)),
      parent_commit: o
    }, f = await this.caller.call(oe(), `${this.apiUrl}/commits/${r}/${i}`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(l),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(f, "create commit");
    const u = await f.json();
    return this._getPromptUrl(`${r}/${i}${u.commit_hash ? `:${u.commit_hash}` : ""}`);
  }
  /**
   * Update examples with attachments using multipart form data.
   * @param updates List of ExampleUpdateWithAttachments objects to upsert
   * @returns Promise with the update response
   */
  async updateExamplesMultipart(e, n = []) {
    return this._updateExamplesMultipart(e, n);
  }
  async _updateExamplesMultipart(e, n = []) {
    if (!await this._getMultiPartSupport())
      throw new Error("Your LangSmith version does not allow using the multipart examples endpoint, please update to the latest version.");
    const a = new FormData();
    for (const o of n) {
      const l = o.id, f = {
        ...o.metadata && { metadata: o.metadata },
        ...o.split && { split: o.split }
      }, u = gn(f), c = new Blob([u], {
        type: "application/json"
      });
      if (a.append(l, c), o.inputs) {
        const h = gn(o.inputs), p = new Blob([h], {
          type: "application/json"
        });
        a.append(`${l}.inputs`, p);
      }
      if (o.outputs) {
        const h = gn(o.outputs), p = new Blob([h], {
          type: "application/json"
        });
        a.append(`${l}.outputs`, p);
      }
      if (o.attachments)
        for (const [h, p] of Object.entries(o.attachments)) {
          let d, m;
          Array.isArray(p) ? [d, m] = p : (d = p.mimeType, m = p.data);
          const b = new Blob([m], {
            type: `${d}; length=${m.byteLength}`
          });
          a.append(`${l}.attachment.${h}`, b);
        }
      if (o.attachments_operations) {
        const h = gn(o.attachments_operations), p = new Blob([h], {
          type: "application/json"
        });
        a.append(`${l}.attachments_operations`, p);
      }
    }
    const r = e ?? n[0]?.dataset_id;
    return await (await this.caller.call(oe(), `${this.apiUrl}/v1/platform/datasets/${r}/examples`, {
      method: "PATCH",
      headers: this.headers,
      body: a
    })).json();
  }
  /**
   * Upload examples with attachments using multipart form data.
   * @param uploads List of ExampleUploadWithAttachments objects to upload
   * @returns Promise with the upload response
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead
   */
  async uploadExamplesMultipart(e, n = []) {
    return this._uploadExamplesMultipart(e, n);
  }
  async _uploadExamplesMultipart(e, n = []) {
    if (!await this._getMultiPartSupport())
      throw new Error("Your LangSmith version does not allow using the multipart examples endpoint, please update to the latest version.");
    const a = new FormData();
    for (const s of n) {
      const o = (s.id ?? Pt()).toString(), l = {
        created_at: s.created_at,
        ...s.metadata && { metadata: s.metadata },
        ...s.split && { split: s.split },
        ...s.source_run_id && { source_run_id: s.source_run_id },
        ...s.use_source_run_io && {
          use_source_run_io: s.use_source_run_io
        },
        ...s.use_source_run_attachments && {
          use_source_run_attachments: s.use_source_run_attachments
        }
      }, f = gn(l), u = new Blob([f], {
        type: "application/json"
      });
      if (a.append(o, u), s.inputs) {
        const c = gn(s.inputs), h = new Blob([c], {
          type: "application/json"
        });
        a.append(`${o}.inputs`, h);
      }
      if (s.outputs) {
        const c = gn(s.outputs), h = new Blob([c], {
          type: "application/json"
        });
        a.append(`${o}.outputs`, h);
      }
      if (s.attachments)
        for (const [c, h] of Object.entries(s.attachments)) {
          let p, d;
          Array.isArray(h) ? [p, d] = h : (p = h.mimeType, d = h.data);
          const m = new Blob([d], {
            type: `${p}; length=${d.byteLength}`
          });
          a.append(`${o}.attachment.${c}`, m);
        }
    }
    return await (await this.caller.call(oe(), `${this.apiUrl}/v1/platform/datasets/${e}/examples`, {
      method: "POST",
      headers: this.headers,
      body: a
    })).json();
  }
  async updatePrompt(e, n) {
    if (!await this.promptExists(e))
      throw new Error("Prompt does not exist, you must create it first.");
    const [a, r] = Qs(e);
    if (!await this._currentTenantIsOwner(a))
      throw await this._ownerConflictError("update a prompt", a);
    const i = {};
    if (n?.description !== void 0 && (i.description = n.description), n?.readme !== void 0 && (i.readme = n.readme), n?.tags !== void 0 && (i.tags = n.tags), n?.isPublic !== void 0 && (i.is_public = n.isPublic), n?.isArchived !== void 0 && (i.is_archived = n.isArchived), Object.keys(i).length === 0)
      throw new Error("No valid update options provided");
    const s = await this.caller.call(oe(), `${this.apiUrl}/repos/${a}/${r}`, {
      method: "PATCH",
      body: JSON.stringify(i),
      headers: {
        ...this.headers,
        "Content-Type": "application/json"
      },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(s, "update prompt"), s.json();
  }
  async deletePrompt(e) {
    if (!await this.promptExists(e))
      throw new Error("Prompt does not exist, you must create it first.");
    const [n, a, r] = Qs(e);
    if (!await this._currentTenantIsOwner(n))
      throw await this._ownerConflictError("delete a prompt", n);
    return await (await this.caller.call(oe(), `${this.apiUrl}/repos/${n}/${a}`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
  }
  async pullPromptCommit(e, n) {
    const [a, r, i] = Qs(e), s = await this.caller.call(oe(), `${this.apiUrl}/commits/${a}/${r}/${i}${n?.includeModel ? "?include_model=true" : ""}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(s, "pull prompt commit");
    const o = await s.json();
    return {
      owner: a,
      repo: r,
      commit_hash: o.commit_hash,
      manifest: o.manifest,
      examples: o.examples
    };
  }
  /**
   * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
   * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
   * @private
   */
  async _pullPrompt(e, n) {
    const a = await this.pullPromptCommit(e, {
      includeModel: n?.includeModel
    });
    return JSON.stringify(a.manifest);
  }
  async pushPrompt(e, n) {
    return await this.promptExists(e) ? n && Object.keys(n).some((r) => r !== "object") && await this.updatePrompt(e, {
      description: n?.description,
      readme: n?.readme,
      tags: n?.tags,
      isPublic: n?.isPublic
    }) : await this.createPrompt(e, {
      description: n?.description,
      readme: n?.readme,
      tags: n?.tags,
      isPublic: n?.isPublic
    }), n?.object ? await this.createCommit(e, n?.object, {
      parentCommitHash: n?.parentCommitHash
    }) : await this._getPromptUrl(e);
  }
  /**
     * Clone a public dataset to your own langsmith tenant.
     * This operation is idempotent. If you already have a dataset with the given name,
     * this function will do nothing.
  
     * @param {string} tokenOrUrl The token of the public dataset to clone.
     * @param {Object} [options] Additional options for cloning the dataset.
     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
     * @returns {Promise<void>}
     */
  async clonePublicDataset(e, n = {}) {
    const { sourceApiUrl: a = this.apiUrl, datasetName: r } = n, [i, s] = this.parseTokenOrUrl(e, a), o = new Od({
      apiUrl: i,
      // Placeholder API key not needed anymore in most cases, but
      // some private deployments may have API key-based rate limiting
      // that would cause this to fail if we provide no value.
      apiKey: "placeholder"
    }), l = await o.readSharedDataset(s), f = r || l.name;
    try {
      if (await this.hasDataset({ datasetId: f })) {
        console.log(`Dataset ${f} already exists in your tenant. Skipping.`);
        return;
      }
    } catch {
    }
    const u = await o.listSharedExamples(s), c = await this.createDataset(f, {
      description: l.description,
      dataType: l.data_type || "kv",
      inputsSchema: l.inputs_schema_definition ?? void 0,
      outputsSchema: l.outputs_schema_definition ?? void 0
    });
    try {
      await this.createExamples({
        inputs: u.map((h) => h.inputs),
        outputs: u.flatMap((h) => h.outputs ? [h.outputs] : []),
        datasetId: c.id
      });
    } catch (h) {
      throw console.error(`An error occurred while creating dataset ${f}. You should delete it manually.`), h;
    }
  }
  parseTokenOrUrl(e, n, a = 2, r = "dataset") {
    try {
      return be(e), [n, e];
    } catch {
    }
    try {
      const s = new URL(e).pathname.split("/").filter((o) => o !== "");
      if (s.length >= a) {
        const o = s[s.length - a];
        return [n, o];
      } else
        throw new Error(`Invalid public ${r} URL: ${e}`);
    } catch {
      throw new Error(`Invalid public ${r} URL or token: ${e}`);
    }
  }
  /**
   * Awaits all pending trace batches. Useful for environments where
   * you need to be sure that all tracing requests finish before execution ends,
   * such as serverless environments.
   *
   * @example
   * ```
   * import { Client } from "langsmith";
   *
   * const client = new Client();
   *
   * try {
   *   // Tracing happens here
   *   ...
   * } finally {
   *   await client.awaitPendingTraceBatches();
   * }
   * ```
   *
   * @returns A promise that resolves once all currently pending traces have sent.
   */
  awaitPendingTraceBatches() {
    return this.manualFlushMode ? (console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches."), Promise.resolve()) : Promise.all([
      ...this.autoBatchQueue.items.map(({ itemPromise: e }) => e),
      this.batchIngestCaller.queue.onIdle()
    ]);
  }
}
function Tw(t) {
  return "dataset_id" in t || "dataset_name" in t;
}
const wC = "0.3.15";
var EN = {};
let va;
const IN = () => typeof window < "u" && typeof window.document < "u", NN = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", kN = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), vC = () => typeof Deno < "u", FN = () => typeof ue < "u" && typeof EN < "u" && !0 && !vC(), DN = () => va || (IN() ? va = "browser" : FN() ? va = "node" : NN() ? va = "webworker" : kN() ? va = "jsdom" : vC() ? va = "deno" : va = "other", va);
let Mm;
function SC() {
  if (Mm === void 0) {
    const t = DN(), e = LN();
    Mm = {
      library: "langsmith",
      runtime: t,
      sdk: "langsmith-js",
      sdk_version: wC,
      ...e
    };
  }
  return Mm;
}
function qN() {
  const t = JN() || {}, e = {}, n = [
    "LANGCHAIN_API_KEY",
    "LANGCHAIN_ENDPOINT",
    "LANGCHAIN_TRACING_V2",
    "LANGCHAIN_PROJECT",
    "LANGCHAIN_SESSION",
    "LANGSMITH_API_KEY",
    "LANGSMITH_ENDPOINT",
    "LANGSMITH_TRACING_V2",
    "LANGSMITH_PROJECT",
    "LANGSMITH_SESSION"
  ];
  for (const [a, r] of Object.entries(t))
    (a.startsWith("LANGCHAIN_") || a.startsWith("LANGSMITH_")) && typeof r == "string" && !n.includes(a) && !a.toLowerCase().includes("key") && !a.toLowerCase().includes("secret") && !a.toLowerCase().includes("token") && (a === "LANGCHAIN_REVISION_ID" ? e.revision_id = r : e[a] = r);
  return e;
}
function JN() {
  try {
    return typeof ue < "u" && ue.env ? Object.entries(ue.env).reduce((t, [e, n]) => (t[e] = String(n), t), {}) : void 0;
  } catch {
    return;
  }
}
function xo(t) {
  try {
    return typeof ue < "u" ? (
      // eslint-disable-next-line no-process-env
      ue.env?.[t]
    ) : void 0;
  } catch {
    return;
  }
}
function so(t) {
  return xo(`LANGSMITH_${t}`) || xo(`LANGCHAIN_${t}`);
}
let Am;
function LN() {
  if (Am !== void 0)
    return Am;
  const t = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT"
  ], e = {};
  for (const n of t) {
    const a = xo(n);
    a !== void 0 && (e[n] = a);
  }
  return Am = e, e;
}
const UN = (t) => !!["TRACING_V2", "TRACING"].find((n) => so(n) === "true"), Em = Symbol.for("lc:context_variables");
function BN(t) {
  return t.replace(/[-:.]/g, "");
}
function xN(t, e, n = 1) {
  const a = n.toFixed(0).slice(0, 3).padStart(3, "0");
  return BN(`${new Date(t).toISOString().slice(0, -1)}${a}Z`) + e;
}
class kh {
  constructor(e, n) {
    Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.metadata = e, this.tags = n;
  }
  static fromHeader(e) {
    const n = e.split(",");
    let a = {}, r = [];
    for (const i of n) {
      const [s, o] = i.split("="), l = decodeURIComponent(o);
      s === "langsmith-metadata" ? a = JSON.parse(l) : s === "langsmith-tags" && (r = l.split(","));
    }
    return new kh(a, r);
  }
  toHeader() {
    const e = [];
    return this.metadata && Object.keys(this.metadata).length > 0 && e.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`), this.tags && this.tags.length > 0 && e.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`), e.join(",");
  }
}
class wn {
  constructor(e) {
    if (Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "run_type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "project_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "parent_run", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "child_runs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "start_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "end_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "extra", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "error", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serialized", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reference_example_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "trace_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dotted_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tracingEnabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "execution_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "child_execution_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "attachments", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), OC(e)) {
      Object.assign(this, { ...e });
      return;
    }
    const n = wn.getDefaultConfig(), { metadata: a, ...r } = e, i = r.client ?? wn.getSharedClient(), s = {
      ...a,
      ...r?.extra?.metadata
    };
    if (r.extra = { ...r.extra, metadata: s }, Object.assign(this, { ...n, ...r, client: i }), this.trace_id || (this.parent_run ? this.trace_id = this.parent_run.trace_id ?? this.id : this.trace_id = this.id), this.execution_order ??= 1, this.child_execution_order ??= 1, !this.dotted_order) {
      const o = xN(this.start_time, this.id, this.execution_order);
      this.parent_run ? this.dotted_order = this.parent_run.dotted_order + "." + o : this.dotted_order = o;
    }
  }
  static getDefaultConfig() {
    return {
      id: Pt(),
      run_type: "chain",
      project_name: so("PROJECT") ?? xo("LANGCHAIN_SESSION") ?? // TODO: Deprecate
      "default",
      child_runs: [],
      api_url: xo("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
      api_key: xo("LANGCHAIN_API_KEY"),
      caller_options: {},
      start_time: Date.now(),
      serialized: {},
      inputs: {},
      extra: {}
    };
  }
  static getSharedClient() {
    return wn.sharedClient || (wn.sharedClient = new Od()), wn.sharedClient;
  }
  createChild(e) {
    const n = this.child_execution_order + 1, a = new wn({
      ...e,
      parent_run: this,
      project_name: this.project_name,
      client: this.client,
      tracingEnabled: this.tracingEnabled,
      execution_order: n,
      child_execution_order: n
    });
    Em in this && (a[Em] = this[Em]);
    const r = Symbol.for("lc:child_config"), i = e.extra?.[r] ?? this.extra[r];
    if (zN(i)) {
      const l = { ...i }, f = VN(l.callbacks) ? l.callbacks.copy?.() : void 0;
      f && (Object.assign(f, { _parentRunId: a.id }), f.handlers?.find(jC)?.updateFromRunTree?.(a), l.callbacks = f), a.extra[r] = l;
    }
    const s = /* @__PURE__ */ new Set();
    let o = this;
    for (; o != null && !s.has(o.id); )
      s.add(o.id), o.child_execution_order = Math.max(o.child_execution_order, n), o = o.parent_run;
    return this.child_runs.push(a), a;
  }
  async end(e, n, a = Date.now(), r) {
    this.outputs = this.outputs ?? e, this.error = this.error ?? n, this.end_time = this.end_time ?? a, r && Object.keys(r).length > 0 && (this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...r } } : { metadata: r });
  }
  _convertToCreate(e, n, a = !0) {
    const r = e.extra ?? {};
    if (r.runtime || (r.runtime = {}), n)
      for (const [l, f] of Object.entries(n))
        r.runtime[l] || (r.runtime[l] = f);
    let i, s;
    return a ? (s = e.parent_run?.id, i = []) : (i = e.child_runs.map((l) => this._convertToCreate(l, n, a)), s = void 0), {
      id: e.id,
      name: e.name,
      start_time: e.start_time,
      end_time: e.end_time,
      run_type: e.run_type,
      reference_example_id: e.reference_example_id,
      extra: r,
      serialized: e.serialized,
      error: e.error,
      inputs: e.inputs,
      outputs: e.outputs,
      session_name: e.project_name,
      child_runs: i,
      parent_run_id: s,
      trace_id: e.trace_id,
      dotted_order: e.dotted_order,
      tags: e.tags,
      attachments: e.attachments
    };
  }
  async postRun(e = !0) {
    try {
      const n = SC(), a = await this._convertToCreate(this, n, !0);
      if (await this.client.createRun(a), !e) {
        yC("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
        for (const r of this.child_runs)
          await r.postRun(!1);
      }
    } catch (n) {
      console.error(`Error in postRun for run ${this.id}:`, n);
    }
  }
  async patchRun() {
    try {
      const e = {
        end_time: this.end_time,
        error: this.error,
        inputs: this.inputs,
        outputs: this.outputs,
        parent_run_id: this.parent_run?.id,
        reference_example_id: this.reference_example_id,
        extra: this.extra,
        events: this.events,
        dotted_order: this.dotted_order,
        trace_id: this.trace_id,
        tags: this.tags,
        attachments: this.attachments
      };
      await this.client.updateRun(this.id, e);
    } catch (e) {
      console.error(`Error in patchRun for run ${this.id}`, e);
    }
  }
  toJSON() {
    return this._convertToCreate(this, void 0, !1);
  }
  /**
   * Add an event to the run tree.
   * @param event - A single event or string to add
   */
  addEvent(e) {
    this.events || (this.events = []), typeof e == "string" ? this.events.push({
      name: "event",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      message: e
    }) : this.events.push({
      ...e,
      time: e.time ?? (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  static fromRunnableConfig(e, n) {
    const a = e?.callbacks;
    let r, i, s, o = UN();
    if (a) {
      const f = a?.getParentRunId?.() ?? "", u = a?.handlers?.find((c) => c?.name == "langchain_tracer");
      r = u?.getRun?.(f), i = u?.projectName, s = u?.client, o = o || !!u;
    }
    return r ? new wn({
      name: r.name,
      id: r.id,
      trace_id: r.trace_id,
      dotted_order: r.dotted_order,
      client: s,
      tracingEnabled: o,
      project_name: i,
      tags: [
        ...new Set((r?.tags ?? []).concat(e?.tags ?? []))
      ],
      extra: {
        metadata: {
          ...r?.extra?.metadata,
          ...e?.metadata
        }
      }
    }).createChild(n) : new wn({
      ...n,
      client: s,
      tracingEnabled: o,
      project_name: i
    });
  }
  static fromDottedOrder(e) {
    return this.fromHeaders({ "langsmith-trace": e });
  }
  static fromHeaders(e, n) {
    const a = "get" in e && typeof e.get == "function" ? {
      "langsmith-trace": e.get("langsmith-trace"),
      baggage: e.get("baggage")
    } : e, r = a["langsmith-trace"];
    if (!r || typeof r != "string")
      return;
    const i = r.trim(), s = i.split(".").map((f) => {
      const [u, c] = f.split("Z");
      return { strTime: u, time: Date.parse(u + "Z"), uuid: c };
    }), o = s[0].uuid, l = {
      ...n,
      name: n?.name ?? "parent",
      run_type: n?.run_type ?? "chain",
      start_time: n?.start_time ?? Date.now(),
      id: s.at(-1)?.uuid,
      trace_id: o,
      dotted_order: i
    };
    if (a.baggage && typeof a.baggage == "string") {
      const f = kh.fromHeader(a.baggage);
      l.metadata = f.metadata, l.tags = f.tags;
    }
    return new wn(l);
  }
  toHeaders(e) {
    const n = {
      "langsmith-trace": this.dotted_order,
      baggage: new kh(this.extra?.metadata, this.tags).toHeader()
    };
    if (e)
      for (const [a, r] of Object.entries(n))
        e.set(a, r);
    return n;
  }
}
Object.defineProperty(wn, "sharedClient", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: null
});
function OC(t) {
  return t !== void 0 && typeof t.createChild == "function" && typeof t.postRun == "function";
}
function jC(t) {
  return typeof t == "object" && t != null && typeof t.name == "string" && t.name === "langchain_tracer";
}
function $w(t) {
  return Array.isArray(t) && t.some((e) => jC(e));
}
function VN(t) {
  return typeof t == "object" && t != null && Array.isArray(t.handlers);
}
function zN(t) {
  return t !== void 0 && typeof t.callbacks == "object" && // Callback manager with a langchain tracer
  ($w(t.callbacks?.handlers) || // Or it's an array with a LangChainTracerLike object within it
  $w(t.callbacks));
}
let ZN = class {
  getStore() {
  }
  run(e, n) {
    return n();
  }
};
const Im = Symbol.for("ls:tracing_async_local_storage"), KN = new ZN();
let HN = class {
  getInstance() {
    return globalThis[Im] ?? KN;
  }
  initializeGlobalInstance(e) {
    globalThis[Im] === void 0 && (globalThis[Im] = e);
  }
};
const GN = new HN(), WN = () => {
  const t = GN.getInstance().getStore();
  if (!OC(t))
    throw new Error([
      "Could not get the current run tree.",
      "",
      "Please make sure you are calling this method within a traceable function and that tracing is enabled."
    ].join(`
`));
  return t;
};
function u_(t) {
  return typeof t == "function" && "langsmith:traceable" in t;
}
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
const XN = Object.prototype.hasOwnProperty;
function Yb(t, e) {
  return XN.call(t, e);
}
function eg(t) {
  if (Array.isArray(t)) {
    const n = new Array(t.length);
    for (let a = 0; a < n.length; a++)
      n[a] = "" + a;
    return n;
  }
  if (Object.keys)
    return Object.keys(t);
  let e = [];
  for (let n in t)
    Yb(t, n) && e.push(n);
  return e;
}
function sa(t) {
  switch (typeof t) {
    case "object":
      return JSON.parse(JSON.stringify(t));
    //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
    case "undefined":
      return null;
    //this is how JSON.stringify behaves for array items
    default:
      return t;
  }
}
function tg(t) {
  let e = 0;
  const n = t.length;
  let a;
  for (; e < n; ) {
    if (a = t.charCodeAt(e), a >= 48 && a <= 57) {
      e++;
      continue;
    }
    return !1;
  }
  return !0;
}
function bu(t) {
  return t.indexOf("/") === -1 && t.indexOf("~") === -1 ? t : t.replace(/~/g, "~0").replace(/\//g, "~1");
}
function QN(t) {
  return t.replace(/~1/g, "/").replace(/~0/g, "~");
}
function ng(t) {
  if (t === void 0)
    return !0;
  if (t) {
    if (Array.isArray(t)) {
      for (let n = 0, a = t.length; n < a; n++)
        if (ng(t[n]))
          return !0;
    } else if (typeof t == "object") {
      const n = eg(t), a = n.length;
      for (var e = 0; e < a; e++)
        if (ng(t[n[e]]))
          return !0;
    }
  }
  return !1;
}
function Mw(t, e) {
  const n = [t];
  for (const a in e) {
    const r = typeof e[a] == "object" ? JSON.stringify(e[a], null, 2) : e[a];
    typeof r < "u" && n.push(`${a}: ${r}`);
  }
  return n.join(`
`);
}
class YN extends Error {
  constructor(e, n, a, r, i) {
    super(Mw(e, { name: n, index: a, operation: r, tree: i })), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "index", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    }), Object.defineProperty(this, "operation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "tree", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.setPrototypeOf(this, new.target.prototype), this.message = Mw(e, {
      name: n,
      index: a,
      operation: r,
      tree: i
    });
  }
}
const ct = YN, Du = {
  add: function(t, e, n) {
    return t[e] = this.value, { newDocument: n };
  },
  remove: function(t, e, n) {
    var a = t[e];
    return delete t[e], { newDocument: n, removed: a };
  },
  replace: function(t, e, n) {
    var a = t[e];
    return t[e] = this.value, { newDocument: n, removed: a };
  },
  move: function(t, e, n) {
    let a = rg(n, this.path);
    a && (a = sa(a));
    const r = Wl(n, {
      op: "remove",
      path: this.from
    }).removed;
    return Wl(n, {
      op: "add",
      path: this.path,
      value: r
    }), { newDocument: n, removed: a };
  },
  copy: function(t, e, n) {
    const a = rg(n, this.from);
    return Wl(n, {
      op: "add",
      path: this.path,
      value: sa(a)
    }), { newDocument: n };
  },
  test: function(t, e, n) {
    return { newDocument: n, test: Dh(t[e], this.value) };
  },
  _get: function(t, e, n) {
    return this.value = t[e], { newDocument: n };
  }
};
var ek = {
  add: function(t, e, n) {
    return tg(e) ? t.splice(e, 0, this.value) : t[e] = this.value, { newDocument: n, index: e };
  },
  remove: function(t, e, n) {
    var a = t.splice(e, 1);
    return { newDocument: n, removed: a[0] };
  },
  replace: function(t, e, n) {
    var a = t[e];
    return t[e] = this.value, { newDocument: n, removed: a };
  },
  move: Du.move,
  copy: Du.copy,
  test: Du.test,
  _get: Du._get
};
function rg(t, e) {
  if (e == "")
    return t;
  var n = { op: "_get", path: e };
  return Wl(t, n), n.value;
}
function Wl(t, e, n = !1, a = !0, r = !0, i = 0) {
  if (n && (typeof n == "function" ? n(e, 0, t, e.path) : ag(e, 0)), e.path === "") {
    let s = { newDocument: t };
    if (e.op === "add")
      return s.newDocument = e.value, s;
    if (e.op === "replace")
      return s.newDocument = e.value, s.removed = t, s;
    if (e.op === "move" || e.op === "copy")
      return s.newDocument = rg(t, e.from), e.op === "move" && (s.removed = t), s;
    if (e.op === "test") {
      if (s.test = Dh(t, e.value), s.test === !1)
        throw new ct("Test operation failed", "TEST_OPERATION_FAILED", i, e, t);
      return s.newDocument = t, s;
    } else {
      if (e.op === "remove")
        return s.removed = t, s.newDocument = null, s;
      if (e.op === "_get")
        return e.value = t, s;
      if (n)
        throw new ct("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", i, e, t);
      return s;
    }
  } else {
    a || (t = sa(t));
    const o = (e.path || "").split("/");
    let l = t, f = 1, u = o.length, c, h, p;
    for (typeof n == "function" ? p = n : p = ag; ; ) {
      if (h = o[f], h && h.indexOf("~") != -1 && (h = QN(h)), r && (h == "__proto__" || h == "prototype" && f > 0 && o[f - 1] == "constructor"))
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (n && c === void 0 && (l[h] === void 0 ? c = o.slice(0, f).join("/") : f == u - 1 && (c = e.path), c !== void 0 && p(e, 0, t, c)), f++, Array.isArray(l)) {
        if (h === "-")
          h = l.length;
        else {
          if (n && !tg(h))
            throw new ct("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", i, e, t);
          tg(h) && (h = ~~h);
        }
        if (f >= u) {
          if (n && e.op === "add" && h > l.length)
            throw new ct("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", i, e, t);
          const d = ek[e.op].call(e, l, h, t);
          if (d.test === !1)
            throw new ct("Test operation failed", "TEST_OPERATION_FAILED", i, e, t);
          return d;
        }
      } else if (f >= u) {
        const d = Du[e.op].call(e, l, h, t);
        if (d.test === !1)
          throw new ct("Test operation failed", "TEST_OPERATION_FAILED", i, e, t);
        return d;
      }
      if (l = l[h], n && f < u && (!l || typeof l != "object"))
        throw new ct("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", i, e, t);
    }
  }
}
function Fh(t, e, n, a = !0, r = !0) {
  if (n && !Array.isArray(e))
    throw new ct("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  a || (t = sa(t));
  const i = new Array(e.length);
  for (let s = 0, o = e.length; s < o; s++)
    i[s] = Wl(t, e[s], n, !0, r, s), t = i[s].newDocument;
  return i.newDocument = t, i;
}
function ag(t, e, n, a) {
  if (typeof t != "object" || t === null || Array.isArray(t))
    throw new ct("Operation is not an object", "OPERATION_NOT_AN_OBJECT", e, t, n);
  if (Du[t.op]) {
    if (typeof t.path != "string")
      throw new ct("Operation `path` property is not a string", "OPERATION_PATH_INVALID", e, t, n);
    if (t.path.indexOf("/") !== 0 && t.path.length > 0)
      throw new ct('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", e, t, n);
    if ((t.op === "move" || t.op === "copy") && typeof t.from != "string")
      throw new ct("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", e, t, n);
    if ((t.op === "add" || t.op === "replace" || t.op === "test") && t.value === void 0)
      throw new ct("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", e, t, n);
    if ((t.op === "add" || t.op === "replace" || t.op === "test") && ng(t.value))
      throw new ct("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", e, t, n);
    if (n) {
      if (t.op == "add") {
        var r = t.path.split("/").length, i = a.split("/").length;
        if (r !== i + 1 && r !== i)
          throw new ct("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", e, t, n);
      } else if (t.op === "replace" || t.op === "remove" || t.op === "_get") {
        if (t.path !== a)
          throw new ct("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", e, t, n);
      } else if (t.op === "move" || t.op === "copy") {
        var s = {
          op: "_get",
          path: t.from,
          value: void 0
        }, o = tk([s], n);
        if (o && o.name === "OPERATION_PATH_UNRESOLVABLE")
          throw new ct("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", e, t, n);
      }
    }
  } else throw new ct("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", e, t, n);
}
function tk(t, e, n) {
  try {
    if (!Array.isArray(t))
      throw new ct("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (e)
      Fh(sa(e), sa(t), n || !0);
    else {
      n = n || ag;
      for (var a = 0; a < t.length; a++)
        n(t[a], a, e, void 0);
    }
  } catch (r) {
    if (r instanceof ct)
      return r;
    throw r;
  }
}
function Dh(t, e) {
  if (t === e)
    return !0;
  if (t && e && typeof t == "object" && typeof e == "object") {
    var n = Array.isArray(t), a = Array.isArray(e), r, i, s;
    if (n && a) {
      if (i = t.length, i != e.length)
        return !1;
      for (r = i; r-- !== 0; )
        if (!Dh(t[r], e[r]))
          return !1;
      return !0;
    }
    if (n != a)
      return !1;
    var o = Object.keys(t);
    if (i = o.length, i !== Object.keys(e).length)
      return !1;
    for (r = i; r-- !== 0; )
      if (!e.hasOwnProperty(o[r]))
        return !1;
    for (r = i; r-- !== 0; )
      if (s = o[r], !Dh(t[s], e[s]))
        return !1;
    return !0;
  }
  return t !== t && e !== e;
}
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2013-2021 Joachim Wester
 * MIT license
 */
function PC(t, e, n, a, r) {
  if (e !== t) {
    typeof e.toJSON == "function" && (e = e.toJSON());
    for (var i = eg(e), s = eg(t), o = !1, l = s.length - 1; l >= 0; l--) {
      var f = s[l], u = t[f];
      if (Yb(e, f) && !(e[f] === void 0 && u !== void 0 && Array.isArray(e) === !1)) {
        var c = e[f];
        typeof u == "object" && u != null && typeof c == "object" && c != null && Array.isArray(u) === Array.isArray(c) ? PC(u, c, n, a + "/" + bu(f), r) : u !== c && (r && n.push({
          op: "test",
          path: a + "/" + bu(f),
          value: sa(u)
        }), n.push({
          op: "replace",
          path: a + "/" + bu(f),
          value: sa(c)
        }));
      } else Array.isArray(t) === Array.isArray(e) ? (r && n.push({
        op: "test",
        path: a + "/" + bu(f),
        value: sa(u)
      }), n.push({
        op: "remove",
        path: a + "/" + bu(f)
      }), o = !0) : (r && n.push({ op: "test", path: a, value: t }), n.push({ op: "replace", path: a, value: e }));
    }
    if (!(!o && i.length == s.length))
      for (var l = 0; l < i.length; l++) {
        var f = i[l];
        !Yb(t, f) && e[f] !== void 0 && n.push({
          op: "add",
          path: a + "/" + bu(f),
          value: sa(e[f])
        });
      }
  }
}
function nk(t, e, n = !1) {
  var a = [];
  return PC(t, e, a, "", n), a;
}
var rk = {};
const ak = () => typeof window < "u" && typeof window.document < "u", ik = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", sk = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), c_ = () => typeof Deno < "u", ok = () => typeof ue < "u" && typeof rk < "u" && !0 && !c_(), uk = () => {
  let t;
  return ak() ? t = "browser" : ok() ? t = "node" : ik() ? t = "webworker" : sk() ? t = "jsdom" : c_() ? t = "deno" : t = "other", t;
};
let Nm;
async function ck() {
  return Nm === void 0 && (Nm = {
    library: "langchain-js",
    runtime: uk()
  }), Nm;
}
function ft(t) {
  try {
    return typeof ue < "u" ? ue.env?.[t] : c_() ? Deno?.env.get(t) : void 0;
  } catch {
    return;
  }
}
class lk {
}
function RC(t) {
  return "lc_prefer_streaming" in t && t.lc_prefer_streaming;
}
class cc extends lk {
  get lc_namespace() {
    return ["langchain_core", "callbacks", this.name];
  }
  get lc_secrets() {
  }
  get lc_attributes() {
  }
  get lc_aliases() {
  }
  get lc_serializable_keys() {
  }
  /**
   * The name of the serializable. Override to provide an alias or
   * to preserve the serialized module name in minified environments.
   *
   * Implemented as a static method to support loading logic.
   */
  static lc_name() {
    return this.name;
  }
  /**
   * The final serialized identifier for the module.
   */
  get lc_id() {
    return [
      ...this.lc_namespace,
      iC(this.constructor)
    ];
  }
  constructor(e) {
    super(), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "lc_kwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ignoreLLM", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "ignoreChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "ignoreAgent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "ignoreRetriever", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "ignoreCustomEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "raiseError", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "awaitHandlers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ft("LANGCHAIN_CALLBACKS_BACKGROUND") === "false"
    }), this.lc_kwargs = e || {}, e && (this.ignoreLLM = e.ignoreLLM ?? this.ignoreLLM, this.ignoreChain = e.ignoreChain ?? this.ignoreChain, this.ignoreAgent = e.ignoreAgent ?? this.ignoreAgent, this.ignoreRetriever = e.ignoreRetriever ?? this.ignoreRetriever, this.ignoreCustomEvent = e.ignoreCustomEvent ?? this.ignoreCustomEvent, this.raiseError = e.raiseError ?? this.raiseError, this.awaitHandlers = this.raiseError || (e._awaitHandler ?? this.awaitHandlers));
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return gr.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return gr.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods(e) {
    class n extends cc {
      constructor() {
        super(), Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: Pt()
        }), Object.assign(this, e);
      }
    }
    return new n();
  }
}
const dk = (t) => {
  const e = t;
  return e !== void 0 && typeof e.copy == "function" && typeof e.name == "string" && typeof e.awaitHandlers == "boolean";
};
function km(t, e) {
  return t && !Array.isArray(t) && typeof t == "object" ? t : { [e]: t };
}
function fk(t) {
  return t.replace(/[-:.]/g, "");
}
function hk(t, e, n) {
  const a = n.toFixed(0).slice(0, 3).padStart(3, "0");
  return fk(`${new Date(t).toISOString().slice(0, -1)}${a}Z`) + e;
}
function Oc(t) {
  return typeof t._addRunToRunMap == "function";
}
class Zd extends cc {
  constructor(e) {
    super(...arguments), Object.defineProperty(this, "runMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
  }
  copy() {
    return this;
  }
  stringifyError(e) {
    return e instanceof Error ? e.message + (e?.stack ? `

${e.stack}` : "") : typeof e == "string" ? e : `${e}`;
  }
  _addChildRun(e, n) {
    e.child_runs.push(n);
  }
  _addRunToRunMap(e) {
    const n = hk(e.start_time, e.id, e.execution_order), a = { ...e };
    if (a.parent_run_id !== void 0) {
      const r = this.runMap.get(a.parent_run_id);
      r && (this._addChildRun(r, a), r.child_execution_order = Math.max(r.child_execution_order, a.child_execution_order), a.trace_id = r.trace_id, r.dotted_order !== void 0 && (a.dotted_order = [
        r.dotted_order,
        n
      ].join(".")));
    } else
      a.trace_id = a.id, a.dotted_order = n;
    return this.runMap.set(a.id, a), a;
  }
  async _endTrace(e) {
    const n = e.parent_run_id !== void 0 && this.runMap.get(e.parent_run_id);
    n ? n.child_execution_order = Math.max(n.child_execution_order, e.child_execution_order) : await this.persistRun(e), this.runMap.delete(e.id), await this.onRunUpdate?.(e);
  }
  _getExecutionOrder(e) {
    const n = e !== void 0 && this.runMap.get(e);
    return n ? n.child_execution_order + 1 : 1;
  }
  /**
   * Create and add a run to the run map for LLM start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForLLMStart(e, n, a, r, i, s, o, l) {
    const f = this._getExecutionOrder(r), u = Date.now(), c = o ? { ...i, metadata: o } : i, h = {
      id: a,
      name: l ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: u,
      serialized: e,
      events: [
        {
          name: "start",
          time: new Date(u).toISOString()
        }
      ],
      inputs: { prompts: n },
      execution_order: f,
      child_runs: [],
      child_execution_order: f,
      run_type: "llm",
      extra: c ?? {},
      tags: s || []
    };
    return this._addRunToRunMap(h);
  }
  async handleLLMStart(e, n, a, r, i, s, o, l) {
    const f = this.runMap.get(a) ?? this._createRunForLLMStart(e, n, a, r, i, s, o, l);
    return await this.onRunCreate?.(f), await this.onLLMStart?.(f), f;
  }
  /**
   * Create and add a run to the run map for chat model start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForChatModelStart(e, n, a, r, i, s, o, l) {
    const f = this._getExecutionOrder(r), u = Date.now(), c = o ? { ...i, metadata: o } : i, h = {
      id: a,
      name: l ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: u,
      serialized: e,
      events: [
        {
          name: "start",
          time: new Date(u).toISOString()
        }
      ],
      inputs: { messages: n },
      execution_order: f,
      child_runs: [],
      child_execution_order: f,
      run_type: "llm",
      extra: c ?? {},
      tags: s || []
    };
    return this._addRunToRunMap(h);
  }
  async handleChatModelStart(e, n, a, r, i, s, o, l) {
    const f = this.runMap.get(a) ?? this._createRunForChatModelStart(e, n, a, r, i, s, o, l);
    return await this.onRunCreate?.(f), await this.onLLMStart?.(f), f;
  }
  async handleLLMEnd(e, n, a, r, i) {
    const s = this.runMap.get(n);
    if (!s || s?.run_type !== "llm")
      throw new Error("No LLM run to end.");
    return s.end_time = Date.now(), s.outputs = e, s.events.push({
      name: "end",
      time: new Date(s.end_time).toISOString()
    }), s.extra = { ...s.extra, ...i }, await this.onLLMEnd?.(s), await this._endTrace(s), s;
  }
  async handleLLMError(e, n, a, r, i) {
    const s = this.runMap.get(n);
    if (!s || s?.run_type !== "llm")
      throw new Error("No LLM run to end.");
    return s.end_time = Date.now(), s.error = this.stringifyError(e), s.events.push({
      name: "error",
      time: new Date(s.end_time).toISOString()
    }), s.extra = { ...s.extra, ...i }, await this.onLLMError?.(s), await this._endTrace(s), s;
  }
  /**
   * Create and add a run to the run map for chain start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForChainStart(e, n, a, r, i, s, o, l) {
    const f = this._getExecutionOrder(r), u = Date.now(), c = {
      id: a,
      name: l ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: u,
      serialized: e,
      events: [
        {
          name: "start",
          time: new Date(u).toISOString()
        }
      ],
      inputs: n,
      execution_order: f,
      child_execution_order: f,
      run_type: o ?? "chain",
      child_runs: [],
      extra: s ? { metadata: s } : {},
      tags: i || []
    };
    return this._addRunToRunMap(c);
  }
  async handleChainStart(e, n, a, r, i, s, o, l) {
    const f = this.runMap.get(a) ?? this._createRunForChainStart(e, n, a, r, i, s, o, l);
    return await this.onRunCreate?.(f), await this.onChainStart?.(f), f;
  }
  async handleChainEnd(e, n, a, r, i) {
    const s = this.runMap.get(n);
    if (!s)
      throw new Error("No chain run to end.");
    return s.end_time = Date.now(), s.outputs = km(e, "output"), s.events.push({
      name: "end",
      time: new Date(s.end_time).toISOString()
    }), i?.inputs !== void 0 && (s.inputs = km(i.inputs, "input")), await this.onChainEnd?.(s), await this._endTrace(s), s;
  }
  async handleChainError(e, n, a, r, i) {
    const s = this.runMap.get(n);
    if (!s)
      throw new Error("No chain run to end.");
    return s.end_time = Date.now(), s.error = this.stringifyError(e), s.events.push({
      name: "error",
      time: new Date(s.end_time).toISOString()
    }), i?.inputs !== void 0 && (s.inputs = km(i.inputs, "input")), await this.onChainError?.(s), await this._endTrace(s), s;
  }
  /**
   * Create and add a run to the run map for tool start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForToolStart(e, n, a, r, i, s, o) {
    const l = this._getExecutionOrder(r), f = Date.now(), u = {
      id: a,
      name: o ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: f,
      serialized: e,
      events: [
        {
          name: "start",
          time: new Date(f).toISOString()
        }
      ],
      inputs: { input: n },
      execution_order: l,
      child_execution_order: l,
      run_type: "tool",
      child_runs: [],
      extra: s ? { metadata: s } : {},
      tags: i || []
    };
    return this._addRunToRunMap(u);
  }
  async handleToolStart(e, n, a, r, i, s, o) {
    const l = this.runMap.get(a) ?? this._createRunForToolStart(e, n, a, r, i, s, o);
    return await this.onRunCreate?.(l), await this.onToolStart?.(l), l;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleToolEnd(e, n) {
    const a = this.runMap.get(n);
    if (!a || a?.run_type !== "tool")
      throw new Error("No tool run to end");
    return a.end_time = Date.now(), a.outputs = { output: e }, a.events.push({
      name: "end",
      time: new Date(a.end_time).toISOString()
    }), await this.onToolEnd?.(a), await this._endTrace(a), a;
  }
  async handleToolError(e, n) {
    const a = this.runMap.get(n);
    if (!a || a?.run_type !== "tool")
      throw new Error("No tool run to end");
    return a.end_time = Date.now(), a.error = this.stringifyError(e), a.events.push({
      name: "error",
      time: new Date(a.end_time).toISOString()
    }), await this.onToolError?.(a), await this._endTrace(a), a;
  }
  async handleAgentAction(e, n) {
    const a = this.runMap.get(n);
    if (!a || a?.run_type !== "chain")
      return;
    const r = a;
    r.actions = r.actions || [], r.actions.push(e), r.events.push({
      name: "agent_action",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action: e }
    }), await this.onAgentAction?.(a);
  }
  async handleAgentEnd(e, n) {
    const a = this.runMap.get(n);
    !a || a?.run_type !== "chain" || (a.events.push({
      name: "agent_end",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action: e }
    }), await this.onAgentEnd?.(a));
  }
  /**
   * Create and add a run to the run map for retriever start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForRetrieverStart(e, n, a, r, i, s, o) {
    const l = this._getExecutionOrder(r), f = Date.now(), u = {
      id: a,
      name: o ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: f,
      serialized: e,
      events: [
        {
          name: "start",
          time: new Date(f).toISOString()
        }
      ],
      inputs: { query: n },
      execution_order: l,
      child_execution_order: l,
      run_type: "retriever",
      child_runs: [],
      extra: s ? { metadata: s } : {},
      tags: i || []
    };
    return this._addRunToRunMap(u);
  }
  async handleRetrieverStart(e, n, a, r, i, s, o) {
    const l = this.runMap.get(a) ?? this._createRunForRetrieverStart(e, n, a, r, i, s, o);
    return await this.onRunCreate?.(l), await this.onRetrieverStart?.(l), l;
  }
  async handleRetrieverEnd(e, n) {
    const a = this.runMap.get(n);
    if (!a || a?.run_type !== "retriever")
      throw new Error("No retriever run to end");
    return a.end_time = Date.now(), a.outputs = { documents: e }, a.events.push({
      name: "end",
      time: new Date(a.end_time).toISOString()
    }), await this.onRetrieverEnd?.(a), await this._endTrace(a), a;
  }
  async handleRetrieverError(e, n) {
    const a = this.runMap.get(n);
    if (!a || a?.run_type !== "retriever")
      throw new Error("No retriever run to end");
    return a.end_time = Date.now(), a.error = this.stringifyError(e), a.events.push({
      name: "error",
      time: new Date(a.end_time).toISOString()
    }), await this.onRetrieverError?.(a), await this._endTrace(a), a;
  }
  async handleText(e, n) {
    const a = this.runMap.get(n);
    !a || a?.run_type !== "chain" || (a.events.push({
      name: "text",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { text: e }
    }), await this.onText?.(a));
  }
  async handleLLMNewToken(e, n, a, r, i, s) {
    const o = this.runMap.get(a);
    if (!o || o?.run_type !== "llm")
      throw new Error('Invalid "runId" provided to "handleLLMNewToken" callback.');
    return o.events.push({
      name: "new_token",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { token: e, idx: n, chunk: s?.chunk }
    }), await this.onLLMNewToken?.(o, e, { chunk: s?.chunk }), o;
  }
}
var Fm = { exports: {} }, Aw;
function pk() {
  return Aw || (Aw = 1, function(t) {
    const n = (i = 0) => (s) => `\x1B[${38 + i};5;${s}m`, a = (i = 0) => (s, o, l) => `\x1B[${38 + i};2;${s};${o};${l}m`;
    function r() {
      const i = /* @__PURE__ */ new Map(), s = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      s.color.gray = s.color.blackBright, s.bgColor.bgGray = s.bgColor.bgBlackBright, s.color.grey = s.color.blackBright, s.bgColor.bgGrey = s.bgColor.bgBlackBright;
      for (const [o, l] of Object.entries(s)) {
        for (const [f, u] of Object.entries(l))
          s[f] = {
            open: `\x1B[${u[0]}m`,
            close: `\x1B[${u[1]}m`
          }, l[f] = s[f], i.set(u[0], u[1]);
        Object.defineProperty(s, o, {
          value: l,
          enumerable: !1
        });
      }
      return Object.defineProperty(s, "codes", {
        value: i,
        enumerable: !1
      }), s.color.close = "\x1B[39m", s.bgColor.close = "\x1B[49m", s.color.ansi256 = n(), s.color.ansi16m = a(), s.bgColor.ansi256 = n(10), s.bgColor.ansi16m = a(10), Object.defineProperties(s, {
        rgbToAnsi256: {
          value: (o, l, f) => o === l && l === f ? o < 8 ? 16 : o > 248 ? 231 : Math.round((o - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(o / 255 * 5) + 6 * Math.round(l / 255 * 5) + Math.round(f / 255 * 5),
          enumerable: !1
        },
        hexToRgb: {
          value: (o) => {
            const l = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(o.toString(16));
            if (!l)
              return [0, 0, 0];
            let { colorString: f } = l.groups;
            f.length === 3 && (f = f.split("").map((c) => c + c).join(""));
            const u = Number.parseInt(f, 16);
            return [
              u >> 16 & 255,
              u >> 8 & 255,
              u & 255
            ];
          },
          enumerable: !1
        },
        hexToAnsi256: {
          value: (o) => s.rgbToAnsi256(...s.hexToRgb(o)),
          enumerable: !1
        }
      }), s;
    }
    Object.defineProperty(t, "exports", {
      enumerable: !0,
      get: r
    });
  }(Fm)), Fm.exports;
}
var mk = /* @__PURE__ */ pk();
const CC = /* @__PURE__ */ Bd(mk);
function Zt(t, e) {
  return `${t.open}${e}${t.close}`;
}
function qn(t, e) {
  try {
    return JSON.stringify(t, null, 2);
  } catch {
    return e;
  }
}
function Ew(t) {
  return typeof t == "string" ? t.trim() : t == null ? t : qn(t, t.toString());
}
function Ys(t) {
  if (!t.end_time)
    return "";
  const e = t.end_time - t.start_time;
  return e < 1e3 ? `${e}ms` : `${(e / 1e3).toFixed(2)}s`;
}
const { color: nn } = CC;
class Iw extends Zd {
  constructor() {
    super(...arguments), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "console_callback_handler"
    });
  }
  /**
   * Method used to persist the run. In this case, it simply returns a
   * resolved promise as there's no persistence logic.
   * @param _run The run to persist.
   * @returns A resolved promise.
   */
  persistRun(e) {
    return Promise.resolve();
  }
  // utility methods
  /**
   * Method used to get all the parent runs of a given run.
   * @param run The run whose parents are to be retrieved.
   * @returns An array of parent runs.
   */
  getParents(e) {
    const n = [];
    let a = e;
    for (; a.parent_run_id; ) {
      const r = this.runMap.get(a.parent_run_id);
      if (r)
        n.push(r), a = r;
      else
        break;
    }
    return n;
  }
  /**
   * Method used to get a string representation of the run's lineage, which
   * is used in logging.
   * @param run The run whose lineage is to be retrieved.
   * @returns A string representation of the run's lineage.
   */
  getBreadcrumbs(e) {
    const a = [...this.getParents(e).reverse(), e].map((r, i, s) => {
      const o = `${r.execution_order}:${r.run_type}:${r.name}`;
      return i === s.length - 1 ? Zt(CC.bold, o) : o;
    }).join(" > ");
    return Zt(nn.grey, a);
  }
  // logging methods
  /**
   * Method used to log the start of a chain run.
   * @param run The chain run that has started.
   * @returns void
   */
  onChainStart(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Zt(nn.green, "[chain/start]")} [${n}] Entering Chain run with input: ${qn(e.inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of a chain run.
   * @param run The chain run that has ended.
   * @returns void
   */
  onChainEnd(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Zt(nn.cyan, "[chain/end]")} [${n}] [${Ys(e)}] Exiting Chain run with output: ${qn(e.outputs, "[outputs]")}`);
  }
  /**
   * Method used to log any errors of a chain run.
   * @param run The chain run that has errored.
   * @returns void
   */
  onChainError(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Zt(nn.red, "[chain/error]")} [${n}] [${Ys(e)}] Chain run errored with error: ${qn(e.error, "[error]")}`);
  }
  /**
   * Method used to log the start of an LLM run.
   * @param run The LLM run that has started.
   * @returns void
   */
  onLLMStart(e) {
    const n = this.getBreadcrumbs(e), a = "prompts" in e.inputs ? { prompts: e.inputs.prompts.map((r) => r.trim()) } : e.inputs;
    console.log(`${Zt(nn.green, "[llm/start]")} [${n}] Entering LLM run with input: ${qn(a, "[inputs]")}`);
  }
  /**
   * Method used to log the end of an LLM run.
   * @param run The LLM run that has ended.
   * @returns void
   */
  onLLMEnd(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Zt(nn.cyan, "[llm/end]")} [${n}] [${Ys(e)}] Exiting LLM run with output: ${qn(e.outputs, "[response]")}`);
  }
  /**
   * Method used to log any errors of an LLM run.
   * @param run The LLM run that has errored.
   * @returns void
   */
  onLLMError(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Zt(nn.red, "[llm/error]")} [${n}] [${Ys(e)}] LLM run errored with error: ${qn(e.error, "[error]")}`);
  }
  /**
   * Method used to log the start of a tool run.
   * @param run The tool run that has started.
   * @returns void
   */
  onToolStart(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Zt(nn.green, "[tool/start]")} [${n}] Entering Tool run with input: "${Ew(e.inputs.input)}"`);
  }
  /**
   * Method used to log the end of a tool run.
   * @param run The tool run that has ended.
   * @returns void
   */
  onToolEnd(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Zt(nn.cyan, "[tool/end]")} [${n}] [${Ys(e)}] Exiting Tool run with output: "${Ew(e.outputs?.output)}"`);
  }
  /**
   * Method used to log any errors of a tool run.
   * @param run The tool run that has errored.
   * @returns void
   */
  onToolError(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Zt(nn.red, "[tool/error]")} [${n}] [${Ys(e)}] Tool run errored with error: ${qn(e.error, "[error]")}`);
  }
  /**
   * Method used to log the start of a retriever run.
   * @param run The retriever run that has started.
   * @returns void
   */
  onRetrieverStart(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Zt(nn.green, "[retriever/start]")} [${n}] Entering Retriever run with input: ${qn(e.inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of a retriever run.
   * @param run The retriever run that has ended.
   * @returns void
   */
  onRetrieverEnd(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Zt(nn.cyan, "[retriever/end]")} [${n}] [${Ys(e)}] Exiting Retriever run with output: ${qn(e.outputs, "[outputs]")}`);
  }
  /**
   * Method used to log any errors of a retriever run.
   * @param run The retriever run that has errored.
   * @returns void
   */
  onRetrieverError(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Zt(nn.red, "[retriever/error]")} [${n}] [${Ys(e)}] Retriever run errored with error: ${qn(e.error, "[error]")}`);
  }
  /**
   * Method used to log the action selected by the agent.
   * @param run The run in which the agent action occurred.
   * @returns void
   */
  onAgentAction(e) {
    const n = e, a = this.getBreadcrumbs(e);
    console.log(`${Zt(nn.blue, "[agent/action]")} [${a}] Agent selected action: ${qn(n.actions[n.actions.length - 1], "[action]")}`);
  }
}
let Dm;
const bk = () => {
  if (Dm === void 0) {
    const t = ft("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? {
      // LangSmith has its own backgrounding system
      blockOnRootRunFinalization: !0
    } : {};
    Dm = new Od(t);
  }
  return Dm;
};
class Xl extends Zd {
  constructor(e = {}) {
    super(e), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "langchain_tracer"
    }), Object.defineProperty(this, "projectName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "exampleId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { exampleId: n, projectName: a, client: r } = e;
    this.projectName = a ?? ft("LANGCHAIN_PROJECT") ?? ft("LANGCHAIN_SESSION"), this.exampleId = n, this.client = r ?? bk();
    const i = Xl.getTraceableRunTree();
    i && this.updateFromRunTree(i);
  }
  async _convertToCreate(e, n = void 0) {
    return {
      ...e,
      extra: {
        ...e.extra,
        runtime: await ck()
      },
      child_runs: void 0,
      session_name: this.projectName,
      reference_example_id: e.parent_run_id ? void 0 : n
    };
  }
  async persistRun(e) {
  }
  async onRunCreate(e) {
    const n = await this._convertToCreate(e, this.exampleId);
    await this.client.createRun(n);
  }
  async onRunUpdate(e) {
    const n = {
      end_time: e.end_time,
      error: e.error,
      outputs: e.outputs,
      events: e.events,
      inputs: e.inputs,
      trace_id: e.trace_id,
      dotted_order: e.dotted_order,
      parent_run_id: e.parent_run_id,
      extra: e.extra
    };
    await this.client.updateRun(e.id, n);
  }
  getRun(e) {
    return this.runMap.get(e);
  }
  updateFromRunTree(e) {
    let n = e;
    const a = /* @__PURE__ */ new Set();
    for (; n.parent_run && !(a.has(n.id) || (a.add(n.id), !n.parent_run)); )
      n = n.parent_run;
    a.clear();
    const r = [n];
    for (; r.length > 0; ) {
      const i = r.shift();
      !i || a.has(i.id) || (a.add(i.id), this.runMap.set(i.id, i), i.child_runs && r.push(...i.child_runs));
    }
    this.client = e.client ?? this.client, this.projectName = e.project_name ?? this.projectName, this.exampleId = e.reference_example_id ?? this.exampleId;
  }
  convertToRunTree(e) {
    const n = {}, a = [];
    for (const [r, i] of this.runMap) {
      const s = new wn({
        ...i,
        child_runs: [],
        parent_run: void 0,
        // inherited properties
        client: this.client,
        project_name: this.projectName,
        reference_example_id: this.exampleId,
        tracingEnabled: !0
      });
      n[r] = s, a.push([r, i.dotted_order]);
    }
    a.sort((r, i) => !r[1] || !i[1] ? 0 : r[1].localeCompare(i[1]));
    for (const [r] of a) {
      const i = this.runMap.get(r), s = n[r];
      if (!(!i || !s) && i.parent_run_id) {
        const o = n[i.parent_run_id];
        o && (o.child_runs.push(s), s.parent_run = o);
      }
    }
    return n[e];
  }
  static getTraceableRunTree() {
    try {
      return WN();
    } catch {
      return;
    }
  }
}
const TC = Symbol.for("ls:tracing_async_local_storage"), dh = Symbol.for("lc:context_variables"), gk = (t) => {
  globalThis[TC] = t;
}, jd = () => globalThis[TC];
let Ql;
function _k() {
  const t = "default" in Bs ? Bs.default : Bs;
  return new t({
    autoStart: !0,
    concurrency: 1
  });
}
function yk() {
  return typeof Ql > "u" && (Ql = _k()), Ql;
}
async function yt(t, e) {
  if (e === !0) {
    const n = jd();
    n !== void 0 ? await n.run(void 0, async () => t()) : await t();
  } else
    Ql = yk(), Ql.add(async () => {
      const n = jd();
      n !== void 0 ? await n.run(void 0, async () => t()) : await t();
    });
}
const wk = (t) => !![
  "LANGSMITH_TRACING_V2",
  "LANGCHAIN_TRACING_V2",
  "LANGSMITH_TRACING",
  "LANGCHAIN_TRACING"
].find((n) => ft(n) === "true");
function $C(t) {
  const e = jd();
  return e === void 0 ? void 0 : e.getStore()?.[dh]?.[t];
}
const vk = Symbol("lc:configure_hooks"), Sk = () => $C(vk) || [];
function Cp(t) {
  return t ? Array.isArray(t) || "name" in t ? { callbacks: t } : t : {};
}
class Ok {
  setHandler(e) {
    return this.setHandlers([e]);
  }
}
class Tp {
  constructor(e, n, a, r, i, s, o, l) {
    Object.defineProperty(this, "runId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "handlers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "inheritableHandlers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "inheritableTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "inheritableMetadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: o
    }), Object.defineProperty(this, "_parentRunId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    });
  }
  get parentRunId() {
    return this._parentRunId;
  }
  async handleText(e) {
    await Promise.all(this.handlers.map((n) => yt(async () => {
      try {
        await n.handleText?.(e, this.runId, this._parentRunId, this.tags);
      } catch (a) {
        if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleText: ${a}`), n.raiseError)
          throw a;
      }
    }, n.awaitHandlers)));
  }
  async handleCustomEvent(e, n, a, r, i) {
    await Promise.all(this.handlers.map((s) => yt(async () => {
      try {
        await s.handleCustomEvent?.(e, n, this.runId, this.tags, this.metadata);
      } catch (o) {
        if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleCustomEvent: ${o}`), s.raiseError)
          throw o;
      }
    }, s.awaitHandlers)));
  }
}
class jk extends Tp {
  getChild(e) {
    const n = new st(this.runId);
    return n.setHandlers(this.inheritableHandlers), n.addTags(this.inheritableTags), n.addMetadata(this.inheritableMetadata), e && n.addTags([e], !1), n;
  }
  async handleRetrieverEnd(e) {
    await Promise.all(this.handlers.map((n) => yt(async () => {
      if (!n.ignoreRetriever)
        try {
          await n.handleRetrieverEnd?.(e, this.runId, this._parentRunId, this.tags);
        } catch (a) {
          if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleRetriever`), n.raiseError)
            throw a;
        }
    }, n.awaitHandlers)));
  }
  async handleRetrieverError(e) {
    await Promise.all(this.handlers.map((n) => yt(async () => {
      if (!n.ignoreRetriever)
        try {
          await n.handleRetrieverError?.(e, this.runId, this._parentRunId, this.tags);
        } catch (a) {
          if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleRetrieverError: ${a}`), n.raiseError)
            throw e;
        }
    }, n.awaitHandlers)));
  }
}
class Nw extends Tp {
  async handleLLMNewToken(e, n, a, r, i, s) {
    await Promise.all(this.handlers.map((o) => yt(async () => {
      if (!o.ignoreLLM)
        try {
          await o.handleLLMNewToken?.(e, n ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, s);
        } catch (l) {
          if ((o.raiseError ? console.error : console.warn)(`Error in handler ${o.constructor.name}, handleLLMNewToken: ${l}`), o.raiseError)
            throw l;
        }
    }, o.awaitHandlers)));
  }
  async handleLLMError(e, n, a, r, i) {
    await Promise.all(this.handlers.map((s) => yt(async () => {
      if (!s.ignoreLLM)
        try {
          await s.handleLLMError?.(e, this.runId, this._parentRunId, this.tags, i);
        } catch (o) {
          if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleLLMError: ${o}`), s.raiseError)
            throw o;
        }
    }, s.awaitHandlers)));
  }
  async handleLLMEnd(e, n, a, r, i) {
    await Promise.all(this.handlers.map((s) => yt(async () => {
      if (!s.ignoreLLM)
        try {
          await s.handleLLMEnd?.(e, this.runId, this._parentRunId, this.tags, i);
        } catch (o) {
          if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleLLMEnd: ${o}`), s.raiseError)
            throw o;
        }
    }, s.awaitHandlers)));
  }
}
class Pk extends Tp {
  getChild(e) {
    const n = new st(this.runId);
    return n.setHandlers(this.inheritableHandlers), n.addTags(this.inheritableTags), n.addMetadata(this.inheritableMetadata), e && n.addTags([e], !1), n;
  }
  async handleChainError(e, n, a, r, i) {
    await Promise.all(this.handlers.map((s) => yt(async () => {
      if (!s.ignoreChain)
        try {
          await s.handleChainError?.(e, this.runId, this._parentRunId, this.tags, i);
        } catch (o) {
          if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleChainError: ${o}`), s.raiseError)
            throw o;
        }
    }, s.awaitHandlers)));
  }
  async handleChainEnd(e, n, a, r, i) {
    await Promise.all(this.handlers.map((s) => yt(async () => {
      if (!s.ignoreChain)
        try {
          await s.handleChainEnd?.(e, this.runId, this._parentRunId, this.tags, i);
        } catch (o) {
          if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleChainEnd: ${o}`), s.raiseError)
            throw o;
        }
    }, s.awaitHandlers)));
  }
  async handleAgentAction(e) {
    await Promise.all(this.handlers.map((n) => yt(async () => {
      if (!n.ignoreAgent)
        try {
          await n.handleAgentAction?.(e, this.runId, this._parentRunId, this.tags);
        } catch (a) {
          if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleAgentAction: ${a}`), n.raiseError)
            throw a;
        }
    }, n.awaitHandlers)));
  }
  async handleAgentEnd(e) {
    await Promise.all(this.handlers.map((n) => yt(async () => {
      if (!n.ignoreAgent)
        try {
          await n.handleAgentEnd?.(e, this.runId, this._parentRunId, this.tags);
        } catch (a) {
          if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleAgentEnd: ${a}`), n.raiseError)
            throw a;
        }
    }, n.awaitHandlers)));
  }
}
class Rk extends Tp {
  getChild(e) {
    const n = new st(this.runId);
    return n.setHandlers(this.inheritableHandlers), n.addTags(this.inheritableTags), n.addMetadata(this.inheritableMetadata), e && n.addTags([e], !1), n;
  }
  async handleToolError(e) {
    await Promise.all(this.handlers.map((n) => yt(async () => {
      if (!n.ignoreAgent)
        try {
          await n.handleToolError?.(e, this.runId, this._parentRunId, this.tags);
        } catch (a) {
          if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleToolError: ${a}`), n.raiseError)
            throw a;
        }
    }, n.awaitHandlers)));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleToolEnd(e) {
    await Promise.all(this.handlers.map((n) => yt(async () => {
      if (!n.ignoreAgent)
        try {
          await n.handleToolEnd?.(e, this.runId, this._parentRunId, this.tags);
        } catch (a) {
          if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleToolEnd: ${a}`), n.raiseError)
            throw a;
        }
    }, n.awaitHandlers)));
  }
}
class st extends Ok {
  constructor(e, n) {
    super(), Object.defineProperty(this, "handlers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "inheritableHandlers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "inheritableTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "inheritableMetadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "callback_manager"
    }), Object.defineProperty(this, "_parentRunId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.handlers = n?.handlers ?? this.handlers, this.inheritableHandlers = n?.inheritableHandlers ?? this.inheritableHandlers, this.tags = n?.tags ?? this.tags, this.inheritableTags = n?.inheritableTags ?? this.inheritableTags, this.metadata = n?.metadata ?? this.metadata, this.inheritableMetadata = n?.inheritableMetadata ?? this.inheritableMetadata, this._parentRunId = e;
  }
  /**
   * Gets the parent run ID, if any.
   *
   * @returns The parent run ID.
   */
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(e, n, a = void 0, r = void 0, i = void 0, s = void 0, o = void 0, l = void 0) {
    return Promise.all(n.map(async (f, u) => {
      const c = u === 0 && a ? a : Pt();
      return await Promise.all(this.handlers.map((h) => {
        if (!h.ignoreLLM)
          return Oc(h) && h._createRunForLLMStart(e, [f], c, this._parentRunId, i, this.tags, this.metadata, l), yt(async () => {
            try {
              await h.handleLLMStart?.(e, [f], c, this._parentRunId, i, this.tags, this.metadata, l);
            } catch (p) {
              if ((h.raiseError ? console.error : console.warn)(`Error in handler ${h.constructor.name}, handleLLMStart: ${p}`), h.raiseError)
                throw p;
            }
          }, h.awaitHandlers);
      })), new Nw(c, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(e, n, a = void 0, r = void 0, i = void 0, s = void 0, o = void 0, l = void 0) {
    return Promise.all(n.map(async (f, u) => {
      const c = u === 0 && a ? a : Pt();
      return await Promise.all(this.handlers.map((h) => {
        if (!h.ignoreLLM)
          return Oc(h) && h._createRunForChatModelStart(e, [f], c, this._parentRunId, i, this.tags, this.metadata, l), yt(async () => {
            try {
              if (h.handleChatModelStart)
                await h.handleChatModelStart?.(e, [f], c, this._parentRunId, i, this.tags, this.metadata, l);
              else if (h.handleLLMStart) {
                const p = lo(f);
                await h.handleLLMStart?.(e, [p], c, this._parentRunId, i, this.tags, this.metadata, l);
              }
            } catch (p) {
              if ((h.raiseError ? console.error : console.warn)(`Error in handler ${h.constructor.name}, handleLLMStart: ${p}`), h.raiseError)
                throw p;
            }
          }, h.awaitHandlers);
      })), new Nw(c, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(e, n, a = Pt(), r = void 0, i = void 0, s = void 0, o = void 0) {
    return await Promise.all(this.handlers.map((l) => {
      if (!l.ignoreChain)
        return Oc(l) && l._createRunForChainStart(e, n, a, this._parentRunId, this.tags, this.metadata, r, o), yt(async () => {
          try {
            await l.handleChainStart?.(e, n, a, this._parentRunId, this.tags, this.metadata, r, o);
          } catch (f) {
            if ((l.raiseError ? console.error : console.warn)(`Error in handler ${l.constructor.name}, handleChainStart: ${f}`), l.raiseError)
              throw f;
          }
        }, l.awaitHandlers);
    })), new Pk(a, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(e, n, a = Pt(), r = void 0, i = void 0, s = void 0, o = void 0) {
    return await Promise.all(this.handlers.map((l) => {
      if (!l.ignoreAgent)
        return Oc(l) && l._createRunForToolStart(e, n, a, this._parentRunId, this.tags, this.metadata, o), yt(async () => {
          try {
            await l.handleToolStart?.(e, n, a, this._parentRunId, this.tags, this.metadata, o);
          } catch (f) {
            if ((l.raiseError ? console.error : console.warn)(`Error in handler ${l.constructor.name}, handleToolStart: ${f}`), l.raiseError)
              throw f;
          }
        }, l.awaitHandlers);
    })), new Rk(a, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(e, n, a = Pt(), r = void 0, i = void 0, s = void 0, o = void 0) {
    return await Promise.all(this.handlers.map((l) => {
      if (!l.ignoreRetriever)
        return Oc(l) && l._createRunForRetrieverStart(e, n, a, this._parentRunId, this.tags, this.metadata, o), yt(async () => {
          try {
            await l.handleRetrieverStart?.(e, n, a, this._parentRunId, this.tags, this.metadata, o);
          } catch (f) {
            if ((l.raiseError ? console.error : console.warn)(`Error in handler ${l.constructor.name}, handleRetrieverStart: ${f}`), l.raiseError)
              throw f;
          }
        }, l.awaitHandlers);
    })), new jk(a, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleCustomEvent(e, n, a, r, i) {
    await Promise.all(this.handlers.map((s) => yt(async () => {
      if (!s.ignoreCustomEvent)
        try {
          await s.handleCustomEvent?.(e, n, a, this.tags, this.metadata);
        } catch (o) {
          if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleCustomEvent: ${o}`), s.raiseError)
            throw o;
        }
    }, s.awaitHandlers)));
  }
  addHandler(e, n = !0) {
    this.handlers.push(e), n && this.inheritableHandlers.push(e);
  }
  removeHandler(e) {
    this.handlers = this.handlers.filter((n) => n !== e), this.inheritableHandlers = this.inheritableHandlers.filter((n) => n !== e);
  }
  setHandlers(e, n = !0) {
    this.handlers = [], this.inheritableHandlers = [];
    for (const a of e)
      this.addHandler(a, n);
  }
  addTags(e, n = !0) {
    this.removeTags(e), this.tags.push(...e), n && this.inheritableTags.push(...e);
  }
  removeTags(e) {
    this.tags = this.tags.filter((n) => !e.includes(n)), this.inheritableTags = this.inheritableTags.filter((n) => !e.includes(n));
  }
  addMetadata(e, n = !0) {
    this.metadata = { ...this.metadata, ...e }, n && (this.inheritableMetadata = { ...this.inheritableMetadata, ...e });
  }
  removeMetadata(e) {
    for (const n of Object.keys(e))
      delete this.metadata[n], delete this.inheritableMetadata[n];
  }
  copy(e = [], n = !0) {
    const a = new st(this._parentRunId);
    for (const r of this.handlers) {
      const i = this.inheritableHandlers.includes(r);
      a.addHandler(r, i);
    }
    for (const r of this.tags) {
      const i = this.inheritableTags.includes(r);
      a.addTags([r], i);
    }
    for (const r of Object.keys(this.metadata)) {
      const i = Object.keys(this.inheritableMetadata).includes(r);
      a.addMetadata({ [r]: this.metadata[r] }, i);
    }
    for (const r of e)
      // Prevent multiple copies of console_callback_handler
      a.handlers.filter((i) => i.name === "console_callback_handler").some((i) => i.name === r.name) || a.addHandler(r, n);
    return a;
  }
  static fromHandlers(e) {
    class n extends cc {
      constructor() {
        super(), Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: Pt()
        }), Object.assign(this, e);
      }
    }
    const a = new this();
    return a.addHandler(new n()), a;
  }
  static configure(e, n, a, r, i, s, o) {
    return this._configureSync(e, n, a, r, i, s, o);
  }
  // TODO: Deprecate async method in favor of this one.
  static _configureSync(e, n, a, r, i, s, o) {
    let l;
    (e || n) && (Array.isArray(e) || !e ? (l = new st(), l.setHandlers(e?.map(qh) ?? [], !0)) : l = e, l = l.copy(Array.isArray(n) ? n.map(qh) : n?.handlers, !1));
    const f = ft("LANGCHAIN_VERBOSE") === "true" || o?.verbose, u = Xl.getTraceableRunTree()?.tracingEnabled || wk(), c = u || (ft("LANGCHAIN_TRACING") ?? !1);
    if (f || c) {
      if (l || (l = new st()), f && !l.handlers.some((h) => h.name === Iw.prototype.name)) {
        const h = new Iw();
        l.addHandler(h, !0);
      }
      if (c && !l.handlers.some((h) => h.name === "langchain_tracer") && u) {
        const h = new Xl();
        l.addHandler(h, !0), l._parentRunId = Xl.getTraceableRunTree()?.id ?? l._parentRunId;
      }
    }
    for (const { contextVar: h, inheritable: p = !0, handlerClass: d, envVar: m } of Sk()) {
      const b = m && ft(m) === "true" && d;
      let g;
      const _ = h !== void 0 ? $C(h) : void 0;
      _ && dk(_) ? g = _ : b && (g = new d({})), g !== void 0 && (l || (l = new st()), l.handlers.some((P) => P.name === g.name) || l.addHandler(g, p));
    }
    return (a || r) && l && (l.addTags(a ?? []), l.addTags(r ?? [], !1)), (i || s) && l && (l.addMetadata(i ?? {}), l.addMetadata(s ?? {}, !1)), l;
  }
}
function qh(t) {
  return "name" in t ? t : cc.fromMethods(t);
}
class Ck {
  getStore() {
  }
  run(e, n) {
    return n();
  }
  enterWith(e) {
  }
}
const Tk = new Ck(), kw = Symbol.for("lc:child_config");
class $k {
  getInstance() {
    return jd() ?? Tk;
  }
  getRunnableConfig() {
    return this.getInstance().getStore()?.extra?.[kw];
  }
  runWithConfig(e, n, a) {
    const r = st._configureSync(e?.callbacks, void 0, e?.tags, void 0, e?.metadata), i = this.getInstance(), s = i.getStore(), o = r?.getParentRunId(), l = r?.handlers?.find((u) => u?.name === "langchain_tracer");
    let f;
    return l && o ? f = l.convertToRunTree(o) : a || (f = new wn({
      name: "<runnable_lambda>",
      tracingEnabled: !1
    })), f && (f.extra = { ...f.extra, [kw]: e }), s !== void 0 && s[dh] !== void 0 && (f === void 0 && (f = {}), f[dh] = s[dh]), i.run(f, n);
  }
  initializeGlobalInstance(e) {
    jd() === void 0 && gk(e);
  }
}
const xn = new $k(), qm = 25;
async function Vn(t) {
  return st._configureSync(t?.callbacks, void 0, t?.tags, void 0, t?.metadata);
}
function oa(...t) {
  const e = {};
  for (const n of t.filter((a) => !!a))
    for (const a of Object.keys(n))
      if (a === "metadata")
        e[a] = { ...e[a], ...n[a] };
      else if (a === "tags") {
        const r = e[a] ?? [];
        e[a] = [...new Set(r.concat(n[a] ?? []))];
      } else if (a === "configurable")
        e[a] = { ...e[a], ...n[a] };
      else if (a === "timeout")
        e.timeout === void 0 ? e.timeout = n.timeout : n.timeout !== void 0 && (e.timeout = Math.min(e.timeout, n.timeout));
      else if (a === "signal")
        e.signal === void 0 ? e.signal = n.signal : n.signal !== void 0 && ("any" in AbortSignal ? e.signal = AbortSignal.any([
          e.signal,
          n.signal
        ]) : e.signal = n.signal);
      else if (a === "callbacks") {
        const r = e.callbacks, i = n.callbacks;
        if (Array.isArray(i))
          if (!r)
            e.callbacks = i;
          else if (Array.isArray(r))
            e.callbacks = r.concat(i);
          else {
            const s = r.copy();
            for (const o of i)
              s.addHandler(qh(o), !0);
            e.callbacks = s;
          }
        else if (i)
          if (!r)
            e.callbacks = i;
          else if (Array.isArray(r)) {
            const s = i.copy();
            for (const o of r)
              s.addHandler(qh(o), !0);
            e.callbacks = s;
          } else
            e.callbacks = new st(i._parentRunId, {
              handlers: r.handlers.concat(i.handlers),
              inheritableHandlers: r.inheritableHandlers.concat(i.inheritableHandlers),
              tags: Array.from(new Set(r.tags.concat(i.tags))),
              inheritableTags: Array.from(new Set(r.inheritableTags.concat(i.inheritableTags))),
              metadata: {
                ...r.metadata,
                ...i.metadata
              }
            });
      } else {
        const r = a;
        e[r] = n[r] ?? e[r];
      }
  return e;
}
const Mk = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
function Re(t) {
  const e = xn.getRunnableConfig();
  let n = {
    tags: [],
    metadata: {},
    recursionLimit: 25,
    runId: void 0
  };
  if (e) {
    const { runId: a, runName: r, ...i } = e;
    n = Object.entries(i).reduce(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (s, [o, l]) => (l !== void 0 && (s[o] = l), s),
      n
    );
  }
  if (t && (n = Object.entries(t).reduce(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (a, [r, i]) => (i !== void 0 && (a[r] = i), a),
    n
  )), n?.configurable)
    for (const a of Object.keys(n.configurable))
      Mk.has(typeof n.configurable[a]) && !n.metadata?.[a] && (n.metadata || (n.metadata = {}), n.metadata[a] = n.configurable[a]);
  if (n.timeout !== void 0) {
    if (n.timeout <= 0)
      throw new Error("Timeout must be a positive number");
    const a = AbortSignal.timeout(n.timeout);
    n.signal !== void 0 ? "any" in AbortSignal && (n.signal = AbortSignal.any([n.signal, a])) : n.signal = a, delete n.timeout;
  }
  return n;
}
function Ye(t = {}, { callbacks: e, maxConcurrency: n, recursionLimit: a, runName: r, configurable: i, runId: s } = {}) {
  const o = Re(t);
  return e !== void 0 && (delete o.runName, o.callbacks = e), a !== void 0 && (o.recursionLimit = a), n !== void 0 && (o.maxConcurrency = n), r !== void 0 && (o.runName = r), i !== void 0 && (o.configurable = { ...o.configurable, ...i }), s !== void 0 && delete o.runId, o;
}
function Qu(t) {
  return t ? {
    configurable: t.configurable,
    recursionLimit: t.recursionLimit,
    callbacks: t.callbacks,
    tags: t.tags,
    metadata: t.metadata,
    maxConcurrency: t.maxConcurrency,
    timeout: t.timeout,
    signal: t.signal
  } : void 0;
}
async function go(t, e) {
  if (e === void 0)
    return t;
  let n;
  return Promise.race([
    t.catch((a) => {
      if (!e?.aborted)
        throw a;
    }),
    new Promise((a, r) => {
      n = () => {
        r(new Error("Aborted"));
      }, e.addEventListener("abort", n), e.aborted && r(new Error("Aborted"));
    })
  ]).finally(() => e.removeEventListener("abort", n));
}
class ln extends ReadableStream {
  constructor() {
    super(...arguments), Object.defineProperty(this, "reader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  ensureReader() {
    this.reader || (this.reader = this.getReader());
  }
  async next() {
    this.ensureReader();
    try {
      const e = await this.reader.read();
      return e.done ? (this.reader.releaseLock(), {
        done: !0,
        value: void 0
      }) : {
        done: !1,
        value: e.value
      };
    } catch (e) {
      throw this.reader.releaseLock(), e;
    }
  }
  async return() {
    if (this.ensureReader(), this.locked) {
      const e = this.reader.cancel();
      this.reader.releaseLock(), await e;
    }
    return { done: !0, value: void 0 };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async throw(e) {
    if (this.ensureReader(), this.locked) {
      const n = this.reader.cancel();
      this.reader.releaseLock(), await n;
    }
    throw e;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore Not present in Node 18 types, required in latest Node 22
  async [Symbol.asyncDispose]() {
    await this.return();
  }
  static fromReadableStream(e) {
    const n = e.getReader();
    return new ln({
      start(a) {
        return r();
        function r() {
          return n.read().then(({ done: i, value: s }) => {
            if (i) {
              a.close();
              return;
            }
            return a.enqueue(s), r();
          });
        }
      },
      cancel() {
        n.releaseLock();
      }
    });
  }
  static fromAsyncGenerator(e) {
    return new ln({
      async pull(n) {
        const { value: a, done: r } = await e.next();
        r && n.close(), n.enqueue(a);
      },
      async cancel(n) {
        await e.return(n);
      }
    });
  }
}
function MC(t, e = 2) {
  const n = Array.from({ length: e }, () => []);
  return n.map(async function* (r) {
    for (; ; )
      if (r.length === 0) {
        const i = await t.next();
        for (const s of n)
          s.push(i);
      } else {
        if (r[0].done)
          return;
        yield r.shift().value;
      }
  });
}
function on(t, e) {
  if (Array.isArray(t) && Array.isArray(e))
    return t.concat(e);
  if (typeof t == "string" && typeof e == "string")
    return t + e;
  if (typeof t == "number" && typeof e == "number")
    return t + e;
  if (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    "concat" in t && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof t.concat == "function"
  )
    return t.concat(e);
  if (typeof t == "object" && typeof e == "object") {
    const n = { ...t };
    for (const [a, r] of Object.entries(e))
      a in n && !Array.isArray(n[a]) ? n[a] = on(n[a], r) : n[a] = r;
    return n;
  } else
    throw new Error(`Cannot concat ${typeof t} and ${typeof e}`);
}
class lc {
  constructor(e) {
    Object.defineProperty(this, "generator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "setup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "firstResult", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "firstResultUsed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.generator = e.generator, this.config = e.config, this.signal = e.signal ?? this.config?.signal, this.setup = new Promise((n, a) => {
      xn.runWithConfig(Qu(e.config), async () => {
        this.firstResult = e.generator.next(), e.startSetup ? this.firstResult.then(e.startSetup).then(n, a) : this.firstResult.then((r) => n(void 0), a);
      }, !0);
    });
  }
  async next(...e) {
    return this.signal?.throwIfAborted(), this.firstResultUsed ? xn.runWithConfig(Qu(this.config), this.signal ? async () => go(this.generator.next(...e), this.signal) : async () => this.generator.next(...e), !0) : (this.firstResultUsed = !0, this.firstResult);
  }
  async return(e) {
    return this.generator.return(e);
  }
  async throw(e) {
    return this.generator.throw(e);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore Not present in Node 18 types, required in latest Node 22
  async [Symbol.asyncDispose]() {
    await this.return();
  }
}
async function Ak(t, e, n, a, ...r) {
  const i = new lc({
    generator: e,
    startSetup: n,
    signal: a
  }), s = await i.setup;
  return { output: t(i, s, ...r), setup: s };
}
class ao {
  constructor(e) {
    Object.defineProperty(this, "ops", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.ops = e.ops ?? [];
  }
  concat(e) {
    const n = this.ops.concat(e.ops), a = Fh({}, n);
    return new Pd({
      ops: n,
      state: a[a.length - 1].newDocument
    });
  }
}
class Pd extends ao {
  constructor(e) {
    super(e), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.state = e.state;
  }
  concat(e) {
    const n = this.ops.concat(e.ops), a = Fh(this.state, e.ops);
    return new Pd({ ops: n, state: a[a.length - 1].newDocument });
  }
  static fromRunLogPatch(e) {
    const n = Fh({}, e.ops);
    return new Pd({
      ops: e.ops,
      state: n[n.length - 1].newDocument
    });
  }
}
const Ek = (t) => t.name === "log_stream_tracer";
async function Fw(t, e) {
  if (e === "original")
    throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  const { inputs: n } = t;
  if (["retriever", "llm", "prompt"].includes(t.run_type))
    return n;
  if (!(Object.keys(n).length === 1 && n?.input === ""))
    return n.input;
}
async function Dw(t, e) {
  const { outputs: n } = t;
  return e === "original" || ["retriever", "llm", "prompt"].includes(t.run_type) ? n : n !== void 0 && Object.keys(n).length === 1 && n?.output !== void 0 ? n.output : n;
}
function Ik(t) {
  return t !== void 0 && t.message !== void 0;
}
class qw extends Zd {
  constructor(e) {
    super({ _awaitHandler: !0, ...e }), Object.defineProperty(this, "autoClose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "includeNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "includeTypes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "includeTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeTypes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_schemaFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "original"
    }), Object.defineProperty(this, "rootId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "keyMapByRunId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "counterMapByRunName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "transformStream", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "writer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "receiveStream", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "log_stream_tracer"
    }), Object.defineProperty(this, "lc_prefer_streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.autoClose = e?.autoClose ?? !0, this.includeNames = e?.includeNames, this.includeTypes = e?.includeTypes, this.includeTags = e?.includeTags, this.excludeNames = e?.excludeNames, this.excludeTypes = e?.excludeTypes, this.excludeTags = e?.excludeTags, this._schemaFormat = e?._schemaFormat ?? this._schemaFormat, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = ln.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(e) {
  }
  _includeRun(e) {
    if (e.id === this.rootId)
      return !1;
    const n = e.tags ?? [];
    let a = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    return this.includeNames !== void 0 && (a = a || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (a = a || this.includeTypes.includes(e.run_type)), this.includeTags !== void 0 && (a = a || n.find((r) => this.includeTags?.includes(r)) !== void 0), this.excludeNames !== void 0 && (a = a && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (a = a && !this.excludeTypes.includes(e.run_type)), this.excludeTags !== void 0 && (a = a && n.every((r) => !this.excludeTags?.includes(r))), a;
  }
  async *tapOutputIterable(e, n) {
    for await (const a of n) {
      if (e !== this.rootId) {
        const r = this.keyMapByRunId[e];
        r && await this.writer.write(new ao({
          ops: [
            {
              op: "add",
              path: `/logs/${r}/streamed_output/-`,
              value: a
            }
          ]
        }));
      }
      yield a;
    }
  }
  async onRunCreate(e) {
    if (this.rootId === void 0 && (this.rootId = e.id, await this.writer.write(new ao({
      ops: [
        {
          op: "replace",
          path: "",
          value: {
            id: e.id,
            name: e.name,
            type: e.run_type,
            streamed_output: [],
            final_output: void 0,
            logs: {}
          }
        }
      ]
    }))), !this._includeRun(e))
      return;
    this.counterMapByRunName[e.name] === void 0 && (this.counterMapByRunName[e.name] = 0), this.counterMapByRunName[e.name] += 1;
    const n = this.counterMapByRunName[e.name];
    this.keyMapByRunId[e.id] = n === 1 ? e.name : `${e.name}:${n}`;
    const a = {
      id: e.id,
      name: e.name,
      type: e.run_type,
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      start_time: new Date(e.start_time).toISOString(),
      streamed_output: [],
      streamed_output_str: [],
      final_output: void 0,
      end_time: void 0
    };
    this._schemaFormat === "streaming_events" && (a.inputs = await Fw(e, this._schemaFormat)), await this.writer.write(new ao({
      ops: [
        {
          op: "add",
          path: `/logs/${this.keyMapByRunId[e.id]}`,
          value: a
        }
      ]
    }));
  }
  async onRunUpdate(e) {
    try {
      const n = this.keyMapByRunId[e.id];
      if (n === void 0)
        return;
      const a = [];
      this._schemaFormat === "streaming_events" && a.push({
        op: "replace",
        path: `/logs/${n}/inputs`,
        value: await Fw(e, this._schemaFormat)
      }), a.push({
        op: "add",
        path: `/logs/${n}/final_output`,
        value: await Dw(e, this._schemaFormat)
      }), e.end_time !== void 0 && a.push({
        op: "add",
        path: `/logs/${n}/end_time`,
        value: new Date(e.end_time).toISOString()
      });
      const r = new ao({ ops: a });
      await this.writer.write(r);
    } finally {
      if (e.id === this.rootId) {
        const n = new ao({
          ops: [
            {
              op: "replace",
              path: "/final_output",
              value: await Dw(e, this._schemaFormat)
            }
          ]
        });
        await this.writer.write(n), this.autoClose && await this.writer.close();
      }
    }
  }
  async onLLMNewToken(e, n, a) {
    const r = this.keyMapByRunId[e.id];
    if (r === void 0)
      return;
    const i = e.inputs.messages !== void 0;
    let s;
    i ? Ik(a?.chunk) ? s = a?.chunk : s = new Ze({
      id: `run-${e.id}`,
      content: n
    }) : s = n;
    const o = new ao({
      ops: [
        {
          op: "add",
          path: `/logs/${r}/streamed_output_str/-`,
          value: n
        },
        {
          op: "add",
          path: `/logs/${r}/streamed_output/-`,
          value: s
        }
      ]
    });
    await this.writer.write(o);
  }
}
const Rd = "__run";
class ma {
  constructor(e) {
    Object.defineProperty(this, "text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "generationInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.text = e.text, this.generationInfo = e.generationInfo;
  }
  concat(e) {
    return new ma({
      text: this.text + e.text,
      generationInfo: {
        ...this.generationInfo,
        ...e.generationInfo
      }
    });
  }
}
class Bt extends ma {
  constructor(e) {
    super(e), Object.defineProperty(this, "message", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.message = e.message;
  }
  concat(e) {
    return new Bt({
      text: this.text + e.text,
      generationInfo: {
        ...this.generationInfo,
        ...e.generationInfo
      },
      message: this.message.concat(e.message)
    });
  }
}
function Pf({ name: t, serialized: e }) {
  return t !== void 0 ? t : e?.name !== void 0 ? e.name : e?.id !== void 0 && Array.isArray(e?.id) ? e.id[e.id.length - 1] : "Unnamed";
}
const Nk = (t) => t.name === "event_stream_tracer";
class kk extends Zd {
  constructor(e) {
    super({ _awaitHandler: !0, ...e }), Object.defineProperty(this, "autoClose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "includeNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "includeTypes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "includeTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeTypes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "runInfoMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "tappedPromises", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "transformStream", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "writer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "receiveStream", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "event_stream_tracer"
    }), Object.defineProperty(this, "lc_prefer_streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.autoClose = e?.autoClose ?? !0, this.includeNames = e?.includeNames, this.includeTypes = e?.includeTypes, this.includeTags = e?.includeTags, this.excludeNames = e?.excludeNames, this.excludeTypes = e?.excludeTypes, this.excludeTags = e?.excludeTags, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = ln.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(e) {
  }
  _includeRun(e) {
    const n = e.tags ?? [];
    let a = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    return this.includeNames !== void 0 && (a = a || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (a = a || this.includeTypes.includes(e.runType)), this.includeTags !== void 0 && (a = a || n.find((r) => this.includeTags?.includes(r)) !== void 0), this.excludeNames !== void 0 && (a = a && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (a = a && !this.excludeTypes.includes(e.runType)), this.excludeTags !== void 0 && (a = a && n.every((r) => !this.excludeTags?.includes(r))), a;
  }
  async *tapOutputIterable(e, n) {
    const a = await n.next();
    if (a.done)
      return;
    const r = this.runInfoMap.get(e);
    if (r === void 0) {
      yield a.value;
      return;
    }
    function i(o, l) {
      return o === "llm" && typeof l == "string" ? new ma({ text: l }) : l;
    }
    let s = this.tappedPromises.get(e);
    if (s === void 0) {
      let o;
      s = new Promise((l) => {
        o = l;
      }), this.tappedPromises.set(e, s);
      try {
        const l = {
          event: `on_${r.runType}_stream`,
          run_id: e,
          name: r.name,
          tags: r.tags,
          metadata: r.metadata,
          data: {}
        };
        await this.send({
          ...l,
          data: {
            chunk: i(r.runType, a.value)
          }
        }, r), yield a.value;
        for await (const f of n)
          r.runType !== "tool" && r.runType !== "retriever" && await this.send({
            ...l,
            data: {
              chunk: i(r.runType, f)
            }
          }, r), yield f;
      } finally {
        o();
      }
    } else {
      yield a.value;
      for await (const o of n)
        yield o;
    }
  }
  async send(e, n) {
    this._includeRun(n) && await this.writer.write(e);
  }
  async sendEndEvent(e, n) {
    const a = this.tappedPromises.get(e.run_id);
    a !== void 0 ? a.then(() => {
      this.send(e, n);
    }) : await this.send(e, n);
  }
  async onLLMStart(e) {
    const n = Pf(e), a = e.inputs.messages !== void 0 ? "chat_model" : "llm", r = {
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      name: n,
      runType: a,
      inputs: e.inputs
    };
    this.runInfoMap.set(e.id, r);
    const i = `on_${a}_start`;
    await this.send({
      event: i,
      data: {
        input: e.inputs
      },
      name: n,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: e.extra?.metadata ?? {}
    }, r);
  }
  async onLLMNewToken(e, n, a) {
    const r = this.runInfoMap.get(e.id);
    let i, s;
    if (r === void 0)
      throw new Error(`onLLMNewToken: Run ID ${e.id} not found in run map.`);
    if (this.runInfoMap.size !== 1) {
      if (r.runType === "chat_model")
        s = "on_chat_model_stream", a?.chunk === void 0 ? i = new Ze({ content: n, id: `run-${e.id}` }) : i = a.chunk.message;
      else if (r.runType === "llm")
        s = "on_llm_stream", a?.chunk === void 0 ? i = new ma({ text: n }) : i = a.chunk;
      else
        throw new Error(`Unexpected run type ${r.runType}`);
      await this.send({
        event: s,
        data: {
          chunk: i
        },
        run_id: e.id,
        name: r.name,
        tags: r.tags,
        metadata: r.metadata
      }, r);
    }
  }
  async onLLMEnd(e) {
    const n = this.runInfoMap.get(e.id);
    this.runInfoMap.delete(e.id);
    let a;
    if (n === void 0)
      throw new Error(`onLLMEnd: Run ID ${e.id} not found in run map.`);
    const r = e.outputs?.generations;
    let i;
    if (n.runType === "chat_model") {
      for (const s of r ?? []) {
        if (i !== void 0)
          break;
        i = s[0]?.message;
      }
      a = "on_chat_model_end";
    } else if (n.runType === "llm")
      i = {
        generations: r?.map((s) => s.map((o) => ({
          text: o.text,
          generationInfo: o.generationInfo
        }))),
        llmOutput: e.outputs?.llmOutput ?? {}
      }, a = "on_llm_end";
    else
      throw new Error(`onLLMEnd: Unexpected run type: ${n.runType}`);
    await this.sendEndEvent({
      event: a,
      data: {
        output: i,
        input: n.inputs
      },
      run_id: e.id,
      name: n.name,
      tags: n.tags,
      metadata: n.metadata
    }, n);
  }
  async onChainStart(e) {
    const n = Pf(e), a = e.run_type ?? "chain", r = {
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      name: n,
      runType: e.run_type
    };
    let i = {};
    e.inputs.input === "" && Object.keys(e.inputs).length === 1 ? (i = {}, r.inputs = {}) : e.inputs.input !== void 0 ? (i.input = e.inputs.input, r.inputs = e.inputs.input) : (i.input = e.inputs, r.inputs = e.inputs), this.runInfoMap.set(e.id, r), await this.send({
      event: `on_${a}_start`,
      data: i,
      name: n,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: e.extra?.metadata ?? {}
    }, r);
  }
  async onChainEnd(e) {
    const n = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), n === void 0)
      throw new Error(`onChainEnd: Run ID ${e.id} not found in run map.`);
    const a = `on_${e.run_type}_end`, r = e.inputs ?? n.inputs ?? {}, s = {
      output: e.outputs?.output ?? e.outputs,
      input: r
    };
    r.input && Object.keys(r).length === 1 && (s.input = r.input, n.inputs = r.input), await this.sendEndEvent({
      event: a,
      data: s,
      run_id: e.id,
      name: n.name,
      tags: n.tags,
      metadata: n.metadata ?? {}
    }, n);
  }
  async onToolStart(e) {
    const n = Pf(e), a = {
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      name: n,
      runType: "tool",
      inputs: e.inputs ?? {}
    };
    this.runInfoMap.set(e.id, a), await this.send({
      event: "on_tool_start",
      data: {
        input: e.inputs ?? {}
      },
      name: n,
      run_id: e.id,
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {}
    }, a);
  }
  async onToolEnd(e) {
    const n = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), n === void 0)
      throw new Error(`onToolEnd: Run ID ${e.id} not found in run map.`);
    if (n.inputs === void 0)
      throw new Error(`onToolEnd: Run ID ${e.id} is a tool call, and is expected to have traced inputs.`);
    const a = e.outputs?.output === void 0 ? e.outputs : e.outputs.output;
    await this.sendEndEvent({
      event: "on_tool_end",
      data: {
        output: a,
        input: n.inputs
      },
      run_id: e.id,
      name: n.name,
      tags: n.tags,
      metadata: n.metadata
    }, n);
  }
  async onRetrieverStart(e) {
    const n = Pf(e), r = {
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      name: n,
      runType: "retriever",
      inputs: {
        query: e.inputs.query
      }
    };
    this.runInfoMap.set(e.id, r), await this.send({
      event: "on_retriever_start",
      data: {
        input: {
          query: e.inputs.query
        }
      },
      name: n,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: e.extra?.metadata ?? {}
    }, r);
  }
  async onRetrieverEnd(e) {
    const n = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), n === void 0)
      throw new Error(`onRetrieverEnd: Run ID ${e.id} not found in run map.`);
    await this.sendEndEvent({
      event: "on_retriever_end",
      data: {
        output: e.outputs?.documents ?? e.outputs,
        input: n.inputs
      },
      run_id: e.id,
      name: n.name,
      tags: n.tags,
      metadata: n.metadata
    }, n);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleCustomEvent(e, n, a) {
    const r = this.runInfoMap.get(a);
    if (r === void 0)
      throw new Error(`handleCustomEvent: Run ID ${a} not found in run map.`);
    await this.send({
      event: "on_custom_event",
      run_id: a,
      name: e,
      tags: r.tags,
      metadata: r.metadata,
      data: n
    }, r);
  }
  async finish() {
    const e = [...this.tappedPromises.values()];
    Promise.all(e).finally(() => {
      this.writer.close();
    });
  }
}
const Fk = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  409
  // Conflict
], Dk = (t) => {
  if (t.message.startsWith("Cancel") || t.message.startsWith("AbortError") || t.name === "AbortError" || t?.code === "ECONNABORTED")
    throw t;
  const e = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    t?.response?.status ?? t?.status
  );
  if (e && Fk.includes(+e))
    throw t;
  if (t?.error?.code === "insufficient_quota") {
    const n = new Error(t?.message);
    throw n.name = "InsufficientQuotaError", n;
  }
};
class ru {
  constructor(e) {
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxRetries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onFailedAttempt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxConcurrency = e.maxConcurrency ?? 1 / 0, this.maxRetries = e.maxRetries ?? 6, this.onFailedAttempt = e.onFailedAttempt ?? Dk;
    const n = "default" in Bs ? Bs.default : Bs;
    this.queue = new n({ concurrency: this.maxConcurrency });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(e, ...n) {
    return this.queue.add(() => Ih(() => e(...n).catch((a) => {
      throw a instanceof Error ? a : new Error(a);
    }), {
      onFailedAttempt: this.onFailedAttempt,
      retries: this.maxRetries,
      randomize: !0
      // If needed we can change some of the defaults here,
      // but they're quite sensible.
    }), { throwOnTimeout: !0 });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(e, n, ...a) {
    return e.signal ? Promise.race([
      this.call(n, ...a),
      new Promise((r, i) => {
        e.signal?.addEventListener("abort", () => {
          i(new Error("AbortError"));
        });
      })
    ]) : this.call(n, ...a);
  }
  fetch(...e) {
    return this.call(() => fetch(...e).then((n) => n.ok ? n : Promise.reject(n)));
  }
}
class AC extends Zd {
  constructor({ config: e, onStart: n, onEnd: a, onError: r }) {
    super({ _awaitHandler: !0 }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RootListenersTracer"
    }), Object.defineProperty(this, "rootId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "argOnStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "argOnEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "argOnError", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.config = e, this.argOnStart = n, this.argOnEnd = a, this.argOnError = r;
  }
  /**
   * This is a legacy method only called once for an entire run tree
   * therefore not useful here
   * @param {Run} _ Not used
   */
  persistRun(e) {
    return Promise.resolve();
  }
  async onRunCreate(e) {
    this.rootId || (this.rootId = e.id, this.argOnStart && await this.argOnStart(e, this.config));
  }
  async onRunUpdate(e) {
    e.id === this.rootId && (e.error ? this.argOnError && await this.argOnError(e, this.config) : this.argOnEnd && await this.argOnEnd(e, this.config));
  }
}
function l_(t) {
  return t ? t.lc_runnable : !1;
}
class qk {
  constructor(e) {
    Object.defineProperty(this, "includeNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "includeTypes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "includeTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeTypes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.includeNames = e.includeNames, this.includeTypes = e.includeTypes, this.includeTags = e.includeTags, this.excludeNames = e.excludeNames, this.excludeTypes = e.excludeTypes, this.excludeTags = e.excludeTags;
  }
  includeEvent(e, n) {
    let a = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
    const r = e.tags ?? [];
    return this.includeNames !== void 0 && (a = a || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (a = a || this.includeTypes.includes(n)), this.includeTags !== void 0 && (a = a || r.some((i) => this.includeTags?.includes(i))), this.excludeNames !== void 0 && (a = a && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (a = a && !this.excludeTypes.includes(n)), this.excludeTags !== void 0 && (a = a && r.every((i) => !this.excludeTags?.includes(i))), a;
  }
}
const Jk = Symbol("Let zodToJsonSchema decide on which parser to use"), Jw = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, Lk = (t) => typeof t == "string" ? {
  ...Jw,
  name: t
} : {
  ...Jw,
  ...t
}, Uk = (t) => {
  const e = Lk(t), n = e.name !== void 0 ? [...e.basePath, e.definitionPath, e.name] : e.basePath;
  return {
    ...e,
    currentPath: n,
    propertyPath: void 0,
    seen: new Map(Object.entries(e.definitions).map(([a, r]) => [
      r._def,
      {
        def: r._def,
        path: [...e.basePath, e.definitionPath, a],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function EC(t, e, n, a) {
  a?.errorMessages && n && (t.errorMessage = {
    ...t.errorMessage,
    [e]: n
  });
}
function Ue(t, e, n, a, r) {
  t[e] = n, EC(t, e, a, r);
}
function Bk() {
  return {};
}
function xk(t, e) {
  const n = {
    type: "array"
  };
  return t.type?._def && t.type?._def?.typeName !== K.ZodAny && (n.items = Ie(t.type._def, {
    ...e,
    currentPath: [...e.currentPath, "items"]
  })), t.minLength && Ue(n, "minItems", t.minLength.value, t.minLength.message, e), t.maxLength && Ue(n, "maxItems", t.maxLength.value, t.maxLength.message, e), t.exactLength && (Ue(n, "minItems", t.exactLength.value, t.exactLength.message, e), Ue(n, "maxItems", t.exactLength.value, t.exactLength.message, e)), n;
}
function Vk(t, e) {
  const n = {
    type: "integer",
    format: "int64"
  };
  if (!t.checks)
    return n;
  for (const a of t.checks)
    switch (a.kind) {
      case "min":
        e.target === "jsonSchema7" ? a.inclusive ? Ue(n, "minimum", a.value, a.message, e) : Ue(n, "exclusiveMinimum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMinimum = !0), Ue(n, "minimum", a.value, a.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? a.inclusive ? Ue(n, "maximum", a.value, a.message, e) : Ue(n, "exclusiveMaximum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMaximum = !0), Ue(n, "maximum", a.value, a.message, e));
        break;
      case "multipleOf":
        Ue(n, "multipleOf", a.value, a.message, e);
        break;
    }
  return n;
}
function zk() {
  return {
    type: "boolean"
  };
}
function IC(t, e) {
  return Ie(t.type._def, e);
}
const Zk = (t, e) => Ie(t.innerType._def, e);
function NC(t, e, n) {
  const a = n ?? e.dateStrategy;
  if (Array.isArray(a))
    return {
      anyOf: a.map((r, i) => NC(t, e, r))
    };
  switch (a) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return Kk(t, e);
  }
}
const Kk = (t, e) => {
  const n = {
    type: "integer",
    format: "unix-time"
  };
  if (e.target === "openApi3")
    return n;
  for (const a of t.checks)
    switch (a.kind) {
      case "min":
        Ue(
          n,
          "minimum",
          a.value,
          // This is in milliseconds
          a.message,
          e
        );
        break;
      case "max":
        Ue(
          n,
          "maximum",
          a.value,
          // This is in milliseconds
          a.message,
          e
        );
        break;
    }
  return n;
};
function Hk(t, e) {
  return {
    ...Ie(t.innerType._def, e),
    default: t.defaultValue()
  };
}
function Gk(t, e) {
  return e.effectStrategy === "input" ? Ie(t.schema._def, e) : {};
}
function Wk(t) {
  return {
    type: "string",
    enum: Array.from(t.values)
  };
}
const Xk = (t) => "type" in t && t.type === "string" ? !1 : "allOf" in t;
function Qk(t, e) {
  const n = [
    Ie(t.left._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "0"]
    }),
    Ie(t.right._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "1"]
    })
  ].filter((i) => !!i);
  let a = e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const r = [];
  return n.forEach((i) => {
    if (Xk(i))
      r.push(...i.allOf), i.unevaluatedProperties === void 0 && (a = void 0);
    else {
      let s = i;
      if ("additionalProperties" in i && i.additionalProperties === !1) {
        const { additionalProperties: o, ...l } = i;
        s = l;
      } else
        a = void 0;
      r.push(s);
    }
  }), r.length ? {
    allOf: r,
    ...a
  } : void 0;
}
function Yk(t, e) {
  const n = typeof t.value;
  return n !== "bigint" && n !== "number" && n !== "boolean" && n !== "string" ? {
    type: Array.isArray(t.value) ? "array" : "object"
  } : e.target === "openApi3" ? {
    type: n === "bigint" ? "integer" : n,
    enum: [t.value]
  } : {
    type: n === "bigint" ? "integer" : n,
    const: t.value
  };
}
let Jm;
const Wn = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (Jm === void 0 && (Jm = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), Jm),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function kC(t, e) {
  const n = {
    type: "string"
  };
  if (t.checks)
    for (const a of t.checks)
      switch (a.kind) {
        case "min":
          Ue(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, a.value) : a.value, a.message, e);
          break;
        case "max":
          Ue(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, a.value) : a.value, a.message, e);
          break;
        case "email":
          switch (e.emailStrategy) {
            case "format:email":
              Xn(n, "email", a.message, e);
              break;
            case "format:idn-email":
              Xn(n, "idn-email", a.message, e);
              break;
            case "pattern:zod":
              Kt(n, Wn.email, a.message, e);
              break;
          }
          break;
        case "url":
          Xn(n, "uri", a.message, e);
          break;
        case "uuid":
          Xn(n, "uuid", a.message, e);
          break;
        case "regex":
          Kt(n, a.regex, a.message, e);
          break;
        case "cuid":
          Kt(n, Wn.cuid, a.message, e);
          break;
        case "cuid2":
          Kt(n, Wn.cuid2, a.message, e);
          break;
        case "startsWith":
          Kt(n, RegExp(`^${Lm(a.value, e)}`), a.message, e);
          break;
        case "endsWith":
          Kt(n, RegExp(`${Lm(a.value, e)}$`), a.message, e);
          break;
        case "datetime":
          Xn(n, "date-time", a.message, e);
          break;
        case "date":
          Xn(n, "date", a.message, e);
          break;
        case "time":
          Xn(n, "time", a.message, e);
          break;
        case "duration":
          Xn(n, "duration", a.message, e);
          break;
        case "length":
          Ue(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, a.value) : a.value, a.message, e), Ue(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, a.value) : a.value, a.message, e);
          break;
        case "includes": {
          Kt(n, RegExp(Lm(a.value, e)), a.message, e);
          break;
        }
        case "ip": {
          a.version !== "v6" && Xn(n, "ipv4", a.message, e), a.version !== "v4" && Xn(n, "ipv6", a.message, e);
          break;
        }
        case "base64url":
          Kt(n, Wn.base64url, a.message, e);
          break;
        case "jwt":
          Kt(n, Wn.jwt, a.message, e);
          break;
        case "cidr": {
          a.version !== "v6" && Kt(n, Wn.ipv4Cidr, a.message, e), a.version !== "v4" && Kt(n, Wn.ipv6Cidr, a.message, e);
          break;
        }
        case "emoji":
          Kt(n, Wn.emoji(), a.message, e);
          break;
        case "ulid": {
          Kt(n, Wn.ulid, a.message, e);
          break;
        }
        case "base64": {
          switch (e.base64Strategy) {
            case "format:binary": {
              Xn(n, "binary", a.message, e);
              break;
            }
            case "contentEncoding:base64": {
              Ue(n, "contentEncoding", "base64", a.message, e);
              break;
            }
            case "pattern:zod": {
              Kt(n, Wn.base64, a.message, e);
              break;
            }
          }
          break;
        }
        case "nanoid":
          Kt(n, Wn.nanoid, a.message, e);
      }
  return n;
}
function Lm(t, e) {
  return e.patternStrategy === "escape" ? tF(t) : t;
}
const eF = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function tF(t) {
  let e = "";
  for (let n = 0; n < t.length; n++)
    eF.has(t[n]) || (e += "\\"), e += t[n];
  return e;
}
function Xn(t, e, n, a) {
  t.format || t.anyOf?.some((r) => r.format) ? (t.anyOf || (t.anyOf = []), t.format && (t.anyOf.push({
    format: t.format,
    ...t.errorMessage && a.errorMessages && {
      errorMessage: { format: t.errorMessage.format }
    }
  }), delete t.format, t.errorMessage && (delete t.errorMessage.format, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.anyOf.push({
    format: e,
    ...n && a.errorMessages && { errorMessage: { format: n } }
  })) : Ue(t, "format", e, n, a);
}
function Kt(t, e, n, a) {
  t.pattern || t.allOf?.some((r) => r.pattern) ? (t.allOf || (t.allOf = []), t.pattern && (t.allOf.push({
    pattern: t.pattern,
    ...t.errorMessage && a.errorMessages && {
      errorMessage: { pattern: t.errorMessage.pattern }
    }
  }), delete t.pattern, t.errorMessage && (delete t.errorMessage.pattern, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.allOf.push({
    pattern: Lw(e, a),
    ...n && a.errorMessages && { errorMessage: { pattern: n } }
  })) : Ue(t, "pattern", Lw(e, a), n, a);
}
function Lw(t, e) {
  if (!e.applyRegexFlags || !t.flags)
    return t.source;
  const n = {
    i: t.flags.includes("i"),
    m: t.flags.includes("m"),
    s: t.flags.includes("s")
    // `.` matches newlines
  }, a = n.i ? t.source.toLowerCase() : t.source;
  let r = "", i = !1, s = !1, o = !1;
  for (let l = 0; l < a.length; l++) {
    if (i) {
      r += a[l], i = !1;
      continue;
    }
    if (n.i) {
      if (s) {
        if (a[l].match(/[a-z]/)) {
          o ? (r += a[l], r += `${a[l - 2]}-${a[l]}`.toUpperCase(), o = !1) : a[l + 1] === "-" && a[l + 2]?.match(/[a-z]/) ? (r += a[l], o = !0) : r += `${a[l]}${a[l].toUpperCase()}`;
          continue;
        }
      } else if (a[l].match(/[a-z]/)) {
        r += `[${a[l]}${a[l].toUpperCase()}]`;
        continue;
      }
    }
    if (n.m) {
      if (a[l] === "^") {
        r += `(^|(?<=[\r
]))`;
        continue;
      } else if (a[l] === "$") {
        r += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (n.s && a[l] === ".") {
      r += s ? `${a[l]}\r
` : `[${a[l]}\r
]`;
      continue;
    }
    r += a[l], a[l] === "\\" ? i = !0 : s && a[l] === "]" ? s = !1 : !s && a[l] === "[" && (s = !0);
  }
  try {
    new RegExp(r);
  } catch {
    return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), t.source;
  }
  return r;
}
function FC(t, e) {
  if (e.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."), e.target === "openApi3" && t.keyType?._def.typeName === K.ZodEnum)
    return {
      type: "object",
      required: t.keyType._def.values,
      properties: t.keyType._def.values.reduce((a, r) => ({
        ...a,
        [r]: Ie(t.valueType._def, {
          ...e,
          currentPath: [...e.currentPath, "properties", r]
        }) ?? {}
      }), {}),
      additionalProperties: e.rejectedAdditionalProperties
    };
  const n = {
    type: "object",
    additionalProperties: Ie(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    }) ?? e.allowedAdditionalProperties
  };
  if (e.target === "openApi3")
    return n;
  if (t.keyType?._def.typeName === K.ZodString && t.keyType._def.checks?.length) {
    const { type: a, ...r } = kC(t.keyType._def, e);
    return {
      ...n,
      propertyNames: r
    };
  } else {
    if (t.keyType?._def.typeName === K.ZodEnum)
      return {
        ...n,
        propertyNames: {
          enum: t.keyType._def.values
        }
      };
    if (t.keyType?._def.typeName === K.ZodBranded && t.keyType._def.type._def.typeName === K.ZodString && t.keyType._def.type._def.checks?.length) {
      const { type: a, ...r } = IC(t.keyType._def, e);
      return {
        ...n,
        propertyNames: r
      };
    }
  }
  return n;
}
function nF(t, e) {
  if (e.mapStrategy === "record")
    return FC(t, e);
  const n = Ie(t.keyType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "0"]
  }) || {}, a = Ie(t.valueType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, a],
      minItems: 2,
      maxItems: 2
    }
  };
}
function rF(t) {
  const e = t.values, a = Object.keys(t.values).filter((i) => typeof e[e[i]] != "number").map((i) => e[i]), r = Array.from(new Set(a.map((i) => typeof i)));
  return {
    type: r.length === 1 ? r[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: a
  };
}
function aF() {
  return {
    not: {}
  };
}
function iF(t) {
  return t.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const Jh = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function sF(t, e) {
  if (e.target === "openApi3")
    return Uw(t, e);
  const n = t.options instanceof Map ? Array.from(t.options.values()) : t.options;
  if (n.every((a) => a._def.typeName in Jh && (!a._def.checks || !a._def.checks.length))) {
    const a = n.reduce((r, i) => {
      const s = Jh[i._def.typeName];
      return s && !r.includes(s) ? [...r, s] : r;
    }, []);
    return {
      type: a.length > 1 ? a : a[0]
    };
  } else if (n.every((a) => a._def.typeName === "ZodLiteral" && !a.description)) {
    const a = n.reduce((r, i) => {
      const s = typeof i._def.value;
      switch (s) {
        case "string":
        case "number":
        case "boolean":
          return [...r, s];
        case "bigint":
          return [...r, "integer"];
        case "object":
          if (i._def.value === null)
            return [...r, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return r;
      }
    }, []);
    if (a.length === n.length) {
      const r = a.filter((i, s, o) => o.indexOf(i) === s);
      return {
        type: r.length > 1 ? r : r[0],
        enum: n.reduce((i, s) => i.includes(s._def.value) ? i : [...i, s._def.value], [])
      };
    }
  } else if (n.every((a) => a._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce((a, r) => [
        ...a,
        ...r._def.values.filter((i) => !a.includes(i))
      ], [])
    };
  return Uw(t, e);
}
const Uw = (t, e) => {
  const n = (t.options instanceof Map ? Array.from(t.options.values()) : t.options).map((a, r) => Ie(a._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", `${r}`]
  })).filter((a) => !!a && (!e.strictUnions || typeof a == "object" && Object.keys(a).length > 0));
  return n.length ? { anyOf: n } : void 0;
};
function oF(t, e) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(t.innerType._def.typeName) && (!t.innerType._def.checks || !t.innerType._def.checks.length))
    return e.target === "openApi3" ? {
      type: Jh[t.innerType._def.typeName],
      nullable: !0
    } : {
      type: [
        Jh[t.innerType._def.typeName],
        "null"
      ]
    };
  if (e.target === "openApi3") {
    const a = Ie(t.innerType._def, {
      ...e,
      currentPath: [...e.currentPath]
    });
    return a && "$ref" in a ? { allOf: [a], nullable: !0 } : a && { ...a, nullable: !0 };
  }
  const n = Ie(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "0"]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function uF(t, e) {
  const n = {
    type: "number"
  };
  if (!t.checks)
    return n;
  for (const a of t.checks)
    switch (a.kind) {
      case "int":
        n.type = "integer", EC(n, "type", a.message, e);
        break;
      case "min":
        e.target === "jsonSchema7" ? a.inclusive ? Ue(n, "minimum", a.value, a.message, e) : Ue(n, "exclusiveMinimum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMinimum = !0), Ue(n, "minimum", a.value, a.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? a.inclusive ? Ue(n, "maximum", a.value, a.message, e) : Ue(n, "exclusiveMaximum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMaximum = !0), Ue(n, "maximum", a.value, a.message, e));
        break;
      case "multipleOf":
        Ue(n, "multipleOf", a.value, a.message, e);
        break;
    }
  return n;
}
function cF(t, e) {
  const n = e.target === "openAi", a = {
    type: "object",
    properties: {}
  }, r = [], i = t.shape();
  for (const o in i) {
    let l = i[o];
    if (l === void 0 || l._def === void 0)
      continue;
    let f = dF(l);
    f && n && (l instanceof mr && (l = l._def.innerType), l.isNullable() || (l = l.nullable()), f = !1);
    const u = Ie(l._def, {
      ...e,
      currentPath: [...e.currentPath, "properties", o],
      propertyPath: [...e.currentPath, "properties", o]
    });
    u !== void 0 && (a.properties[o] = u, f || r.push(o));
  }
  r.length && (a.required = r);
  const s = lF(t, e);
  return s !== void 0 && (a.additionalProperties = s), a;
}
function lF(t, e) {
  if (t.catchall._def.typeName !== "ZodNever")
    return Ie(t.catchall._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    });
  switch (t.unknownKeys) {
    case "passthrough":
      return e.allowedAdditionalProperties;
    case "strict":
      return e.rejectedAdditionalProperties;
    case "strip":
      return e.removeAdditionalStrategy === "strict" ? e.allowedAdditionalProperties : e.rejectedAdditionalProperties;
  }
}
function dF(t) {
  try {
    return t.isOptional();
  } catch {
    return !0;
  }
}
const fF = (t, e) => {
  if (e.currentPath.toString() === e.propertyPath?.toString())
    return Ie(t.innerType._def, e);
  const n = Ie(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "1"]
  });
  return n ? {
    anyOf: [
      {
        not: {}
      },
      n
    ]
  } : {};
}, hF = (t, e) => {
  if (e.pipeStrategy === "input")
    return Ie(t.in._def, e);
  if (e.pipeStrategy === "output")
    return Ie(t.out._def, e);
  const n = Ie(t.in._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", "0"]
  }), a = Ie(t.out._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", n ? "1" : "0"]
  });
  return {
    allOf: [n, a].filter((r) => r !== void 0)
  };
};
function pF(t, e) {
  return Ie(t.type._def, e);
}
function mF(t, e) {
  const a = {
    type: "array",
    uniqueItems: !0,
    items: Ie(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "items"]
    })
  };
  return t.minSize && Ue(a, "minItems", t.minSize.value, t.minSize.message, e), t.maxSize && Ue(a, "maxItems", t.maxSize.value, t.maxSize.message, e), a;
}
function bF(t, e) {
  return t.rest ? {
    type: "array",
    minItems: t.items.length,
    items: t.items.map((n, a) => Ie(n._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${a}`]
    })).reduce((n, a) => a === void 0 ? n : [...n, a], []),
    additionalItems: Ie(t.rest._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: t.items.length,
    maxItems: t.items.length,
    items: t.items.map((n, a) => Ie(n._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${a}`]
    })).reduce((n, a) => a === void 0 ? n : [...n, a], [])
  };
}
function gF() {
  return {
    not: {}
  };
}
function _F() {
  return {};
}
const yF = (t, e) => Ie(t.innerType._def, e), wF = (t, e, n) => {
  switch (e) {
    case K.ZodString:
      return kC(t, n);
    case K.ZodNumber:
      return uF(t, n);
    case K.ZodObject:
      return cF(t, n);
    case K.ZodBigInt:
      return Vk(t, n);
    case K.ZodBoolean:
      return zk();
    case K.ZodDate:
      return NC(t, n);
    case K.ZodUndefined:
      return gF();
    case K.ZodNull:
      return iF(n);
    case K.ZodArray:
      return xk(t, n);
    case K.ZodUnion:
    case K.ZodDiscriminatedUnion:
      return sF(t, n);
    case K.ZodIntersection:
      return Qk(t, n);
    case K.ZodTuple:
      return bF(t, n);
    case K.ZodRecord:
      return FC(t, n);
    case K.ZodLiteral:
      return Yk(t, n);
    case K.ZodEnum:
      return Wk(t);
    case K.ZodNativeEnum:
      return rF(t);
    case K.ZodNullable:
      return oF(t, n);
    case K.ZodOptional:
      return fF(t, n);
    case K.ZodMap:
      return nF(t, n);
    case K.ZodSet:
      return mF(t, n);
    case K.ZodLazy:
      return () => t.getter()._def;
    case K.ZodPromise:
      return pF(t, n);
    case K.ZodNaN:
    case K.ZodNever:
      return aF();
    case K.ZodEffects:
      return Gk(t, n);
    case K.ZodAny:
      return Bk();
    case K.ZodUnknown:
      return _F();
    case K.ZodDefault:
      return Hk(t, n);
    case K.ZodBranded:
      return IC(t, n);
    case K.ZodReadonly:
      return yF(t, n);
    case K.ZodCatch:
      return Zk(t, n);
    case K.ZodPipeline:
      return hF(t, n);
    case K.ZodFunction:
    case K.ZodVoid:
    case K.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((a) => {
      })();
  }
};
function Ie(t, e, n = !1) {
  const a = e.seen.get(t);
  if (e.override) {
    const o = e.override?.(t, e, a, n);
    if (o !== Jk)
      return o;
  }
  if (a && !n) {
    const o = vF(a, e);
    if (o !== void 0)
      return o;
  }
  const r = { def: t, path: e.currentPath, jsonSchema: void 0 };
  e.seen.set(t, r);
  const i = wF(t, t.typeName, e), s = typeof i == "function" ? Ie(i(), e) : i;
  if (s && OF(t, e, s), e.postProcess) {
    const o = e.postProcess(s, t, e);
    return r.jsonSchema = s, o;
  }
  return r.jsonSchema = s, s;
}
const vF = (t, e) => {
  switch (e.$refStrategy) {
    case "root":
      return { $ref: t.path.join("/") };
    case "relative":
      return { $ref: SF(e.currentPath, t.path) };
    case "none":
    case "seen":
      return t.path.length < e.currentPath.length && t.path.every((n, a) => e.currentPath[a] === n) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`), {}) : e.$refStrategy === "seen" ? {} : void 0;
  }
}, SF = (t, e) => {
  let n = 0;
  for (; n < t.length && n < e.length && t[n] === e[n]; n++)
    ;
  return [(t.length - n).toString(), ...e.slice(n)].join("/");
}, OF = (t, e, n) => (t.description && (n.description = t.description, e.markdownDescription && (n.markdownDescription = t.description)), n), Cn = (t, e) => {
  const n = Uk(e), a = typeof e == "object" && e.definitions ? Object.entries(e.definitions).reduce((l, [f, u]) => ({
    ...l,
    [f]: Ie(u._def, {
      ...n,
      currentPath: [...n.basePath, n.definitionPath, f]
    }, !0) ?? {}
  }), {}) : void 0, r = typeof e == "string" ? e : e?.nameStrategy === "title" ? void 0 : e?.name, i = Ie(t._def, r === void 0 ? n : {
    ...n,
    currentPath: [...n.basePath, n.definitionPath, r]
  }, !1) ?? {}, s = typeof e == "object" && e.name !== void 0 && e.nameStrategy === "title" ? e.name : void 0;
  s !== void 0 && (i.title = s);
  const o = r === void 0 ? a ? {
    ...i,
    [n.definitionPath]: a
  } : i : {
    $ref: [
      ...n.$refStrategy === "relative" ? [] : n.basePath,
      n.definitionPath,
      r
    ].join("/"),
    [n.definitionPath]: {
      ...a,
      [r]: i
    }
  };
  return n.target === "jsonSchema7" ? o.$schema = "http://json-schema.org/draft-07/schema#" : (n.target === "jsonSchema2019-09" || n.target === "openAi") && (o.$schema = "https://json-schema.org/draft/2019-09/schema#"), n.target === "openAi" && ("anyOf" in o || "oneOf" in o || "allOf" in o || "type" in o && Array.isArray(o.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."), o;
};
function Um(t) {
  return t.replace(/[^a-zA-Z-_0-9]/g, "_");
}
const jF = ["*", "_", "`"];
function PF(t) {
  let e = "";
  for (const [n, a] of Object.entries(t))
    e += `	classDef ${n} ${a};
`;
  return e;
}
function RF(t, e, n) {
  const { firstNode: a, lastNode: r, nodeColors: i, withStyles: s = !0, curveStyle: o = "linear", wrapLabelNWords: l = 9 } = n ?? {};
  let f = s ? `%%{init: {'flowchart': {'curve': '${o}'}}}%%
graph TD;
` : `graph TD;
`;
  if (s) {
    const p = "default", d = {
      [p]: "{0}({1})"
    };
    a !== void 0 && (d[a] = "{0}([{1}]):::first"), r !== void 0 && (d[r] = "{0}([{1}]):::last");
    for (const [m, b] of Object.entries(t)) {
      const g = b.name.split(":").pop() ?? "";
      let P = jF.some((R) => g.startsWith(R) && g.endsWith(R)) ? `<p>${g}</p>` : g;
      Object.keys(b.metadata ?? {}).length && (P += `<hr/><small><em>${Object.entries(b.metadata ?? {}).map(([R, T]) => `${R} = ${T}`).join(`
`)}</em></small>`);
      const C = (d[m] ?? d[p]).replace("{0}", Um(m)).replace("{1}", P);
      f += `	${C}
`;
    }
  }
  const u = {};
  for (const p of e) {
    const d = p.source.split(":"), m = p.target.split(":"), b = d.filter((g, _) => g === m[_]).join(":");
    u[b] || (u[b] = []), u[b].push(p);
  }
  const c = /* @__PURE__ */ new Set();
  function h(p, d) {
    const m = p.length === 1 && p[0].source === p[0].target;
    if (d && !m) {
      const b = d.split(":").pop();
      if (c.has(b))
        throw new Error(`Found duplicate subgraph '${b}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
      c.add(b), f += `	subgraph ${b}
`;
    }
    for (const b of p) {
      const { source: g, target: _, data: P, conditional: C } = b;
      let R = "";
      if (P !== void 0) {
        let T = P;
        const O = T.split(" ");
        O.length > l && (T = Array.from({ length: Math.ceil(O.length / l) }, (A, M) => O.slice(M * l, (M + 1) * l).join(" ")).join("&nbsp;<br>&nbsp;")), R = C ? ` -. &nbsp;${T}&nbsp; .-> ` : ` -- &nbsp;${T}&nbsp; --> `;
      } else
        R = C ? " -.-> " : " --> ";
      f += `	${Um(g)}${R}${Um(_)};
`;
    }
    for (const b in u)
      b.startsWith(`${d}:`) && b !== d && h(u[b], b);
    d && !m && (f += `	end
`);
  }
  h(u[""] ?? [], "");
  for (const p in u)
    !p.includes(":") && p !== "" && h(u[p], p);
  return s && (f += PF(i ?? {})), f;
}
async function CF(t, e) {
  let { backgroundColor: n = "white" } = e ?? {};
  const a = btoa(t);
  n !== void 0 && (/^#(?:[0-9a-fA-F]{3}){1,2}$/.test(n) || (n = `!${n}`));
  const r = `https://mermaid.ink/img/${a}?bgColor=${n}`, i = await fetch(r);
  if (!i.ok)
    throw new Error([
      "Failed to render the graph using the Mermaid.INK API.",
      `Status code: ${i.status}`,
      `Status text: ${i.statusText}`
    ].join(`
`));
  return await i.blob();
}
function TF(t, e) {
  if (t !== void 0 && !Us(t))
    return t;
  if (l_(e))
    try {
      let n = e.getName();
      return n = n.startsWith("Runnable") ? n.slice(8) : n, n;
    } catch {
      return e.getName();
    }
  else
    return e.name ?? "UnknownSchema";
}
function $F(t) {
  return l_(t.data) ? {
    type: "runnable",
    data: {
      id: t.data.lc_id,
      name: t.data.getName()
    }
  } : {
    type: "schema",
    data: { ...Cn(t.data.schema), title: t.data.name }
  };
}
let Lh = class DC {
  constructor(e) {
    Object.defineProperty(this, "nodes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "edges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this.nodes = e?.nodes ?? this.nodes, this.edges = e?.edges ?? this.edges;
  }
  // Convert the graph to a JSON-serializable format.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON() {
    const e = {};
    return Object.values(this.nodes).forEach((n, a) => {
      e[n.id] = Us(n.id) ? a : n.id;
    }), {
      nodes: Object.values(this.nodes).map((n) => ({
        id: e[n.id],
        ...$F(n)
      })),
      edges: this.edges.map((n) => {
        const a = {
          source: e[n.source],
          target: e[n.target]
        };
        return typeof n.data < "u" && (a.data = n.data), typeof n.conditional < "u" && (a.conditional = n.conditional), a;
      })
    };
  }
  addNode(e, n, a) {
    if (n !== void 0 && this.nodes[n] !== void 0)
      throw new Error(`Node with id ${n} already exists`);
    const r = n ?? Pt(), i = {
      id: r,
      data: e,
      name: TF(n, e),
      metadata: a
    };
    return this.nodes[r] = i, i;
  }
  removeNode(e) {
    delete this.nodes[e.id], this.edges = this.edges.filter((n) => n.source !== e.id && n.target !== e.id);
  }
  addEdge(e, n, a, r) {
    if (this.nodes[e.id] === void 0)
      throw new Error(`Source node ${e.id} not in graph`);
    if (this.nodes[n.id] === void 0)
      throw new Error(`Target node ${n.id} not in graph`);
    const i = {
      source: e.id,
      target: n.id,
      data: a,
      conditional: r
    };
    return this.edges.push(i), i;
  }
  firstNode() {
    return Bw(this);
  }
  lastNode() {
    return xw(this);
  }
  /**
   * Add all nodes and edges from another graph.
   * Note this doesn't check for duplicates, nor does it connect the graphs.
   */
  extend(e, n = "") {
    let a = n;
    Object.values(e.nodes).map((f) => f.id).every(Us) && (a = "");
    const i = (f) => a ? `${a}:${f}` : f;
    Object.entries(e.nodes).forEach(([f, u]) => {
      this.nodes[i(f)] = { ...u, id: i(f) };
    });
    const s = e.edges.map((f) => ({
      ...f,
      source: i(f.source),
      target: i(f.target)
    }));
    this.edges = [...this.edges, ...s];
    const o = e.firstNode(), l = e.lastNode();
    return [
      o ? { id: i(o.id), data: o.data } : void 0,
      l ? { id: i(l.id), data: l.data } : void 0
    ];
  }
  trimFirstNode() {
    const e = this.firstNode();
    e && Bw(this, [e.id]) && this.removeNode(e);
  }
  trimLastNode() {
    const e = this.lastNode();
    e && xw(this, [e.id]) && this.removeNode(e);
  }
  /**
   * Return a new graph with all nodes re-identified,
   * using their unique, readable names where possible.
   */
  reid() {
    const e = Object.fromEntries(Object.values(this.nodes).map((r) => [r.id, r.name])), n = /* @__PURE__ */ new Map();
    Object.values(e).forEach((r) => {
      n.set(r, (n.get(r) || 0) + 1);
    });
    const a = (r) => {
      const i = e[r];
      return Us(r) && n.get(i) === 1 ? i : r;
    };
    return new DC({
      nodes: Object.fromEntries(Object.entries(this.nodes).map(([r, i]) => [
        a(r),
        { ...i, id: a(r) }
      ])),
      edges: this.edges.map((r) => ({
        ...r,
        source: a(r.source),
        target: a(r.target)
      }))
    });
  }
  drawMermaid(e) {
    const { withStyles: n, curveStyle: a, nodeColors: r = {
      default: "fill:#f2f0ff,line-height:1.2",
      first: "fill-opacity:0",
      last: "fill:#bfb6fc"
    }, wrapLabelNWords: i } = e ?? {}, s = this.reid(), o = s.firstNode(), l = s.lastNode();
    return RF(s.nodes, s.edges, {
      firstNode: o?.id,
      lastNode: l?.id,
      withStyles: n,
      curveStyle: a,
      nodeColors: r,
      wrapLabelNWords: i
    });
  }
  async drawMermaidPng(e) {
    const n = this.drawMermaid(e);
    return CF(n, {
      backgroundColor: e?.backgroundColor
    });
  }
};
function Bw(t, e = []) {
  const n = new Set(t.edges.filter((r) => !e.includes(r.source)).map((r) => r.target)), a = [];
  for (const r of Object.values(t.nodes))
    !e.includes(r.id) && !n.has(r.id) && a.push(r);
  return a.length === 1 ? a[0] : void 0;
}
function xw(t, e = []) {
  const n = new Set(t.edges.filter((r) => !e.includes(r.target)).map((r) => r.source)), a = [];
  for (const r of Object.values(t.nodes))
    !e.includes(r.id) && !n.has(r.id) && a.push(r);
  return a.length === 1 ? a[0] : void 0;
}
function MF(t) {
  const e = new TextEncoder(), n = new ReadableStream({
    async start(a) {
      for await (const r of t)
        a.enqueue(e.encode(`event: data
data: ${JSON.stringify(r)}

`));
      a.enqueue(e.encode(`event: end

`)), a.close();
    }
  });
  return ln.fromReadableStream(n);
}
function Vw(t) {
  return typeof t == "object" && t !== null && typeof t[Symbol.iterator] == "function" && // avoid detecting array/set as iterator
  typeof t.next == "function";
}
const AF = (t) => t != null && typeof t == "object" && "next" in t && typeof t.next == "function";
function ig(t) {
  return typeof t == "object" && t !== null && typeof t[Symbol.asyncIterator] == "function";
}
function* zw(t, e) {
  for (; ; ) {
    const { value: n, done: a } = xn.runWithConfig(Qu(t), e.next.bind(e), !0);
    if (a)
      break;
    yield n;
  }
}
async function* sg(t, e) {
  const n = e[Symbol.asyncIterator]();
  for (; ; ) {
    const { value: a, done: r } = await xn.runWithConfig(Qu(t), n.next.bind(e), !0);
    if (r)
      break;
    yield a;
  }
}
function Rt(t, e) {
  return t && !Array.isArray(t) && // eslint-disable-next-line no-instanceof/no-instanceof
  !(t instanceof Date) && typeof t == "object" ? t : { [e]: t };
}
class Te extends gr {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_runnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  getName(e) {
    const n = (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this.name ?? this.constructor.lc_name() ?? this.constructor.name
    );
    return e ? `${n}${e}` : n;
  }
  /**
   * Bind arguments to a Runnable, returning a new Runnable.
   * @param kwargs
   * @returns A new RunnableBinding that, when invoked, will apply the bound args.
   */
  bind(e) {
    return new fo({ bound: this, kwargs: e, config: {} });
  }
  /**
   * Return a new Runnable that maps a list of inputs to a list of outputs,
   * by calling invoke() with each input.
   */
  map() {
    return new Uh({ bound: this });
  }
  /**
   * Add retry logic to an existing runnable.
   * @param kwargs
   * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
   */
  withRetry(e) {
    return new EF({
      bound: this,
      kwargs: {},
      config: {},
      maxAttemptNumber: e?.stopAfterAttempt,
      ...e
    });
  }
  /**
   * Bind config to a Runnable, returning a new Runnable.
   * @param config New configuration parameters to attach to the new runnable.
   * @returns A new RunnableBinding with a config matching what's passed.
   */
  withConfig(e) {
    return new fo({
      bound: this,
      config: e,
      kwargs: {}
    });
  }
  /**
   * Create a new runnable from the current one that will try invoking
   * other passed fallback runnables if the initial invocation fails.
   * @param fields.fallbacks Other runnables to call if the runnable errors.
   * @returns A new RunnableWithFallbacks.
   */
  withFallbacks(e) {
    const n = Array.isArray(e) ? e : e.fallbacks;
    return new NF({
      runnable: this,
      fallbacks: n
    });
  }
  _getOptionsList(e, n = 0) {
    if (Array.isArray(e) && e.length !== n)
      throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${e.length} options for ${n} inputs`);
    if (Array.isArray(e))
      return e.map(Re);
    if (n > 1 && !Array.isArray(e) && e.runId) {
      console.warn("Provided runId will be used only for the first element of the batch.");
      const a = Object.fromEntries(Object.entries(e).filter(([r]) => r !== "runId"));
      return Array.from({ length: n }, (r, i) => Re(i === 0 ? e : a));
    }
    return Array.from({ length: n }, () => Re(e));
  }
  async batch(e, n, a) {
    const r = this._getOptionsList(n ?? {}, e.length), i = r[0]?.maxConcurrency ?? a?.maxConcurrency, s = new ru({
      maxConcurrency: i,
      onFailedAttempt: (l) => {
        throw l;
      }
    }), o = e.map((l, f) => s.call(async () => {
      try {
        return await this.invoke(l, r[f]);
      } catch (u) {
        if (a?.returnExceptions)
          return u;
        throw u;
      }
    }));
    return Promise.all(o);
  }
  /**
   * Default streaming implementation.
   * Subclasses should override this method if they support streaming output.
   * @param input
   * @param options
   */
  async *_streamIterator(e, n) {
    yield this.invoke(e, n);
  }
  /**
   * Stream output in chunks.
   * @param input
   * @param options
   * @returns A readable stream that is also an iterable.
   */
  async stream(e, n) {
    const a = Re(n), r = new lc({
      generator: this._streamIterator(e, a),
      config: a
    });
    return await r.setup, ln.fromAsyncGenerator(r);
  }
  _separateRunnableConfigFromCallOptions(e) {
    let n;
    e === void 0 ? n = Re(e) : n = Re({
      callbacks: e.callbacks,
      tags: e.tags,
      metadata: e.metadata,
      runName: e.runName,
      configurable: e.configurable,
      recursionLimit: e.recursionLimit,
      maxConcurrency: e.maxConcurrency,
      runId: e.runId,
      timeout: e.timeout,
      signal: e.signal
    });
    const a = { ...e };
    return delete a.callbacks, delete a.tags, delete a.metadata, delete a.runName, delete a.configurable, delete a.recursionLimit, delete a.maxConcurrency, delete a.runId, delete a.timeout, delete a.signal, [n, a];
  }
  async _callWithConfig(e, n, a) {
    const r = Re(a), s = await (await Vn(r))?.handleChainStart(this.toJSON(), Rt(n, "input"), r.runId, r?.runType, void 0, void 0, r?.runName ?? this.getName());
    delete r.runId;
    let o;
    try {
      const l = e.call(this, n, r, s);
      o = await go(l, a?.signal);
    } catch (l) {
      throw await s?.handleChainError(l), l;
    }
    return await s?.handleChainEnd(Rt(o, "output")), o;
  }
  /**
   * Internal method that handles batching and configuration for a runnable
   * It takes a function, input values, and optional configuration, and
   * returns a promise that resolves to the output values.
   * @param func The function to be executed for each input value.
   * @param input The input values to be processed.
   * @param config Optional configuration for the function execution.
   * @returns A promise that resolves to the output values.
   */
  async _batchWithConfig(e, n, a, r) {
    const i = this._getOptionsList(a ?? {}, n.length), s = await Promise.all(i.map(Vn)), o = await Promise.all(s.map(async (f, u) => {
      const c = await f?.handleChainStart(this.toJSON(), Rt(n[u], "input"), i[u].runId, i[u].runType, void 0, void 0, i[u].runName ?? this.getName());
      return delete i[u].runId, c;
    }));
    let l;
    try {
      const f = e.call(this, n, i, o, r);
      l = await go(f, i?.[0]?.signal);
    } catch (f) {
      throw await Promise.all(o.map((u) => u?.handleChainError(f))), f;
    }
    return await Promise.all(o.map((f) => f?.handleChainEnd(Rt(l, "output")))), l;
  }
  /**
   * Helper method to transform an Iterator of Input values into an Iterator of
   * Output values, with callbacks.
   * Use this to implement `stream()` or `transform()` in Runnable subclasses.
   */
  async *_transformStreamWithConfig(e, n, a) {
    let r, i = !0, s, o = !0;
    const l = Re(a), f = await Vn(l);
    async function* u() {
      for await (const h of e) {
        if (i)
          if (r === void 0)
            r = h;
          else
            try {
              r = on(r, h);
            } catch {
              r = void 0, i = !1;
            }
        yield h;
      }
    }
    let c;
    try {
      const h = await Ak(n.bind(this), u(), async () => f?.handleChainStart(this.toJSON(), { input: "" }, l.runId, l.runType, void 0, void 0, l.runName ?? this.getName()), a?.signal, l);
      delete l.runId, c = h.setup;
      const p = c?.handlers.find(Nk);
      let d = h.output;
      p !== void 0 && c !== void 0 && (d = p.tapOutputIterable(c.runId, d));
      const m = c?.handlers.find(Ek);
      m !== void 0 && c !== void 0 && (d = m.tapOutputIterable(c.runId, d));
      for await (const b of d)
        if (yield b, o)
          if (s === void 0)
            s = b;
          else
            try {
              s = on(s, b);
            } catch {
              s = void 0, o = !1;
            }
    } catch (h) {
      throw await c?.handleChainError(h, void 0, void 0, void 0, {
        inputs: Rt(r, "input")
      }), h;
    }
    await c?.handleChainEnd(s ?? {}, void 0, void 0, void 0, { inputs: Rt(r, "input") });
  }
  getGraph(e) {
    const n = new Lh(), a = n.addNode({
      name: `${this.getName()}Input`,
      schema: jn.any()
    }), r = n.addNode(this), i = n.addNode({
      name: `${this.getName()}Output`,
      schema: jn.any()
    });
    return n.addEdge(a, r), n.addEdge(r, i), n;
  }
  /**
   * Create a new runnable sequence that runs each individual runnable in series,
   * piping the output of one runnable into another runnable or runnable-like.
   * @param coerceable A runnable, function, or object whose values are functions or runnables.
   * @returns A new runnable sequence.
   */
  pipe(e) {
    return new dt({
      first: this,
      last: Pn(e)
    });
  }
  /**
   * Pick keys from the dict output of this runnable. Returns a new runnable.
   */
  pick(e) {
    return this.pipe(new kF(e));
  }
  /**
   * Assigns new fields to the dict output of this runnable. Returns a new runnable.
   */
  assign(e) {
    return this.pipe(
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      new qC(
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        new dc({ steps: e })
      )
    );
  }
  /**
   * Default implementation of transform, which buffers input and then calls stream.
   * Subclasses should override this method if they can start producing output while
   * input is still being generated.
   * @param generator
   * @param options
   */
  async *transform(e, n) {
    let a;
    for await (const r of e)
      a === void 0 ? a = r : a = on(a, r);
    yield* this._streamIterator(a, Re(n));
  }
  /**
   * Stream all output from a runnable, as reported to the callback system.
   * This includes all inner runs of LLMs, Retrievers, Tools, etc.
   * Output is streamed as Log objects, which include a list of
   * jsonpatch ops that describe how the state of the run has changed in each
   * step, and the final state of the run.
   * The jsonpatch ops can be applied in order to construct state.
   * @param input
   * @param options
   * @param streamOptions
   */
  async *streamLog(e, n, a) {
    const r = new qw({
      ...a,
      autoClose: !1,
      _schemaFormat: "original"
    }), i = Re(n);
    yield* this._streamLog(e, r, i);
  }
  async *_streamLog(e, n, a) {
    const { callbacks: r } = a;
    if (r === void 0)
      a.callbacks = [n];
    else if (Array.isArray(r))
      a.callbacks = r.concat([n]);
    else {
      const l = r.copy();
      l.addHandler(n, !0), a.callbacks = l;
    }
    const i = this.stream(e, a);
    async function s() {
      try {
        const l = await i;
        for await (const f of l) {
          const u = new ao({
            ops: [
              {
                op: "add",
                path: "/streamed_output/-",
                value: f
              }
            ]
          });
          await n.writer.write(u);
        }
      } finally {
        await n.writer.close();
      }
    }
    const o = s();
    try {
      for await (const l of n)
        yield l;
    } finally {
      await o;
    }
  }
  streamEvents(e, n, a) {
    let r;
    if (n.version === "v1")
      r = this._streamEventsV1(e, n, a);
    else if (n.version === "v2")
      r = this._streamEventsV2(e, n, a);
    else
      throw new Error('Only versions "v1" and "v2" of the schema are currently supported.');
    return n.encoding === "text/event-stream" ? MF(r) : ln.fromAsyncGenerator(r);
  }
  async *_streamEventsV2(e, n, a) {
    const r = new kk({
      ...a,
      autoClose: !1
    }), i = Re(n), s = i.runId ?? Pt();
    i.runId = s;
    const o = i.callbacks;
    if (o === void 0)
      i.callbacks = [r];
    else if (Array.isArray(o))
      i.callbacks = o.concat(r);
    else {
      const d = o.copy();
      d.addHandler(r, !0), i.callbacks = d;
    }
    const l = new AbortController(), f = this;
    async function u() {
      try {
        let d;
        n?.signal ? "any" in AbortSignal ? d = AbortSignal.any([
          l.signal,
          n.signal
        ]) : (d = n.signal, n.signal.addEventListener("abort", () => {
          l.abort();
        }, { once: !0 })) : d = l.signal;
        const m = await f.stream(e, {
          ...i,
          signal: d
        }), b = r.tapOutputIterable(s, m);
        for await (const g of b)
          if (l.signal.aborted)
            break;
      } finally {
        await r.finish();
      }
    }
    const c = u();
    let h = !1, p;
    try {
      for await (const d of r) {
        if (!h) {
          d.data.input = e, h = !0, p = d.run_id, yield d;
          continue;
        }
        d.run_id === p && d.event.endsWith("_end") && d.data?.input && delete d.data.input, yield d;
      }
    } finally {
      l.abort(), await c;
    }
  }
  async *_streamEventsV1(e, n, a) {
    let r, i = !1;
    const s = Re(n), o = s.tags ?? [], l = s.metadata ?? {}, f = s.runName ?? this.getName(), u = new qw({
      ...a,
      autoClose: !1,
      _schemaFormat: "streaming_events"
    }), c = new qk({
      ...a
    }), h = this._streamLog(e, u, s);
    for await (const d of h) {
      if (r ? r = r.concat(d) : r = Pd.fromRunLogPatch(d), r.state === void 0)
        throw new Error('Internal error: "streamEvents" state is missing. Please open a bug report.');
      if (!i) {
        i = !0;
        const _ = { ...r.state }, P = {
          run_id: _.id,
          event: `on_${_.type}_start`,
          name: f,
          tags: o,
          metadata: l,
          data: {
            input: e
          }
        };
        c.includeEvent(P, _.type) && (yield P);
      }
      const m = d.ops.filter((_) => _.path.startsWith("/logs/")).map((_) => _.path.split("/")[2]), b = [...new Set(m)];
      for (const _ of b) {
        let P, C = {};
        const R = r.state.logs[_];
        if (R.end_time === void 0 ? R.streamed_output.length > 0 ? P = "stream" : P = "start" : P = "end", P === "start")
          R.inputs !== void 0 && (C.input = R.inputs);
        else if (P === "end")
          R.inputs !== void 0 && (C.input = R.inputs), C.output = R.final_output;
        else if (P === "stream") {
          const T = R.streamed_output.length;
          if (T !== 1)
            throw new Error(`Expected exactly one chunk of streamed output, got ${T} instead. Encountered in: "${R.name}"`);
          C = { chunk: R.streamed_output[0] }, R.streamed_output = [];
        }
        yield {
          event: `on_${R.type}_${P}`,
          name: R.name,
          run_id: R.id,
          tags: R.tags,
          metadata: R.metadata,
          data: C
        };
      }
      const { state: g } = r;
      if (g.streamed_output.length > 0) {
        const _ = g.streamed_output.length;
        if (_ !== 1)
          throw new Error(`Expected exactly one chunk of streamed output, got ${_} instead. Encountered in: "${g.name}"`);
        const P = { chunk: g.streamed_output[0] };
        g.streamed_output = [];
        const C = {
          event: `on_${g.type}_stream`,
          run_id: g.id,
          tags: o,
          metadata: l,
          name: f,
          data: P
        };
        c.includeEvent(C, g.type) && (yield C);
      }
    }
    const p = r?.state;
    if (p !== void 0) {
      const d = {
        event: `on_${p.type}_end`,
        name: f,
        run_id: p.id,
        tags: o,
        metadata: l,
        data: {
          output: p.final_output
        }
      };
      c.includeEvent(d, p.type) && (yield d);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isRunnable(e) {
    return l_(e);
  }
  /**
   * Bind lifecycle listeners to a Runnable, returning a new Runnable.
   * The Run object contains information about the run, including its id,
   * type, input, output, error, startTime, endTime, and any tags or metadata
   * added to the run.
   *
   * @param {Object} params - The object containing the callback functions.
   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
   */
  withListeners({ onStart: e, onEnd: n, onError: a }) {
    return new fo({
      bound: this,
      config: {},
      configFactories: [
        (r) => ({
          callbacks: [
            new AC({
              config: r,
              onStart: e,
              onEnd: n,
              onError: a
            })
          ]
        })
      ]
    });
  }
  /**
   * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
   * which contains the runnable, name, description and schema.
   *
   * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
   *
   * @param fields
   * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
   * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
   * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
   * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
   */
  asTool(e) {
    return FF(this, e);
  }
}
class fo extends Te {
  static lc_name() {
    return "RunnableBinding";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "bound", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "kwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "configFactories", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.bound = e.bound, this.kwargs = e.kwargs, this.config = e.config, this.configFactories = e.configFactories;
  }
  getName(e) {
    return this.bound.getName(e);
  }
  async _mergeConfig(...e) {
    const n = oa(this.config, ...e);
    return oa(n, ...this.configFactories ? await Promise.all(this.configFactories.map(async (a) => await a(n))) : []);
  }
  bind(e) {
    return new this.constructor({
      bound: this.bound,
      kwargs: { ...this.kwargs, ...e },
      config: this.config
    });
  }
  withConfig(e) {
    return new this.constructor({
      bound: this.bound,
      kwargs: this.kwargs,
      config: { ...this.config, ...e }
    });
  }
  withRetry(e) {
    return new this.constructor({
      bound: this.bound.withRetry(e),
      kwargs: this.kwargs,
      config: this.config
    });
  }
  async invoke(e, n) {
    return this.bound.invoke(e, await this._mergeConfig(Re(n), this.kwargs));
  }
  async batch(e, n, a) {
    const r = Array.isArray(n) ? await Promise.all(n.map(async (i) => this._mergeConfig(Re(i), this.kwargs))) : await this._mergeConfig(Re(n), this.kwargs);
    return this.bound.batch(e, r, a);
  }
  async *_streamIterator(e, n) {
    yield* this.bound._streamIterator(e, await this._mergeConfig(Re(n), this.kwargs));
  }
  async stream(e, n) {
    return this.bound.stream(e, await this._mergeConfig(Re(n), this.kwargs));
  }
  async *transform(e, n) {
    yield* this.bound.transform(e, await this._mergeConfig(Re(n), this.kwargs));
  }
  streamEvents(e, n, a) {
    const r = this, i = async function* () {
      yield* r.bound.streamEvents(e, {
        ...await r._mergeConfig(Re(n), r.kwargs),
        version: n.version
      }, a);
    };
    return ln.fromAsyncGenerator(i());
  }
  static isRunnableBinding(e) {
    return e.bound && Te.isRunnable(e.bound);
  }
  /**
   * Bind lifecycle listeners to a Runnable, returning a new Runnable.
   * The Run object contains information about the run, including its id,
   * type, input, output, error, startTime, endTime, and any tags or metadata
   * added to the run.
   *
   * @param {Object} params - The object containing the callback functions.
   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
   */
  withListeners({ onStart: e, onEnd: n, onError: a }) {
    return new fo({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      configFactories: [
        (r) => ({
          callbacks: [
            new AC({
              config: r,
              onStart: e,
              onEnd: n,
              onError: a
            })
          ]
        })
      ]
    });
  }
}
class Uh extends Te {
  static lc_name() {
    return "RunnableEach";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "bound", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.bound = e.bound;
  }
  /**
   * Binds the runnable with the specified arguments.
   * @param kwargs The arguments to bind the runnable with.
   * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.
   */
  bind(e) {
    return new Uh({
      bound: this.bound.bind(e)
    });
  }
  /**
   * Invokes the runnable with the specified input and configuration.
   * @param input The input to invoke the runnable with.
   * @param config The configuration to invoke the runnable with.
   * @returns A promise that resolves to the output of the runnable.
   */
  async invoke(e, n) {
    return this._callWithConfig(this._invoke.bind(this), e, n);
  }
  /**
   * A helper method that is used to invoke the runnable with the specified input and configuration.
   * @param input The input to invoke the runnable with.
   * @param config The configuration to invoke the runnable with.
   * @returns A promise that resolves to the output of the runnable.
   */
  async _invoke(e, n, a) {
    return this.bound.batch(e, Ye(n, { callbacks: a?.getChild() }));
  }
  /**
   * Bind lifecycle listeners to a Runnable, returning a new Runnable.
   * The Run object contains information about the run, including its id,
   * type, input, output, error, startTime, endTime, and any tags or metadata
   * added to the run.
   *
   * @param {Object} params - The object containing the callback functions.
   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
   */
  withListeners({ onStart: e, onEnd: n, onError: a }) {
    return new Uh({
      bound: this.bound.withListeners({ onStart: e, onEnd: n, onError: a })
    });
  }
}
class EF extends fo {
  static lc_name() {
    return "RunnableRetry";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "maxAttemptNumber", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "onFailedAttempt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
      }
    }), this.maxAttemptNumber = e.maxAttemptNumber ?? this.maxAttemptNumber, this.onFailedAttempt = e.onFailedAttempt ?? this.onFailedAttempt;
  }
  _patchConfigForRetry(e, n, a) {
    const r = e > 1 ? `retry:attempt:${e}` : void 0;
    return Ye(n, { callbacks: a?.getChild(r) });
  }
  async _invoke(e, n, a) {
    return Ih((r) => super.invoke(e, this._patchConfigForRetry(r, n, a)), {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onFailedAttempt: (r) => this.onFailedAttempt(r, e),
      retries: Math.max(this.maxAttemptNumber - 1, 0),
      randomize: !0
    });
  }
  /**
   * Method that invokes the runnable with the specified input, run manager,
   * and config. It handles the retry logic by catching any errors and
   * recursively invoking itself with the updated config for the next retry
   * attempt.
   * @param input The input for the runnable.
   * @param runManager The run manager for the runnable.
   * @param config The config for the runnable.
   * @returns A promise that resolves to the output of the runnable.
   */
  async invoke(e, n) {
    return this._callWithConfig(this._invoke.bind(this), e, n);
  }
  async _batch(e, n, a, r) {
    const i = {};
    try {
      await Ih(async (s) => {
        const o = e.map((h, p) => p).filter((h) => i[h.toString()] === void 0 || // eslint-disable-next-line no-instanceof/no-instanceof
        i[h.toString()] instanceof Error), l = o.map((h) => e[h]), f = o.map((h) => this._patchConfigForRetry(s, n?.[h], a?.[h])), u = await super.batch(l, f, {
          ...r,
          returnExceptions: !0
        });
        let c;
        for (let h = 0; h < u.length; h += 1) {
          const p = u[h], d = o[h];
          p instanceof Error && c === void 0 && (c = p, c.input = l[h]), i[d.toString()] = p;
        }
        if (c)
          throw c;
        return u;
      }, {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        onFailedAttempt: (s) => this.onFailedAttempt(s, s.input),
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: !0
      });
    } catch (s) {
      if (r?.returnExceptions !== !0)
        throw s;
    }
    return Object.keys(i).sort((s, o) => parseInt(s, 10) - parseInt(o, 10)).map((s) => i[parseInt(s, 10)]);
  }
  async batch(e, n, a) {
    return this._batchWithConfig(this._batch.bind(this), e, n, a);
  }
}
class dt extends Te {
  static lc_name() {
    return "RunnableSequence";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "first", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "middle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "last", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "omitSequenceTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), this.first = e.first, this.middle = e.middle ?? this.middle, this.last = e.last, this.name = e.name, this.omitSequenceTags = e.omitSequenceTags ?? this.omitSequenceTags;
  }
  get steps() {
    return [this.first, ...this.middle, this.last];
  }
  async invoke(e, n) {
    const a = Re(n), i = await (await Vn(a))?.handleChainStart(this.toJSON(), Rt(e, "input"), a.runId, void 0, void 0, void 0, a?.runName);
    delete a.runId;
    let s = e, o;
    try {
      const l = [this.first, ...this.middle];
      for (let f = 0; f < l.length; f += 1) {
        const c = l[f].invoke(s, Ye(a, {
          callbacks: i?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${f + 1}`)
        }));
        s = await go(c, n?.signal);
      }
      if (n?.signal?.aborted)
        throw new Error("Aborted");
      o = await this.last.invoke(s, Ye(a, {
        callbacks: i?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`)
      }));
    } catch (l) {
      throw await i?.handleChainError(l), l;
    }
    return await i?.handleChainEnd(Rt(o, "output")), o;
  }
  async batch(e, n, a) {
    const r = this._getOptionsList(n ?? {}, e.length), i = await Promise.all(r.map(Vn)), s = await Promise.all(i.map(async (l, f) => {
      const u = await l?.handleChainStart(this.toJSON(), Rt(e[f], "input"), r[f].runId, void 0, void 0, void 0, r[f].runName);
      return delete r[f].runId, u;
    }));
    let o = e;
    try {
      for (let l = 0; l < this.steps.length; l += 1) {
        const u = this.steps[l].batch(o, s.map((c, h) => {
          const p = c?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${l + 1}`);
          return Ye(r[h], { callbacks: p });
        }), a);
        o = await go(u, r[0]?.signal);
      }
    } catch (l) {
      throw await Promise.all(s.map((f) => f?.handleChainError(l))), l;
    }
    return await Promise.all(s.map((l) => l?.handleChainEnd(Rt(o, "output")))), o;
  }
  async *_streamIterator(e, n) {
    const a = await Vn(n), { runId: r, ...i } = n ?? {}, s = await a?.handleChainStart(this.toJSON(), Rt(e, "input"), r, void 0, void 0, void 0, i?.runName), o = [this.first, ...this.middle, this.last];
    let l = !0, f;
    async function* u() {
      yield e;
    }
    try {
      let c = o[0].transform(u(), Ye(i, {
        callbacks: s?.getChild(this.omitSequenceTags ? void 0 : "seq:step:1")
      }));
      for (let h = 1; h < o.length; h += 1)
        c = await o[h].transform(c, Ye(i, {
          callbacks: s?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${h + 1}`)
        }));
      for await (const h of c)
        if (n?.signal?.throwIfAborted(), yield h, l)
          if (f === void 0)
            f = h;
          else
            try {
              f = on(f, h);
            } catch {
              f = void 0, l = !1;
            }
    } catch (c) {
      throw await s?.handleChainError(c), c;
    }
    await s?.handleChainEnd(Rt(f, "output"));
  }
  getGraph(e) {
    const n = new Lh();
    let a = null;
    return this.steps.forEach((r, i) => {
      const s = r.getGraph(e);
      i !== 0 && s.trimFirstNode(), i !== this.steps.length - 1 && s.trimLastNode(), n.extend(s);
      const o = s.firstNode();
      if (!o)
        throw new Error(`Runnable ${r} has no first node`);
      a && n.addEdge(a, o), a = s.lastNode();
    }), n;
  }
  pipe(e) {
    return dt.isRunnableSequence(e) ? new dt({
      first: this.first,
      middle: this.middle.concat([
        this.last,
        e.first,
        ...e.middle
      ]),
      last: e.last,
      name: this.name ?? e.name
    }) : new dt({
      first: this.first,
      middle: [...this.middle, this.last],
      last: Pn(e),
      name: this.name
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isRunnableSequence(e) {
    return Array.isArray(e.middle) && Te.isRunnable(e);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static from([e, ...n], a) {
    let r = {};
    return typeof a == "string" ? r.name = a : a !== void 0 && (r = a), new dt({
      ...r,
      first: Pn(e),
      middle: n.slice(0, -1).map(Pn),
      last: Pn(n[n.length - 1])
    });
  }
}
class dc extends Te {
  static lc_name() {
    return "RunnableMap";
  }
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "steps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.steps = {};
    for (const [n, a] of Object.entries(e.steps))
      this.steps[n] = Pn(a);
  }
  static from(e) {
    return new dc({ steps: e });
  }
  async invoke(e, n) {
    const a = Re(n), i = await (await Vn(a))?.handleChainStart(this.toJSON(), {
      input: e
    }, a.runId, void 0, void 0, void 0, a?.runName);
    delete a.runId;
    const s = {};
    try {
      const o = Object.entries(this.steps).map(async ([l, f]) => {
        s[l] = await f.invoke(e, Ye(a, {
          callbacks: i?.getChild(`map:key:${l}`)
        }));
      });
      await go(Promise.all(o), n?.signal);
    } catch (o) {
      throw await i?.handleChainError(o), o;
    }
    return await i?.handleChainEnd(s), s;
  }
  async *_transform(e, n, a) {
    const r = { ...this.steps }, i = MC(e, Object.keys(r).length), s = new Map(Object.entries(r).map(([o, l], f) => {
      const u = l.transform(i[f], Ye(a, {
        callbacks: n?.getChild(`map:key:${o}`)
      }));
      return [o, u.next().then((c) => ({ key: o, gen: u, result: c }))];
    }));
    for (; s.size; ) {
      const o = Promise.race(s.values()), { key: l, result: f, gen: u } = await go(o, a?.signal);
      s.delete(l), f.done || (yield { [l]: f.value }, s.set(l, u.next().then((c) => ({ key: l, gen: u, result: c }))));
    }
  }
  transform(e, n) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), n);
  }
  async stream(e, n) {
    async function* a() {
      yield e;
    }
    const r = Re(n), i = new lc({
      generator: this.transform(a(), r),
      config: r
    });
    return await i.setup, ln.fromAsyncGenerator(i);
  }
}
class d_ extends Te {
  constructor(e) {
    if (super(e), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "func", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), !u_(e.func))
      throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
    this.func = e.func;
  }
  async invoke(e, n) {
    const [a] = this._getOptionsList(n ?? {}, 1), r = await Vn(a), i = this.func(Ye(a, { callbacks: r }), e);
    return go(i, a?.signal);
  }
  async *_streamIterator(e, n) {
    const [a] = this._getOptionsList(n ?? {}, 1), r = await this.invoke(e, n);
    if (ig(r)) {
      for await (const i of r)
        a?.signal?.throwIfAborted(), yield i;
      return;
    }
    if (AF(r)) {
      for (; ; ) {
        a?.signal?.throwIfAborted();
        const i = r.next();
        if (i.done)
          break;
        yield i.value;
      }
      return;
    }
    yield r;
  }
  static from(e) {
    return new d_({ func: e });
  }
}
function IF(t) {
  if (u_(t))
    throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
}
class au extends Te {
  static lc_name() {
    return "RunnableLambda";
  }
  constructor(e) {
    if (u_(e.func))
      return d_.from(e.func);
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "func", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), IF(e.func), this.func = e.func;
  }
  static from(e) {
    return new au({
      func: e
    });
  }
  async _invoke(e, n, a) {
    return new Promise((r, i) => {
      const s = Ye(n, {
        callbacks: a?.getChild(),
        recursionLimit: (n?.recursionLimit ?? qm) - 1
      });
      xn.runWithConfig(Qu(s), async () => {
        try {
          let o = await this.func(e, {
            ...s
          });
          if (o && Te.isRunnable(o)) {
            if (n?.recursionLimit === 0)
              throw new Error("Recursion limit reached.");
            o = await o.invoke(e, {
              ...s,
              recursionLimit: (s.recursionLimit ?? qm) - 1
            });
          } else if (ig(o)) {
            let l;
            for await (const f of sg(s, o))
              if (n?.signal?.throwIfAborted(), l === void 0)
                l = f;
              else
                try {
                  l = on(l, f);
                } catch {
                  l = f;
                }
            o = l;
          } else if (Vw(o)) {
            let l;
            for (const f of zw(s, o))
              if (n?.signal?.throwIfAborted(), l === void 0)
                l = f;
              else
                try {
                  l = on(l, f);
                } catch {
                  l = f;
                }
            o = l;
          }
          r(o);
        } catch (o) {
          i(o);
        }
      });
    });
  }
  async invoke(e, n) {
    return this._callWithConfig(this._invoke.bind(this), e, n);
  }
  async *_transform(e, n, a) {
    let r;
    for await (const o of e)
      if (r === void 0)
        r = o;
      else
        try {
          r = on(r, o);
        } catch {
          r = o;
        }
    const i = Ye(a, {
      callbacks: n?.getChild(),
      recursionLimit: (a?.recursionLimit ?? qm) - 1
    }), s = await new Promise((o, l) => {
      xn.runWithConfig(Qu(i), async () => {
        try {
          const f = await this.func(r, {
            ...i,
            config: i
          });
          o(f);
        } catch (f) {
          l(f);
        }
      });
    });
    if (s && Te.isRunnable(s)) {
      if (a?.recursionLimit === 0)
        throw new Error("Recursion limit reached.");
      const o = await s.stream(r, i);
      for await (const l of o)
        yield l;
    } else if (ig(s))
      for await (const o of sg(i, s))
        a?.signal?.throwIfAborted(), yield o;
    else if (Vw(s))
      for (const o of zw(i, s))
        a?.signal?.throwIfAborted(), yield o;
    else
      yield s;
  }
  transform(e, n) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), n);
  }
  async stream(e, n) {
    async function* a() {
      yield e;
    }
    const r = Re(n), i = new lc({
      generator: this.transform(a(), r),
      config: r
    });
    return await i.setup, ln.fromAsyncGenerator(i);
  }
}
class NF extends Te {
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "runnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fallbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.runnable = e.runnable, this.fallbacks = e.fallbacks;
  }
  *runnables() {
    yield this.runnable;
    for (const e of this.fallbacks)
      yield e;
  }
  async invoke(e, n) {
    const a = Re(n), r = await Vn(a), { runId: i, ...s } = a, o = await r?.handleChainStart(this.toJSON(), Rt(e, "input"), i, void 0, void 0, void 0, s?.runName), l = Ye(s, {
      callbacks: o?.getChild()
    });
    return await xn.runWithConfig(l, async () => {
      let u;
      for (const c of this.runnables()) {
        a?.signal?.throwIfAborted();
        try {
          const h = await c.invoke(e, l);
          return await o?.handleChainEnd(Rt(h, "output")), h;
        } catch (h) {
          u === void 0 && (u = h);
        }
      }
      throw u === void 0 ? new Error("No error stored at end of fallback.") : (await o?.handleChainError(u), u);
    });
  }
  async *_streamIterator(e, n) {
    const a = Re(n), r = await Vn(a), { runId: i, ...s } = a, o = await r?.handleChainStart(this.toJSON(), Rt(e, "input"), i, void 0, void 0, void 0, s?.runName);
    let l, f;
    for (const c of this.runnables()) {
      a?.signal?.throwIfAborted();
      const h = Ye(s, {
        callbacks: o?.getChild()
      });
      try {
        const p = await c.stream(e, h);
        f = sg(h, p);
        break;
      } catch (p) {
        l === void 0 && (l = p);
      }
    }
    if (f === void 0) {
      const c = l ?? new Error("No error stored at end of fallback.");
      throw await o?.handleChainError(c), c;
    }
    let u;
    try {
      for await (const c of f) {
        yield c;
        try {
          u = u === void 0 ? u : on(u, c);
        } catch {
          u = void 0;
        }
      }
    } catch (c) {
      throw await o?.handleChainError(c), c;
    }
    await o?.handleChainEnd(Rt(u, "output"));
  }
  async batch(e, n, a) {
    if (a?.returnExceptions)
      throw new Error("Not implemented.");
    const r = this._getOptionsList(n ?? {}, e.length), i = await Promise.all(r.map((l) => Vn(l))), s = await Promise.all(i.map(async (l, f) => {
      const u = await l?.handleChainStart(this.toJSON(), Rt(e[f], "input"), r[f].runId, void 0, void 0, void 0, r[f].runName);
      return delete r[f].runId, u;
    }));
    let o;
    for (const l of this.runnables()) {
      r[0].signal?.throwIfAborted();
      try {
        const f = await l.batch(e, s.map((u, c) => Ye(r[c], {
          callbacks: u?.getChild()
        })), a);
        return await Promise.all(s.map((u, c) => u?.handleChainEnd(Rt(f[c], "output")))), f;
      } catch (f) {
        o === void 0 && (o = f);
      }
    }
    throw o ? (await Promise.all(s.map((l) => l?.handleChainError(o))), o) : new Error("No error stored at end of fallbacks.");
  }
}
function Pn(t) {
  if (typeof t == "function")
    return new au({ func: t });
  if (Te.isRunnable(t))
    return t;
  if (!Array.isArray(t) && typeof t == "object") {
    const e = {};
    for (const [n, a] of Object.entries(t))
      e[n] = Pn(a);
    return new dc({
      steps: e
    });
  } else
    throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
}
class qC extends Te {
  static lc_name() {
    return "RunnableAssign";
  }
  constructor(e) {
    e instanceof dc && (e = { mapper: e }), super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "mapper", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.mapper = e.mapper;
  }
  async invoke(e, n) {
    const a = await this.mapper.invoke(e, n);
    return {
      ...e,
      ...a
    };
  }
  async *_transform(e, n, a) {
    const r = this.mapper.getStepsKeys(), [i, s] = MC(e), o = this.mapper.transform(s, Ye(a, { callbacks: n?.getChild() })), l = o.next();
    for await (const f of i) {
      if (typeof f != "object" || Array.isArray(f))
        throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof f}`);
      const u = Object.fromEntries(Object.entries(f).filter(([c]) => !r.includes(c)));
      Object.keys(u).length > 0 && (yield u);
    }
    yield (await l).value;
    for await (const f of o)
      yield f;
  }
  transform(e, n) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), n);
  }
  async stream(e, n) {
    async function* a() {
      yield e;
    }
    const r = Re(n), i = new lc({
      generator: this.transform(a(), r),
      config: r
    });
    return await i.setup, ln.fromAsyncGenerator(i);
  }
}
class kF extends Te {
  static lc_name() {
    return "RunnablePick";
  }
  constructor(e) {
    (typeof e == "string" || Array.isArray(e)) && (e = { keys: e }), super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "keys", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.keys = e.keys;
  }
  async _pick(e) {
    if (typeof this.keys == "string")
      return e[this.keys];
    {
      const n = this.keys.map((a) => [a, e[a]]).filter((a) => a[1] !== void 0);
      return n.length === 0 ? void 0 : Object.fromEntries(n);
    }
  }
  async invoke(e, n) {
    return this._callWithConfig(this._pick.bind(this), e, n);
  }
  async *_transform(e) {
    for await (const n of e) {
      const a = await this._pick(n);
      a !== void 0 && (yield a);
    }
  }
  transform(e, n) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), n);
  }
  async stream(e, n) {
    async function* a() {
      yield e;
    }
    const r = Re(n), i = new lc({
      generator: this.transform(a(), r),
      config: r
    });
    return await i.setup, ln.fromAsyncGenerator(i);
  }
}
class Zw extends fo {
  constructor(e) {
    const n = dt.from([
      au.from(async (a) => {
        let r;
        if (s_(a))
          try {
            r = await this.schema.parseAsync(a.args);
          } catch {
            throw new Ph("Received tool input did not match expected schema", JSON.stringify(a.args));
          }
        else
          r = a;
        return r;
      }).withConfig({ runName: `${e.name}:parse_input` }),
      e.bound
    ]).withConfig({ runName: e.name });
    super({
      bound: n,
      config: e.config ?? {}
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "description", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "schema", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = e.name, this.description = e.description, this.schema = e.schema;
  }
  static lc_name() {
    return "RunnableToolLike";
  }
}
function FF(t, e) {
  const n = e.name ?? t.getName(), a = e.description ?? e.schema?.description;
  return e.schema.constructor === jn.ZodString ? new Zw({
    name: n,
    description: a,
    schema: jn.object({
      input: jn.string()
    }).transform((r) => r.input),
    bound: t
  }) : new Zw({
    name: n,
    description: a,
    schema: e.schema,
    bound: t
  });
}
/*
 * [js-sha1]{@link https://github.com/emn178/js-sha1}
 *
 * @version 0.6.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
var DF = typeof window == "object" ? window : {}, _e = "0123456789abcdef".split(""), qF = [-2147483648, 8388608, 32768, 128], Qn = [24, 16, 8, 0], Ot = [];
function wr(t) {
  t ? (Ot[0] = Ot[16] = Ot[1] = Ot[2] = Ot[3] = Ot[4] = Ot[5] = Ot[6] = Ot[7] = Ot[8] = Ot[9] = Ot[10] = Ot[11] = Ot[12] = Ot[13] = Ot[14] = Ot[15] = 0, this.blocks = Ot) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.h0 = 1732584193, this.h1 = 4023233417, this.h2 = 2562383102, this.h3 = 271733878, this.h4 = 3285377520, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0;
}
wr.prototype.update = function(t) {
  if (!this.finalized) {
    var e = typeof t != "string";
    e && t.constructor === DF.ArrayBuffer && (t = new Uint8Array(t));
    for (var n, a = 0, r, i = t.length || 0, s = this.blocks; a < i; ) {
      if (this.hashed && (this.hashed = !1, s[0] = this.block, s[16] = s[1] = s[2] = s[3] = s[4] = s[5] = s[6] = s[7] = s[8] = s[9] = s[10] = s[11] = s[12] = s[13] = s[14] = s[15] = 0), e)
        for (r = this.start; a < i && r < 64; ++a)
          s[r >> 2] |= t[a] << Qn[r++ & 3];
      else
        for (r = this.start; a < i && r < 64; ++a)
          n = t.charCodeAt(a), n < 128 ? s[r >> 2] |= n << Qn[r++ & 3] : n < 2048 ? (s[r >> 2] |= (192 | n >> 6) << Qn[r++ & 3], s[r >> 2] |= (128 | n & 63) << Qn[r++ & 3]) : n < 55296 || n >= 57344 ? (s[r >> 2] |= (224 | n >> 12) << Qn[r++ & 3], s[r >> 2] |= (128 | n >> 6 & 63) << Qn[r++ & 3], s[r >> 2] |= (128 | n & 63) << Qn[r++ & 3]) : (n = 65536 + ((n & 1023) << 10 | t.charCodeAt(++a) & 1023), s[r >> 2] |= (240 | n >> 18) << Qn[r++ & 3], s[r >> 2] |= (128 | n >> 12 & 63) << Qn[r++ & 3], s[r >> 2] |= (128 | n >> 6 & 63) << Qn[r++ & 3], s[r >> 2] |= (128 | n & 63) << Qn[r++ & 3]);
      this.lastByteIndex = r, this.bytes += r - this.start, r >= 64 ? (this.block = s[16], this.start = r - 64, this.hash(), this.hashed = !0) : this.start = r;
    }
    return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
  }
};
wr.prototype.finalize = function() {
  if (!this.finalized) {
    this.finalized = !0;
    var t = this.blocks, e = this.lastByteIndex;
    t[16] = this.block, t[e >> 2] |= qF[e & 3], this.block = t[16], e >= 56 && (this.hashed || this.hash(), t[0] = this.block, t[16] = t[1] = t[2] = t[3] = t[4] = t[5] = t[6] = t[7] = t[8] = t[9] = t[10] = t[11] = t[12] = t[13] = t[14] = t[15] = 0), t[14] = this.hBytes << 3 | this.bytes >>> 29, t[15] = this.bytes << 3, this.hash();
  }
};
wr.prototype.hash = function() {
  var t = this.h0, e = this.h1, n = this.h2, a = this.h3, r = this.h4, i, s, o, l = this.blocks;
  for (s = 16; s < 80; ++s)
    o = l[s - 3] ^ l[s - 8] ^ l[s - 14] ^ l[s - 16], l[s] = o << 1 | o >>> 31;
  for (s = 0; s < 20; s += 5)
    i = e & n | ~e & a, o = t << 5 | t >>> 27, r = o + i + r + 1518500249 + l[s] << 0, e = e << 30 | e >>> 2, i = t & e | ~t & n, o = r << 5 | r >>> 27, a = o + i + a + 1518500249 + l[s + 1] << 0, t = t << 30 | t >>> 2, i = r & t | ~r & e, o = a << 5 | a >>> 27, n = o + i + n + 1518500249 + l[s + 2] << 0, r = r << 30 | r >>> 2, i = a & r | ~a & t, o = n << 5 | n >>> 27, e = o + i + e + 1518500249 + l[s + 3] << 0, a = a << 30 | a >>> 2, i = n & a | ~n & r, o = e << 5 | e >>> 27, t = o + i + t + 1518500249 + l[s + 4] << 0, n = n << 30 | n >>> 2;
  for (; s < 40; s += 5)
    i = e ^ n ^ a, o = t << 5 | t >>> 27, r = o + i + r + 1859775393 + l[s] << 0, e = e << 30 | e >>> 2, i = t ^ e ^ n, o = r << 5 | r >>> 27, a = o + i + a + 1859775393 + l[s + 1] << 0, t = t << 30 | t >>> 2, i = r ^ t ^ e, o = a << 5 | a >>> 27, n = o + i + n + 1859775393 + l[s + 2] << 0, r = r << 30 | r >>> 2, i = a ^ r ^ t, o = n << 5 | n >>> 27, e = o + i + e + 1859775393 + l[s + 3] << 0, a = a << 30 | a >>> 2, i = n ^ a ^ r, o = e << 5 | e >>> 27, t = o + i + t + 1859775393 + l[s + 4] << 0, n = n << 30 | n >>> 2;
  for (; s < 60; s += 5)
    i = e & n | e & a | n & a, o = t << 5 | t >>> 27, r = o + i + r - 1894007588 + l[s] << 0, e = e << 30 | e >>> 2, i = t & e | t & n | e & n, o = r << 5 | r >>> 27, a = o + i + a - 1894007588 + l[s + 1] << 0, t = t << 30 | t >>> 2, i = r & t | r & e | t & e, o = a << 5 | a >>> 27, n = o + i + n - 1894007588 + l[s + 2] << 0, r = r << 30 | r >>> 2, i = a & r | a & t | r & t, o = n << 5 | n >>> 27, e = o + i + e - 1894007588 + l[s + 3] << 0, a = a << 30 | a >>> 2, i = n & a | n & r | a & r, o = e << 5 | e >>> 27, t = o + i + t - 1894007588 + l[s + 4] << 0, n = n << 30 | n >>> 2;
  for (; s < 80; s += 5)
    i = e ^ n ^ a, o = t << 5 | t >>> 27, r = o + i + r - 899497514 + l[s] << 0, e = e << 30 | e >>> 2, i = t ^ e ^ n, o = r << 5 | r >>> 27, a = o + i + a - 899497514 + l[s + 1] << 0, t = t << 30 | t >>> 2, i = r ^ t ^ e, o = a << 5 | a >>> 27, n = o + i + n - 899497514 + l[s + 2] << 0, r = r << 30 | r >>> 2, i = a ^ r ^ t, o = n << 5 | n >>> 27, e = o + i + e - 899497514 + l[s + 3] << 0, a = a << 30 | a >>> 2, i = n ^ a ^ r, o = e << 5 | e >>> 27, t = o + i + t - 899497514 + l[s + 4] << 0, n = n << 30 | n >>> 2;
  this.h0 = this.h0 + t << 0, this.h1 = this.h1 + e << 0, this.h2 = this.h2 + n << 0, this.h3 = this.h3 + a << 0, this.h4 = this.h4 + r << 0;
};
wr.prototype.hex = function() {
  this.finalize();
  var t = this.h0, e = this.h1, n = this.h2, a = this.h3, r = this.h4;
  return _e[t >> 28 & 15] + _e[t >> 24 & 15] + _e[t >> 20 & 15] + _e[t >> 16 & 15] + _e[t >> 12 & 15] + _e[t >> 8 & 15] + _e[t >> 4 & 15] + _e[t & 15] + _e[e >> 28 & 15] + _e[e >> 24 & 15] + _e[e >> 20 & 15] + _e[e >> 16 & 15] + _e[e >> 12 & 15] + _e[e >> 8 & 15] + _e[e >> 4 & 15] + _e[e & 15] + _e[n >> 28 & 15] + _e[n >> 24 & 15] + _e[n >> 20 & 15] + _e[n >> 16 & 15] + _e[n >> 12 & 15] + _e[n >> 8 & 15] + _e[n >> 4 & 15] + _e[n & 15] + _e[a >> 28 & 15] + _e[a >> 24 & 15] + _e[a >> 20 & 15] + _e[a >> 16 & 15] + _e[a >> 12 & 15] + _e[a >> 8 & 15] + _e[a >> 4 & 15] + _e[a & 15] + _e[r >> 28 & 15] + _e[r >> 24 & 15] + _e[r >> 20 & 15] + _e[r >> 16 & 15] + _e[r >> 12 & 15] + _e[r >> 8 & 15] + _e[r >> 4 & 15] + _e[r & 15];
};
wr.prototype.toString = wr.prototype.hex;
wr.prototype.digest = function() {
  this.finalize();
  var t = this.h0, e = this.h1, n = this.h2, a = this.h3, r = this.h4;
  return [
    t >> 24 & 255,
    t >> 16 & 255,
    t >> 8 & 255,
    t & 255,
    e >> 24 & 255,
    e >> 16 & 255,
    e >> 8 & 255,
    e & 255,
    n >> 24 & 255,
    n >> 16 & 255,
    n >> 8 & 255,
    n & 255,
    a >> 24 & 255,
    a >> 16 & 255,
    a >> 8 & 255,
    a & 255,
    r >> 24 & 255,
    r >> 16 & 255,
    r >> 8 & 255,
    r & 255
  ];
};
wr.prototype.array = wr.prototype.digest;
wr.prototype.arrayBuffer = function() {
  this.finalize();
  var t = new ArrayBuffer(20), e = new DataView(t);
  return e.setUint32(0, this.h0), e.setUint32(4, this.h1), e.setUint32(8, this.h2), e.setUint32(12, this.h3), e.setUint32(16, this.h4), t;
};
const JF = (t) => new wr(!0).update(t).hex(), Kw = (...t) => JF(t.join("_"));
class LF {
}
const UF = /* @__PURE__ */ new Map();
class f_ extends LF {
  constructor(e) {
    super(), Object.defineProperty(this, "cache", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cache = e ?? /* @__PURE__ */ new Map();
  }
  /**
   * Retrieves data from the cache using a prompt and an LLM key. If the
   * data is not found, it returns null.
   * @param prompt The prompt used to find the data.
   * @param llmKey The LLM key used to find the data.
   * @returns The data corresponding to the prompt and LLM key, or null if not found.
   */
  lookup(e, n) {
    return Promise.resolve(this.cache.get(Kw(e, n)) ?? null);
  }
  /**
   * Updates the cache with new data using a prompt and an LLM key.
   * @param prompt The prompt used to store the data.
   * @param llmKey The LLM key used to store the data.
   * @param value The data to be stored.
   */
  async update(e, n, a) {
    this.cache.set(Kw(e, n), a);
  }
  /**
   * Returns a global instance of InMemoryCache using a predefined global
   * map as the initial cache.
   * @returns A global instance of InMemoryCache.
   */
  static global() {
    return new f_(UF);
  }
}
class h_ extends gr {
}
class JC extends h_ {
  static lc_name() {
    return "StringPromptValue";
  }
  constructor(e) {
    super({ value: e }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompt_values"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.value = e;
  }
  toString() {
    return this.value;
  }
  toChatMessages() {
    return [new _r(this.value)];
  }
}
class LC extends h_ {
  static lc_name() {
    return "ChatPromptValue";
  }
  constructor(e) {
    Array.isArray(e) && (e = { messages: e }), super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompt_values"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "messages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.messages = e.messages;
  }
  toString() {
    return lo(this.messages);
  }
  toChatMessages() {
    return this.messages;
  }
}
class BF extends h_ {
  static lc_name() {
    return "ImagePromptValue";
  }
  constructor(e) {
    "imageUrl" in e || (e = { imageUrl: e }), super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompt_values"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "imageUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.imageUrl = e.imageUrl;
  }
  toString() {
    return this.imageUrl.url;
  }
  toChatMessages() {
    return [
      new _r({
        content: [
          {
            type: "image_url",
            image_url: {
              detail: this.imageUrl.detail,
              url: this.imageUrl.url
            }
          }
        ]
      })
    ];
  }
}
var jc = {}, Hw;
function xF() {
  if (Hw) return jc;
  Hw = 1, jc.byteLength = o, jc.toByteArray = f, jc.fromByteArray = h;
  for (var t = [], e = [], n = typeof Uint8Array < "u" ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = 0, i = a.length; r < i; ++r)
    t[r] = a[r], e[a.charCodeAt(r)] = r;
  e[45] = 62, e[95] = 63;
  function s(p) {
    var d = p.length;
    if (d % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var m = p.indexOf("=");
    m === -1 && (m = d);
    var b = m === d ? 0 : 4 - m % 4;
    return [m, b];
  }
  function o(p) {
    var d = s(p), m = d[0], b = d[1];
    return (m + b) * 3 / 4 - b;
  }
  function l(p, d, m) {
    return (d + m) * 3 / 4 - m;
  }
  function f(p) {
    var d, m = s(p), b = m[0], g = m[1], _ = new n(l(p, b, g)), P = 0, C = g > 0 ? b - 4 : b, R;
    for (R = 0; R < C; R += 4)
      d = e[p.charCodeAt(R)] << 18 | e[p.charCodeAt(R + 1)] << 12 | e[p.charCodeAt(R + 2)] << 6 | e[p.charCodeAt(R + 3)], _[P++] = d >> 16 & 255, _[P++] = d >> 8 & 255, _[P++] = d & 255;
    return g === 2 && (d = e[p.charCodeAt(R)] << 2 | e[p.charCodeAt(R + 1)] >> 4, _[P++] = d & 255), g === 1 && (d = e[p.charCodeAt(R)] << 10 | e[p.charCodeAt(R + 1)] << 4 | e[p.charCodeAt(R + 2)] >> 2, _[P++] = d >> 8 & 255, _[P++] = d & 255), _;
  }
  function u(p) {
    return t[p >> 18 & 63] + t[p >> 12 & 63] + t[p >> 6 & 63] + t[p & 63];
  }
  function c(p, d, m) {
    for (var b, g = [], _ = d; _ < m; _ += 3)
      b = (p[_] << 16 & 16711680) + (p[_ + 1] << 8 & 65280) + (p[_ + 2] & 255), g.push(u(b));
    return g.join("");
  }
  function h(p) {
    for (var d, m = p.length, b = m % 3, g = [], _ = 16383, P = 0, C = m - b; P < C; P += _)
      g.push(c(p, P, P + _ > C ? C : P + _));
    return b === 1 ? (d = p[m - 1], g.push(
      t[d >> 2] + t[d << 4 & 63] + "=="
    )) : b === 2 && (d = (p[m - 2] << 8) + p[m - 1], g.push(
      t[d >> 10] + t[d >> 4 & 63] + t[d << 2 & 63] + "="
    )), g.join("");
  }
  return jc;
}
var VF = /* @__PURE__ */ xF();
const zF = /* @__PURE__ */ Bd(VF);
var ZF = Object.defineProperty, KF = (t, e, n) => e in t ? ZF(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, HF = (t, e, n) => (KF(t, e + "", n), n);
function GF(t, e) {
  let n = Array.from(
    { length: t.length },
    (a, r) => ({ start: r, end: r + 1 })
  );
  for (; n.length > 1; ) {
    let a = null;
    for (let r = 0; r < n.length - 1; r++) {
      const i = t.slice(n[r].start, n[r + 1].end), s = e.get(i.join(","));
      s != null && (a == null || s < a[0]) && (a = [s, r]);
    }
    if (a != null) {
      const r = a[1];
      n[r] = { start: n[r].start, end: n[r + 1].end }, n.splice(r + 1, 1);
    } else
      break;
  }
  return n;
}
function WF(t, e) {
  return t.length === 1 ? [e.get(t.join(","))] : GF(t, e).map((n) => e.get(t.slice(n.start, n.end).join(","))).filter((n) => n != null);
}
function XF(t) {
  return t.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var og = class {
  /** @internal */
  specialTokens;
  /** @internal */
  inverseSpecialTokens;
  /** @internal */
  patStr;
  /** @internal */
  textEncoder = new TextEncoder();
  /** @internal */
  textDecoder = new TextDecoder("utf-8");
  /** @internal */
  rankMap = /* @__PURE__ */ new Map();
  /** @internal */
  textMap = /* @__PURE__ */ new Map();
  constructor(t, e) {
    this.patStr = t.pat_str;
    const n = t.bpe_ranks.split(`
`).filter(Boolean).reduce((a, r) => {
      const [i, s, ...o] = r.split(" "), l = Number.parseInt(s, 10);
      return o.forEach((f, u) => a[f] = l + u), a;
    }, {});
    for (const [a, r] of Object.entries(n)) {
      const i = zF.toByteArray(a);
      this.rankMap.set(i.join(","), r), this.textMap.set(r, i);
    }
    this.specialTokens = { ...t.special_tokens, ...e }, this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((a, [r, i]) => (a[i] = this.textEncoder.encode(r), a), {});
  }
  encode(t, e = [], n = "all") {
    const a = new RegExp(this.patStr, "ug"), r = og.specialTokenRegex(
      Object.keys(this.specialTokens)
    ), i = [], s = new Set(
      e === "all" ? Object.keys(this.specialTokens) : e
    ), o = new Set(
      n === "all" ? Object.keys(this.specialTokens).filter(
        (f) => !s.has(f)
      ) : n
    );
    if (o.size > 0) {
      const f = og.specialTokenRegex([
        ...o
      ]), u = t.match(f);
      if (u != null)
        throw new Error(
          `The text contains a special token that is not allowed: ${u[0]}`
        );
    }
    let l = 0;
    for (; ; ) {
      let f = null, u = l;
      for (; r.lastIndex = u, f = r.exec(t), !(f == null || s.has(f[0])); )
        u = f.index + 1;
      const c = f?.index ?? t.length;
      for (const p of t.substring(l, c).matchAll(a)) {
        const d = this.textEncoder.encode(p[0]), m = this.rankMap.get(d.join(","));
        if (m != null) {
          i.push(m);
          continue;
        }
        i.push(...WF(d, this.rankMap));
      }
      if (f == null)
        break;
      let h = this.specialTokens[f[0]];
      i.push(h), l = f.index + f[0].length;
    }
    return i;
  }
  decode(t) {
    const e = [];
    let n = 0;
    for (let i = 0; i < t.length; ++i) {
      const s = t[i], o = this.textMap.get(s) ?? this.inverseSpecialTokens[s];
      o != null && (e.push(o), n += o.length);
    }
    const a = new Uint8Array(n);
    let r = 0;
    for (const i of e)
      a.set(i, r), r += i.length;
    return this.textDecoder.decode(a);
  }
}, UC = og;
HF(UC, "specialTokenRegex", (t) => new RegExp(t.map((e) => XF(e)).join("|"), "g"));
function QF(t) {
  switch (t) {
    case "gpt2":
      return "gpt2";
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003":
      return "p50k_base";
    case "code-davinci-edit-001":
    case "text-davinci-edit-001":
      return "p50k_edit";
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001":
      return "r50k_base";
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002":
    case "text-embedding-3-small":
    case "text-embedding-3-large":
      return "cl100k_base";
    case "gpt-4o":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
    case "gpt-4o-2024-11-20":
    case "gpt-4o-mini-2024-07-18":
    case "gpt-4o-mini":
    case "o1":
    case "o1-2024-12-17":
    case "o1-mini":
    case "o1-preview":
    case "o1-preview-2024-09-12":
    case "o1-mini-2024-09-12":
    case "o3-mini":
    case "o3-mini-2025-01-31":
    case "chatgpt-4o-latest":
    case "gpt-4o-realtime":
    case "gpt-4o-realtime-preview-2024-10-01":
      return "o200k_base";
    default:
      throw new Error("Unknown model");
  }
}
const Rf = {}, YF = /* @__PURE__ */ new ru({});
async function BC(t) {
  return t in Rf || (Rf[t] = YF.fetch(`https://tiktoken.pages.dev/js/${t}.json`).then((e) => e.json()).then((e) => new UC(e)).catch((e) => {
    throw delete Rf[t], e;
  })), await Rf[t];
}
async function xC(t) {
  return BC(QF(t));
}
const p_ = (t) => t.startsWith("gpt-3.5-turbo-16k") ? "gpt-3.5-turbo-16k" : t.startsWith("gpt-3.5-turbo-") ? "gpt-3.5-turbo" : t.startsWith("gpt-4-32k") ? "gpt-4-32k" : t.startsWith("gpt-4-") ? "gpt-4" : t.startsWith("gpt-4o") ? "gpt-4o" : t, eD = (t) => {
  switch (p_(t)) {
    case "gpt-3.5-turbo-16k":
      return 16384;
    case "gpt-3.5-turbo":
      return 4096;
    case "gpt-4-32k":
      return 32768;
    case "gpt-4":
      return 8192;
    case "text-davinci-003":
      return 4097;
    case "text-curie-001":
      return 2048;
    case "text-babbage-001":
      return 2048;
    case "text-ada-001":
      return 2048;
    case "code-davinci-002":
      return 8e3;
    case "code-cushman-001":
      return 2048;
    default:
      return 4097;
  }
};
function fc(t) {
  return typeof t != "object" || !t ? !1 : !!("type" in t && t.type === "function" && "function" in t && typeof t.function == "object" && t.function && "name" in t.function && "parameters" in t.function);
}
const tD = async ({ prompt: t, modelName: e }) => {
  let n;
  try {
    n = (await xC(p_(e))).encode(t).length;
  } catch {
    console.warn("Failed to calculate number of tokens, falling back to approximate count"), n = Math.ceil(t.length / 4);
  }
  return eD(e) - n;
}, nD = () => !1;
class m_ extends Te {
  get lc_attributes() {
    return {
      callbacks: void 0,
      verbose: void 0
    };
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "verbose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.verbose = e.verbose ?? nD(), this.callbacks = e.callbacks, this.tags = e.tags ?? [], this.metadata = e.metadata ?? {};
  }
}
class b_ extends m_ {
  /**
   * Keys that the language model accepts as call options.
   */
  get callKeys() {
    return ["stop", "timeout", "signal", "tags", "metadata", "callbacks"];
  }
  constructor({ callbacks: e, callbackManager: n, ...a }) {
    const { cache: r, ...i } = a;
    super({
      callbacks: e ?? n,
      ...i
    }), Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cache", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_encoding", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), typeof r == "object" ? this.cache = r : r ? this.cache = f_.global() : this.cache = void 0, this.caller = new ru(a ?? {});
  }
  async getNumTokens(e) {
    if (typeof e != "string")
      return 0;
    let n = Math.ceil(e.length / 4);
    if (!this._encoding)
      try {
        this._encoding = await xC("modelName" in this ? p_(this.modelName) : "gpt2");
      } catch (a) {
        console.warn("Failed to calculate number of tokens, falling back to approximate count", a);
      }
    if (this._encoding)
      try {
        n = this._encoding.encode(e).length;
      } catch (a) {
        console.warn("Failed to calculate number of tokens, falling back to approximate count", a);
      }
    return n;
  }
  static _convertInputToPromptValue(e) {
    return typeof e == "string" ? new JC(e) : Array.isArray(e) ? new LC(e.map(co)) : e;
  }
  /**
   * Get the identifying parameters of the LLM.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _identifyingParams() {
    return {};
  }
  /**
   * Create a unique cache key for a specific call to a specific language model.
   * @param callOptions Call options for the model
   * @returns A unique cache key.
   */
  _getSerializedCacheKeyParametersForCall({ config: e, ...n }) {
    const a = {
      ...this._identifyingParams(),
      ...n,
      _type: this._llmType(),
      _model: this._modelType()
    };
    return Object.entries(a).filter(([s, o]) => o !== void 0).map(([s, o]) => `${s}:${JSON.stringify(o)}`).sort().join(",");
  }
  /**
   * @deprecated
   * Return a json-like object representing this LLM.
   */
  serialize() {
    return {
      ...this._identifyingParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  /**
   * @deprecated
   * Load an LLM from a json-like object describing it.
   */
  static async deserialize(e) {
    throw new Error("Use .toJSON() instead");
  }
}
class Mt extends Te {
  static lc_name() {
    return "RunnablePassthrough";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "func", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), e && (this.func = e.func);
  }
  async invoke(e, n) {
    const a = Re(n);
    return this.func && await this.func(e, a), this._callWithConfig((r) => Promise.resolve(r), e, a);
  }
  async *transform(e, n) {
    const a = Re(n);
    let r, i = !0;
    for await (const s of this._transformStreamWithConfig(e, (o) => o, a))
      if (yield s, i)
        if (r === void 0)
          r = s;
        else
          try {
            r = on(r, s);
          } catch {
            r = void 0, i = !1;
          }
    this.func && r !== void 0 && await this.func(r, a);
  }
  /**
   * A runnable that assigns key-value pairs to the input.
   *
   * The example below shows how you could use it with an inline function.
   *
   * @example
   * ```typescript
   * const prompt =
   *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}
   * Question: {question}
   * SQL Query:`);
   *
   * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`
   * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.
   * // In this case, we're passing the schema.
   * const sqlQueryGeneratorChain = RunnableSequence.from([
   *   RunnablePassthrough.assign({
   *     schema: async () => db.getTableInfo(),
   *   }),
   *   prompt,
   *   new ChatOpenAI({}).bind({ stop: ["\nSQLResult:"] }),
   *   new StringOutputParser(),
   * ]);
   * const result = await sqlQueryGeneratorChain.invoke({
   *   question: "How many employees are there?",
   * });
   * ```
   */
  static assign(e) {
    return new qC(new dc({ steps: e }));
  }
}
function eu(t) {
  return typeof t?.parse == "function";
}
class Sn extends b_ {
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "chat_models", this._llmType()]
    }), Object.defineProperty(this, "disableStreaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _separateRunnableConfigFromCallOptionsCompat(e) {
    const [n, a] = super._separateRunnableConfigFromCallOptions(e);
    return a.signal = n.signal, [n, a];
  }
  /**
   * Invokes the chat model with a single input.
   * @param input The input for the language model.
   * @param options The call options.
   * @returns A Promise that resolves to a BaseMessageChunk.
   */
  async invoke(e, n) {
    const a = Sn._convertInputToPromptValue(e);
    return (await this.generatePrompt([a], n, n?.callbacks)).generations[0][0].message;
  }
  // eslint-disable-next-line require-yield
  async *_streamResponseChunks(e, n, a) {
    throw new Error("Not implemented.");
  }
  async *_streamIterator(e, n) {
    if (this._streamResponseChunks === Sn.prototype._streamResponseChunks || this.disableStreaming)
      yield this.invoke(e, n);
    else {
      const r = Sn._convertInputToPromptValue(e).toChatMessages(), [i, s] = this._separateRunnableConfigFromCallOptionsCompat(n), o = {
        ...i.metadata,
        ...this.getLsParams(s)
      }, l = await st.configure(i.callbacks, this.callbacks, i.tags, this.tags, o, this.metadata, { verbose: this.verbose }), f = {
        options: s,
        invocation_params: this?.invocationParams(s),
        batch_size: 1
      }, u = await l?.handleChatModelStart(this.toJSON(), [r], i.runId, void 0, f, void 0, void 0, i.runName);
      let c, h;
      try {
        for await (const p of this._streamResponseChunks(r, s, u?.[0])) {
          if (p.message.id == null) {
            const d = u?.at(0)?.runId;
            d != null && p.message._updateId(`run-${d}`);
          }
          p.message.response_metadata = {
            ...p.generationInfo,
            ...p.message.response_metadata
          }, yield p.message, c ? c = c.concat(p) : c = p, aw(p.message) && p.message.usage_metadata !== void 0 && (h = {
            tokenUsage: {
              promptTokens: p.message.usage_metadata.input_tokens,
              completionTokens: p.message.usage_metadata.output_tokens,
              totalTokens: p.message.usage_metadata.total_tokens
            }
          });
        }
      } catch (p) {
        throw await Promise.all((u ?? []).map((d) => d?.handleLLMError(p))), p;
      }
      await Promise.all((u ?? []).map((p) => p?.handleLLMEnd({
        // TODO: Remove cast after figuring out inheritance
        generations: [[c]],
        llmOutput: h
      })));
    }
  }
  getLsParams(e) {
    const n = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
    return {
      ls_model_type: "chat",
      ls_stop: e.stop,
      ls_provider: n
    };
  }
  /** @ignore */
  async _generateUncached(e, n, a, r) {
    const i = e.map((c) => c.map(co));
    let s;
    if (r !== void 0 && r.length === i.length)
      s = r;
    else {
      const c = {
        ...a.metadata,
        ...this.getLsParams(n)
      }, h = await st.configure(a.callbacks, this.callbacks, a.tags, this.tags, c, this.metadata, { verbose: this.verbose }), p = {
        options: n,
        invocation_params: this?.invocationParams(n),
        batch_size: 1
      };
      s = await h?.handleChatModelStart(this.toJSON(), i, a.runId, void 0, p, void 0, void 0, a.runName);
    }
    const o = [], l = [];
    if (!!s?.[0].handlers.find(RC) && !this.disableStreaming && i.length === 1 && this._streamResponseChunks !== Sn.prototype._streamResponseChunks)
      try {
        const c = await this._streamResponseChunks(i[0], n, s?.[0]);
        let h, p;
        for await (const d of c) {
          if (d.message.id == null) {
            const m = s?.at(0)?.runId;
            m != null && d.message._updateId(`run-${m}`);
          }
          h === void 0 ? h = d : h = on(h, d), aw(d.message) && d.message.usage_metadata !== void 0 && (p = {
            tokenUsage: {
              promptTokens: d.message.usage_metadata.input_tokens,
              completionTokens: d.message.usage_metadata.output_tokens,
              totalTokens: d.message.usage_metadata.total_tokens
            }
          });
        }
        if (h === void 0)
          throw new Error("Received empty response from chat model call.");
        o.push([h]), await s?.[0].handleLLMEnd({
          generations: o,
          llmOutput: p
        });
      } catch (c) {
        throw await s?.[0].handleLLMError(c), c;
      }
    else {
      const c = await Promise.allSettled(i.map((h, p) => this._generate(h, { ...n, promptIndex: p }, s?.[p])));
      await Promise.all(c.map(async (h, p) => {
        if (h.status === "fulfilled") {
          const d = h.value;
          for (const m of d.generations) {
            if (m.message.id == null) {
              const b = s?.at(0)?.runId;
              b != null && m.message._updateId(`run-${b}`);
            }
            m.message.response_metadata = {
              ...m.generationInfo,
              ...m.message.response_metadata
            };
          }
          return d.generations.length === 1 && (d.generations[0].message.response_metadata = {
            ...d.llmOutput,
            ...d.generations[0].message.response_metadata
          }), o[p] = d.generations, l[p] = d.llmOutput, s?.[p]?.handleLLMEnd({
            generations: [d.generations],
            llmOutput: d.llmOutput
          });
        } else
          return await s?.[p]?.handleLLMError(h.reason), Promise.reject(h.reason);
      }));
    }
    const u = {
      generations: o,
      llmOutput: l.length ? this._combineLLMOutput?.(...l) : void 0
    };
    return Object.defineProperty(u, Rd, {
      value: s ? { runIds: s?.map((c) => c.runId) } : void 0,
      configurable: !0
    }), u;
  }
  async _generateCached({ messages: e, cache: n, llmStringKey: a, parsedOptions: r, handledOptions: i }) {
    const s = e.map((b) => b.map(co)), o = {
      ...i.metadata,
      ...this.getLsParams(r)
    }, l = await st.configure(i.callbacks, this.callbacks, i.tags, this.tags, o, this.metadata, { verbose: this.verbose }), f = {
      options: r,
      invocation_params: this?.invocationParams(r),
      batch_size: 1
    }, u = await l?.handleChatModelStart(this.toJSON(), s, i.runId, void 0, f, void 0, void 0, i.runName), c = [], p = (await Promise.allSettled(s.map(async (b, g) => {
      const _ = Sn._convertInputToPromptValue(b).toString(), P = await n.lookup(_, a);
      return P == null && c.push(g), P;
    }))).map((b, g) => ({ result: b, runManager: u?.[g] })).filter(({ result: b }) => b.status === "fulfilled" && b.value != null || b.status === "rejected"), d = [];
    await Promise.all(p.map(async ({ result: b, runManager: g }, _) => {
      if (b.status === "fulfilled") {
        const P = b.value;
        return d[_] = P.map((C) => ("message" in C && an(C.message) && Vs(C.message) && (C.message.usage_metadata = {
          input_tokens: 0,
          output_tokens: 0,
          total_tokens: 0
        }), C.generationInfo = {
          ...C.generationInfo,
          tokenUsage: {}
        }, C)), P.length && await g?.handleLLMNewToken(P[0].text), g?.handleLLMEnd({
          generations: [P]
        }, void 0, void 0, void 0, {
          cached: !0
        });
      } else
        return await g?.handleLLMError(b.reason, void 0, void 0, void 0, {
          cached: !0
        }), Promise.reject(b.reason);
    }));
    const m = {
      generations: d,
      missingPromptIndices: c,
      startedRunManagers: u
    };
    return Object.defineProperty(m, Rd, {
      value: u ? { runIds: u?.map((b) => b.runId) } : void 0,
      configurable: !0
    }), m;
  }
  /**
   * Generates chat based on the input messages.
   * @param messages An array of arrays of BaseMessage instances.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to an LLMResult.
   */
  async generate(e, n, a) {
    let r;
    Array.isArray(n) ? r = { stop: n } : r = n;
    const i = e.map((d) => d.map(co)), [s, o] = this._separateRunnableConfigFromCallOptionsCompat(r);
    if (s.callbacks = s.callbacks ?? a, !this.cache)
      return this._generateUncached(i, o, s);
    const { cache: l } = this, f = this._getSerializedCacheKeyParametersForCall(o), { generations: u, missingPromptIndices: c, startedRunManagers: h } = await this._generateCached({
      messages: i,
      cache: l,
      llmStringKey: f,
      parsedOptions: o,
      handledOptions: s
    });
    let p = {};
    if (c.length > 0) {
      const d = await this._generateUncached(c.map((m) => i[m]), o, s, h !== void 0 ? c.map((m) => h?.[m]) : void 0);
      await Promise.all(d.generations.map(async (m, b) => {
        const g = c[b];
        u[g] = m;
        const _ = Sn._convertInputToPromptValue(i[g]).toString();
        return l.update(_, f, m);
      })), p = d.llmOutput ?? {};
    }
    return { generations: u, llmOutput: p };
  }
  /**
   * Get the parameters used to invoke the model
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  invocationParams(e) {
    return {};
  }
  _modelType() {
    return "base_chat_model";
  }
  /**
   * @deprecated
   * Return a json-like object representing this LLM.
   */
  serialize() {
    return {
      ...this.invocationParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  /**
   * Generates a prompt based on the input prompt values.
   * @param promptValues An array of BasePromptValue instances.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to an LLMResult.
   */
  async generatePrompt(e, n, a) {
    const r = e.map((i) => i.toChatMessages());
    return this.generate(r, n, a);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Makes a single call to the chat model.
   * @param messages An array of BaseMessage instances.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to a BaseMessage.
   */
  async call(e, n, a) {
    return (await this.generate([e.map(co)], n, a)).generations[0][0].message;
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Makes a single call to the chat model with a prompt value.
   * @param promptValue The value of the prompt.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to a BaseMessage.
   */
  async callPrompt(e, n, a) {
    const r = e.toChatMessages();
    return this.call(r, n, a);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Predicts the next message based on the input messages.
   * @param messages An array of BaseMessage instances.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to a BaseMessage.
   */
  async predictMessages(e, n, a) {
    return this.call(e, n, a);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Predicts the next message based on a text input.
   * @param text The text input.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to a string.
   */
  async predict(e, n, a) {
    const r = new _r(e), i = await this.call([r], n, a);
    if (typeof i.content != "string")
      throw new Error("Cannot use predict when output is not a string.");
    return i.content;
  }
  withStructuredOutput(e, n) {
    if (typeof this.bindTools != "function")
      throw new Error('Chat model must implement ".bindTools()" to use withStructuredOutput.');
    if (n?.strict)
      throw new Error('"strict" mode is not supported for this model by default.');
    const a = e, r = n?.name, i = a.description ?? "A function available to call.", s = n?.method, o = n?.includeRaw;
    if (s === "jsonMode")
      throw new Error('Base withStructuredOutput implementation only supports "functionCalling" as a method.');
    let l = r ?? "extract", f;
    eu(a) ? f = [
      {
        type: "function",
        function: {
          name: l,
          description: i,
          parameters: Cn(a)
        }
      }
    ] : ("name" in a && (l = a.name), f = [
      {
        type: "function",
        function: {
          name: l,
          description: i,
          parameters: a
        }
      }
    ]);
    const u = this.bindTools(f), c = au.from((m) => {
      if (!m.tool_calls || m.tool_calls.length === 0)
        throw new Error("No tool calls found in the response.");
      const b = m.tool_calls.find((g) => g.name === l);
      if (!b)
        throw new Error(`No tool call found with name ${l}.`);
      return b.args;
    });
    if (!o)
      return u.pipe(c).withConfig({
        runName: "StructuredOutput"
      });
    const h = Mt.assign({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parsed: (m, b) => c.invoke(m.raw, b)
    }), p = Mt.assign({
      parsed: () => null
    }), d = h.withFallbacks({
      fallbacks: [p]
    });
    return dt.from([
      {
        raw: u
      },
      d
    ]).withConfig({
      runName: "StructuredOutputRunnable"
    });
  }
}
class VC extends Te {
  /**
   * Parses the result of an LLM call with a given prompt. By default, it
   * simply calls `parseResult`.
   * @param generations The generations from an LLM call.
   * @param _prompt The prompt used in the LLM call.
   * @param callbacks Optional callbacks.
   * @returns A promise of the parsed output.
   */
  parseResultWithPrompt(e, n, a) {
    return this.parseResult(e, a);
  }
  _baseMessageToString(e) {
    return typeof e.content == "string" ? e.content : this._baseMessageContentToString(e.content);
  }
  _baseMessageContentToString(e) {
    return JSON.stringify(e);
  }
  /**
   * Calls the parser with a given input and optional configuration options.
   * If the input is a string, it creates a generation with the input as
   * text and calls `parseResult`. If the input is a `BaseMessage`, it
   * creates a generation with the input as a message and the content of the
   * input as text, and then calls `parseResult`.
   * @param input The input to the parser, which can be a string or a `BaseMessage`.
   * @param options Optional configuration options.
   * @returns A promise of the parsed output.
   */
  async invoke(e, n) {
    return typeof e == "string" ? this._callWithConfig(async (a, r) => this.parseResult([{ text: a }], r?.callbacks), e, { ...n, runType: "parser" }) : this._callWithConfig(async (a, r) => this.parseResult([
      {
        message: a,
        text: this._baseMessageToString(a)
      }
    ], r?.callbacks), e, { ...n, runType: "parser" });
  }
}
class Kd extends VC {
  parseResult(e, n) {
    return this.parse(e[0].text, n);
  }
  async parseWithPrompt(e, n, a) {
    return this.parse(e, a);
  }
  /**
   * Return the string type key uniquely identifying this class of parser
   */
  _type() {
    throw new Error("_type not implemented");
  }
}
class Vt extends Error {
  constructor(e, n, a, r = !1) {
    if (super(e), Object.defineProperty(this, "llmOutput", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "observation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sendToLLM", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.llmOutput = n, this.observation = a, this.sendToLLM = r, r && (a === void 0 || n === void 0))
      throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
    Pp(this, "OUTPUT_PARSING_FAILURE");
  }
}
function ug(t, e) {
  const n = typeof t;
  if (n !== typeof e)
    return !1;
  if (Array.isArray(t)) {
    if (!Array.isArray(e))
      return !1;
    const a = t.length;
    if (a !== e.length)
      return !1;
    for (let r = 0; r < a; r++)
      if (!ug(t[r], e[r]))
        return !1;
    return !0;
  }
  if (n === "object") {
    if (!t || !e)
      return t === e;
    const a = Object.keys(t), r = Object.keys(e);
    if (a.length !== r.length)
      return !1;
    for (const s of a)
      if (!ug(t[s], e[s]))
        return !1;
    return !0;
  }
  return t === e;
}
class g_ extends Kd {
  async *_transform(e) {
    for await (const n of e)
      typeof n == "string" ? yield this.parseResult([{ text: n }]) : yield this.parseResult([
        {
          message: n,
          text: this._baseMessageToString(n)
        }
      ]);
  }
  /**
   * Transforms an asynchronous generator of input into an asynchronous
   * generator of parsed output.
   * @param inputGenerator An asynchronous generator of input.
   * @param options A configuration object.
   * @returns An asynchronous generator of parsed output.
   */
  async *transform(e, n) {
    yield* this._transformStreamWithConfig(e, this._transform.bind(this), {
      ...n,
      runType: "parser"
    });
  }
}
class zC extends g_ {
  constructor(e) {
    super(e), Object.defineProperty(this, "diff", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.diff = e?.diff ?? this.diff;
  }
  async *_transform(e) {
    let n, a;
    for await (const r of e) {
      if (typeof r != "string" && typeof r.content != "string")
        throw new Error("Cannot handle non-string output.");
      let i;
      if (Zb(r)) {
        if (typeof r.content != "string")
          throw new Error("Cannot handle non-string message output.");
        i = new Bt({
          message: r,
          text: r.content
        });
      } else if (an(r)) {
        if (typeof r.content != "string")
          throw new Error("Cannot handle non-string message output.");
        i = new Bt({
          message: EI(r),
          text: r.content
        });
      } else
        i = new ma({ text: r });
      a === void 0 ? a = i : a = a.concat(i);
      const s = await this.parsePartialResult([a]);
      s != null && !ug(s, n) && (this.diff ? yield this._diff(n, s) : yield s, n = s);
    }
  }
  getFormatInstructions() {
    return "";
  }
}
class rD extends g_ {
  constructor() {
    super(...arguments), Object.defineProperty(this, "re", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  async *_transform(e) {
    let n = "";
    for await (const a of e)
      if (typeof a == "string" ? n += a : n += a.content, this.re) {
        const r = [...n.matchAll(this.re)];
        if (r.length > 1) {
          let i = 0;
          for (const s of r.slice(0, -1))
            yield [s[1]], i += (s.index ?? 0) + s[0].length;
          n = n.slice(i);
        }
      } else {
        const r = await this.parse(n);
        if (r.length > 1) {
          for (const i of r.slice(0, -1))
            yield [i];
          n = r[r.length - 1];
        }
      }
    for (const a of await this.parse(n))
      yield [a];
  }
}
class Vz extends rD {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "output_parsers", "list"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
  }
  static lc_name() {
    return "CommaSeparatedListOutputParser";
  }
  /**
   * Parses the given text into an array of strings, using a comma as the
   * separator. If the parsing fails, throws an OutputParserException.
   * @param text The text to parse.
   * @returns An array of strings obtained by splitting the input text at each comma.
   */
  async parse(e) {
    try {
      return e.trim().split(",").map((n) => n.trim());
    } catch {
      throw new Vt(`Could not parse output: ${e}`, e);
    }
  }
  /**
   * Provides instructions on the expected format of the response for the
   * CommaSeparatedListOutputParser.
   * @returns A string containing instructions on the expected format of the response.
   */
  getFormatInstructions() {
    return "Your response should be a list of comma separated values, eg: `foo, bar, baz`";
  }
}
class zz extends g_ {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "output_parsers", "string"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
  }
  static lc_name() {
    return "StrOutputParser";
  }
  /**
   * Parses a string output from an LLM call. This method is meant to be
   * implemented by subclasses to define how a string output from an LLM
   * should be parsed.
   * @param text The string output from an LLM call.
   * @param callbacks Optional callbacks.
   * @returns A promise of the parsed output.
   */
  parse(e) {
    return Promise.resolve(e);
  }
  getFormatInstructions() {
    return "";
  }
  _textContentToString(e) {
    return e.text;
  }
  _imageUrlContentToString(e) {
    throw new Error('Cannot coerce a multimodal "image_url" message part into a string.');
  }
  _messageContentComplexToString(e) {
    switch (e.type) {
      case "text":
      case "text_delta":
        if ("text" in e)
          return this._textContentToString(e);
        break;
      case "image_url":
        if ("image_url" in e)
          return this._imageUrlContentToString(e);
        break;
      default:
        throw new Error(`Cannot coerce "${e.type}" message part into a string.`);
    }
    throw new Error(`Invalid content type: ${e.type}`);
  }
  _baseMessageContentToString(e) {
    return e.reduce((n, a) => n + this._messageContentComplexToString(a), "");
  }
}
class Cd extends Kd {
  static lc_name() {
    return "StructuredOutputParser";
  }
  toJSON() {
    return this.toJSONNotImplemented();
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "schema", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "output_parsers", "structured"]
    });
  }
  /**
   * Creates a new StructuredOutputParser from a Zod schema.
   * @param schema The Zod schema which the output should match
   * @returns A new instance of StructuredOutputParser.
   */
  static fromZodSchema(e) {
    return new this(e);
  }
  /**
   * Creates a new StructuredOutputParser from a set of names and
   * descriptions.
   * @param schemas An object where each key is a name and each value is a description
   * @returns A new instance of StructuredOutputParser.
   */
  static fromNamesAndDescriptions(e) {
    const n = jn.object(Object.fromEntries(Object.entries(e).map(([a, r]) => [a, jn.string().describe(r)])));
    return new this(n);
  }
  /**
   * Returns a markdown code snippet with a JSON object formatted according
   * to the schema.
   * @param options Optional. The options for formatting the instructions
   * @returns A markdown code snippet with a JSON object formatted according to the schema.
   */
  getFormatInstructions() {
    return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(Cn(this.schema))}
\`\`\`
`;
  }
  /**
   * Parses the given text according to the schema.
   * @param text The text to parse
   * @returns The parsed output.
   */
  async parse(e) {
    try {
      const a = (e.includes("```") ? e.trim().split(/```(?:json)?/)[1] : e.trim()).replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (r, i) => `"${i.replace(/\n/g, "\\n")}"`).replace(/\n/g, "");
      return await this.schema.parseAsync(JSON.parse(a));
    } catch (n) {
      throw new Vt(`Failed to parse. Text: "${e}". Error: ${n}`, e);
    }
  }
}
class Td extends zC {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "output_parsers"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
  }
  static lc_name() {
    return "JsonOutputParser";
  }
  _diff(e, n) {
    if (n)
      return e ? nk(e, n) : [{ op: "replace", path: "", value: n }];
  }
  // This should actually return Partial<T>, but there's no way
  // to specify emitted chunks as instances separate from the main output type.
  async parsePartialResult(e) {
    return tw(e[0].text);
  }
  async parse(e) {
    return tw(e, JSON.parse);
  }
  getFormatInstructions() {
    return "";
  }
}
function Hd(t, e) {
  if (t.function === void 0)
    return;
  let n;
  if (e?.partial)
    try {
      n = i_(t.function.arguments ?? "{}");
    } catch {
      return;
    }
  else
    try {
      n = JSON.parse(t.function.arguments);
    } catch (r) {
      throw new Vt([
        `Function "${t.function.name}" arguments:`,
        "",
        t.function.arguments,
        "",
        "are not valid JSON.",
        `Error: ${r.message}`
      ].join(`
`));
    }
  const a = {
    name: t.function.name,
    args: n,
    type: "tool_call"
  };
  return e?.returnId && (a.id = t.id), a;
}
function __(t) {
  if (t.id === void 0)
    throw new Error('All OpenAI tool calls must have an "id" field.');
  return {
    id: t.id,
    type: "function",
    function: {
      name: t.name,
      arguments: JSON.stringify(t.args)
    }
  };
}
function $p(t, e) {
  return {
    name: t.function?.name,
    args: t.function?.arguments,
    id: t.id,
    error: e,
    type: "invalid_tool_call"
  };
}
class aD extends zC {
  static lc_name() {
    return "JsonOutputToolsParser";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "returnId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "output_parsers", "openai_tools"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.returnId = e?.returnId ?? this.returnId;
  }
  _diff() {
    throw new Error("Not supported.");
  }
  async parse() {
    throw new Error("Not implemented.");
  }
  async parseResult(e) {
    return await this.parsePartialResult(e, !1);
  }
  /**
   * Parses the output and returns a JSON object. If `argsOnly` is true,
   * only the arguments of the function call are returned.
   * @param generations The output of the LLM to parse.
   * @returns A JSON object representation of the function call or its arguments.
   */
  async parsePartialResult(e, n = !0) {
    const a = e[0].message;
    let r;
    if (Vs(a) && a.tool_calls?.length ? r = a.tool_calls.map((s) => {
      const { id: o, ...l } = s;
      return this.returnId ? {
        id: o,
        ...l
      } : l;
    }) : a.additional_kwargs.tool_calls !== void 0 && (r = JSON.parse(JSON.stringify(a.additional_kwargs.tool_calls)).map((o) => Hd(o, { returnId: this.returnId, partial: n }))), !r)
      return [];
    const i = [];
    for (const s of r)
      if (s !== void 0) {
        const o = {
          type: s.name,
          args: s.args,
          id: s.id
        };
        i.push(o);
      }
    return i;
  }
}
class Yu extends aD {
  static lc_name() {
    return "JsonOutputKeyToolsParser";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "output_parsers", "openai_tools"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "returnId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "keyName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnSingle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "zodSchema", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.keyName = e.keyName, this.returnSingle = e.returnSingle ?? this.returnSingle, this.zodSchema = e.zodSchema;
  }
  async _validateResult(e) {
    if (this.zodSchema === void 0)
      return e;
    const n = await this.zodSchema.safeParseAsync(e);
    if (n.success)
      return n.data;
    throw new Vt(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(n.error.errors)}`, JSON.stringify(e, null, 2));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async parsePartialResult(e) {
    const a = (await super.parsePartialResult(e)).filter((i) => i.type === this.keyName);
    let r = a;
    if (a.length)
      return this.returnId || (r = a.map((i) => i.args)), this.returnSingle ? r[0] : r;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async parseResult(e) {
    const a = (await super.parsePartialResult(e, !1)).filter((s) => s.type === this.keyName);
    let r = a;
    return a.length ? (this.returnId || (r = a.map((s) => s.args)), this.returnSingle ? this._validateResult(r[0]) : await Promise.all(r.map((s) => this._validateResult(s)))) : void 0;
  }
}
const iD = Symbol("Let zodToJsonSchema decide on which parser to use"), Gw = {
  name: void 0,
  $refStrategy: "root",
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  nullableStrategy: "from-target",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, sD = (t) => typeof t == "string" ? {
  ...Gw,
  basePath: ["#"],
  definitions: {},
  name: t
} : {
  ...Gw,
  basePath: ["#"],
  definitions: {},
  ...t
}, cg = (t) => "_def" in t ? t._def : t;
function oD(t) {
  if (!t)
    return !0;
  for (const e in t)
    return !1;
  return !0;
}
const uD = (t) => {
  const e = sD(t), n = e.name !== void 0 ? [...e.basePath, e.definitionPath, e.name] : e.basePath;
  return {
    ...e,
    currentPath: n,
    propertyPath: void 0,
    seenRefs: /* @__PURE__ */ new Set(),
    seen: new Map(Object.entries(e.definitions).map(([a, r]) => [
      cg(r),
      {
        def: cg(r),
        path: [...e.basePath, e.definitionPath, a],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function ZC(t, e, n, a) {
  a?.errorMessages && n && (t.errorMessage = {
    ...t.errorMessage,
    [e]: n
  });
}
function Be(t, e, n, a, r) {
  t[e] = n, ZC(t, e, a, r);
}
function cD() {
  return {};
}
function lD(t, e) {
  const n = {
    type: "array"
  };
  return t.type?._def?.typeName !== K.ZodAny && (n.items = Ae(t.type._def, {
    ...e,
    currentPath: [...e.currentPath, "items"]
  })), t.minLength && Be(n, "minItems", t.minLength.value, t.minLength.message, e), t.maxLength && Be(n, "maxItems", t.maxLength.value, t.maxLength.message, e), t.exactLength && (Be(n, "minItems", t.exactLength.value, t.exactLength.message, e), Be(n, "maxItems", t.exactLength.value, t.exactLength.message, e)), n;
}
function dD(t, e) {
  const n = {
    type: "integer",
    format: "int64"
  };
  if (!t.checks)
    return n;
  for (const a of t.checks)
    switch (a.kind) {
      case "min":
        e.target === "jsonSchema7" ? a.inclusive ? Be(n, "minimum", a.value, a.message, e) : Be(n, "exclusiveMinimum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMinimum = !0), Be(n, "minimum", a.value, a.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? a.inclusive ? Be(n, "maximum", a.value, a.message, e) : Be(n, "exclusiveMaximum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMaximum = !0), Be(n, "maximum", a.value, a.message, e));
        break;
      case "multipleOf":
        Be(n, "multipleOf", a.value, a.message, e);
        break;
    }
  return n;
}
function fD() {
  return {
    type: "boolean"
  };
}
function hD(t, e) {
  return Ae(t.type._def, e);
}
const pD = (t, e) => Ae(t.innerType._def, e);
function KC(t, e, n) {
  const a = n ?? e.dateStrategy;
  if (Array.isArray(a))
    return {
      anyOf: a.map((r, i) => KC(t, e, r))
    };
  switch (a) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return mD(t, e);
  }
}
const mD = (t, e) => {
  const n = {
    type: "integer",
    format: "unix-time"
  };
  if (e.target === "openApi3")
    return n;
  for (const a of t.checks)
    switch (a.kind) {
      case "min":
        Be(
          n,
          "minimum",
          a.value,
          // This is in milliseconds
          a.message,
          e
        );
        break;
      case "max":
        Be(
          n,
          "maximum",
          a.value,
          // This is in milliseconds
          a.message,
          e
        );
        break;
    }
  return n;
};
function bD(t, e) {
  return {
    ...Ae(t.innerType._def, e),
    default: t.defaultValue()
  };
}
function gD(t, e, n) {
  return e.effectStrategy === "input" ? Ae(t.schema._def, e, n) : {};
}
function _D(t) {
  return {
    type: "string",
    enum: [...t.values]
  };
}
const yD = (t) => "type" in t && t.type === "string" ? !1 : "allOf" in t;
function wD(t, e) {
  const n = [
    Ae(t.left._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "0"]
    }),
    Ae(t.right._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "1"]
    })
  ].filter((i) => !!i);
  let a = e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const r = [];
  return n.forEach((i) => {
    if (yD(i))
      r.push(...i.allOf), i.unevaluatedProperties === void 0 && (a = void 0);
    else {
      let s = i;
      if ("additionalProperties" in i && i.additionalProperties === !1) {
        const { additionalProperties: o, ...l } = i;
        s = l;
      } else
        a = void 0;
      r.push(s);
    }
  }), r.length ? {
    allOf: r,
    ...a
  } : void 0;
}
function vD(t, e) {
  const n = typeof t.value;
  return n !== "bigint" && n !== "number" && n !== "boolean" && n !== "string" ? {
    type: Array.isArray(t.value) ? "array" : "object"
  } : e.target === "openApi3" ? {
    type: n === "bigint" ? "integer" : n,
    enum: [t.value]
  } : {
    type: n === "bigint" ? "integer" : n,
    const: t.value
  };
}
let Bm;
const Co = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (Bm === void 0 && (Bm = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), Bm),
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/
};
function HC(t, e) {
  const n = {
    type: "string"
  };
  function a(r) {
    return e.patternStrategy === "escape" ? SD(r) : r;
  }
  if (t.checks)
    for (const r of t.checks)
      switch (r.kind) {
        case "min":
          Be(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value, r.message, e);
          break;
        case "max":
          Be(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value, r.message, e);
          break;
        case "email":
          switch (e.emailStrategy) {
            case "format:email":
              Yn(n, "email", r.message, e);
              break;
            case "format:idn-email":
              Yn(n, "idn-email", r.message, e);
              break;
            case "pattern:zod":
              er(n, Co.email, r.message, e);
              break;
          }
          break;
        case "url":
          Yn(n, "uri", r.message, e);
          break;
        case "uuid":
          Yn(n, "uuid", r.message, e);
          break;
        case "regex":
          er(n, r.regex, r.message, e);
          break;
        case "cuid":
          er(n, Co.cuid, r.message, e);
          break;
        case "cuid2":
          er(n, Co.cuid2, r.message, e);
          break;
        case "startsWith":
          er(n, RegExp(`^${a(r.value)}`), r.message, e);
          break;
        case "endsWith":
          er(n, RegExp(`${a(r.value)}$`), r.message, e);
          break;
        case "datetime":
          Yn(n, "date-time", r.message, e);
          break;
        case "date":
          Yn(n, "date", r.message, e);
          break;
        case "time":
          Yn(n, "time", r.message, e);
          break;
        case "duration":
          Yn(n, "duration", r.message, e);
          break;
        case "length":
          Be(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value, r.message, e), Be(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value, r.message, e);
          break;
        case "includes": {
          er(n, RegExp(a(r.value)), r.message, e);
          break;
        }
        case "ip": {
          r.version !== "v6" && Yn(n, "ipv4", r.message, e), r.version !== "v4" && Yn(n, "ipv6", r.message, e);
          break;
        }
        case "emoji":
          er(n, Co.emoji, r.message, e);
          break;
        case "ulid": {
          er(n, Co.ulid, r.message, e);
          break;
        }
        case "base64": {
          switch (e.base64Strategy) {
            case "format:binary": {
              Yn(n, "binary", r.message, e);
              break;
            }
            case "contentEncoding:base64": {
              Be(n, "contentEncoding", "base64", r.message, e);
              break;
            }
            case "pattern:zod": {
              er(n, Co.base64, r.message, e);
              break;
            }
          }
          break;
        }
        case "nanoid":
          er(n, Co.nanoid, r.message, e);
      }
  return n;
}
const SD = (t) => Array.from(t).map((e) => /[a-zA-Z0-9]/.test(e) ? e : `\\${e}`).join(""), Yn = (t, e, n, a) => {
  t.format || t.anyOf?.some((r) => r.format) ? (t.anyOf || (t.anyOf = []), t.format && (t.anyOf.push({
    format: t.format,
    ...t.errorMessage && a.errorMessages && {
      errorMessage: { format: t.errorMessage.format }
    }
  }), delete t.format, t.errorMessage && (delete t.errorMessage.format, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.anyOf.push({
    format: e,
    ...n && a.errorMessages && { errorMessage: { format: n } }
  })) : Be(t, "format", e, n, a);
}, er = (t, e, n, a) => {
  t.pattern || t.allOf?.some((r) => r.pattern) ? (t.allOf || (t.allOf = []), t.pattern && (t.allOf.push({
    pattern: t.pattern,
    ...t.errorMessage && a.errorMessages && {
      errorMessage: { pattern: t.errorMessage.pattern }
    }
  }), delete t.pattern, t.errorMessage && (delete t.errorMessage.pattern, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.allOf.push({
    pattern: Ww(e, a),
    ...n && a.errorMessages && { errorMessage: { pattern: n } }
  })) : Be(t, "pattern", Ww(e, a), n, a);
}, Ww = (t, e) => {
  const n = typeof t == "function" ? t() : t;
  if (!e.applyRegexFlags || !n.flags)
    return n.source;
  const a = {
    i: n.flags.includes("i"),
    m: n.flags.includes("m"),
    s: n.flags.includes("s")
    // `.` matches newlines
  }, r = a.i ? n.source.toLowerCase() : n.source;
  let i = "", s = !1, o = !1, l = !1;
  for (let f = 0; f < r.length; f++) {
    if (s) {
      i += r[f], s = !1;
      continue;
    }
    if (a.i) {
      if (o) {
        if (r[f].match(/[a-z]/)) {
          l ? (i += r[f], i += `${r[f - 2]}-${r[f]}`.toUpperCase(), l = !1) : r[f + 1] === "-" && r[f + 2]?.match(/[a-z]/) ? (i += r[f], l = !0) : i += `${r[f]}${r[f].toUpperCase()}`;
          continue;
        }
      } else if (r[f].match(/[a-z]/)) {
        i += `[${r[f]}${r[f].toUpperCase()}]`;
        continue;
      }
    }
    if (a.m) {
      if (r[f] === "^") {
        i += `(^|(?<=[\r
]))`;
        continue;
      } else if (r[f] === "$") {
        i += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (a.s && r[f] === ".") {
      i += o ? `${r[f]}\r
` : `[${r[f]}\r
]`;
      continue;
    }
    i += r[f], r[f] === "\\" ? s = !0 : o && r[f] === "]" ? o = !1 : !o && r[f] === "[" && (o = !0);
  }
  try {
    const f = new RegExp(i);
  } catch {
    return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), n.source;
  }
  return i;
};
function GC(t, e) {
  if (e.target === "openApi3" && t.keyType?._def.typeName === K.ZodEnum)
    return {
      type: "object",
      required: t.keyType._def.values,
      properties: t.keyType._def.values.reduce((a, r) => ({
        ...a,
        [r]: Ae(t.valueType._def, {
          ...e,
          currentPath: [...e.currentPath, "properties", r]
        }) ?? {}
      }), {}),
      additionalProperties: !1
    };
  const n = {
    type: "object",
    additionalProperties: Ae(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (e.target === "openApi3")
    return n;
  if (t.keyType?._def.typeName === K.ZodString && t.keyType._def.checks?.length) {
    const a = Object.entries(HC(t.keyType._def, e)).reduce((r, [i, s]) => i === "type" ? r : { ...r, [i]: s }, {});
    return {
      ...n,
      propertyNames: a
    };
  } else if (t.keyType?._def.typeName === K.ZodEnum)
    return {
      ...n,
      propertyNames: {
        enum: t.keyType._def.values
      }
    };
  return n;
}
function OD(t, e) {
  if (e.mapStrategy === "record")
    return GC(t, e);
  const n = Ae(t.keyType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "0"]
  }) || {}, a = Ae(t.valueType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, a],
      minItems: 2,
      maxItems: 2
    }
  };
}
function jD(t) {
  const e = t.values, a = Object.keys(t.values).filter((i) => typeof e[e[i]] != "number").map((i) => e[i]), r = Array.from(new Set(a.map((i) => typeof i)));
  return {
    type: r.length === 1 ? r[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: a
  };
}
function PD() {
  return {
    not: {}
  };
}
function RD(t) {
  return t.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const Bh = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function CD(t, e) {
  if (e.target === "openApi3")
    return Xw(t, e);
  const n = t.options instanceof Map ? Array.from(t.options.values()) : t.options;
  if (n.every((a) => a._def.typeName in Bh && (!a._def.checks || !a._def.checks.length))) {
    const a = n.reduce((r, i) => {
      const s = Bh[i._def.typeName];
      return s && !r.includes(s) ? [...r, s] : r;
    }, []);
    return {
      type: a.length > 1 ? a : a[0]
    };
  } else if (n.every((a) => a._def.typeName === "ZodLiteral" && !a.description)) {
    const a = n.reduce((r, i) => {
      const s = typeof i._def.value;
      switch (s) {
        case "string":
        case "number":
        case "boolean":
          return [...r, s];
        case "bigint":
          return [...r, "integer"];
        case "object":
          if (i._def.value === null)
            return [...r, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return r;
      }
    }, []);
    if (a.length === n.length) {
      const r = a.filter((i, s, o) => o.indexOf(i) === s);
      return {
        type: r.length > 1 ? r : r[0],
        enum: n.reduce((i, s) => i.includes(s._def.value) ? i : [...i, s._def.value], [])
      };
    }
  } else if (n.every((a) => a._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce((a, r) => [...a, ...r._def.values.filter((i) => !a.includes(i))], [])
    };
  return Xw(t, e);
}
const Xw = (t, e) => {
  const n = (t.options instanceof Map ? Array.from(t.options.values()) : t.options).map((a, r) => Ae(a._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", `${r}`]
  })).filter((a) => !!a && (!e.strictUnions || typeof a == "object" && Object.keys(a).length > 0));
  return n.length ? { anyOf: n } : void 0;
};
function TD(t, e) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(t.innerType._def.typeName) && (!t.innerType._def.checks || !t.innerType._def.checks.length))
    return e.target === "openApi3" || e.nullableStrategy === "property" ? {
      type: Bh[t.innerType._def.typeName],
      nullable: !0
    } : {
      type: [Bh[t.innerType._def.typeName], "null"]
    };
  if (e.target === "openApi3") {
    const a = Ae(t.innerType._def, {
      ...e,
      currentPath: [...e.currentPath]
    });
    return a && "$ref" in a ? { allOf: [a], nullable: !0 } : a && { ...a, nullable: !0 };
  }
  const n = Ae(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "0"]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function $D(t, e) {
  const n = {
    type: "number"
  };
  if (!t.checks)
    return n;
  for (const a of t.checks)
    switch (a.kind) {
      case "int":
        n.type = "integer", ZC(n, "type", a.message, e);
        break;
      case "min":
        e.target === "jsonSchema7" ? a.inclusive ? Be(n, "minimum", a.value, a.message, e) : Be(n, "exclusiveMinimum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMinimum = !0), Be(n, "minimum", a.value, a.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? a.inclusive ? Be(n, "maximum", a.value, a.message, e) : Be(n, "exclusiveMaximum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMaximum = !0), Be(n, "maximum", a.value, a.message, e));
        break;
      case "multipleOf":
        Be(n, "multipleOf", a.value, a.message, e);
        break;
    }
  return n;
}
function MD(t, e) {
  return e.removeAdditionalStrategy === "strict" ? t.catchall._def.typeName === "ZodNever" ? t.unknownKeys !== "strict" : Ae(t.catchall._def, {
    ...e,
    currentPath: [...e.currentPath, "additionalProperties"]
  }) ?? !0 : t.catchall._def.typeName === "ZodNever" ? t.unknownKeys === "passthrough" : Ae(t.catchall._def, {
    ...e,
    currentPath: [...e.currentPath, "additionalProperties"]
  }) ?? !0;
}
function AD(t, e) {
  const n = {
    type: "object",
    ...Object.entries(t.shape()).reduce((a, [r, i]) => {
      if (i === void 0 || i._def === void 0)
        return a;
      const s = Ae(i._def, {
        ...e,
        currentPath: [...e.currentPath, "properties", r],
        propertyPath: [...e.currentPath, "properties", r]
      });
      return s === void 0 ? a : {
        properties: {
          ...a.properties,
          [r]: s
        },
        required: i.isOptional() && !e.openaiStrictMode ? a.required : [...a.required, r]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: MD(t, e)
  };
  return n.required.length || delete n.required, n;
}
const ED = (t, e) => {
  if (e.currentPath.toString() === e.propertyPath?.toString())
    return Ae(t.innerType._def, e);
  const n = Ae(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "1"]
  });
  return n ? {
    anyOf: [
      {
        not: {}
      },
      n
    ]
  } : {};
}, ID = (t, e) => {
  if (e.pipeStrategy === "input")
    return Ae(t.in._def, e);
  if (e.pipeStrategy === "output")
    return Ae(t.out._def, e);
  const n = Ae(t.in._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", "0"]
  }), a = Ae(t.out._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", n ? "1" : "0"]
  });
  return {
    allOf: [n, a].filter((r) => r !== void 0)
  };
};
function ND(t, e) {
  return Ae(t.type._def, e);
}
function kD(t, e) {
  const a = {
    type: "array",
    uniqueItems: !0,
    items: Ae(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "items"]
    })
  };
  return t.minSize && Be(a, "minItems", t.minSize.value, t.minSize.message, e), t.maxSize && Be(a, "maxItems", t.maxSize.value, t.maxSize.message, e), a;
}
function FD(t, e) {
  return t.rest ? {
    type: "array",
    minItems: t.items.length,
    items: t.items.map((n, a) => Ae(n._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${a}`]
    })).reduce((n, a) => a === void 0 ? n : [...n, a], []),
    additionalItems: Ae(t.rest._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: t.items.length,
    maxItems: t.items.length,
    items: t.items.map((n, a) => Ae(n._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${a}`]
    })).reduce((n, a) => a === void 0 ? n : [...n, a], [])
  };
}
function DD() {
  return {
    not: {}
  };
}
function qD() {
  return {};
}
const JD = (t, e) => Ae(t.innerType._def, e);
function Ae(t, e, n = !1) {
  const a = e.seen.get(t);
  if (e.override) {
    const s = e.override?.(t, e, a, n);
    if (s !== iD)
      return s;
  }
  if (a && !n) {
    const s = LD(a, e);
    if (s !== void 0)
      return "$ref" in s && e.seenRefs.add(s.$ref), s;
  }
  const r = { def: t, path: e.currentPath, jsonSchema: void 0 };
  e.seen.set(t, r);
  const i = BD(t, t.typeName, e, n);
  return i && xD(t, e, i), r.jsonSchema = i, i;
}
const LD = (t, e) => {
  switch (e.$refStrategy) {
    case "root":
      return { $ref: t.path.join("/") };
    // this case is needed as OpenAI strict mode doesn't support top-level `$ref`s, i.e.
    // the top-level schema *must* be `{"type": "object", "properties": {...}}` but if we ever
    // need to define a `$ref`, relative `$ref`s aren't supported, so we need to extract
    // the schema to `#/definitions/` and reference that.
    //
    // e.g. if we need to reference a schema at
    // `["#","definitions","contactPerson","properties","person1","properties","name"]`
    // then we'll extract it out to `contactPerson_properties_person1_properties_name`
    case "extract-to-root":
      const n = t.path.slice(e.basePath.length + 1).join("_");
      return n !== e.name && e.nameStrategy === "duplicate-ref" && (e.definitions[n] = t.def), { $ref: [...e.basePath, e.definitionPath, n].join("/") };
    case "relative":
      return { $ref: UD(e.currentPath, t.path) };
    case "none":
    case "seen":
      return t.path.length < e.currentPath.length && t.path.every((a, r) => e.currentPath[r] === a) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`), {}) : e.$refStrategy === "seen" ? {} : void 0;
  }
}, UD = (t, e) => {
  let n = 0;
  for (; n < t.length && n < e.length && t[n] === e[n]; n++)
    ;
  return [(t.length - n).toString(), ...e.slice(n)].join("/");
}, BD = (t, e, n, a) => {
  switch (e) {
    case K.ZodString:
      return HC(t, n);
    case K.ZodNumber:
      return $D(t, n);
    case K.ZodObject:
      return AD(t, n);
    case K.ZodBigInt:
      return dD(t, n);
    case K.ZodBoolean:
      return fD();
    case K.ZodDate:
      return KC(t, n);
    case K.ZodUndefined:
      return DD();
    case K.ZodNull:
      return RD(n);
    case K.ZodArray:
      return lD(t, n);
    case K.ZodUnion:
    case K.ZodDiscriminatedUnion:
      return CD(t, n);
    case K.ZodIntersection:
      return wD(t, n);
    case K.ZodTuple:
      return FD(t, n);
    case K.ZodRecord:
      return GC(t, n);
    case K.ZodLiteral:
      return vD(t, n);
    case K.ZodEnum:
      return _D(t);
    case K.ZodNativeEnum:
      return jD(t);
    case K.ZodNullable:
      return TD(t, n);
    case K.ZodOptional:
      return ED(t, n);
    case K.ZodMap:
      return OD(t, n);
    case K.ZodSet:
      return kD(t, n);
    case K.ZodLazy:
      return Ae(t.getter()._def, n);
    case K.ZodPromise:
      return ND(t, n);
    case K.ZodNaN:
    case K.ZodNever:
      return PD();
    case K.ZodEffects:
      return gD(t, n, a);
    case K.ZodAny:
      return cD();
    case K.ZodUnknown:
      return qD();
    case K.ZodDefault:
      return bD(t, n);
    case K.ZodBranded:
      return hD(t, n);
    case K.ZodReadonly:
      return JD(t, n);
    case K.ZodCatch:
      return pD(t, n);
    case K.ZodPipeline:
      return ID(t, n);
    case K.ZodFunction:
    case K.ZodVoid:
    case K.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((r) => {
      })();
  }
}, xD = (t, e, n) => (t.description && (n.description = t.description, e.markdownDescription && (n.markdownDescription = t.description)), n), VD = (t, e) => {
  const n = uD(e), a = typeof e == "string" ? e : e?.nameStrategy === "title" ? void 0 : e?.name, r = Ae(t._def, a === void 0 ? n : {
    ...n,
    currentPath: [...n.basePath, n.definitionPath, a]
  }, !1) ?? {}, i = typeof e == "object" && e.name !== void 0 && e.nameStrategy === "title" ? e.name : void 0;
  i !== void 0 && (r.title = i);
  const s = (() => {
    if (oD(n.definitions))
      return;
    const l = {}, f = /* @__PURE__ */ new Set();
    for (let u = 0; u < 500; u++) {
      const c = Object.entries(n.definitions).filter(([h]) => !f.has(h));
      if (c.length === 0)
        break;
      for (const [h, p] of c)
        l[h] = Ae(cg(p), { ...n, currentPath: [...n.basePath, n.definitionPath, h] }, !0) ?? {}, f.add(h);
    }
    return l;
  })(), o = a === void 0 ? s ? {
    ...r,
    [n.definitionPath]: s
  } : r : n.nameStrategy === "duplicate-ref" ? {
    ...r,
    ...s || n.seenRefs.size ? {
      [n.definitionPath]: {
        ...s,
        // only actually duplicate the schema definition if it was ever referenced
        // otherwise the duplication is completely pointless
        ...n.seenRefs.size ? { [a]: r } : void 0
      }
    } : void 0
  } : {
    $ref: [...n.$refStrategy === "relative" ? [] : n.basePath, n.definitionPath, a].join("/"),
    [n.definitionPath]: {
      ...s,
      [a]: r
    }
  };
  return n.target === "jsonSchema7" ? o.$schema = "http://json-schema.org/draft-07/schema#" : n.target === "jsonSchema2019-09" && (o.$schema = "https://json-schema.org/draft/2019-09/schema#"), o;
};
function WC(t, e) {
  return VD(t, {
    openaiStrictMode: !0,
    name: e.name,
    nameStrategy: "duplicate-ref",
    $refStrategy: "extract-to-root",
    nullableStrategy: "property"
  });
}
function zD(t, e, n) {
  return HE({
    type: "json_schema",
    json_schema: {
      ...n,
      name: e,
      strict: !0,
      schema: WC(t, { name: e })
    }
  }, (a) => t.parse(JSON.parse(a)));
}
function ZD(t) {
  return GE({
    type: "function",
    function: {
      name: t.name,
      parameters: WC(t.parameters, { name: t.name }),
      strict: !0,
      ...t.description ? { description: t.description } : void 0
    }
  }, {
    callback: t.function,
    parser: (e) => t.parameters.parse(JSON.parse(e))
  });
}
function y_(t) {
  const { azureOpenAIApiDeploymentName: e, azureOpenAIApiInstanceName: n, azureOpenAIApiKey: a, azureOpenAIBasePath: r, baseURL: i, azureADTokenProvider: s, azureOpenAIEndpoint: o } = t;
  if ((a || s) && r && e)
    return `${r}/${e}`;
  if ((a || s) && o && e)
    return `${o}/openai/deployments/${e}`;
  if (a || s) {
    if (!n)
      throw new Error("azureOpenAIApiInstanceName is required when using azureOpenAIApiKey");
    if (!e)
      throw new Error("azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey");
    return `https://${n}.openai.azure.com/openai/deployments/${e}`;
  }
  return i;
}
function w_(t, e) {
  const n = typeof e == "number" ? void 0 : e;
  return {
    name: t.name,
    description: t.description,
    parameters: Cn(t.schema),
    // Do not include the `strict` field if it is `undefined`.
    ...n?.strict !== void 0 ? { strict: n.strict } : {}
  };
}
function $d(t, e) {
  let n;
  return v_(t) ? n = {
    type: "function",
    function: w_(t)
  } : n = t, n;
}
function XC(t) {
  return t !== void 0 && Array.isArray(t.lc_namespace);
}
function KD(t) {
  return t !== void 0 && Te.isRunnable(t) && "lc_name" in t.constructor && typeof t.constructor.lc_name == "function" && t.constructor.lc_name() === "RunnableToolLike";
}
function HD(t) {
  return !!t && typeof t == "object" && "name" in t && "schema" in t && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  eu(t.schema);
}
function v_(t) {
  return HD(t) || KD(t) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
  XC(t);
}
function Cf(t, e) {
  return t.lc_error_code = e, t.message = `${t.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${e}/
`, t;
}
function Yl(t) {
  let e;
  return t.constructor.name === pp.name ? (e = new Error(t.message), e.name = "TimeoutError") : t.constructor.name === On.name ? (e = new Error(t.message), e.name = "AbortError") : t.status === 400 && t.message.includes("tool_calls") ? e = Cf(t, "INVALID_TOOL_RESULTS") : t.status === 401 ? e = Cf(t, "MODEL_AUTHENTICATION") : t.status === 429 ? e = Cf(t, "MODEL_RATE_LIMIT") : t.status === 404 ? e = Cf(t, "MODEL_NOT_FOUND") : e = t, e;
}
function Qw(t) {
  if (t)
    return t === "any" || t === "required" ? "required" : t === "auto" ? "auto" : t === "none" ? "none" : typeof t == "string" ? {
      type: "function",
      function: {
        name: t
      }
    } : t;
}
function GD(t) {
  return t.anyOf !== void 0 && Array.isArray(t.anyOf);
}
function WD(t) {
  const e = ["namespace functions {", ""];
  for (const n of t)
    n.description && e.push(`// ${n.description}`), Object.keys(n.parameters.properties ?? {}).length > 0 ? (e.push(`type ${n.name} = (_: {`), e.push(QC(n.parameters, 0)), e.push("}) => any;")) : e.push(`type ${n.name} = () => any;`), e.push("");
  return e.push("} // namespace functions"), e.join(`
`);
}
function QC(t, e) {
  const n = [];
  for (const [a, r] of Object.entries(t.properties ?? {}))
    r.description && e < 2 && n.push(`// ${r.description}`), t.required?.includes(a) ? n.push(`${a}: ${xh(r, e)},`) : n.push(`${a}?: ${xh(r, e)},`);
  return n.map((a) => " ".repeat(e) + a).join(`
`);
}
function xh(t, e) {
  if (GD(t))
    return t.anyOf.map((n) => xh(n, e)).join(" | ");
  switch (t.type) {
    case "string":
      return t.enum ? t.enum.map((n) => `"${n}"`).join(" | ") : "string";
    case "number":
      return t.enum ? t.enum.map((n) => `${n}`).join(" | ") : "number";
    case "integer":
      return t.enum ? t.enum.map((n) => `${n}`).join(" | ") : "number";
    case "boolean":
      return "boolean";
    case "null":
      return "null";
    case "object":
      return ["{", QC(t, e + 2), "}"].join(`
`);
    case "array":
      return t.items ? `${xh(t.items, e)}[]` : "any[]";
    default:
      return "";
  }
}
function XD(t, e) {
  let n;
  if (v_(t)) {
    const a = ZD({
      name: t.name,
      parameters: t.schema,
      description: t.description
    });
    a.function.parameters ? n = {
      type: a.type,
      function: {
        name: a.function.name,
        description: a.function.description,
        parameters: a.function.parameters,
        ...e?.strict !== void 0 ? { strict: e.strict } : {}
      }
    } : n = {
      type: "function",
      function: w_(t, e)
    };
  } else
    n = t;
  return e?.strict !== void 0 && (n.function.strict = e.strict), n;
}
function QD(t) {
  return t.role !== "system" && t.role !== "developer" && t.role !== "assistant" && t.role !== "user" && t.role !== "function" && t.role !== "tool" && console.warn(`Unknown message role: ${t.role}`), t.role;
}
function S_(t) {
  const e = t._getType();
  switch (e) {
    case "system":
      return "system";
    case "ai":
      return "assistant";
    case "human":
      return "user";
    case "function":
      return "function";
    case "tool":
      return "tool";
    case "generic": {
      if (!yo.isInstance(t))
        throw new Error("Invalid generic chat message");
      return QD(t);
    }
    default:
      throw new Error(`Unknown message type: ${e}`);
  }
}
function Yw(t, e) {
  return t.flatMap((n) => {
    let a = S_(n);
    a === "system" && O_(e) && (a = "developer");
    const r = {
      role: a,
      content: n.content
    };
    if (n.name != null && (r.name = n.name), n.additional_kwargs.function_call != null && (r.function_call = n.additional_kwargs.function_call, r.content = ""), Vs(n) && n.tool_calls?.length ? (r.tool_calls = n.tool_calls.map(__), r.content = "") : (n.additional_kwargs.tool_calls != null && (r.tool_calls = n.additional_kwargs.tool_calls), n.tool_call_id != null && (r.tool_call_id = n.tool_call_id)), n.additional_kwargs.audio && typeof n.additional_kwargs.audio == "object" && "id" in n.additional_kwargs.audio) {
      const i = {
        role: "assistant",
        audio: {
          id: n.additional_kwargs.audio.id
        }
      };
      return [r, i];
    }
    return r;
  });
}
const Vh = "__openai_function_call_ids__";
function ev(t, e) {
  return t.flatMap((n) => {
    let a = S_(n);
    if (a === "system" && O_(e) && (a = "developer"), a === "function")
      throw new Error("Function messages are not supported in Responses API");
    if (a === "tool") {
      const r = n;
      return r.additional_kwargs?.type === "computer_call_output" ? {
        type: "computer_call_output",
        output: (() => {
          if (typeof r.content == "string")
            return {
              type: "computer_screenshot",
              image_url: r.content
            };
          if (Array.isArray(r.content)) {
            const s = r.content.find((l) => l.type === "computer_screenshot");
            if (s)
              return s;
            const o = r.content.find((l) => l.type === "image_url");
            if (o)
              return {
                type: "computer_screenshot",
                image_url: typeof o.image_url == "string" ? o.image_url : o.image_url.url
              };
          }
          throw new Error("Invalid computer call output");
        })(),
        call_id: r.tool_call_id
      } : {
        type: "function_call_output",
        call_id: r.tool_call_id,
        id: r.id,
        output: typeof r.content != "string" ? JSON.stringify(r.content) : r.content
      };
    }
    if (a === "assistant") {
      const r = [];
      n.additional_kwargs.reasoning != null && ((l) => typeof l == "object" && l != null && "type" in l && l.type === "reasoning")(n.additional_kwargs.reasoning) && r.push(n.additional_kwargs.reasoning);
      let { content: i } = n;
      n.additional_kwargs.refusal != null && (typeof i == "string" && (i = [{ type: "output_text", text: i, annotations: [] }]), i = [
        ...i,
        { type: "refusal", refusal: n.additional_kwargs.refusal }
      ]), r.push({
        type: "message",
        role: "assistant",
        content: typeof i == "string" ? i : i.flatMap((o) => o.type === "text" ? {
          type: "output_text",
          text: o.text,
          // @ts-expect-error TODO: add types for `annotations`
          annotations: o.annotations ?? []
        } : o.type === "output_text" || o.type === "refusal" ? o : [])
      });
      const s = (
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        n.additional_kwargs[Vh]
      );
      if (Vs(n) && n.tool_calls?.length ? r.push(...n.tool_calls.map((o) => ({
        type: "function_call",
        name: o.name,
        arguments: JSON.stringify(o.args),
        call_id: o.id,
        // @ts-expect-error Might come from a non-Responses API message
        id: s?.[o.id]
      }))) : n.additional_kwargs.tool_calls != null && r.push(...n.additional_kwargs.tool_calls.map((o) => ({
        type: "function_call",
        name: o.function.name,
        call_id: o.id,
        // @ts-expect-error Might come from a non-Responses API message
        id: s?.[o.id],
        arguments: o.function.arguments
      }))), n.additional_kwargs.tool_outputs != null) {
        const l = n.additional_kwargs.tool_outputs?.filter((f) => f.type === "computer_call");
        l.length > 0 && r.push(...l);
      }
      return r;
    }
    return a === "user" ? {
      type: "message",
      role: "user",
      content: typeof n.content == "string" ? n.content : n.content.flatMap((r) => {
        if (r.type === "text")
          return { type: "input_text", text: r.text };
        if (r.type === "image_url") {
          const i = typeof r.image_url == "string" ? r.image_url : r.image_url.url, s = typeof r.image_url == "string" ? "auto" : r.image_url.detail;
          return { type: "input_image", image_url: i, detail: s };
        }
        return r.type === "input_text" || r.type === "input_image" || r.type === "input_file" ? r : [];
      })
    } : [];
  });
}
function YC(t) {
  if (t.error) {
    const s = new Error(t.error.message);
    throw s.name = t.error.code, s;
  }
  const e = [], n = [], a = [], r = {
    model: t.model,
    created_at: t.created_at,
    id: t.id,
    incomplete_details: t.incomplete_details,
    metadata: t.metadata,
    object: t.object,
    status: t.status,
    user: t.user,
    // for compatibility with chat completion calls.
    model_name: t.model
  }, i = {};
  for (const s of t.output)
    if (s.type === "message")
      e.push(...s.content.flatMap((o) => o.type === "output_text" ? ("parsed" in o && o.parsed != null && (i.parsed = o.parsed), {
        type: "text",
        text: o.text,
        annotations: o.annotations
      }) : o.type === "refusal" ? (i.refusal = o.refusal, []) : o));
    else if (s.type === "function_call") {
      const o = {
        function: { name: s.name, arguments: s.arguments },
        id: s.call_id
      };
      try {
        n.push(Hd(o, { returnId: !0 }));
      } catch (l) {
        let f;
        typeof l == "object" && l != null && "message" in l && typeof l.message == "string" && (f = l.message), a.push($p(o, f));
      }
      i[Vh] ??= {}, i[Vh][s.call_id] = s.id;
    } else s.type === "reasoning" ? i.reasoning = s : (i.tool_outputs ??= [], i.tool_outputs.push(s));
  return new $t({
    id: t.id,
    content: e,
    tool_calls: n,
    invalid_tool_calls: a,
    usage_metadata: t.usage,
    additional_kwargs: i,
    response_metadata: r
  });
}
function YD(t) {
  const e = [];
  let n = {}, a;
  const r = [], i = {}, s = {};
  let o;
  if (t.type === "response.output_text.delta")
    e.push({
      type: "text",
      text: t.delta,
      index: t.content_index
    });
  else if (t.type === "response.output_text.annotation.added")
    e.push({
      type: "text",
      text: "",
      annotations: [t.annotation],
      index: t.content_index
    });
  else if (t.type === "response.output_item.added" && t.item.type === "message")
    o = t.item.id;
  else if (t.type === "response.output_item.added" && t.item.type === "function_call")
    r.push({
      type: "tool_call_chunk",
      name: t.item.name,
      args: t.item.arguments,
      id: t.item.id,
      index: t.output_index
    }), s[Vh] = {
      [t.item.call_id]: t.item.id
    };
  else if (t.type === "response.output_item.done" && (t.item.type === "web_search_call" || t.item.type === "file_search_call" || t.item.type === "computer_call"))
    s.tool_outputs = [t.item];
  else if (t.type === "response.created")
    i.id = t.response.id, i.model_name = t.response.model, i.model = t.response.model;
  else if (t.type === "response.completed") {
    const l = YC(t.response);
    a = t.response.usage, t.response.text?.format?.type === "json_schema" && (s.parsed ??= JSON.parse(l.text));
    for (const [f, u] of Object.entries(t.response))
      f !== "id" && (i[f] = u);
  } else if (t.type === "response.function_call_arguments.delta")
    r.push({
      type: "tool_call_chunk",
      args: t.delta,
      index: t.output_index
    });
  else if (t.type === "response.web_search_call.completed" || t.type === "response.file_search_call.completed")
    n = {
      tool_outputs: {
        id: t.item_id,
        type: t.type.replace("response.", "").replace(".completed", ""),
        status: "completed"
      }
    };
  else if (t.type === "response.refusal.done")
    s.refusal = t.refusal;
  else
    return null;
  return new Bt({
    // Legacy reasons, `onLLMNewToken` should pulls this out
    text: e.map((l) => l.text).join(""),
    message: new Ze({
      id: o,
      content: e,
      tool_call_chunks: r,
      usage_metadata: a,
      additional_kwargs: s,
      response_metadata: i
    }),
    generationInfo: n
  });
}
function xm(t) {
  return "type" in t && t.type !== "function";
}
function eq(t) {
  return t != null && typeof t == "object" && "type" in t && t.type !== "function";
}
function tv(t, e) {
  return fc(t) ? e?.strict !== void 0 ? {
    ...t,
    function: {
      ...t.function,
      strict: e.strict
    }
  } : t : XD(t, e);
}
function O_(t) {
  return t?.startsWith("o1") || t?.startsWith("o3");
}
class Zz extends Sn {
  static lc_name() {
    return "ChatOpenAI";
  }
  get callKeys() {
    return [
      ...super.callKeys,
      "options",
      "function_call",
      "functions",
      "tools",
      "tool_choice",
      "promptIndex",
      "response_format",
      "seed",
      "reasoning_effort"
    ];
  }
  get lc_secrets() {
    return {
      openAIApiKey: "OPENAI_API_KEY",
      apiKey: "OPENAI_API_KEY",
      organization: "OPENAI_ORGANIZATION"
    };
  }
  get lc_aliases() {
    return {
      modelName: "model",
      openAIApiKey: "openai_api_key",
      apiKey: "openai_api_key"
    };
  }
  get lc_serializable_keys() {
    return [
      "configuration",
      "logprobs",
      "topLogprobs",
      "prefixMessages",
      "supportsStrictToolCalling",
      "modalities",
      "audio",
      "reasoningEffort",
      "temperature",
      "maxTokens",
      "topP",
      "frequencyPenalty",
      "presencePenalty",
      "n",
      "logitBias",
      "user",
      "streaming",
      "streamUsage",
      "modelName",
      "model",
      "modelKwargs",
      "stop",
      "stopSequences",
      "timeout",
      "openAIApiKey",
      "apiKey",
      "cache",
      "maxConcurrency",
      "maxRetries",
      "verbose",
      "callbacks",
      "tags",
      "metadata",
      "disableStreaming"
    ];
  }
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "frequencyPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "presencePenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "n", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logitBias", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "modelName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "gpt-3.5-turbo"
    }), Object.defineProperty(this, "modelKwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stopSequences", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "user", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "streamUsage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "maxTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logprobs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topLogprobs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "openAIApiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "organization", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "__includeRawResponse", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "clientConfig", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "supportsStrictToolCalling", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "audio", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "modalities", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reasoningEffort", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useResponsesApi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.openAIApiKey = e?.apiKey ?? e?.openAIApiKey ?? e?.configuration?.apiKey ?? ft("OPENAI_API_KEY"), this.apiKey = this.openAIApiKey, this.organization = e?.configuration?.organization ?? ft("OPENAI_ORGANIZATION"), this.model = e?.model ?? e?.modelName ?? this.model, this.modelName = this.model, this.modelKwargs = e?.modelKwargs ?? {}, this.timeout = e?.timeout, this.temperature = e?.temperature ?? this.temperature, this.topP = e?.topP ?? this.topP, this.frequencyPenalty = e?.frequencyPenalty ?? this.frequencyPenalty, this.presencePenalty = e?.presencePenalty ?? this.presencePenalty, this.logprobs = e?.logprobs, this.topLogprobs = e?.topLogprobs, this.n = e?.n ?? this.n, this.logitBias = e?.logitBias, this.stop = e?.stopSequences ?? e?.stop, this.stopSequences = this.stop, this.user = e?.user, this.__includeRawResponse = e?.__includeRawResponse, this.audio = e?.audio, this.modalities = e?.modalities, this.reasoningEffort = e?.reasoningEffort, this.maxTokens = e?.maxCompletionTokens ?? e?.maxTokens, this.useResponsesApi = e?.useResponsesApi ?? this.useResponsesApi, this.model === "o1" && (this.disableStreaming = !0), this.streaming = e?.streaming ?? !1, this.streamUsage = e?.streamUsage ?? this.streamUsage, this.clientConfig = {
      apiKey: this.apiKey,
      organization: this.organization,
      dangerouslyAllowBrowser: !0,
      ...e?.configuration
    }, e?.supportsStrictToolCalling !== void 0 && (this.supportsStrictToolCalling = e.supportsStrictToolCalling);
  }
  getLsParams(e) {
    const n = this.invocationParams(e);
    return {
      ls_provider: "openai",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: n.temperature ?? void 0,
      ls_max_tokens: n.max_tokens ?? void 0,
      ls_stop: e.stop
    };
  }
  bindTools(e, n) {
    let a;
    return n?.strict !== void 0 ? a = n.strict : this.supportsStrictToolCalling !== void 0 && (a = this.supportsStrictToolCalling), this.bind({
      tools: e.map((r) => xm(r) ? r : tv(r, { strict: a })),
      ...n
    });
  }
  createResponseFormat(e) {
    return e && e.type === "json_schema" && e.json_schema.schema && Tf(e.json_schema.schema) ? zD(e.json_schema.schema, e.json_schema.name, {
      description: e.json_schema.description
    }) : e;
  }
  /**
   * Get the parameters used to invoke the model
   */
  invocationParams(e, n) {
    let a;
    if (e?.strict !== void 0 ? a = e.strict : this.supportsStrictToolCalling !== void 0 && (a = this.supportsStrictToolCalling), this._useResponseApi(e)) {
      const o = {
        model: this.model,
        temperature: this.temperature,
        top_p: this.topP,
        user: this.user,
        // if include_usage is set or streamUsage then stream must be set to true.
        stream: this.streaming,
        previous_response_id: e?.previous_response_id,
        truncation: e?.truncation,
        include: e?.include,
        tools: e?.tools?.length ? e.tools.map((f) => xm(f) ? f : fc(f) ? {
          type: "function",
          name: f.function.name,
          parameters: f.function.parameters,
          description: f.function.description,
          strict: a
        } : null).filter((f) => f !== null) : void 0,
        tool_choice: eq(e?.tool_choice) ? e?.tool_choice : (() => {
          const f = Qw(e?.tool_choice);
          if (typeof f == "object" && "type" in f)
            return { type: "function", name: f.function.name };
        })(),
        text: (() => {
          if (e?.text)
            return e.text;
          const f = this.createResponseFormat(e?.response_format);
          return f?.type === "json_schema" ? f.json_schema.schema != null ? {
            format: {
              type: "json_schema",
              schema: f.json_schema.schema,
              description: f.json_schema.description,
              name: f.json_schema.name,
              strict: f.json_schema.strict
            }
          } : void 0 : { format: f };
        })(),
        parallel_tool_calls: e?.parallel_tool_calls,
        max_output_tokens: this.maxTokens === -1 ? void 0 : this.maxTokens,
        ...this.modelKwargs
      }, l = e?.reasoning_effort ?? this.reasoningEffort;
      return l !== void 0 && (o.reasoning = { effort: l }), o;
    }
    let r = {};
    e?.stream_options !== void 0 ? r = { stream_options: e.stream_options } : this.streamUsage && (this.streaming || n?.streaming) && (r = { stream_options: { include_usage: !0 } });
    const i = {
      model: this.model,
      temperature: this.temperature,
      top_p: this.topP,
      frequency_penalty: this.frequencyPenalty,
      presence_penalty: this.presencePenalty,
      logprobs: this.logprobs,
      top_logprobs: this.topLogprobs,
      n: this.n,
      logit_bias: this.logitBias,
      stop: e?.stop ?? this.stopSequences,
      user: this.user,
      // if include_usage is set or streamUsage then stream must be set to true.
      stream: this.streaming,
      functions: e?.functions,
      function_call: e?.function_call,
      tools: e?.tools?.length ? e.tools.map((o) => tv(o, { strict: a })) : void 0,
      tool_choice: Qw(e?.tool_choice),
      response_format: this.createResponseFormat(e?.response_format),
      seed: e?.seed,
      ...r,
      parallel_tool_calls: e?.parallel_tool_calls,
      ...this.audio || e?.audio ? { audio: this.audio || e?.audio } : {},
      ...this.modalities || e?.modalities ? { modalities: this.modalities || e?.modalities } : {},
      ...this.modelKwargs
    };
    e?.prediction !== void 0 && (i.prediction = e.prediction);
    const s = e?.reasoning_effort ?? this.reasoningEffort;
    return s !== void 0 && (i.reasoning_effort = s), O_(i.model) ? i.max_completion_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens : i.max_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens, i;
  }
  _convertOpenAIChatCompletionMessageToBaseMessage(e, n) {
    const a = e.tool_calls;
    switch (e.role) {
      case "assistant": {
        const r = [], i = [];
        for (const l of a ?? [])
          try {
            r.push(Hd(l, { returnId: !0 }));
          } catch (f) {
            i.push($p(l, f.message));
          }
        const s = {
          function_call: e.function_call,
          tool_calls: a
        };
        this.__includeRawResponse !== void 0 && (s.__raw_response = n);
        const o = {
          model_name: n.model,
          ...n.system_fingerprint ? {
            usage: { ...n.usage },
            system_fingerprint: n.system_fingerprint
          } : {}
        };
        return e.audio && (s.audio = e.audio), new $t({
          content: e.content || "",
          tool_calls: r,
          invalid_tool_calls: i,
          additional_kwargs: s,
          response_metadata: o,
          id: n.id
        });
      }
      default:
        return new yo(e.content || "", e.role ?? "unknown");
    }
  }
  _convertOpenAIDeltaToBaseMessageChunk(e, n, a) {
    const r = e.role ?? a, i = e.content ?? "";
    let s;
    e.function_call ? s = {
      function_call: e.function_call
    } : e.tool_calls ? s = {
      tool_calls: e.tool_calls
    } : s = {}, this.__includeRawResponse && (s.__raw_response = n), e.audio && (s.audio = {
      ...e.audio,
      index: n.choices[0].index
    });
    const o = { usage: { ...n.usage } };
    if (r === "user")
      return new uc({ content: i, response_metadata: o });
    if (r === "assistant") {
      const l = [];
      if (Array.isArray(e.tool_calls))
        for (const f of e.tool_calls)
          l.push({
            name: f.function?.name,
            args: f.function?.arguments,
            id: f.id,
            index: f.index,
            type: "tool_call_chunk"
          });
      return new Ze({
        content: i,
        tool_call_chunks: l,
        additional_kwargs: s,
        id: n.id,
        response_metadata: o
      });
    } else return r === "system" ? new Hu({ content: i, response_metadata: o }) : r === "developer" ? new Hu({
      content: i,
      response_metadata: o,
      additional_kwargs: {
        __openai_role__: "developer"
      }
    }) : r === "function" ? new xd({
      content: i,
      additional_kwargs: s,
      name: e.name,
      response_metadata: o
    }) : r === "tool" ? new jp({
      content: i,
      additional_kwargs: s,
      tool_call_id: e.tool_call_id,
      response_metadata: o
    }) : new oc({ content: i, role: r, response_metadata: o });
  }
  /** @ignore */
  _identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams(),
      ...this.clientConfig
    };
  }
  async *_streamResponseChunks(e, n, a) {
    if (this._useResponseApi(n)) {
      const f = await this.responseApiWithRetry({
        ...this.invocationParams(n, { streaming: !0 }),
        input: ev(e, this.model),
        stream: !0
      }, n);
      for await (const u of f) {
        const c = YD(u);
        c != null && (yield c);
      }
      return;
    }
    const r = Yw(e, this.model), i = {
      ...this.invocationParams(n, {
        streaming: !0
      }),
      messages: r,
      stream: !0
    };
    let s;
    const o = await this.completionWithRetry(i, n);
    let l;
    for await (const f of o) {
      const u = f?.choices?.[0];
      if (f.usage && (l = f.usage), !u)
        continue;
      const { delta: c } = u;
      if (!c)
        continue;
      const h = this._convertOpenAIDeltaToBaseMessageChunk(c, f, s);
      s = c.role ?? s;
      const p = {
        prompt: n.promptIndex ?? 0,
        completion: u.index ?? 0
      };
      if (typeof h.content != "string") {
        console.log("[WARNING]: Received non-string content from OpenAI. This is currently not supported.");
        continue;
      }
      const d = { ...p };
      u.finish_reason != null && (d.finish_reason = u.finish_reason, d.system_fingerprint = f.system_fingerprint, d.model_name = f.model), this.logprobs && (d.logprobs = u.logprobs);
      const m = new Bt({
        message: h,
        text: h.content,
        generationInfo: d
      });
      yield m, await a?.handleLLMNewToken(m.text ?? "", p, void 0, void 0, void 0, { chunk: m });
    }
    if (l) {
      const f = {
        ...l.prompt_tokens_details?.audio_tokens !== null && {
          audio: l.prompt_tokens_details?.audio_tokens
        },
        ...l.prompt_tokens_details?.cached_tokens !== null && {
          cache_read: l.prompt_tokens_details?.cached_tokens
        }
      }, u = {
        ...l.completion_tokens_details?.audio_tokens !== null && {
          audio: l.completion_tokens_details?.audio_tokens
        },
        ...l.completion_tokens_details?.reasoning_tokens !== null && {
          reasoning: l.completion_tokens_details?.reasoning_tokens
        }
      };
      yield new Bt({
        message: new Ze({
          content: "",
          response_metadata: {
            usage: { ...l }
          },
          usage_metadata: {
            input_tokens: l.prompt_tokens,
            output_tokens: l.completion_tokens,
            total_tokens: l.total_tokens,
            ...Object.keys(f).length > 0 && {
              input_token_details: f
            },
            ...Object.keys(u).length > 0 && {
              output_token_details: u
            }
          }
        }),
        text: ""
      });
    }
    if (n.signal?.aborted)
      throw new Error("AbortError");
  }
  /**
   * Get the identifying parameters for the model
   *
   */
  identifyingParams() {
    return this._identifyingParams();
  }
  /** @ignore */
  async _responseApiGenerate(e, n, a) {
    const r = this.invocationParams(n);
    if (r.stream) {
      const o = this._streamResponseChunks(e, n, a);
      let l;
      for await (const f of o)
        f.message.response_metadata = {
          ...f.generationInfo,
          ...f.message.response_metadata
        }, l = l?.concat(f) ?? f;
      return {
        generations: l ? [l] : [],
        llmOutput: {
          estimatedTokenUsage: l?.message?.usage_metadata
        }
      };
    }
    const i = ev(e, this.model), s = await this.responseApiWithRetry({ input: i, ...r }, { signal: n?.signal, ...n?.options });
    return {
      generations: [
        {
          text: s.output_text,
          message: YC(s)
        }
      ],
      llmOutput: {
        id: s.id,
        estimatedTokenUsage: s.usage ? {
          promptTokens: s.usage.input_tokens,
          completionTokens: s.usage.output_tokens,
          totalTokens: s.usage.total_tokens
        } : void 0
      }
    };
  }
  _useResponseApi(e) {
    const n = e?.tools?.some(xm), a = e?.previous_response_id != null || e?.text != null || e?.truncation != null || e?.include != null;
    return this.useResponsesApi || n || a;
  }
  /** @ignore */
  async _generate(e, n, a) {
    if (this._useResponseApi(n))
      return this._responseApiGenerate(e, n, a);
    const r = {}, i = this.invocationParams(n), s = Yw(e, this.model);
    if (i.stream) {
      const o = this._streamResponseChunks(e, n, a), l = {};
      for await (const d of o) {
        d.message.response_metadata = {
          ...d.generationInfo,
          ...d.message.response_metadata
        };
        const m = d.generationInfo?.completion ?? 0;
        l[m] === void 0 ? l[m] = d : l[m] = l[m].concat(d);
      }
      const f = Object.entries(l).sort(([d], [m]) => parseInt(d, 10) - parseInt(m, 10)).map(([d, m]) => m), { functions: u, function_call: c } = this.invocationParams(n), h = await this.getEstimatedTokenCountFromPrompt(e, u, c), p = await this.getNumTokensFromGenerations(f);
      return r.input_tokens = h, r.output_tokens = p, r.total_tokens = h + p, {
        generations: f,
        llmOutput: {
          estimatedTokenUsage: {
            promptTokens: r.input_tokens,
            completionTokens: r.output_tokens,
            totalTokens: r.total_tokens
          }
        }
      };
    } else {
      let o;
      n.response_format && n.response_format.type === "json_schema" ? o = await this.betaParsedCompletionWithRetry({
        ...i,
        stream: !1,
        messages: s
      }, {
        signal: n?.signal,
        ...n?.options
      }) : o = await this.completionWithRetry({
        ...i,
        stream: !1,
        messages: s
      }, {
        signal: n?.signal,
        ...n?.options
      });
      const { completion_tokens: l, prompt_tokens: f, total_tokens: u, prompt_tokens_details: c, completion_tokens_details: h } = o?.usage ?? {};
      l && (r.output_tokens = (r.output_tokens ?? 0) + l), f && (r.input_tokens = (r.input_tokens ?? 0) + f), u && (r.total_tokens = (r.total_tokens ?? 0) + u), (c?.audio_tokens !== null || c?.cached_tokens !== null) && (r.input_token_details = {
        ...c?.audio_tokens !== null && {
          audio: c?.audio_tokens
        },
        ...c?.cached_tokens !== null && {
          cache_read: c?.cached_tokens
        }
      }), (h?.audio_tokens !== null || h?.reasoning_tokens !== null) && (r.output_token_details = {
        ...h?.audio_tokens !== null && {
          audio: h?.audio_tokens
        },
        ...h?.reasoning_tokens !== null && {
          reasoning: h?.reasoning_tokens
        }
      });
      const p = [];
      for (const d of o?.choices ?? []) {
        const b = {
          text: d.message?.content ?? "",
          message: this._convertOpenAIChatCompletionMessageToBaseMessage(d.message ?? { role: "assistant" }, o)
        };
        b.generationInfo = {
          ...d.finish_reason ? { finish_reason: d.finish_reason } : {},
          ...d.logprobs ? { logprobs: d.logprobs } : {}
        }, Vs(b.message) && (b.message.usage_metadata = r), b.message = new $t(Object.fromEntries(Object.entries(b.message).filter(([g]) => !g.startsWith("lc_")))), p.push(b);
      }
      return {
        generations: p,
        llmOutput: {
          tokenUsage: {
            promptTokens: r.input_tokens,
            completionTokens: r.output_tokens,
            totalTokens: r.total_tokens
          }
        }
      };
    }
  }
  /**
   * Estimate the number of tokens a prompt will use.
   * Modified from: https://github.com/hmarr/openai-chat-tokens/blob/main/src/index.ts
   */
  async getEstimatedTokenCountFromPrompt(e, n, a) {
    let r = (await this.getNumTokensFromMessages(e)).totalCount;
    if (n && a !== "auto") {
      const i = WD(n);
      r += await this.getNumTokens(i), r += 9;
    }
    return n && e.find((i) => i._getType() === "system") && (r -= 4), a === "none" ? r += 1 : typeof a == "object" && (r += await this.getNumTokens(a.name) + 4), r;
  }
  /**
   * Estimate the number of tokens an array of generations have used.
   */
  async getNumTokensFromGenerations(e) {
    return (await Promise.all(e.map(async (a) => a.message.additional_kwargs?.function_call ? (await this.getNumTokensFromMessages([a.message])).countPerMessage[0] : await this.getNumTokens(a.message.content)))).reduce((a, r) => a + r, 0);
  }
  async getNumTokensFromMessages(e) {
    let n = 0, a = 0, r = 0;
    this.model === "gpt-3.5-turbo-0301" ? (a = 4, r = -1) : (a = 3, r = 1);
    const i = await Promise.all(e.map(async (s) => {
      const o = await this.getNumTokens(s.content), l = await this.getNumTokens(S_(s)), f = s.name !== void 0 ? r + await this.getNumTokens(s.name) : 0;
      let u = o + a + l + f;
      const c = s;
      if (c._getType() === "function" && (u -= 2), c.additional_kwargs?.function_call && (u += 3), c?.additional_kwargs.function_call?.name && (u += await this.getNumTokens(c.additional_kwargs.function_call?.name)), c.additional_kwargs.function_call?.arguments)
        try {
          u += await this.getNumTokens(
            // Remove newlines and spaces
            JSON.stringify(JSON.parse(c.additional_kwargs.function_call?.arguments))
          );
        } catch (h) {
          console.error("Error parsing function arguments", h, JSON.stringify(c.additional_kwargs.function_call)), u += await this.getNumTokens(c.additional_kwargs.function_call?.arguments);
        }
      return n += u, u;
    }));
    return n += 3, { totalCount: n, countPerMessage: i };
  }
  async completionWithRetry(e, n) {
    const a = this._getClientOptions(n);
    return this.caller.call(async () => {
      try {
        return await this.client.chat.completions.create(e, a);
      } catch (r) {
        throw Yl(r);
      }
    });
  }
  async responseApiWithRetry(e, n) {
    return this.caller.call(async () => {
      const a = this._getClientOptions(n);
      try {
        return e.text?.format?.type === "json_schema" && !e.stream ? await this.client.responses.parse(e, a) : await this.client.responses.create(e, a);
      } catch (r) {
        throw Yl(r);
      }
    });
  }
  /**
   * Call the beta chat completions parse endpoint. This should only be called if
   * response_format is set to "json_object".
   * @param {OpenAIClient.Chat.ChatCompletionCreateParamsNonStreaming} request
   * @param {OpenAICoreRequestOptions | undefined} options
   */
  async betaParsedCompletionWithRetry(e, n) {
    const a = this._getClientOptions(n);
    return this.caller.call(async () => {
      try {
        return await this.client.beta.chat.completions.parse(e, a);
      } catch (r) {
        throw Yl(r);
      }
    });
  }
  _getClientOptions(e) {
    if (!this.client) {
      const a = {
        baseURL: this.clientConfig.baseURL
      }, r = y_(a), i = {
        ...this.clientConfig,
        baseURL: r,
        timeout: this.timeout,
        maxRetries: 0
      };
      i.baseURL || delete i.baseURL, this.client = new ge(i);
    }
    return {
      ...this.clientConfig,
      ...e
    };
  }
  _llmType() {
    return "openai";
  }
  /** @ignore */
  _combineLLMOutput(...e) {
    return e.reduce((n, a) => (a && a.tokenUsage && (n.tokenUsage.completionTokens += a.tokenUsage.completionTokens ?? 0, n.tokenUsage.promptTokens += a.tokenUsage.promptTokens ?? 0, n.tokenUsage.totalTokens += a.tokenUsage.totalTokens ?? 0), n), {
      tokenUsage: {
        completionTokens: 0,
        promptTokens: 0,
        totalTokens: 0
      }
    });
  }
  withStructuredOutput(e, n) {
    let a, r, i, s;
    tq(e) ? (a = e.schema, r = e.name, i = e.method, s = e.includeRaw) : (a = e, r = n?.name, i = n?.method, s = n?.includeRaw);
    let o, l;
    if (n?.strict !== void 0 && i === "jsonMode")
      throw new Error("Argument `strict` is only supported for `method` = 'function_calling'");
    if (!this.model.startsWith("gpt-3") && !this.model.startsWith("gpt-4-") && this.model !== "gpt-4" ? i === void 0 && (i = "jsonSchema") : i === "jsonSchema" && console.warn(`[WARNING]: JSON Schema is not supported for model "${this.model}". Falling back to tool calling.`), i === "jsonMode")
      o = this.bind({
        response_format: { type: "json_object" }
      }), Tf(a) ? l = Cd.fromZodSchema(a) : l = new Td();
    else if (i === "jsonSchema")
      if (o = this.bind({
        response_format: {
          type: "json_schema",
          json_schema: {
            name: r ?? "extract",
            description: a.description,
            schema: a,
            strict: n?.strict
          }
        }
      }), Tf(a)) {
        const h = Cd.fromZodSchema(a);
        l = au.from((p) => "parsed" in p.additional_kwargs ? p.additional_kwargs.parsed : h);
      } else
        l = new Td();
    else {
      let h = r ?? "extract";
      if (Tf(a)) {
        const p = Cn(a);
        o = this.bind({
          tools: [
            {
              type: "function",
              function: {
                name: h,
                description: p.description,
                parameters: p
              }
            }
          ],
          tool_choice: {
            type: "function",
            function: {
              name: h
            }
          },
          // Do not pass `strict` argument to OpenAI if `config.strict` is undefined
          ...n?.strict !== void 0 ? { strict: n.strict } : {}
        }), l = new Yu({
          returnSingle: !0,
          keyName: h,
          zodSchema: a
        });
      } else {
        let p;
        typeof a.name == "string" && typeof a.parameters == "object" && a.parameters != null ? (p = a, h = a.name) : (h = a.title ?? h, p = {
          name: h,
          description: a.description ?? "",
          parameters: a
        }), o = this.bind({
          tools: [
            {
              type: "function",
              function: p
            }
          ],
          tool_choice: {
            type: "function",
            function: {
              name: h
            }
          },
          // Do not pass `strict` argument to OpenAI if `config.strict` is undefined
          ...n?.strict !== void 0 ? { strict: n.strict } : {}
        }), l = new Yu({
          returnSingle: !0,
          keyName: h
        });
      }
    }
    if (!s)
      return o.pipe(l);
    const f = Mt.assign({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parsed: (h, p) => l.invoke(h.raw, p)
    }), u = Mt.assign({
      parsed: () => null
    }), c = f.withFallbacks({
      fallbacks: [u]
    });
    return dt.from([{ raw: o }, c]);
  }
}
function Tf(t) {
  return typeof t?.parse == "function";
}
function tq(t) {
  return t !== void 0 && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  typeof t.schema == "object";
}
class Lo extends b_ {
  constructor({ concurrency: e, ...n }) {
    super(e ? { maxConcurrency: e, ...n } : n), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "llms", this._llmType()]
    });
  }
  /**
   * This method takes an input and options, and returns a string. It
   * converts the input to a prompt value and generates a result based on
   * the prompt.
   * @param input Input for the LLM.
   * @param options Options for the LLM call.
   * @returns A string result based on the prompt.
   */
  async invoke(e, n) {
    const a = Lo._convertInputToPromptValue(e);
    return (await this.generatePrompt([a], n, n?.callbacks)).generations[0][0].text;
  }
  // eslint-disable-next-line require-yield
  async *_streamResponseChunks(e, n, a) {
    throw new Error("Not implemented.");
  }
  _separateRunnableConfigFromCallOptionsCompat(e) {
    const [n, a] = super._separateRunnableConfigFromCallOptions(e);
    return a.signal = n.signal, [n, a];
  }
  async *_streamIterator(e, n) {
    if (this._streamResponseChunks === Lo.prototype._streamResponseChunks)
      yield this.invoke(e, n);
    else {
      const a = Lo._convertInputToPromptValue(e), [r, i] = this._separateRunnableConfigFromCallOptionsCompat(n), s = await st.configure(r.callbacks, this.callbacks, r.tags, this.tags, r.metadata, this.metadata, { verbose: this.verbose }), o = {
        options: i,
        invocation_params: this?.invocationParams(i),
        batch_size: 1
      }, l = await s?.handleLLMStart(this.toJSON(), [a.toString()], r.runId, void 0, o, void 0, void 0, r.runName);
      let f = new ma({
        text: ""
      });
      try {
        for await (const u of this._streamResponseChunks(a.toString(), i, l?.[0]))
          f ? f = f.concat(u) : f = u, typeof u.text == "string" && (yield u.text);
      } catch (u) {
        throw await Promise.all((l ?? []).map((c) => c?.handleLLMError(u))), u;
      }
      await Promise.all((l ?? []).map((u) => u?.handleLLMEnd({
        generations: [[f]]
      })));
    }
  }
  /**
   * This method takes prompt values, options, and callbacks, and generates
   * a result based on the prompts.
   * @param promptValues Prompt values for the LLM.
   * @param options Options for the LLM call.
   * @param callbacks Callbacks for the LLM call.
   * @returns An LLMResult based on the prompts.
   */
  async generatePrompt(e, n, a) {
    const r = e.map((i) => i.toString());
    return this.generate(r, n, a);
  }
  /**
   * Get the parameters used to invoke the model
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  invocationParams(e) {
    return {};
  }
  _flattenLLMResult(e) {
    const n = [];
    for (let a = 0; a < e.generations.length; a += 1) {
      const r = e.generations[a];
      if (a === 0)
        n.push({
          generations: [r],
          llmOutput: e.llmOutput
        });
      else {
        const i = e.llmOutput ? { ...e.llmOutput, tokenUsage: {} } : void 0;
        n.push({
          generations: [r],
          llmOutput: i
        });
      }
    }
    return n;
  }
  /** @ignore */
  async _generateUncached(e, n, a, r) {
    let i;
    if (r !== void 0 && r.length === e.length)
      i = r;
    else {
      const f = await st.configure(a.callbacks, this.callbacks, a.tags, this.tags, a.metadata, this.metadata, { verbose: this.verbose }), u = {
        options: n,
        invocation_params: this?.invocationParams(n),
        batch_size: e.length
      };
      i = await f?.handleLLMStart(this.toJSON(), e, a.runId, void 0, u, void 0, void 0, a?.runName);
    }
    const s = !!i?.[0].handlers.find(RC);
    let o;
    if (s && e.length === 1 && this._streamResponseChunks !== Lo.prototype._streamResponseChunks)
      try {
        const f = await this._streamResponseChunks(e[0], n, i?.[0]);
        let u;
        for await (const c of f)
          u === void 0 ? u = c : u = on(u, c);
        if (u === void 0)
          throw new Error("Received empty response from chat model call.");
        o = { generations: [[u]], llmOutput: {} }, await i?.[0].handleLLMEnd(o);
      } catch (f) {
        throw await i?.[0].handleLLMError(f), f;
      }
    else {
      try {
        o = await this._generate(e, n, i?.[0]);
      } catch (u) {
        throw await Promise.all((i ?? []).map((c) => c?.handleLLMError(u))), u;
      }
      const f = this._flattenLLMResult(o);
      await Promise.all((i ?? []).map((u, c) => u?.handleLLMEnd(f[c])));
    }
    const l = i?.map((f) => f.runId) || void 0;
    return Object.defineProperty(o, Rd, {
      value: l ? { runIds: l } : void 0,
      configurable: !0
    }), o;
  }
  async _generateCached({ prompts: e, cache: n, llmStringKey: a, parsedOptions: r, handledOptions: i, runId: s }) {
    const o = await st.configure(i.callbacks, this.callbacks, i.tags, this.tags, i.metadata, this.metadata, { verbose: this.verbose }), l = {
      options: r,
      invocation_params: this?.invocationParams(r),
      batch_size: e.length
    }, f = await o?.handleLLMStart(this.toJSON(), e, s, void 0, l, void 0, void 0, i?.runName), u = [], h = (await Promise.allSettled(e.map(async (m, b) => {
      const g = await n.lookup(m, a);
      return g == null && u.push(b), g;
    }))).map((m, b) => ({ result: m, runManager: f?.[b] })).filter(({ result: m }) => m.status === "fulfilled" && m.value != null || m.status === "rejected"), p = [];
    await Promise.all(h.map(async ({ result: m, runManager: b }, g) => {
      if (m.status === "fulfilled") {
        const _ = m.value;
        return p[g] = _.map((P) => (P.generationInfo = {
          ...P.generationInfo,
          tokenUsage: {}
        }, P)), _.length && await b?.handleLLMNewToken(_[0].text), b?.handleLLMEnd({
          generations: [_]
        }, void 0, void 0, void 0, {
          cached: !0
        });
      } else
        return await b?.handleLLMError(m.reason, void 0, void 0, void 0, {
          cached: !0
        }), Promise.reject(m.reason);
    }));
    const d = {
      generations: p,
      missingPromptIndices: u,
      startedRunManagers: f
    };
    return Object.defineProperty(d, Rd, {
      value: f ? { runIds: f?.map((m) => m.runId) } : void 0,
      configurable: !0
    }), d;
  }
  /**
   * Run the LLM on the given prompts and input, handling caching.
   */
  async generate(e, n, a) {
    if (!Array.isArray(e))
      throw new Error("Argument 'prompts' is expected to be a string[]");
    let r;
    Array.isArray(n) ? r = { stop: n } : r = n;
    const [i, s] = this._separateRunnableConfigFromCallOptionsCompat(r);
    if (i.callbacks = i.callbacks ?? a, !this.cache)
      return this._generateUncached(e, s, i);
    const { cache: o } = this, l = this._getSerializedCacheKeyParametersForCall(s), { generations: f, missingPromptIndices: u, startedRunManagers: c } = await this._generateCached({
      prompts: e,
      cache: o,
      llmStringKey: l,
      parsedOptions: s,
      handledOptions: i,
      runId: i.runId
    });
    let h = {};
    if (u.length > 0) {
      const p = await this._generateUncached(u.map((d) => e[d]), s, i, c !== void 0 ? u.map((d) => c?.[d]) : void 0);
      await Promise.all(p.generations.map(async (d, m) => {
        const b = u[m];
        return f[b] = d, o.update(e[b], l, d);
      })), h = p.llmOutput ?? {};
    }
    return { generations: f, llmOutput: h };
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   * Convenience wrapper for {@link generate} that takes in a single string prompt and returns a single string output.
   */
  async call(e, n, a) {
    const { generations: r } = await this.generate([e], n, a);
    return r[0][0].text;
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * This method is similar to `call`, but it's used for making predictions
   * based on the input text.
   * @param text Input text for the prediction.
   * @param options Options for the LLM call.
   * @param callbacks Callbacks for the LLM call.
   * @returns A prediction based on the input text.
   */
  async predict(e, n, a) {
    return this.call(e, n, a);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * This method takes a list of messages, options, and callbacks, and
   * returns a predicted message.
   * @param messages A list of messages for the prediction.
   * @param options Options for the LLM call.
   * @param callbacks Callbacks for the LLM call.
   * @returns A predicted message based on the list of messages.
   */
  async predictMessages(e, n, a) {
    const r = lo(e), i = await this.call(r, n, a);
    return new $t(i);
  }
  /**
   * Get the identifying parameters of the LLM.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _identifyingParams() {
    return {};
  }
  /**
   * @deprecated
   * Return a json-like object representing this LLM.
   */
  serialize() {
    return {
      ...this._identifyingParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  _modelType() {
    return "base_llm";
  }
}
class nq extends Lo {
  async _generate(e, n, a) {
    return { generations: await Promise.all(e.map((i, s) => this._call(i, { ...n, promptIndex: s }, a).then((o) => [{ text: o }]))) };
  }
}
const zh = (t, e) => t.reduce((n, a, r) => {
  const i = Math.floor(r / e), s = n[i] || [];
  return n[i] = s.concat([a]), n;
}, []);
class Kz extends Lo {
  static lc_name() {
    return "OpenAI";
  }
  get callKeys() {
    return [...super.callKeys, "options"];
  }
  get lc_secrets() {
    return {
      openAIApiKey: "OPENAI_API_KEY",
      apiKey: "OPENAI_API_KEY",
      organization: "OPENAI_ORGANIZATION"
    };
  }
  get lc_aliases() {
    return {
      modelName: "model",
      openAIApiKey: "openai_api_key",
      apiKey: "openai_api_key"
    };
  }
  constructor(e) {
    if (super(e ?? {}), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "frequencyPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "presencePenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "n", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "bestOf", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logitBias", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "gpt-3.5-turbo-instruct"
    }), Object.defineProperty(this, "modelName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "modelKwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 20
    }), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stopSequences", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "user", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "openAIApiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "organization", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "clientConfig", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.openAIApiKey = e?.apiKey ?? e?.openAIApiKey ?? ft("OPENAI_API_KEY"), this.apiKey = this.openAIApiKey, this.organization = e?.configuration?.organization ?? ft("OPENAI_ORGANIZATION"), this.model = e?.model ?? e?.modelName ?? this.model, (this.model?.startsWith("gpt-3.5-turbo") || this.model?.startsWith("gpt-4") || this.model?.startsWith("o1")) && !this.model?.includes("-instruct"))
      throw new Error([
        `Your chosen OpenAI model, "${this.model}", is a chat model and not a text-in/text-out LLM.`,
        'Passing it into the "OpenAI" class is no longer supported.',
        'Please use the "ChatOpenAI" class instead.',
        "",
        "See this page for more information:",
        "|",
        "> https://js.langchain.com/docs/integrations/chat/openai"
      ].join(`
`));
    if (this.modelName = this.model, this.modelKwargs = e?.modelKwargs ?? {}, this.batchSize = e?.batchSize ?? this.batchSize, this.timeout = e?.timeout, this.temperature = e?.temperature ?? this.temperature, this.maxTokens = e?.maxTokens ?? this.maxTokens, this.topP = e?.topP ?? this.topP, this.frequencyPenalty = e?.frequencyPenalty ?? this.frequencyPenalty, this.presencePenalty = e?.presencePenalty ?? this.presencePenalty, this.n = e?.n ?? this.n, this.bestOf = e?.bestOf ?? this.bestOf, this.logitBias = e?.logitBias, this.stop = e?.stopSequences ?? e?.stop, this.stopSequences = this.stop, this.user = e?.user, this.streaming = e?.streaming ?? !1, this.streaming && this.bestOf && this.bestOf > 1)
      throw new Error("Cannot stream results when bestOf > 1");
    this.clientConfig = {
      apiKey: this.apiKey,
      organization: this.organization,
      dangerouslyAllowBrowser: !0,
      ...e?.configuration
    };
  }
  /**
   * Get the parameters used to invoke the model
   */
  invocationParams(e) {
    return {
      model: this.model,
      temperature: this.temperature,
      max_tokens: this.maxTokens,
      top_p: this.topP,
      frequency_penalty: this.frequencyPenalty,
      presence_penalty: this.presencePenalty,
      n: this.n,
      best_of: this.bestOf,
      logit_bias: this.logitBias,
      stop: e?.stop ?? this.stopSequences,
      user: this.user,
      stream: this.streaming,
      ...this.modelKwargs
    };
  }
  /** @ignore */
  _identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams(),
      ...this.clientConfig
    };
  }
  /**
   * Get the identifying parameters for the model
   */
  identifyingParams() {
    return this._identifyingParams();
  }
  /**
   * Call out to OpenAI's endpoint with k unique prompts
   *
   * @param [prompts] - The prompts to pass into the model.
   * @param [options] - Optional list of stop words to use when generating.
   * @param [runManager] - Optional callback manager to use when generating.
   *
   * @returns The full LLM output.
   *
   * @example
   * ```ts
   * import { OpenAI } from "langchain/llms/openai";
   * const openai = new OpenAI();
   * const response = await openai.generate(["Tell me a joke."]);
   * ```
   */
  async _generate(e, n, a) {
    const r = zh(e, this.batchSize), i = [], s = {}, o = this.invocationParams(n);
    if (o.max_tokens === -1) {
      if (e.length !== 1)
        throw new Error("max_tokens set to -1 not supported for multiple inputs");
      o.max_tokens = await tD({
        prompt: e[0],
        // Cast here to allow for other models that may not fit the union
        modelName: this.model
      });
    }
    for (let f = 0; f < r.length; f += 1) {
      const u = o.stream ? await (async () => {
        const d = [];
        let m;
        const b = await this.completionWithRetry({
          ...o,
          stream: !0,
          prompt: r[f]
        }, n);
        for await (const g of b) {
          m || (m = {
            id: g.id,
            object: g.object,
            created: g.created,
            model: g.model
          });
          for (const _ of g.choices) {
            if (!d[_.index])
              d[_.index] = _;
            else {
              const P = d[_.index];
              P.text += _.text, P.finish_reason = _.finish_reason, P.logprobs = _.logprobs;
            }
            a?.handleLLMNewToken(_.text, {
              prompt: Math.floor(_.index / this.n),
              completion: _.index % this.n
            });
          }
        }
        if (n.signal?.aborted)
          throw new Error("AbortError");
        return { ...m, choices: d };
      })() : await this.completionWithRetry({
        ...o,
        stream: !1,
        prompt: r[f]
      }, {
        signal: n.signal,
        ...n.options
      });
      i.push(...u.choices);
      const { completion_tokens: c, prompt_tokens: h, total_tokens: p } = u.usage ? u.usage : {
        completion_tokens: void 0,
        prompt_tokens: void 0,
        total_tokens: void 0
      };
      c && (s.completionTokens = (s.completionTokens ?? 0) + c), h && (s.promptTokens = (s.promptTokens ?? 0) + h), p && (s.totalTokens = (s.totalTokens ?? 0) + p);
    }
    return {
      generations: zh(i, this.n).map((f) => f.map((u) => ({
        text: u.text ?? "",
        generationInfo: {
          finishReason: u.finish_reason,
          logprobs: u.logprobs
        }
      }))),
      llmOutput: { tokenUsage: s }
    };
  }
  // TODO(jacoblee): Refactor with _generate(..., {stream: true}) implementation?
  async *_streamResponseChunks(e, n, a) {
    const r = {
      ...this.invocationParams(n),
      prompt: e,
      stream: !0
    }, i = await this.completionWithRetry(r, n);
    for await (const s of i) {
      const o = s?.choices[0];
      if (!o)
        continue;
      const l = new ma({
        text: o.text,
        generationInfo: {
          finishReason: o.finish_reason
        }
      });
      yield l, a?.handleLLMNewToken(l.text ?? "");
    }
    if (n.signal?.aborted)
      throw new Error("AbortError");
  }
  async completionWithRetry(e, n) {
    const a = this._getClientOptions(n);
    return this.caller.call(async () => {
      try {
        return await this.client.completions.create(e, a);
      } catch (r) {
        throw Yl(r);
      }
    });
  }
  /**
   * Calls the OpenAI API with retry logic in case of failures.
   * @param request The request to send to the OpenAI API.
   * @param options Optional configuration for the API call.
   * @returns The response from the OpenAI API.
   */
  _getClientOptions(e) {
    if (!this.client) {
      const a = {
        baseURL: this.clientConfig.baseURL
      }, r = y_(a), i = {
        ...this.clientConfig,
        baseURL: r,
        timeout: this.timeout,
        maxRetries: 0
      };
      i.baseURL || delete i.baseURL, this.client = new ge(i);
    }
    return {
      ...this.clientConfig,
      ...e
    };
  }
  _llmType() {
    return "openai";
  }
}
let j_ = class {
  constructor(e) {
    Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.caller = new ru(e ?? {});
  }
};
class Gz extends j_ {
  constructor(e) {
    const n = { maxConcurrency: 2, ...e };
    super(n), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "text-embedding-ada-002"
    }), Object.defineProperty(this, "modelName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 512
    }), Object.defineProperty(this, "stripNewLines", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "dimensions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "organization", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "clientConfig", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const a = n?.apiKey ?? n?.openAIApiKey ?? ft("OPENAI_API_KEY");
    this.organization = n?.configuration?.organization ?? ft("OPENAI_ORGANIZATION"), this.model = n?.model ?? n?.modelName ?? this.model, this.modelName = this.model, this.batchSize = n?.batchSize ?? this.batchSize, this.stripNewLines = n?.stripNewLines ?? this.stripNewLines, this.timeout = n?.timeout, this.dimensions = n?.dimensions, this.clientConfig = {
      apiKey: a,
      organization: this.organization,
      dangerouslyAllowBrowser: !0,
      ...e?.configuration
    };
  }
  /**
   * Method to generate embeddings for an array of documents. Splits the
   * documents into batches and makes requests to the OpenAI API to generate
   * embeddings.
   * @param texts Array of documents to generate embeddings for.
   * @returns Promise that resolves to a 2D array of embeddings for each document.
   */
  async embedDocuments(e) {
    const n = zh(this.stripNewLines ? e.map((s) => s.replace(/\n/g, " ")) : e, this.batchSize), a = n.map((s) => {
      const o = {
        model: this.model,
        input: s
      };
      return this.dimensions && (o.dimensions = this.dimensions), this.embeddingWithRetry(o);
    }), r = await Promise.all(a), i = [];
    for (let s = 0; s < r.length; s += 1) {
      const o = n[s], { data: l } = r[s];
      for (let f = 0; f < o.length; f += 1)
        i.push(l[f].embedding);
    }
    return i;
  }
  /**
   * Method to generate an embedding for a single document. Calls the
   * embeddingWithRetry method with the document as the input.
   * @param text Document to generate an embedding for.
   * @returns Promise that resolves to an embedding for the document.
   */
  async embedQuery(e) {
    const n = {
      model: this.model,
      input: this.stripNewLines ? e.replace(/\n/g, " ") : e
    };
    this.dimensions && (n.dimensions = this.dimensions);
    const { data: a } = await this.embeddingWithRetry(n);
    return a[0].embedding;
  }
  /**
   * Private method to make a request to the OpenAI API to generate
   * embeddings. Handles the retry logic and returns the response from the
   * API.
   * @param request Request to send to the OpenAI API.
   * @returns Promise that resolves to the response from the API.
   */
  async embeddingWithRetry(e) {
    if (!this.client) {
      const a = {
        baseURL: this.clientConfig.baseURL
      }, r = y_(a), i = {
        ...this.clientConfig,
        baseURL: r,
        timeout: this.timeout,
        maxRetries: 0
      };
      i.baseURL || delete i.baseURL, this.client = new ge(i);
    }
    const n = {};
    return this.caller.call(async () => {
      try {
        return await this.client.embeddings.create(e, n);
      } catch (a) {
        throw Yl(a);
      }
    });
  }
}
class rq extends m_ {
  get lc_namespace() {
    return ["langchain", "tools"];
  }
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "returnDirect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "verboseParsingErrors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "responseFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "content"
    }), this.verboseParsingErrors = e?.verboseParsingErrors ?? this.verboseParsingErrors, this.responseFormat = e?.responseFormat ?? this.responseFormat;
  }
  /**
   * Invokes the tool with the provided input and configuration.
   * @param input The input for the tool.
   * @param config Optional configuration for the tool.
   * @returns A Promise that resolves with a string.
   */
  async invoke(e, n) {
    let a, r, i = Re(n);
    return s_(e) ? (a = e.id, r = e.args, i = {
      ...i,
      toolCall: e,
      configurable: {
        ...i.configurable,
        tool_call_id: a
      }
    }) : r = e, this.call(r, i);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
   *
   * Calls the tool with the provided argument, configuration, and tags. It
   * parses the input according to the schema, handles any errors, and
   * manages callbacks.
   * @param arg The input argument for the tool.
   * @param configArg Optional configuration or callbacks for the tool.
   * @param tags Optional tags for the tool.
   * @returns A Promise that resolves with a string.
   */
  async call(e, n, a) {
    let r;
    try {
      r = await this.schema.parseAsync(e);
    } catch (p) {
      let d = "Received tool input did not match expected schema";
      throw this.verboseParsingErrors && (d = `${d}
Details: ${p.message}`), new Ph(d, JSON.stringify(e));
    }
    const i = Cp(n), o = await st.configure(i.callbacks, this.callbacks, i.tags || a, this.tags, i.metadata, this.metadata, { verbose: this.verbose })?.handleToolStart(this.toJSON(), typeof r == "string" ? r : JSON.stringify(r), i.runId, void 0, void 0, void 0, i.runName);
    delete i.runId;
    let l;
    try {
      l = await this._call(r, o, i);
    } catch (p) {
      throw await o?.handleToolError(p), p;
    }
    let f, u;
    if (this.responseFormat === "content_and_artifact")
      if (Array.isArray(l) && l.length === 2)
        [f, u] = l;
      else
        throw new Error(`Tool response format is "content_and_artifact" but the output was not a two-tuple.
Result: ${JSON.stringify(l)}`);
    else
      f = l;
    let c;
    i && "configurable" in i && (c = i.configurable.tool_call_id);
    const h = aq({
      content: f,
      artifact: u,
      toolCallId: c,
      name: this.name
    });
    return await o?.handleToolEnd(h), h;
  }
}
class Mp extends rq {
  constructor(e) {
    super(e), Object.defineProperty(this, "schema", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: jn.object({ input: jn.string().optional() }).transform((n) => n.input)
    });
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
   *
   * Calls the tool with the provided argument and callbacks. It handles
   * string inputs specifically.
   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.
   * @param callbacks Optional callbacks for the tool.
   * @returns A Promise that resolves with a string.
   */
  call(e, n) {
    return super.call(typeof e == "string" || !e ? { input: e } : e, n);
  }
}
class Wz extends Mp {
  static lc_name() {
    return "DynamicTool";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "description", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "func", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = e.name, this.description = e.description, this.func = e.func, this.returnDirect = e.returnDirect ?? this.returnDirect;
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
   */
  async call(e, n) {
    const a = Cp(n);
    return a.runName === void 0 && (a.runName = this.name), super.call(e, a);
  }
  /** @ignore */
  async _call(e, n, a) {
    return this.func(e, n, a);
  }
}
function aq(t) {
  const { content: e, artifact: n, toolCallId: a } = t;
  return a && !RI(e) ? typeof e == "string" || Array.isArray(e) && e.every((r) => typeof r == "object") ? new Kb({
    content: e,
    artifact: n,
    tool_call_id: a,
    name: t.name
  }) : new Kb({
    content: iq(e),
    artifact: n,
    tool_call_id: a,
    name: t.name
  }) : e;
}
function iq(t) {
  try {
    return JSON.stringify(t, null, 2);
  } catch {
    return `${t}`;
  }
}
const $u = "0.37.0";
let nv = !1, ed, eT, lg, tT, nT, rT;
function sq(t, e = { auto: !1 }) {
  if (nv)
    throw new Error(`you must \`import '@anthropic-ai/sdk/shims/${t.kind}'\` before importing anything else from @anthropic-ai/sdk`);
  if (ed)
    throw new Error(`can't \`import '@anthropic-ai/sdk/shims/${t.kind}'\` after \`import '@anthropic-ai/sdk/shims/${ed}'\``);
  nv = e.auto, ed = t.kind, eT = t.fetch, lg = t.File, tT = t.ReadableStream, nT = t.getDefaultAgent, rT = t.fileFromPath;
}
let oq = class {
  constructor(e) {
    this.body = e;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};
function uq({ manuallyImported: t } = {}) {
  const e = t ? "You may need to use polyfills" : "Add one of these imports before your first `import  from '@anthropic-ai/sdk'`:\n- `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)\n- `import '@anthropic-ai/sdk/shims/web'` (otherwise)\n";
  let n, a, r, i;
  try {
    n = fetch, a = Request, r = Response, i = Headers;
  } catch (s) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${s.message}. ${e}`);
  }
  return {
    kind: "web",
    fetch: n,
    Request: a,
    Response: r,
    Headers: i,
    FormData: (
      // @ts-ignore
      typeof FormData < "u" ? FormData : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`);
        }
      }
    ),
    Blob: typeof Blob < "u" ? Blob : class {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File < "u" ? File : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream < "u" ? ReadableStream : class {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`);
        }
      }
    ),
    getMultipartRequestOptions: async (s, o) => ({
      ...o,
      body: new oq(s)
    }),
    getDefaultAgent: (s) => {
    },
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/anthropics/anthropic-sdk-typescript#file-uploads");
    },
    isFsReadStream: (s) => !1
  };
}
ed || sq(uq(), { auto: !0 });
class je extends Error {
}
let $n = class dg extends je {
  constructor(e, n, a, r) {
    super(`${dg.makeMessage(e, n, a)}`), this.status = e, this.headers = r, this.request_id = r?.["request-id"], this.error = n;
  }
  static makeMessage(e, n, a) {
    const r = n?.message ? typeof n.message == "string" ? n.message : JSON.stringify(n.message) : n ? JSON.stringify(n) : a;
    return e && r ? `${e} ${r}` : e ? `${e} status code (no body)` : r || "(no status code or body)";
  }
  static generate(e, n, a, r) {
    if (!e || !r)
      return new Ap({ message: a, cause: fg(n) });
    const i = n;
    return e === 400 ? new iT(e, i, a, r) : e === 401 ? new sT(e, i, a, r) : e === 403 ? new oT(e, i, a, r) : e === 404 ? new uT(e, i, a, r) : e === 409 ? new cT(e, i, a, r) : e === 422 ? new lT(e, i, a, r) : e === 429 ? new dT(e, i, a, r) : e >= 500 ? new fT(e, i, a, r) : new dg(e, i, a, r);
  }
}, cr = class extends $n {
  constructor({ message: e } = {}) {
    super(void 0, void 0, e || "Request was aborted.", void 0);
  }
}, Ap = class extends $n {
  constructor({ message: e, cause: n }) {
    super(void 0, void 0, e || "Connection error.", void 0), n && (this.cause = n);
  }
}, aT = class extends Ap {
  constructor({ message: e } = {}) {
    super({ message: e ?? "Request timed out." });
  }
}, iT = class extends $n {
}, sT = class extends $n {
}, oT = class extends $n {
}, uT = class extends $n {
}, cT = class extends $n {
}, lT = class extends $n {
}, dT = class extends $n {
}, fT = class extends $n {
};
var $f = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, To = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, _n;
let Gd = class {
  constructor() {
    _n.set(this, void 0), this.buffer = new Uint8Array(), $f(this, _n, null, "f");
  }
  decode(e) {
    if (e == null)
      return [];
    const n = e instanceof ArrayBuffer ? new Uint8Array(e) : typeof e == "string" ? new TextEncoder().encode(e) : e;
    let a = new Uint8Array(this.buffer.length + n.length);
    a.set(this.buffer), a.set(n, this.buffer.length), this.buffer = a;
    const r = [];
    let i;
    for (; (i = cq(this.buffer, To(this, _n, "f"))) != null; ) {
      if (i.carriage && To(this, _n, "f") == null) {
        $f(this, _n, i.index, "f");
        continue;
      }
      if (To(this, _n, "f") != null && (i.index !== To(this, _n, "f") + 1 || i.carriage)) {
        r.push(this.decodeText(this.buffer.slice(0, To(this, _n, "f") - 1))), this.buffer = this.buffer.slice(To(this, _n, "f")), $f(this, _n, null, "f");
        continue;
      }
      const s = To(this, _n, "f") !== null ? i.preceding - 1 : i.preceding, o = this.decodeText(this.buffer.slice(0, s));
      r.push(o), this.buffer = this.buffer.slice(i.index), $f(this, _n, null, "f");
    }
    return r;
  }
  decodeText(e) {
    if (e == null)
      return "";
    if (typeof e == "string")
      return e;
    if (typeof Ke < "u") {
      if (e instanceof Ke)
        return e.toString();
      if (e instanceof Uint8Array)
        return Ke.from(e).toString();
      throw new je(`Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder < "u") {
      if (e instanceof Uint8Array || e instanceof ArrayBuffer)
        return this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8")), this.textDecoder.decode(e);
      throw new je(`Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new je("Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.");
  }
  flush() {
    return this.buffer.length ? this.decode(`
`) : [];
  }
};
_n = /* @__PURE__ */ new WeakMap();
Gd.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r"]);
Gd.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function cq(t, e) {
  for (let r = e ?? 0; r < t.length; r++) {
    if (t[r] === 10)
      return { preceding: r, index: r + 1, carriage: !1 };
    if (t[r] === 13)
      return { preceding: r, index: r + 1, carriage: !0 };
  }
  return null;
}
function lq(t) {
  for (let a = 0; a < t.length - 1; a++) {
    if (t[a] === 10 && t[a + 1] === 10 || t[a] === 13 && t[a + 1] === 13)
      return a + 2;
    if (t[a] === 13 && t[a + 1] === 10 && a + 3 < t.length && t[a + 2] === 13 && t[a + 3] === 10)
      return a + 4;
  }
  return -1;
}
function P_(t) {
  if (t[Symbol.asyncIterator])
    return t;
  const e = t.getReader();
  return {
    async next() {
      try {
        const n = await e.read();
        return n?.done && e.releaseLock(), n;
      } catch (n) {
        throw e.releaseLock(), n;
      }
    },
    async return() {
      const n = e.cancel();
      return e.releaseLock(), await n, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
let Md = class Vl {
  constructor(e, n) {
    this.iterator = e, this.controller = n;
  }
  static fromSSEResponse(e, n) {
    let a = !1;
    async function* r() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let i = !1;
      try {
        for await (const s of dq(e, n)) {
          if (s.event === "completion")
            try {
              yield JSON.parse(s.data);
            } catch (o) {
              throw console.error("Could not parse message into JSON:", s.data), console.error("From chunk:", s.raw), o;
            }
          if (s.event === "message_start" || s.event === "message_delta" || s.event === "message_stop" || s.event === "content_block_start" || s.event === "content_block_delta" || s.event === "content_block_stop")
            try {
              yield JSON.parse(s.data);
            } catch (o) {
              throw console.error("Could not parse message into JSON:", s.data), console.error("From chunk:", s.raw), o;
            }
          if (s.event !== "ping" && s.event === "error")
            throw $n.generate(void 0, `SSE Error: ${s.data}`, s.data, gT(e.headers));
        }
        i = !0;
      } catch (s) {
        if (s instanceof Error && s.name === "AbortError")
          return;
        throw s;
      } finally {
        i || n.abort();
      }
    }
    return new Vl(r, n);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(e, n) {
    let a = !1;
    async function* r() {
      const s = new Gd(), o = P_(e);
      for await (const l of o)
        for (const f of s.decode(l))
          yield f;
      for (const l of s.flush())
        yield l;
    }
    async function* i() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let s = !1;
      try {
        for await (const o of r())
          s || o && (yield JSON.parse(o));
        s = !0;
      } catch (o) {
        if (o instanceof Error && o.name === "AbortError")
          return;
        throw o;
      } finally {
        s || n.abort();
      }
    }
    return new Vl(i, n);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const e = [], n = [], a = this.iterator(), r = (i) => ({
      next: () => {
        if (i.length === 0) {
          const s = a.next();
          e.push(s), n.push(s);
        }
        return i.shift();
      }
    });
    return [
      new Vl(() => r(e), this.controller),
      new Vl(() => r(n), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const e = this;
    let n;
    const a = new TextEncoder();
    return new tT({
      async start() {
        n = e[Symbol.asyncIterator]();
      },
      async pull(r) {
        try {
          const { value: i, done: s } = await n.next();
          if (s)
            return r.close();
          const o = a.encode(JSON.stringify(i) + `
`);
          r.enqueue(o);
        } catch (i) {
          r.error(i);
        }
      },
      async cancel() {
        await n.return?.();
      }
    });
  }
};
async function* dq(t, e) {
  if (!t.body)
    throw e.abort(), new je("Attempted to iterate over a response with no body");
  const n = new hq(), a = new Gd(), r = P_(t.body);
  for await (const i of fq(r))
    for (const s of a.decode(i)) {
      const o = n.decode(s);
      o && (yield o);
    }
  for (const i of a.flush()) {
    const s = n.decode(i);
    s && (yield s);
  }
}
async function* fq(t) {
  let e = new Uint8Array();
  for await (const n of t) {
    if (n == null)
      continue;
    const a = n instanceof ArrayBuffer ? new Uint8Array(n) : typeof n == "string" ? new TextEncoder().encode(n) : n;
    let r = new Uint8Array(e.length + a.length);
    r.set(e), r.set(a, e.length), e = r;
    let i;
    for (; (i = lq(e)) !== -1; )
      yield e.slice(0, i), e = e.slice(i);
  }
  e.length > 0 && (yield e);
}
let hq = class {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(e) {
    if (e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e) {
      if (!this.event && !this.data.length)
        return null;
      const i = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], i;
    }
    if (this.chunks.push(e), e.startsWith(":"))
      return null;
    let [n, a, r] = pq(e, ":");
    return r.startsWith(" ") && (r = r.substring(1)), n === "event" ? this.event = r : n === "data" && this.data.push(r), null;
  }
};
function pq(t, e) {
  const n = t.indexOf(e);
  return n !== -1 ? [t.substring(0, n), e, t.substring(n + e.length)] : [t, "", ""];
}
const mq = (t) => t != null && typeof t == "object" && typeof t.url == "string" && typeof t.blob == "function", bq = (t) => t != null && typeof t == "object" && typeof t.name == "string" && typeof t.lastModified == "number" && Ep(t), Ep = (t) => t != null && typeof t == "object" && typeof t.size == "number" && typeof t.type == "string" && typeof t.text == "function" && typeof t.slice == "function" && typeof t.arrayBuffer == "function";
async function gq(t, e, n) {
  if (t = await t, bq(t))
    return t;
  if (mq(t)) {
    const r = await t.blob();
    e || (e = new URL(t.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const i = Ep(r) ? [await r.arrayBuffer()] : [r];
    return new lg(i, e, n);
  }
  const a = await _q(t);
  if (e || (e = wq(t) ?? "unknown_file"), !n?.type) {
    const r = a[0]?.type;
    typeof r == "string" && (n = { ...n, type: r });
  }
  return new lg(a, e, n);
}
async function _q(t) {
  let e = [];
  if (typeof t == "string" || ArrayBuffer.isView(t) || // includes Uint8Array, Buffer, etc.
  t instanceof ArrayBuffer)
    e.push(t);
  else if (Ep(t))
    e.push(await t.arrayBuffer());
  else if (vq(t))
    for await (const n of t)
      e.push(n);
  else
    throw new Error(`Unexpected data type: ${typeof t}; constructor: ${t?.constructor?.name}; props: ${yq(t)}`);
  return e;
}
function yq(t) {
  return `[${Object.getOwnPropertyNames(t).map((n) => `"${n}"`).join(", ")}]`;
}
function wq(t) {
  return Vm(t.name) || Vm(t.filename) || // For fs.ReadStream
  Vm(t.path)?.split(/[\\/]/).pop();
}
const Vm = (t) => {
  if (typeof t == "string")
    return t;
  if (typeof Ke < "u" && t instanceof Ke)
    return String(t);
}, vq = (t) => t != null && typeof t == "object" && typeof t[Symbol.asyncIterator] == "function", rv = (t) => t && typeof t == "object" && t.body && t[Symbol.toStringTag] === "MultipartBody";
var Sq = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, Oq = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, Mf;
async function hT(t) {
  const { response: e } = t;
  if (t.options.stream)
    return zu("response", e.status, e.url, e.headers, e.body), t.options.__streamClass ? t.options.__streamClass.fromSSEResponse(e, t.controller) : Md.fromSSEResponse(e, t.controller);
  if (e.status === 204)
    return null;
  if (t.options.__binaryResponse)
    return e;
  const n = e.headers.get("content-type");
  if (n?.includes("application/json") || n?.includes("application/vnd.api+json")) {
    const i = await e.json();
    return zu("response", e.status, e.url, e.headers, i), pT(i, e);
  }
  const r = await e.text();
  return zu("response", e.status, e.url, e.headers, r), r;
}
function pT(t, e) {
  return !t || typeof t != "object" || Array.isArray(t) ? t : Object.defineProperty(t, "_request_id", {
    value: e.headers.get("request-id"),
    enumerable: !1
  });
}
let mT = class bT extends Promise {
  constructor(e, n = hT) {
    super((a) => {
      a(null);
    }), this.responsePromise = e, this.parseResponse = n;
  }
  _thenUnwrap(e) {
    return new bT(this.responsePromise, async (n) => pT(e(await this.parseResponse(n), n), n.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from '@anthropic-ai/sdk'`:
   * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
   * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((e) => e.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from '@anthropic-ai/sdk'`:
   * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
   * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
   */
  async withResponse() {
    const [e, n] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: e, response: n, request_id: n.headers.get("request-id") };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)), this.parsedPromise;
  }
  then(e, n) {
    return this.parse().then(e, n);
  }
  catch(e) {
    return this.parse().catch(e);
  }
  finally(e) {
    return this.parse().finally(e);
  }
}, jq = class {
  constructor({
    baseURL: e,
    maxRetries: n = 2,
    timeout: a = 6e5,
    // 10 minutes
    httpAgent: r,
    fetch: i
  }) {
    this.baseURL = e, this.maxRetries = zm("maxRetries", n), this.timeout = zm("timeout", a), this.httpAgent = r, this.fetch = i ?? eT;
  }
  authHeaders(e) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(e) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...Mq(),
      ...this.authHeaders(e)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(e, n) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${kq()}`;
  }
  get(e, n) {
    return this.methodRequest("get", e, n);
  }
  post(e, n) {
    return this.methodRequest("post", e, n);
  }
  patch(e, n) {
    return this.methodRequest("patch", e, n);
  }
  put(e, n) {
    return this.methodRequest("put", e, n);
  }
  delete(e, n) {
    return this.methodRequest("delete", e, n);
  }
  methodRequest(e, n, a) {
    return this.request(Promise.resolve(a).then(async (r) => {
      const i = r && Ep(r?.body) ? new DataView(await r.body.arrayBuffer()) : r?.body instanceof DataView ? r.body : r?.body instanceof ArrayBuffer ? new DataView(r.body) : r && ArrayBuffer.isView(r?.body) ? new DataView(r.body.buffer) : r?.body;
      return { method: e, path: n, ...r, body: i };
    }));
  }
  getAPIList(e, n, a) {
    return this.requestAPIList(n, { method: "get", path: e, ...a });
  }
  calculateContentLength(e) {
    if (typeof e == "string") {
      if (typeof Ke < "u")
        return Ke.byteLength(e, "utf8").toString();
      if (typeof TextEncoder < "u")
        return new TextEncoder().encode(e).length.toString();
    } else if (ArrayBuffer.isView(e))
      return e.byteLength.toString();
    return null;
  }
  buildRequest(e, { retryCount: n = 0 } = {}) {
    e = { ...e };
    const { method: a, path: r, query: i, headers: s = {} } = e, o = ArrayBuffer.isView(e.body) || e.__binaryRequest && typeof e.body == "string" ? e.body : rv(e.body) ? e.body.body : e.body ? JSON.stringify(e.body, null, 2) : null, l = this.calculateContentLength(o), f = this.buildURL(r, i);
    "timeout" in e && zm("timeout", e.timeout), e.timeout = e.timeout ?? this.timeout;
    const u = e.httpAgent ?? this.httpAgent ?? nT(f), c = e.timeout + 1e3;
    typeof u?.options?.timeout == "number" && c > (u.options.timeout ?? 0) && (u.options.timeout = c), this.idempotencyHeader && a !== "get" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()), s[this.idempotencyHeader] = e.idempotencyKey);
    const h = this.buildHeaders({ options: e, headers: s, contentLength: l, retryCount: n });
    return { req: {
      method: a,
      ...o && { body: o },
      headers: h,
      ...u && { agent: u },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: e.signal ?? null
    }, url: f, timeout: e.timeout };
  }
  buildHeaders({ options: e, headers: n, contentLength: a, retryCount: r }) {
    const i = {};
    a && (i["content-length"] = a);
    const s = this.defaultHeaders(e);
    return ov(i, s), ov(i, n), rv(e.body) && ed !== "node" && delete i["content-type"], Af(s, "x-stainless-retry-count") === void 0 && Af(n, "x-stainless-retry-count") === void 0 && (i["x-stainless-retry-count"] = String(r)), Af(s, "x-stainless-timeout") === void 0 && Af(n, "x-stainless-timeout") === void 0 && e.timeout && (i["x-stainless-timeout"] = String(e.timeout)), this.validateHeaders(i, n), i;
  }
  _calculateNonstreamingTimeout(e) {
    if (3600 * e / 128e3 > 600)
      throw new je("Streaming is strongly recommended for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-python#streaming-responses for more details");
    return 600 * 1e3;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(e) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(e, { url: n, options: a }) {
  }
  parseHeaders(e) {
    return e ? Symbol.iterator in e ? Object.fromEntries(Array.from(e).map((n) => [...n])) : { ...e } : {};
  }
  makeStatusError(e, n, a, r) {
    return $n.generate(e, n, a, r);
  }
  request(e, n = null) {
    return new mT(this.makeRequest(e, n));
  }
  async makeRequest(e, n) {
    const a = await e, r = a.maxRetries ?? this.maxRetries;
    n == null && (n = r), await this.prepareOptions(a);
    const { req: i, url: s, timeout: o } = this.buildRequest(a, { retryCount: r - n });
    if (await this.prepareRequest(i, { url: s, options: a }), zu("request", s, a, i.headers), a.signal?.aborted)
      throw new cr();
    const l = new AbortController(), f = await this.fetchWithTimeout(s, i, o, l).catch(fg);
    if (f instanceof Error) {
      if (a.signal?.aborted)
        throw new cr();
      if (n)
        return this.retryRequest(a, n);
      throw f.name === "AbortError" ? new aT() : new Ap({ cause: f });
    }
    const u = gT(f.headers);
    if (!f.ok) {
      if (n && this.shouldRetry(f)) {
        const b = `retrying, ${n} attempts remaining`;
        return zu(`response (error; ${b})`, f.status, s, u), this.retryRequest(a, n, u);
      }
      const c = await f.text().catch((b) => fg(b).message), h = Aq(c), p = h ? void 0 : c;
      throw zu(`response (error; ${n ? "(error; no more retries left)" : "(error; not retryable)"})`, f.status, s, u, p), this.makeStatusError(f.status, h, p, u);
    }
    return { response: f, options: a, controller: l };
  }
  requestAPIList(e, n) {
    const a = this.makeRequest(n, null);
    return new Rq(this, a, e);
  }
  buildURL(e, n) {
    const a = Iq(e) ? new URL(e) : new URL(this.baseURL + (this.baseURL.endsWith("/") && e.startsWith("/") ? e.slice(1) : e)), r = this.defaultQuery();
    return Zh(r) || (n = { ...r, ...n }), typeof n == "object" && n && !Array.isArray(n) && (a.search = this.stringifyQuery(n)), a.toString();
  }
  stringifyQuery(e) {
    return Object.entries(e).filter(([n, a]) => typeof a < "u").map(([n, a]) => {
      if (typeof a == "string" || typeof a == "number" || typeof a == "boolean")
        return `${encodeURIComponent(n)}=${encodeURIComponent(a)}`;
      if (a === null)
        return `${encodeURIComponent(n)}=`;
      throw new je(`Cannot stringify type ${typeof a}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(e, n, a, r) {
    const { signal: i, ...s } = n || {};
    i && i.addEventListener("abort", () => r.abort());
    const o = setTimeout(() => r.abort(), a), l = {
      signal: r.signal,
      ...s
    };
    l.method && (l.method = l.method.toUpperCase());
    const f = 60 * 1e3, u = setTimeout(() => {
      if (l && l?.agent?.sockets)
        for (const c of Object.values(l?.agent?.sockets).flat())
          c?.setKeepAlive && c.setKeepAlive(!0, f);
    }, f);
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, e, l).finally(() => {
        clearTimeout(o), clearTimeout(u);
      })
    );
  }
  shouldRetry(e) {
    const n = e.headers.get("x-should-retry");
    return n === "true" ? !0 : n === "false" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500;
  }
  async retryRequest(e, n, a) {
    let r;
    const i = a?.["retry-after-ms"];
    if (i) {
      const o = parseFloat(i);
      Number.isNaN(o) || (r = o);
    }
    const s = a?.["retry-after"];
    if (s && !r) {
      const o = parseFloat(s);
      Number.isNaN(o) ? r = Date.parse(s) - Date.now() : r = o * 1e3;
    }
    if (!(r && 0 <= r && r < 60 * 1e3)) {
      const o = e.maxRetries ?? this.maxRetries;
      r = this.calculateDefaultRetryTimeoutMillis(n, o);
    }
    return await Nq(r), this.makeRequest(e, n - 1);
  }
  calculateDefaultRetryTimeoutMillis(e, n) {
    const i = n - e, s = Math.min(0.5 * Math.pow(2, i), 8), o = 1 - Math.random() * 0.25;
    return s * o * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${$u}`;
  }
};
class Pq {
  constructor(e, n, a, r) {
    Mf.set(this, void 0), Sq(this, Mf, e, "f"), this.options = r, this.response = n, this.body = a;
  }
  hasNextPage() {
    return this.getPaginatedItems().length ? this.nextPageInfo() != null : !1;
  }
  async getNextPage() {
    const e = this.nextPageInfo();
    if (!e)
      throw new je("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    const n = { ...this.options };
    if ("params" in e && typeof n.query == "object")
      n.query = { ...n.query, ...e.params };
    else if ("url" in e) {
      const a = [...Object.entries(n.query || {}), ...e.url.searchParams.entries()];
      for (const [r, i] of a)
        e.url.searchParams.set(r, i);
      n.query = void 0, n.path = e.url.toString();
    }
    return await Oq(this, Mf, "f").requestAPIList(this.constructor, n);
  }
  async *iterPages() {
    let e = this;
    for (yield e; e.hasNextPage(); )
      e = await e.getNextPage(), yield e;
  }
  async *[(Mf = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const e of this.iterPages())
      for (const n of e.getPaginatedItems())
        yield n;
  }
}
let Rq = class extends mT {
  constructor(e, n, a) {
    super(n, async (r) => new a(e, r.response, await hT(r), r.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const e = await this;
    for await (const n of e)
      yield n;
  }
};
const gT = (t) => new Proxy(Object.fromEntries(
  // @ts-ignore
  t.entries()
), {
  get(e, n) {
    const a = n.toString();
    return e[a.toLowerCase()] || e[a];
  }
}), Cq = {
  method: !0,
  path: !0,
  query: !0,
  body: !0,
  headers: !0,
  maxRetries: !0,
  stream: !0,
  timeout: !0,
  httpAgent: !0,
  signal: !0,
  idempotencyKey: !0,
  __binaryRequest: !0,
  __binaryResponse: !0,
  __streamClass: !0
}, oo = (t) => typeof t == "object" && t !== null && !Zh(t) && Object.keys(t).every((e) => _T(Cq, e)), Tq = () => {
  if (typeof Deno < "u" && Deno.build != null)
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": $u,
      "X-Stainless-OS": iv(Deno.build.os),
      "X-Stainless-Arch": av(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": $u,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": ue.version
    };
  if (Object.prototype.toString.call(typeof ue < "u" ? ue : 0) === "[object process]")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": $u,
      "X-Stainless-OS": iv(ue.platform),
      "X-Stainless-Arch": av(ue.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": ue.version
    };
  const t = $q();
  return t ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": $u,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${t.browser}`,
    "X-Stainless-Runtime-Version": t.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": $u,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function $q() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const t = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: e, pattern: n } of t) {
    const a = n.exec(navigator.userAgent);
    if (a) {
      const r = a[1] || 0, i = a[2] || 0, s = a[3] || 0;
      return { browser: e, version: `${r}.${i}.${s}` };
    }
  }
  return null;
}
const av = (t) => t === "x32" ? "x32" : t === "x86_64" || t === "x64" ? "x64" : t === "arm" ? "arm" : t === "aarch64" || t === "arm64" ? "arm64" : t ? `other:${t}` : "unknown", iv = (t) => (t = t.toLowerCase(), t.includes("ios") ? "iOS" : t === "android" ? "Android" : t === "darwin" ? "MacOS" : t === "win32" ? "Windows" : t === "freebsd" ? "FreeBSD" : t === "openbsd" ? "OpenBSD" : t === "linux" ? "Linux" : t ? `Other:${t}` : "Unknown");
let sv;
const Mq = () => sv ?? (sv = Tq()), Aq = (t) => {
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}, Eq = /^[a-z][a-z0-9+.-]*:/i, Iq = (t) => Eq.test(t), Nq = (t) => new Promise((e) => setTimeout(e, t)), zm = (t, e) => {
  if (typeof e != "number" || !Number.isInteger(e))
    throw new je(`${t} must be an integer`);
  if (e < 0)
    throw new je(`${t} must be a positive integer`);
  return e;
}, fg = (t) => {
  if (t instanceof Error)
    return t;
  if (typeof t == "object" && t !== null)
    try {
      return new Error(JSON.stringify(t));
    } catch {
    }
  return new Error(String(t));
}, Zm = (t) => {
  if (typeof ue < "u")
    return ue.env?.[t]?.trim() ?? void 0;
  if (typeof Deno < "u")
    return Deno.env?.get?.(t)?.trim();
};
function Zh(t) {
  if (!t)
    return !0;
  for (const e in t)
    return !1;
  return !0;
}
function _T(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function ov(t, e) {
  for (const n in e) {
    if (!_T(e, n))
      continue;
    const a = n.toLowerCase();
    if (!a)
      continue;
    const r = e[n];
    r === null ? delete t[a] : r !== void 0 && (t[a] = r);
  }
}
function zu(t, ...e) {
  typeof ue < "u" && ue?.env?.DEBUG === "true" && console.log(`Anthropic:DEBUG:${t}`, ...e);
}
const kq = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
  const e = Math.random() * 16 | 0;
  return (t === "x" ? e : e & 3 | 8).toString(16);
}), Fq = () => (
  // @ts-ignore
  typeof window < "u" && // @ts-ignore
  typeof window.document < "u" && // @ts-ignore
  typeof navigator < "u"
), Dq = (t) => typeof t?.get == "function", Af = (t, e) => {
  const n = e.toLowerCase();
  if (Dq(t)) {
    const a = e[0]?.toUpperCase() + e.substring(1).replace(/([^\w])(\w)/g, (r, i, s) => i + s.toUpperCase());
    for (const r of [e, n, e.toUpperCase(), a]) {
      const i = t.get(r);
      if (i)
        return i;
    }
  }
  for (const [a, r] of Object.entries(t))
    if (a.toLowerCase() === n)
      return Array.isArray(r) ? (r.length <= 1 || console.warn(`Received ${r.length} entries for the ${e} header, using the first entry.`), r[0]) : r;
};
class Ip extends Pq {
  constructor(e, n, a, r) {
    super(e, n, a, r), this.data = a.data || [], this.has_more = a.has_more || !1, this.first_id = a.first_id || null, this.last_id = a.last_id || null;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const e = this.nextPageInfo();
    if (!e)
      return null;
    if ("params" in e)
      return e.params;
    const n = Object.fromEntries(e.url.searchParams);
    return Object.keys(n).length ? n : null;
  }
  nextPageInfo() {
    if (this.options.query?.before_id) {
      const n = this.first_id;
      return n ? {
        params: {
          before_id: n
        }
      } : null;
    }
    const e = this.last_id;
    return e ? {
      params: {
        after_id: e
      }
    } : null;
  }
}
let wo = class {
  constructor(e) {
    this._client = e;
  }
}, R_ = class extends wo {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
  retrieve(e, n) {
    return this._client.get(`/v1/models/${e}?beta=true`, n);
  }
  list(e = {}, n) {
    return oo(e) ? this.list({}, e) : this._client.getAPIList("/v1/models?beta=true", C_, { query: e, ...n });
  }
};
class C_ extends Ip {
}
R_.BetaModelInfosPage = C_;
class Np {
  constructor(e, n) {
    this.iterator = e, this.controller = n;
  }
  async *decoder() {
    const e = new Gd();
    for await (const n of this.iterator)
      for (const a of e.decode(n))
        yield JSON.parse(a);
    for (const n of e.flush())
      yield JSON.parse(n);
  }
  [Symbol.asyncIterator]() {
    return this.decoder();
  }
  static fromResponse(e, n) {
    if (!e.body)
      throw n.abort(), new je("Attempted to iterate over a response with no body");
    return new Np(P_(e.body), n);
  }
}
let T_ = class extends wo {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  create(e, n) {
    const { betas: a, ...r } = e;
    return this._client.post("/v1/messages/batches?beta=true", {
      body: r,
      ...n,
      headers: {
        "anthropic-beta": [...a ?? [], "message-batches-2024-09-24"].toString(),
        ...n?.headers
      }
    });
  }
  retrieve(e, n = {}, a) {
    if (oo(n))
      return this.retrieve(e, {}, n);
    const { betas: r } = n;
    return this._client.get(`/v1/messages/batches/${e}?beta=true`, {
      ...a,
      headers: {
        "anthropic-beta": [...r ?? [], "message-batches-2024-09-24"].toString(),
        ...a?.headers
      }
    });
  }
  list(e = {}, n) {
    if (oo(e))
      return this.list({}, e);
    const { betas: a, ...r } = e;
    return this._client.getAPIList("/v1/messages/batches?beta=true", $_, {
      query: r,
      ...n,
      headers: {
        "anthropic-beta": [...a ?? [], "message-batches-2024-09-24"].toString(),
        ...n?.headers
      }
    });
  }
  delete(e, n = {}, a) {
    if (oo(n))
      return this.delete(e, {}, n);
    const { betas: r } = n;
    return this._client.delete(`/v1/messages/batches/${e}?beta=true`, {
      ...a,
      headers: {
        "anthropic-beta": [...r ?? [], "message-batches-2024-09-24"].toString(),
        ...a?.headers
      }
    });
  }
  cancel(e, n = {}, a) {
    if (oo(n))
      return this.cancel(e, {}, n);
    const { betas: r } = n;
    return this._client.post(`/v1/messages/batches/${e}/cancel?beta=true`, {
      ...a,
      headers: {
        "anthropic-beta": [...r ?? [], "message-batches-2024-09-24"].toString(),
        ...a?.headers
      }
    });
  }
  async results(e, n = {}, a) {
    if (oo(n))
      return this.results(e, {}, n);
    const r = await this.retrieve(e);
    if (!r.results_url)
      throw new je(`No batch \`results_url\`; Has it finished processing? ${r.processing_status} - ${r.id}`);
    const { betas: i } = n;
    return this._client.get(r.results_url, {
      ...a,
      headers: {
        "anthropic-beta": [...i ?? [], "message-batches-2024-09-24"].toString(),
        Accept: "application/binary",
        ...a?.headers
      },
      __binaryResponse: !0
    })._thenUnwrap((s, o) => Np.fromResponse(o.response, o.controller));
  }
};
class $_ extends Ip {
}
T_.BetaMessageBatchesPage = $_;
const qq = (t) => {
  let e = 0, n = [];
  for (; e < t.length; ) {
    let a = t[e];
    if (a === "\\") {
      e++;
      continue;
    }
    if (a === "{") {
      n.push({
        type: "brace",
        value: "{"
      }), e++;
      continue;
    }
    if (a === "}") {
      n.push({
        type: "brace",
        value: "}"
      }), e++;
      continue;
    }
    if (a === "[") {
      n.push({
        type: "paren",
        value: "["
      }), e++;
      continue;
    }
    if (a === "]") {
      n.push({
        type: "paren",
        value: "]"
      }), e++;
      continue;
    }
    if (a === ":") {
      n.push({
        type: "separator",
        value: ":"
      }), e++;
      continue;
    }
    if (a === ",") {
      n.push({
        type: "delimiter",
        value: ","
      }), e++;
      continue;
    }
    if (a === '"') {
      let o = "", l = !1;
      for (a = t[++e]; a !== '"'; ) {
        if (e === t.length) {
          l = !0;
          break;
        }
        if (a === "\\") {
          if (e++, e === t.length) {
            l = !0;
            break;
          }
          o += a + t[e], a = t[++e];
        } else
          o += a, a = t[++e];
      }
      a = t[++e], l || n.push({
        type: "string",
        value: o
      });
      continue;
    }
    if (a && /\s/.test(a)) {
      e++;
      continue;
    }
    let i = /[0-9]/;
    if (a && i.test(a) || a === "-" || a === ".") {
      let o = "";
      for (a === "-" && (o += a, a = t[++e]); a && i.test(a) || a === "."; )
        o += a, a = t[++e];
      n.push({
        type: "number",
        value: o
      });
      continue;
    }
    let s = /[a-z]/i;
    if (a && s.test(a)) {
      let o = "";
      for (; a && s.test(a) && e !== t.length; )
        o += a, a = t[++e];
      if (o == "true" || o == "false" || o === "null")
        n.push({
          type: "name",
          value: o
        });
      else {
        e++;
        continue;
      }
      continue;
    }
    e++;
  }
  return n;
}, Mu = (t) => {
  if (t.length === 0)
    return t;
  let e = t[t.length - 1];
  switch (e.type) {
    case "separator":
      return t = t.slice(0, t.length - 1), Mu(t);
    case "number":
      let n = e.value[e.value.length - 1];
      if (n === "." || n === "-")
        return t = t.slice(0, t.length - 1), Mu(t);
    case "string":
      let a = t[t.length - 2];
      if (a?.type === "delimiter")
        return t = t.slice(0, t.length - 1), Mu(t);
      if (a?.type === "brace" && a.value === "{")
        return t = t.slice(0, t.length - 1), Mu(t);
      break;
    case "delimiter":
      return t = t.slice(0, t.length - 1), Mu(t);
  }
  return t;
}, Jq = (t) => {
  let e = [];
  return t.map((n) => {
    n.type === "brace" && (n.value === "{" ? e.push("}") : e.splice(e.lastIndexOf("}"), 1)), n.type === "paren" && (n.value === "[" ? e.push("]") : e.splice(e.lastIndexOf("]"), 1));
  }), e.length > 0 && e.reverse().map((n) => {
    n === "}" ? t.push({
      type: "brace",
      value: "}"
    }) : n === "]" && t.push({
      type: "paren",
      value: "]"
    });
  }), t;
}, Lq = (t) => {
  let e = "";
  return t.map((n) => {
    switch (n.type) {
      case "string":
        e += '"' + n.value + '"';
        break;
      default:
        e += n.value;
        break;
    }
  }), e;
}, yT = (t) => JSON.parse(Lq(Jq(Mu(qq(t)))));
var qt = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, we = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, Nn, eo, Pc, Ef, Rc, Cc, If, Tc, Sa, $c, Nf, kf, gu, Ff, Df, Km, uv, Hm, Gm, Wm, Xm, cv;
const lv = "__json_buf";
class Kh {
  constructor() {
    Nn.add(this), this.messages = [], this.receivedMessages = [], eo.set(this, void 0), this.controller = new AbortController(), Pc.set(this, void 0), Ef.set(this, () => {
    }), Rc.set(this, () => {
    }), Cc.set(this, void 0), If.set(this, () => {
    }), Tc.set(this, () => {
    }), Sa.set(this, {}), $c.set(this, !1), Nf.set(this, !1), kf.set(this, !1), gu.set(this, !1), Ff.set(this, void 0), Df.set(this, void 0), Hm.set(this, (e) => {
      if (qt(this, Nf, !0, "f"), e instanceof Error && e.name === "AbortError" && (e = new cr()), e instanceof cr)
        return qt(this, kf, !0, "f"), this._emit("abort", e);
      if (e instanceof je)
        return this._emit("error", e);
      if (e instanceof Error) {
        const n = new je(e.message);
        return n.cause = e, this._emit("error", n);
      }
      return this._emit("error", new je(String(e)));
    }), qt(this, Pc, new Promise((e, n) => {
      qt(this, Ef, e, "f"), qt(this, Rc, n, "f");
    }), "f"), qt(this, Cc, new Promise((e, n) => {
      qt(this, If, e, "f"), qt(this, Tc, n, "f");
    }), "f"), we(this, Pc, "f").catch(() => {
    }), we(this, Cc, "f").catch(() => {
    });
  }
  get response() {
    return we(this, Ff, "f");
  }
  get request_id() {
    return we(this, Df, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    const e = await we(this, Pc, "f");
    if (!e)
      throw new Error("Could not resolve a `Response` object");
    return {
      data: this,
      response: e,
      request_id: e.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(e) {
    const n = new Kh();
    return n._run(() => n._fromReadableStream(e)), n;
  }
  static createMessage(e, n, a) {
    const r = new Kh();
    for (const i of n.messages)
      r._addMessageParam(i);
    return r._run(() => r._createMessage(e, { ...n, stream: !0 }, { ...a, headers: { ...a?.headers, "X-Stainless-Helper-Method": "stream" } })), r;
  }
  _run(e) {
    e().then(() => {
      this._emitFinal(), this._emit("end");
    }, we(this, Hm, "f"));
  }
  _addMessageParam(e) {
    this.messages.push(e);
  }
  _addMessage(e, n = !0) {
    this.receivedMessages.push(e), n && this._emit("message", e);
  }
  async _createMessage(e, n, a) {
    const r = a?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), we(this, Nn, "m", Gm).call(this);
    const { response: i, data: s } = await e.create({ ...n, stream: !0 }, { ...a, signal: this.controller.signal }).withResponse();
    this._connected(i);
    for await (const o of s)
      we(this, Nn, "m", Wm).call(this, o);
    if (s.controller.signal?.aborted)
      throw new cr();
    we(this, Nn, "m", Xm).call(this);
  }
  _connected(e) {
    this.ended || (qt(this, Ff, e, "f"), qt(this, Df, e?.headers.get("request-id"), "f"), we(this, Ef, "f").call(this, e), this._emit("connect"));
  }
  get ended() {
    return we(this, $c, "f");
  }
  get errored() {
    return we(this, Nf, "f");
  }
  get aborted() {
    return we(this, kf, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(e, n) {
    return (we(this, Sa, "f")[e] || (we(this, Sa, "f")[e] = [])).push({ listener: n }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(e, n) {
    const a = we(this, Sa, "f")[e];
    if (!a)
      return this;
    const r = a.findIndex((i) => i.listener === n);
    return r >= 0 && a.splice(r, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(e, n) {
    return (we(this, Sa, "f")[e] || (we(this, Sa, "f")[e] = [])).push({ listener: n, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(e) {
    return new Promise((n, a) => {
      qt(this, gu, !0, "f"), e !== "error" && this.once("error", a), this.once(e, n);
    });
  }
  async done() {
    qt(this, gu, !0, "f"), await we(this, Cc, "f");
  }
  get currentMessage() {
    return we(this, eo, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalMessage() {
    return await this.done(), we(this, Nn, "m", Km).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    return await this.done(), we(this, Nn, "m", uv).call(this);
  }
  _emit(e, ...n) {
    if (we(this, $c, "f"))
      return;
    e === "end" && (qt(this, $c, !0, "f"), we(this, If, "f").call(this));
    const a = we(this, Sa, "f")[e];
    if (a && (we(this, Sa, "f")[e] = a.filter((r) => !r.once), a.forEach(({ listener: r }) => r(...n))), e === "abort") {
      const r = n[0];
      !we(this, gu, "f") && !a?.length && Promise.reject(r), we(this, Rc, "f").call(this, r), we(this, Tc, "f").call(this, r), this._emit("end");
      return;
    }
    if (e === "error") {
      const r = n[0];
      !we(this, gu, "f") && !a?.length && Promise.reject(r), we(this, Rc, "f").call(this, r), we(this, Tc, "f").call(this, r), this._emit("end");
    }
  }
  _emitFinal() {
    this.receivedMessages.at(-1) && this._emit("finalMessage", we(this, Nn, "m", Km).call(this));
  }
  async _fromReadableStream(e, n) {
    const a = n?.signal;
    a && (a.aborted && this.controller.abort(), a.addEventListener("abort", () => this.controller.abort())), we(this, Nn, "m", Gm).call(this), this._connected(null);
    const r = Md.fromReadableStream(e, this.controller);
    for await (const i of r)
      we(this, Nn, "m", Wm).call(this, i);
    if (r.controller.signal?.aborted)
      throw new cr();
    we(this, Nn, "m", Xm).call(this);
  }
  [(eo = /* @__PURE__ */ new WeakMap(), Pc = /* @__PURE__ */ new WeakMap(), Ef = /* @__PURE__ */ new WeakMap(), Rc = /* @__PURE__ */ new WeakMap(), Cc = /* @__PURE__ */ new WeakMap(), If = /* @__PURE__ */ new WeakMap(), Tc = /* @__PURE__ */ new WeakMap(), Sa = /* @__PURE__ */ new WeakMap(), $c = /* @__PURE__ */ new WeakMap(), Nf = /* @__PURE__ */ new WeakMap(), kf = /* @__PURE__ */ new WeakMap(), gu = /* @__PURE__ */ new WeakMap(), Ff = /* @__PURE__ */ new WeakMap(), Df = /* @__PURE__ */ new WeakMap(), Hm = /* @__PURE__ */ new WeakMap(), Nn = /* @__PURE__ */ new WeakSet(), Km = function() {
    if (this.receivedMessages.length === 0)
      throw new je("stream ended without producing a Message with role=assistant");
    return this.receivedMessages.at(-1);
  }, uv = function() {
    if (this.receivedMessages.length === 0)
      throw new je("stream ended without producing a Message with role=assistant");
    const n = this.receivedMessages.at(-1).content.filter((a) => a.type === "text").map((a) => a.text);
    if (n.length === 0)
      throw new je("stream ended without producing a content block with type=text");
    return n.join(" ");
  }, Gm = function() {
    this.ended || qt(this, eo, void 0, "f");
  }, Wm = function(n) {
    if (this.ended)
      return;
    const a = we(this, Nn, "m", cv).call(this, n);
    switch (this._emit("streamEvent", n, a), n.type) {
      case "content_block_delta": {
        const r = a.content.at(-1);
        switch (n.delta.type) {
          case "text_delta": {
            r.type === "text" && this._emit("text", n.delta.text, r.text || "");
            break;
          }
          case "citations_delta": {
            r.type === "text" && this._emit("citation", n.delta.citation, r.citations ?? []);
            break;
          }
          case "input_json_delta": {
            r.type === "tool_use" && r.input && this._emit("inputJson", n.delta.partial_json, r.input);
            break;
          }
          case "thinking_delta": {
            r.type === "thinking" && this._emit("thinking", n.delta.thinking, r.thinking);
            break;
          }
          case "signature_delta": {
            r.type === "thinking" && this._emit("signature", r.signature);
            break;
          }
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(a), this._addMessage(a, !0);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", a.content.at(-1));
        break;
      }
      case "message_start": {
        qt(this, eo, a, "f");
        break;
      }
    }
  }, Xm = function() {
    if (this.ended)
      throw new je("stream has ended, this shouldn't happen");
    const n = we(this, eo, "f");
    if (!n)
      throw new je("request ended without sending any chunks");
    return qt(this, eo, void 0, "f"), n;
  }, cv = function(n) {
    let a = we(this, eo, "f");
    if (n.type === "message_start") {
      if (a)
        throw new je(`Unexpected event order, got ${n.type} before receiving "message_stop"`);
      return n.message;
    }
    if (!a)
      throw new je(`Unexpected event order, got ${n.type} before "message_start"`);
    switch (n.type) {
      case "message_stop":
        return a;
      case "message_delta":
        return a.stop_reason = n.delta.stop_reason, a.stop_sequence = n.delta.stop_sequence, a.usage.output_tokens = n.usage.output_tokens, a;
      case "content_block_start":
        return a.content.push(n.content_block), a;
      case "content_block_delta": {
        const r = a.content.at(n.index);
        switch (n.delta.type) {
          case "text_delta": {
            r?.type === "text" && (r.text += n.delta.text);
            break;
          }
          case "citations_delta": {
            r?.type === "text" && (r.citations ?? (r.citations = []), r.citations.push(n.delta.citation));
            break;
          }
          case "input_json_delta": {
            if (r?.type === "tool_use") {
              let i = r[lv] || "";
              i += n.delta.partial_json, Object.defineProperty(r, lv, {
                value: i,
                enumerable: !1,
                writable: !0
              }), i && (r.input = yT(i));
            }
            break;
          }
          case "thinking_delta": {
            r?.type === "thinking" && (r.thinking += n.delta.thinking);
            break;
          }
          case "signature_delta": {
            r?.type === "thinking" && (r.signature = n.delta.signature);
            break;
          }
        }
        return a;
      }
      case "content_block_stop":
        return a;
    }
  }, Symbol.asyncIterator)]() {
    const e = [], n = [];
    let a = !1;
    return this.on("streamEvent", (r) => {
      const i = n.shift();
      i ? i.resolve(r) : e.push(r);
    }), this.on("end", () => {
      a = !0;
      for (const r of n)
        r.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), this.on("error", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : a ? { value: void 0, done: !0 } : new Promise((i, s) => n.push({ resolve: i, reject: s })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new Md(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
const dv = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025"
};
let kp = class extends wo {
  constructor() {
    super(...arguments), this.batches = new T_(this._client);
  }
  create(e, n) {
    const { betas: a, ...r } = e;
    return r.model in dv && console.warn(`The model '${r.model}' is deprecated and will reach end-of-life on ${dv[r.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`), this._client.post("/v1/messages?beta=true", {
      body: r,
      timeout: this._client._options.timeout ?? (r.stream ? 6e5 : this._client._calculateNonstreamingTimeout(r.max_tokens)),
      ...n,
      headers: {
        ...a?.toString() != null ? { "anthropic-beta": a?.toString() } : void 0,
        ...n?.headers
      },
      stream: e.stream ?? !1
    });
  }
  /**
   * Create a Message stream
   */
  stream(e, n) {
    return Kh.createMessage(this, e, n);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](/en/docs/build-with-claude/token-counting)
   */
  countTokens(e, n) {
    const { betas: a, ...r } = e;
    return this._client.post("/v1/messages/count_tokens?beta=true", {
      body: r,
      ...n,
      headers: {
        "anthropic-beta": [...a ?? [], "token-counting-2024-11-01"].toString(),
        ...n?.headers
      }
    });
  }
};
kp.Batches = T_;
kp.BetaMessageBatchesPage = $_;
class Wd extends wo {
  constructor() {
    super(...arguments), this.models = new R_(this._client), this.messages = new kp(this._client);
  }
}
Wd.Models = R_;
Wd.BetaModelInfosPage = C_;
Wd.Messages = kp;
let wT = class extends wo {
  create(e, n) {
    return this._client.post("/v1/complete", {
      body: e,
      timeout: this._client._options.timeout ?? 6e5,
      ...n,
      stream: e.stream ?? !1
    });
  }
};
class M_ extends wo {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  create(e, n) {
    return this._client.post("/v1/messages/batches", { body: e, ...n });
  }
  /**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  retrieve(e, n) {
    return this._client.get(`/v1/messages/batches/${e}`, n);
  }
  list(e = {}, n) {
    return oo(e) ? this.list({}, e) : this._client.getAPIList("/v1/messages/batches", A_, { query: e, ...n });
  }
  /**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they've finished processing. If you'd
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  delete(e, n) {
    return this._client.delete(`/v1/messages/batches/${e}`, n);
  }
  /**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  cancel(e, n) {
    return this._client.post(`/v1/messages/batches/${e}/cancel`, n);
  }
  /**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  async results(e, n) {
    const a = await this.retrieve(e);
    if (!a.results_url)
      throw new je(`No batch \`results_url\`; Has it finished processing? ${a.processing_status} - ${a.id}`);
    return this._client.get(a.results_url, {
      ...n,
      headers: {
        Accept: "application/binary",
        ...n?.headers
      },
      __binaryResponse: !0
    })._thenUnwrap((r, i) => Np.fromResponse(i.response, i.controller));
  }
}
class A_ extends Ip {
}
M_.MessageBatchesPage = A_;
var Jt = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, ve = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, kn, to, Mc, qf, Ac, Ec, Jf, Ic, Oa, Nc, Lf, Uf, _u, Bf, xf, Qm, fv, Ym, eb, tb, nb, hv;
const pv = "__json_buf";
class Hh {
  constructor() {
    kn.add(this), this.messages = [], this.receivedMessages = [], to.set(this, void 0), this.controller = new AbortController(), Mc.set(this, void 0), qf.set(this, () => {
    }), Ac.set(this, () => {
    }), Ec.set(this, void 0), Jf.set(this, () => {
    }), Ic.set(this, () => {
    }), Oa.set(this, {}), Nc.set(this, !1), Lf.set(this, !1), Uf.set(this, !1), _u.set(this, !1), Bf.set(this, void 0), xf.set(this, void 0), Ym.set(this, (e) => {
      if (Jt(this, Lf, !0, "f"), e instanceof Error && e.name === "AbortError" && (e = new cr()), e instanceof cr)
        return Jt(this, Uf, !0, "f"), this._emit("abort", e);
      if (e instanceof je)
        return this._emit("error", e);
      if (e instanceof Error) {
        const n = new je(e.message);
        return n.cause = e, this._emit("error", n);
      }
      return this._emit("error", new je(String(e)));
    }), Jt(this, Mc, new Promise((e, n) => {
      Jt(this, qf, e, "f"), Jt(this, Ac, n, "f");
    }), "f"), Jt(this, Ec, new Promise((e, n) => {
      Jt(this, Jf, e, "f"), Jt(this, Ic, n, "f");
    }), "f"), ve(this, Mc, "f").catch(() => {
    }), ve(this, Ec, "f").catch(() => {
    });
  }
  get response() {
    return ve(this, Bf, "f");
  }
  get request_id() {
    return ve(this, xf, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    const e = await ve(this, Mc, "f");
    if (!e)
      throw new Error("Could not resolve a `Response` object");
    return {
      data: this,
      response: e,
      request_id: e.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(e) {
    const n = new Hh();
    return n._run(() => n._fromReadableStream(e)), n;
  }
  static createMessage(e, n, a) {
    const r = new Hh();
    for (const i of n.messages)
      r._addMessageParam(i);
    return r._run(() => r._createMessage(e, { ...n, stream: !0 }, { ...a, headers: { ...a?.headers, "X-Stainless-Helper-Method": "stream" } })), r;
  }
  _run(e) {
    e().then(() => {
      this._emitFinal(), this._emit("end");
    }, ve(this, Ym, "f"));
  }
  _addMessageParam(e) {
    this.messages.push(e);
  }
  _addMessage(e, n = !0) {
    this.receivedMessages.push(e), n && this._emit("message", e);
  }
  async _createMessage(e, n, a) {
    const r = a?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), ve(this, kn, "m", eb).call(this);
    const { response: i, data: s } = await e.create({ ...n, stream: !0 }, { ...a, signal: this.controller.signal }).withResponse();
    this._connected(i);
    for await (const o of s)
      ve(this, kn, "m", tb).call(this, o);
    if (s.controller.signal?.aborted)
      throw new cr();
    ve(this, kn, "m", nb).call(this);
  }
  _connected(e) {
    this.ended || (Jt(this, Bf, e, "f"), Jt(this, xf, e?.headers.get("request-id"), "f"), ve(this, qf, "f").call(this, e), this._emit("connect"));
  }
  get ended() {
    return ve(this, Nc, "f");
  }
  get errored() {
    return ve(this, Lf, "f");
  }
  get aborted() {
    return ve(this, Uf, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(e, n) {
    return (ve(this, Oa, "f")[e] || (ve(this, Oa, "f")[e] = [])).push({ listener: n }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(e, n) {
    const a = ve(this, Oa, "f")[e];
    if (!a)
      return this;
    const r = a.findIndex((i) => i.listener === n);
    return r >= 0 && a.splice(r, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(e, n) {
    return (ve(this, Oa, "f")[e] || (ve(this, Oa, "f")[e] = [])).push({ listener: n, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(e) {
    return new Promise((n, a) => {
      Jt(this, _u, !0, "f"), e !== "error" && this.once("error", a), this.once(e, n);
    });
  }
  async done() {
    Jt(this, _u, !0, "f"), await ve(this, Ec, "f");
  }
  get currentMessage() {
    return ve(this, to, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalMessage() {
    return await this.done(), ve(this, kn, "m", Qm).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    return await this.done(), ve(this, kn, "m", fv).call(this);
  }
  _emit(e, ...n) {
    if (ve(this, Nc, "f"))
      return;
    e === "end" && (Jt(this, Nc, !0, "f"), ve(this, Jf, "f").call(this));
    const a = ve(this, Oa, "f")[e];
    if (a && (ve(this, Oa, "f")[e] = a.filter((r) => !r.once), a.forEach(({ listener: r }) => r(...n))), e === "abort") {
      const r = n[0];
      !ve(this, _u, "f") && !a?.length && Promise.reject(r), ve(this, Ac, "f").call(this, r), ve(this, Ic, "f").call(this, r), this._emit("end");
      return;
    }
    if (e === "error") {
      const r = n[0];
      !ve(this, _u, "f") && !a?.length && Promise.reject(r), ve(this, Ac, "f").call(this, r), ve(this, Ic, "f").call(this, r), this._emit("end");
    }
  }
  _emitFinal() {
    this.receivedMessages.at(-1) && this._emit("finalMessage", ve(this, kn, "m", Qm).call(this));
  }
  async _fromReadableStream(e, n) {
    const a = n?.signal;
    a && (a.aborted && this.controller.abort(), a.addEventListener("abort", () => this.controller.abort())), ve(this, kn, "m", eb).call(this), this._connected(null);
    const r = Md.fromReadableStream(e, this.controller);
    for await (const i of r)
      ve(this, kn, "m", tb).call(this, i);
    if (r.controller.signal?.aborted)
      throw new cr();
    ve(this, kn, "m", nb).call(this);
  }
  [(to = /* @__PURE__ */ new WeakMap(), Mc = /* @__PURE__ */ new WeakMap(), qf = /* @__PURE__ */ new WeakMap(), Ac = /* @__PURE__ */ new WeakMap(), Ec = /* @__PURE__ */ new WeakMap(), Jf = /* @__PURE__ */ new WeakMap(), Ic = /* @__PURE__ */ new WeakMap(), Oa = /* @__PURE__ */ new WeakMap(), Nc = /* @__PURE__ */ new WeakMap(), Lf = /* @__PURE__ */ new WeakMap(), Uf = /* @__PURE__ */ new WeakMap(), _u = /* @__PURE__ */ new WeakMap(), Bf = /* @__PURE__ */ new WeakMap(), xf = /* @__PURE__ */ new WeakMap(), Ym = /* @__PURE__ */ new WeakMap(), kn = /* @__PURE__ */ new WeakSet(), Qm = function() {
    if (this.receivedMessages.length === 0)
      throw new je("stream ended without producing a Message with role=assistant");
    return this.receivedMessages.at(-1);
  }, fv = function() {
    if (this.receivedMessages.length === 0)
      throw new je("stream ended without producing a Message with role=assistant");
    const n = this.receivedMessages.at(-1).content.filter((a) => a.type === "text").map((a) => a.text);
    if (n.length === 0)
      throw new je("stream ended without producing a content block with type=text");
    return n.join(" ");
  }, eb = function() {
    this.ended || Jt(this, to, void 0, "f");
  }, tb = function(n) {
    if (this.ended)
      return;
    const a = ve(this, kn, "m", hv).call(this, n);
    switch (this._emit("streamEvent", n, a), n.type) {
      case "content_block_delta": {
        const r = a.content.at(-1);
        switch (n.delta.type) {
          case "text_delta": {
            r.type === "text" && this._emit("text", n.delta.text, r.text || "");
            break;
          }
          case "citations_delta": {
            r.type === "text" && this._emit("citation", n.delta.citation, r.citations ?? []);
            break;
          }
          case "input_json_delta": {
            r.type === "tool_use" && r.input && this._emit("inputJson", n.delta.partial_json, r.input);
            break;
          }
          case "thinking_delta": {
            r.type === "thinking" && this._emit("thinking", n.delta.thinking, r.thinking);
            break;
          }
          case "signature_delta": {
            r.type === "thinking" && this._emit("signature", r.signature);
            break;
          }
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(a), this._addMessage(a, !0);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", a.content.at(-1));
        break;
      }
      case "message_start": {
        Jt(this, to, a, "f");
        break;
      }
    }
  }, nb = function() {
    if (this.ended)
      throw new je("stream has ended, this shouldn't happen");
    const n = ve(this, to, "f");
    if (!n)
      throw new je("request ended without sending any chunks");
    return Jt(this, to, void 0, "f"), n;
  }, hv = function(n) {
    let a = ve(this, to, "f");
    if (n.type === "message_start") {
      if (a)
        throw new je(`Unexpected event order, got ${n.type} before receiving "message_stop"`);
      return n.message;
    }
    if (!a)
      throw new je(`Unexpected event order, got ${n.type} before "message_start"`);
    switch (n.type) {
      case "message_stop":
        return a;
      case "message_delta":
        return a.stop_reason = n.delta.stop_reason, a.stop_sequence = n.delta.stop_sequence, a.usage.output_tokens = n.usage.output_tokens, a;
      case "content_block_start":
        return a.content.push(n.content_block), a;
      case "content_block_delta": {
        const r = a.content.at(n.index);
        switch (n.delta.type) {
          case "text_delta": {
            r?.type === "text" && (r.text += n.delta.text);
            break;
          }
          case "citations_delta": {
            r?.type === "text" && (r.citations ?? (r.citations = []), r.citations.push(n.delta.citation));
            break;
          }
          case "input_json_delta": {
            if (r?.type === "tool_use") {
              let i = r[pv] || "";
              i += n.delta.partial_json, Object.defineProperty(r, pv, {
                value: i,
                enumerable: !1,
                writable: !0
              }), i && (r.input = yT(i));
            }
            break;
          }
          case "thinking_delta": {
            r?.type === "thinking" && (r.thinking += n.delta.thinking);
            break;
          }
          case "signature_delta": {
            r?.type === "thinking" && (r.signature = n.delta.signature);
            break;
          }
        }
        return a;
      }
      case "content_block_stop":
        return a;
    }
  }, Symbol.asyncIterator)]() {
    const e = [], n = [];
    let a = !1;
    return this.on("streamEvent", (r) => {
      const i = n.shift();
      i ? i.resolve(r) : e.push(r);
    }), this.on("end", () => {
      a = !0;
      for (const r of n)
        r.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), this.on("error", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : a ? { value: void 0, done: !0 } : new Promise((i, s) => n.push({ resolve: i, reject: s })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new Md(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
class Fp extends wo {
  constructor() {
    super(...arguments), this.batches = new M_(this._client);
  }
  create(e, n) {
    return e.model in mv && console.warn(`The model '${e.model}' is deprecated and will reach end-of-life on ${mv[e.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`), this._client.post("/v1/messages", {
      body: e,
      timeout: this._client._options.timeout ?? (e.stream ? 6e5 : this._client._calculateNonstreamingTimeout(e.max_tokens)),
      ...n,
      stream: e.stream ?? !1
    });
  }
  /**
   * Create a Message stream
   */
  stream(e, n) {
    return Hh.createMessage(this, e, n);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](/en/docs/build-with-claude/token-counting)
   */
  countTokens(e, n) {
    return this._client.post("/v1/messages/count_tokens", { body: e, ...n });
  }
}
const mv = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025"
};
Fp.Batches = M_;
Fp.MessageBatchesPage = A_;
let E_ = class extends wo {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
  retrieve(e, n) {
    return this._client.get(`/v1/models/${e}`, n);
  }
  list(e = {}, n) {
    return oo(e) ? this.list({}, e) : this._client.getAPIList("/v1/models", I_, { query: e, ...n });
  }
};
class I_ extends Ip {
}
E_.ModelInfosPage = I_;
var vT;
class Xe extends jq {
  /**
   * API Client for interfacing with the Anthropic API.
   *
   * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
   * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
   * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL: e = Zm("ANTHROPIC_BASE_URL"), apiKey: n = Zm("ANTHROPIC_API_KEY") ?? null, authToken: a = Zm("ANTHROPIC_AUTH_TOKEN") ?? null, ...r } = {}) {
    const i = {
      apiKey: n,
      authToken: a,
      ...r,
      baseURL: e || "https://api.anthropic.com"
    };
    if (!i.dangerouslyAllowBrowser && Fq())
      throw new je(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new Anthropic({ apiKey, dangerouslyAllowBrowser: true });
`);
    super({
      baseURL: i.baseURL,
      timeout: i.timeout ?? 6e5,
      httpAgent: i.httpAgent,
      maxRetries: i.maxRetries,
      fetch: i.fetch
    }), this.completions = new wT(this), this.messages = new Fp(this), this.models = new E_(this), this.beta = new Wd(this), this._options = i, this.apiKey = n, this.authToken = a;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(e) {
    return {
      ...super.defaultHeaders(e),
      ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
      "anthropic-version": "2023-06-01",
      ...this._options.defaultHeaders
    };
  }
  validateHeaders(e, n) {
    if (!(this.apiKey && e["x-api-key"]) && n["x-api-key"] !== null && !(this.authToken && e.authorization) && n.authorization !== null)
      throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
  }
  authHeaders(e) {
    const n = this.apiKeyAuth(e), a = this.bearerAuth(e);
    return n != null && !Zh(n) ? n : a != null && !Zh(a) ? a : {};
  }
  apiKeyAuth(e) {
    return this.apiKey == null ? {} : { "X-Api-Key": this.apiKey };
  }
  bearerAuth(e) {
    return this.authToken == null ? {} : { Authorization: `Bearer ${this.authToken}` };
  }
}
vT = Xe;
Xe.Anthropic = vT;
Xe.HUMAN_PROMPT = `

Human:`;
Xe.AI_PROMPT = `

Assistant:`;
Xe.DEFAULT_TIMEOUT = 6e5;
Xe.AnthropicError = je;
Xe.APIError = $n;
Xe.APIConnectionError = Ap;
Xe.APIConnectionTimeoutError = aT;
Xe.APIUserAbortError = cr;
Xe.NotFoundError = uT;
Xe.ConflictError = cT;
Xe.RateLimitError = dT;
Xe.BadRequestError = iT;
Xe.AuthenticationError = sT;
Xe.InternalServerError = fT;
Xe.PermissionDeniedError = oT;
Xe.UnprocessableEntityError = lT;
Xe.toFile = gq;
Xe.fileFromPath = rT;
Xe.Completions = wT;
Xe.Messages = Fp;
Xe.Models = E_;
Xe.ModelInfosPage = I_;
Xe.Beta = Wd;
class bv extends VC {
  static lc_name() {
    return "AnthropicToolsOutputParser";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "anthropic", "output_parsers"]
    }), Object.defineProperty(this, "returnId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "keyName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnSingle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "zodSchema", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.keyName = e.keyName, this.returnSingle = e.returnSingle ?? this.returnSingle, this.zodSchema = e.zodSchema;
  }
  async _validateResult(e) {
    let n = e;
    if (typeof e == "string")
      try {
        n = JSON.parse(e);
      } catch (r) {
        throw new Vt(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(r.message)}`, e);
      }
    else
      n = e;
    if (this.zodSchema === void 0)
      return n;
    const a = await this.zodSchema.safeParseAsync(n);
    if (a.success)
      return a.data;
    throw new Vt(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(a.error.errors)}`, JSON.stringify(n, null, 2));
  }
  async parseResult(e) {
    const n = e.flatMap((i) => {
      const { message: s } = i;
      return Array.isArray(s.content) ? ST(s.content)[0] : [];
    });
    if (n[0] === void 0)
      throw new Error("No parseable tool calls provided to AnthropicToolsOutputParser.");
    const [a] = n;
    return await this._validateResult(a.args);
  }
}
function ST(t) {
  const e = [];
  for (const n of t)
    n.type === "tool_use" && e.push({
      name: n.name,
      args: n.input,
      id: n.id,
      type: "tool_call"
    });
  return e;
}
function Uq(t) {
  if (t)
    return t === "any" ? {
      type: "any"
    } : t === "auto" ? {
      type: "auto"
    } : typeof t == "string" ? {
      type: "tool",
      name: t
    } : t;
}
function gv(t) {
  const e = /^data:(image\/.+);base64,(.+)$/, n = t.match(e);
  if (n === null)
    throw new Error([
      "Anthropic only supports base64-encoded images currently.",
      "Example: data:image/png;base64,/9j/4AAQSk..."
    ].join(`

`));
  return {
    type: "base64",
    media_type: n[1] ?? "",
    data: n[2] ?? ""
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  };
}
function Bq(t) {
  const e = [];
  for (const n of t)
    if (n._getType() === "tool")
      if (typeof n.content == "string") {
        const a = e[e.length - 1];
        a?._getType() === "human" && Array.isArray(a.content) && "type" in a.content[0] && a.content[0].type === "tool_result" ? a.content.push({
          type: "tool_result",
          content: n.content,
          tool_use_id: n.tool_call_id
        }) : e.push(new _r({
          content: [
            {
              type: "tool_result",
              content: n.content,
              tool_use_id: n.tool_call_id
            }
          ]
        }));
      } else
        e.push(new _r({
          content: [
            {
              type: "tool_result",
              content: hg(n.content),
              tool_use_id: n.tool_call_id
            }
          ]
        }));
    else
      e.push(n);
  return e;
}
function _v(t) {
  if (t.id === void 0)
    throw new Error('Anthropic requires all tool calls to have an "id".');
  return {
    type: "tool_use",
    id: t.id,
    name: t.name,
    input: t.args
  };
}
function hg(t) {
  const e = ["tool_use", "tool_result", "input_json_delta"], n = ["text", "text_delta"];
  return typeof t == "string" ? t : t.map((r) => {
    const i = "cache_control" in r ? r.cache_control : void 0;
    if (r.type === "image_url") {
      let s;
      return typeof r.image_url == "string" ? s = gv(r.image_url) : s = gv(r.image_url.url), {
        type: "image",
        source: s,
        ...i ? { cache_control: i } : {}
      };
    } else {
      if (r.type === "document")
        return {
          ...r,
          ...i ? { cache_control: i } : {}
        };
      if (r.type === "thinking")
        return {
          type: "thinking",
          thinking: r.thinking,
          signature: r.signature,
          ...i ? { cache_control: i } : {}
        };
      if (r.type === "redacted_thinking")
        return {
          type: "redacted_thinking",
          data: r.data,
          ...i ? { cache_control: i } : {}
        };
      if (n.find((s) => s === r.type) && "text" in r)
        return {
          type: "text",
          text: r.text,
          ...i ? { cache_control: i } : {}
        };
      if (e.find((s) => s === r.type)) {
        const s = { ...r };
        if ("index" in s && delete s.index, s.type === "input_json_delta" && (s.type = "tool_use"), "input" in s)
          try {
            s.input = JSON.parse(s.input);
          } catch {
          }
        return {
          ...s,
          ...i ? { cache_control: i } : {}
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        };
      } else
        throw new Error("Unsupported message content format");
    }
  });
}
function yv(t) {
  const e = Bq(t);
  let n;
  e.length > 0 && e[0]._getType() === "system" && (n = t[0].content);
  const r = (n !== void 0 ? e.slice(1) : e).map((i) => {
    let s;
    if (i._getType() === "human")
      s = "user";
    else if (i._getType() === "ai")
      s = "assistant";
    else if (i._getType() === "tool")
      s = "user";
    else throw i._getType() === "system" ? new Error("System messages are only permitted as the first passed message.") : new Error(`Message type "${i._getType()}" is not supported.`);
    if (Vs(i) && i.tool_calls?.length) {
      if (typeof i.content == "string")
        return i.content === "" ? {
          role: s,
          content: i.tool_calls.map(_v)
        } : {
          role: s,
          content: [
            { type: "text", text: i.content },
            ...i.tool_calls.map(_v)
          ]
        };
      {
        const { content: o } = i;
        return !i.tool_calls.every((f) => o.find((u) => (u.type === "tool_use" || u.type === "input_json_delta") && u.id === f.id)) && console.warn('The "tool_calls" field on a message is only respected if content is a string.'), {
          role: s,
          content: hg(i.content)
        };
      }
    } else
      return {
        role: s,
        content: hg(i.content)
      };
  });
  return {
    messages: xq(r),
    system: n
  };
}
function xq(t) {
  if (!t || t.length <= 1)
    return t;
  const e = [];
  let n = t[0];
  const a = (i) => typeof i == "string" ? [
    {
      type: "text",
      text: i
    }
  ] : i, r = (i) => i.role !== "user" || typeof i.content == "string" ? !1 : Array.isArray(i.content) && i.content.every((s) => s.type === "tool_result");
  for (let i = 1; i < t.length; i += 1) {
    const s = t[i];
    r(n) && r(s) ? n = {
      ...n,
      content: [
        ...a(n.content),
        ...a(s.content)
      ]
    } : (e.push(n), n = s);
  }
  return e.push(n), e;
}
function Vq(t, e) {
  if (t.type === "message_start") {
    const { content: n, usage: a, ...r } = t.message, i = {};
    for (const [u, c] of Object.entries(r))
      c != null && (i[u] = c);
    const { input_tokens: s, output_tokens: o, ...l } = a ?? {}, f = {
      input_tokens: s,
      output_tokens: o,
      total_tokens: s + o,
      input_token_details: {
        cache_creation: l.cache_creation_input_tokens,
        cache_read: l.cache_read_input_tokens
      }
    };
    return {
      chunk: new Ze({
        content: e.coerceContentToString ? "" : [],
        additional_kwargs: i,
        usage_metadata: e.streamUsage ? f : void 0,
        response_metadata: {
          usage: {
            ...l
          }
        },
        id: t.message.id
      })
    };
  } else if (t.type === "message_delta") {
    const n = {
      input_tokens: 0,
      output_tokens: t.usage.output_tokens,
      total_tokens: t.usage.output_tokens,
      input_token_details: {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        cache_creation: t.usage.cache_creation_input_tokens,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        cache_read: t.usage.cache_read_input_tokens
      }
    };
    return {
      chunk: new Ze({
        content: e.coerceContentToString ? "" : [],
        additional_kwargs: { ...t.delta },
        usage_metadata: e.streamUsage ? n : void 0
      })
    };
  } else if (t.type === "content_block_start" && ["tool_use", "document"].includes(t.content_block.type)) {
    const n = t.content_block;
    let a;
    return n.type === "tool_use" ? a = [
      {
        id: n.id,
        index: t.index,
        name: n.name,
        args: ""
      }
    ] : a = [], {
      chunk: new Ze({
        content: e.coerceContentToString ? "" : [
          {
            index: t.index,
            ...t.content_block,
            input: ""
          }
        ],
        additional_kwargs: {},
        tool_call_chunks: a
      })
    };
  } else if (t.type === "content_block_delta" && [
    "text_delta",
    "citations_delta",
    "thinking_delta",
    "signature_delta"
  ].includes(t.delta.type)) {
    if (e.coerceContentToString && "text" in t.delta)
      return {
        chunk: new Ze({
          content: t.delta.text
        })
      };
    {
      const n = t.delta;
      return "citation" in n && (n.citations = [n.citation], delete n.citation), n.type === "thinking_delta" || n.type === "signature_delta" ? {
        chunk: new Ze({
          content: [{ index: t.index, ...n, type: "thinking" }]
        })
      } : {
        chunk: new Ze({
          content: [{ index: t.index, ...n, type: "text" }]
        })
      };
    }
  } else {
    if (t.type === "content_block_delta" && t.delta.type === "input_json_delta")
      return {
        chunk: new Ze({
          content: e.coerceContentToString ? "" : [
            {
              index: t.index,
              input: t.delta.partial_json,
              type: t.delta.type
            }
          ],
          additional_kwargs: {},
          tool_call_chunks: [
            {
              index: t.index,
              args: t.delta.partial_json
            }
          ]
        })
      };
    if (t.type === "content_block_start" && t.content_block.type === "text") {
      const n = t.content_block?.text;
      if (n !== void 0)
        return {
          chunk: new Ze({
            content: e.coerceContentToString ? n : [
              {
                index: t.index,
                ...t.content_block
              }
            ],
            additional_kwargs: {}
          })
        };
    } else {
      if (t.type === "content_block_start" && t.content_block.type === "redacted_thinking")
        return {
          chunk: new Ze({
            content: e.coerceContentToString ? "" : [{ index: t.index, ...t.content_block }]
          })
        };
      if (t.type === "content_block_start" && t.content_block.type === "thinking") {
        const n = t.content_block.thinking;
        return {
          chunk: new Ze({
            content: e.coerceContentToString ? n : [{ index: t.index, ...t.content_block }]
          })
        };
      }
    }
  }
  return null;
}
function zq(t, e) {
  const n = e.usage, a = n != null ? {
    input_tokens: n.input_tokens ?? 0,
    output_tokens: n.output_tokens ?? 0,
    total_tokens: (n.input_tokens ?? 0) + (n.output_tokens ?? 0),
    input_token_details: {
      cache_creation: n.cache_creation_input_tokens,
      cache_read: n.cache_read_input_tokens
    }
  } : void 0;
  if (t.length === 1 && t[0].type === "text")
    return [
      {
        text: t[0].text,
        message: new $t({
          content: t[0].text,
          additional_kwargs: e,
          usage_metadata: a,
          response_metadata: e,
          id: e.id
        })
      }
    ];
  {
    const r = ST(t);
    return [
      {
        text: "",
        message: new $t({
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          content: t,
          additional_kwargs: e,
          tool_calls: r,
          usage_metadata: a,
          response_metadata: e,
          id: e.id
        })
      }
    ];
  }
}
function Vf(t, e) {
  return t.lc_error_code = e, t.message = `${t.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${e}/
`, t;
}
function wv(t) {
  let e;
  return t.status === 400 && t.message.includes("tool") ? e = Vf(t, "INVALID_TOOL_RESULTS") : t.status === 401 ? e = Vf(t, "MODEL_AUTHENTICATION") : t.status === 404 ? e = Vf(t, "MODEL_NOT_FOUND") : t.status === 429 ? e = Vf(t, "MODEL_RATE_LIMIT") : e = t, e;
}
function Zq(t) {
  return !!(t.tools && t.tools.length > 0);
}
function Kq(t) {
  for (const e of t.messages ?? [])
    if (typeof e.content != "string") {
      for (const n of e.content ?? [])
        if (typeof n == "object" && n != null && n.type === "document" && typeof n.citations == "object" && n.citations.enabled)
          return !0;
    }
  return !1;
}
function Hq(t) {
  return !!(t.thinking && t.thinking.type === "enabled");
}
function Gq(t) {
  return "input_schema" in t;
}
function Wq(t) {
  if (typeof t.content == "string")
    return t.content;
  if (Array.isArray(t.content) && t.content.length >= 1 && "input" in t.content[0])
    return typeof t.content[0].input == "string" ? t.content[0].input : JSON.stringify(t.content[0].input);
  if (Array.isArray(t.content) && t.content.length >= 1 && "text" in t.content[0])
    return t.content[0].text;
}
class Xq extends Sn {
  static lc_name() {
    return "ChatAnthropic";
  }
  get lc_secrets() {
    return {
      anthropicApiKey: "ANTHROPIC_API_KEY",
      apiKey: "ANTHROPIC_API_KEY"
    };
  }
  get lc_aliases() {
    return {
      modelName: "model"
    };
  }
  constructor(e) {
    if (super(e ?? {}), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "anthropicApiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "topK", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -1
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -1
    }), Object.defineProperty(this, "maxTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 2048
    }), Object.defineProperty(this, "modelName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "claude-2.1"
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "claude-2.1"
    }), Object.defineProperty(this, "invocationKwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stopSequences", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "clientOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "thinking", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { type: "disabled" }
    }), Object.defineProperty(this, "batchClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streamingClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streamUsage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "createClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.anthropicApiKey = e?.apiKey ?? e?.anthropicApiKey ?? ft("ANTHROPIC_API_KEY"), !this.anthropicApiKey && !e?.createClient)
      throw new Error("Anthropic API key not found");
    this.clientOptions = e?.clientOptions ?? {}, this.apiKey = this.anthropicApiKey, this.apiUrl = e?.anthropicApiUrl, this.modelName = e?.model ?? e?.modelName ?? this.model, this.model = this.modelName, this.invocationKwargs = e?.invocationKwargs ?? {}, this.temperature = e?.temperature ?? this.temperature, this.topK = e?.topK ?? this.topK, this.topP = e?.topP ?? this.topP, this.maxTokens = e?.maxTokensToSample ?? e?.maxTokens ?? this.maxTokens, this.stopSequences = e?.stopSequences ?? this.stopSequences, this.streaming = e?.streaming ?? !1, this.streamUsage = e?.streamUsage ?? this.streamUsage, this.thinking = e?.thinking ?? this.thinking, this.createClient = e?.createClient ?? ((n) => new Xe(n));
  }
  getLsParams(e) {
    const n = this.invocationParams(e);
    return {
      ls_provider: "anthropic",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: n.temperature ?? void 0,
      ls_max_tokens: n.max_tokens ?? void 0,
      ls_stop: e.stop
    };
  }
  /**
   * Formats LangChain StructuredTools to AnthropicTools.
   *
   * @param {ChatAnthropicCallOptions["tools"]} tools The tools to format
   * @returns {AnthropicTool[] | undefined} The formatted tools, or undefined if none are passed.
   */
  formatStructuredToolToAnthropic(e) {
    if (!(!e || !e.length))
      return e.map((n) => {
        if (Gq(n))
          return n;
        if (fc(n))
          return {
            name: n.function.name,
            description: n.function.description,
            input_schema: n.function.parameters
          };
        if (v_(n))
          return {
            name: n.name,
            description: n.description,
            input_schema: Cn(n.schema)
          };
        throw new Error(`Unknown tool type passed to ChatAnthropic: ${JSON.stringify(n, null, 2)}`);
      });
  }
  bindTools(e, n) {
    return this.bind({
      tools: this.formatStructuredToolToAnthropic(e),
      ...n
    });
  }
  /**
   * Get the parameters used to invoke the model
   */
  invocationParams(e) {
    const n = Uq(e?.tool_choice);
    if (this.thinking.type === "enabled") {
      if (this.topK !== -1)
        throw new Error("topK is not supported when thinking is enabled");
      if (this.topP !== -1)
        throw new Error("topP is not supported when thinking is enabled");
      if (this.temperature !== 1)
        throw new Error("temperature is not supported when thinking is enabled");
      return {
        model: this.model,
        stop_sequences: e?.stop ?? this.stopSequences,
        stream: this.streaming,
        max_tokens: this.maxTokens,
        tools: this.formatStructuredToolToAnthropic(e?.tools),
        tool_choice: n,
        thinking: this.thinking,
        ...this.invocationKwargs
      };
    }
    return {
      model: this.model,
      temperature: this.temperature,
      top_k: this.topK,
      top_p: this.topP,
      stop_sequences: e?.stop ?? this.stopSequences,
      stream: this.streaming,
      max_tokens: this.maxTokens,
      tools: this.formatStructuredToolToAnthropic(e?.tools),
      tool_choice: n,
      thinking: this.thinking,
      ...this.invocationKwargs
    };
  }
  /** @ignore */
  _identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams()
    };
  }
  /**
   * Get the identifying parameters for the model
   */
  identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams()
    };
  }
  async *_streamResponseChunks(e, n, a) {
    const r = this.invocationParams(n), i = yv(e), s = {
      ...r,
      ...i,
      stream: !0
    }, o = !Zq(s) && !Kq(s) && !Hq(s), l = await this.createStreamWithRetry(s, {
      headers: n.headers
    });
    for await (const f of l) {
      if (n.signal?.aborted)
        throw l.controller.abort(), new Error("AbortError: User aborted the request.");
      const u = this.streamUsage ?? n.streamUsage, c = Vq(f, {
        streamUsage: u,
        coerceContentToString: o
      });
      if (!c)
        continue;
      const { chunk: h } = c, p = Wq(h), d = new Bt({
        message: new Ze({
          // Just yield chunk as it is and tool_use will be concat by BaseChatModel._generateUncached().
          content: h.content,
          additional_kwargs: h.additional_kwargs,
          tool_call_chunks: h.tool_call_chunks,
          usage_metadata: u ? h.usage_metadata : void 0,
          response_metadata: h.response_metadata,
          id: h.id
        }),
        text: p ?? ""
      });
      yield d, await a?.handleLLMNewToken(p ?? "", void 0, void 0, void 0, void 0, { chunk: d });
    }
  }
  /** @ignore */
  async _generateNonStreaming(e, n, a) {
    const r = await this.completionWithRetry({
      ...n,
      stream: !1,
      ...yv(e)
    }, a), { content: i, ...s } = r, o = zq(i, s), { role: l, type: f, ...u } = s;
    return { generations: o, llmOutput: u };
  }
  /** @ignore */
  async _generate(e, n, a) {
    if (this.stopSequences && n.stop)
      throw new Error('"stopSequence" parameter found in input and default params');
    const r = this.invocationParams(n);
    if (r.stream) {
      let i;
      const s = this._streamResponseChunks(e, n, a);
      for await (const o of s)
        i === void 0 ? i = o : i = i.concat(o);
      if (i === void 0)
        throw new Error("No chunks returned from Anthropic API.");
      return {
        generations: [
          {
            text: i.text,
            message: i.message
          }
        ]
      };
    } else
      return this._generateNonStreaming(e, r, {
        signal: n.signal,
        headers: n.headers
      });
  }
  /**
   * Creates a streaming request with retry.
   * @param request The parameters for creating a completion.
   * @param options
   * @returns A streaming request.
   */
  async createStreamWithRetry(e, n) {
    if (!this.streamingClient) {
      const r = this.apiUrl ? { baseURL: this.apiUrl } : void 0;
      this.streamingClient = this.createClient({
        dangerouslyAllowBrowser: !0,
        ...this.clientOptions,
        ...r,
        apiKey: this.apiKey,
        // Prefer LangChain built-in retries
        maxRetries: 0
      });
    }
    const a = async () => {
      try {
        return await this.streamingClient.messages.create({
          ...e,
          ...this.invocationKwargs,
          stream: !0
        }, n);
      } catch (r) {
        throw wv(r);
      }
    };
    return this.caller.call(a);
  }
  /** @ignore */
  async completionWithRetry(e, n) {
    if (!this.batchClient) {
      const r = this.apiUrl ? { baseURL: this.apiUrl } : void 0;
      this.batchClient = this.createClient({
        dangerouslyAllowBrowser: !0,
        ...this.clientOptions,
        ...r,
        apiKey: this.apiKey,
        maxRetries: 0
      });
    }
    const a = async () => {
      try {
        return await this.batchClient.messages.create({
          ...e,
          ...this.invocationKwargs
        }, n);
      } catch (r) {
        throw wv(r);
      }
    };
    return this.caller.callWithOptions({ signal: n.signal ?? void 0 }, a);
  }
  _llmType() {
    return "anthropic";
  }
  withStructuredOutput(e, n) {
    const a = e, r = n?.name, i = n?.method, s = n?.includeRaw;
    if (i === "jsonMode")
      throw new Error('Anthropic only supports "functionCalling" as a method.');
    let o = r ?? "extract", l, f;
    if (eu(a)) {
      const d = Cn(a);
      f = [
        {
          name: o,
          description: d.description ?? "A function available to call.",
          input_schema: d
        }
      ], l = new bv({
        returnSingle: !0,
        keyName: o,
        zodSchema: a
      });
    } else {
      let d;
      typeof a.name == "string" && typeof a.description == "string" && typeof a.input_schema == "object" && a.input_schema != null ? (d = a, o = a.name) : d = {
        name: o,
        description: a.description ?? "",
        input_schema: a
      }, f = [d], l = new bv({
        returnSingle: !0,
        keyName: o
      });
    }
    let u;
    if (this.thinking?.type === "enabled") {
      const d = "Anthropic structured output relies on forced tool calling, which is not supported when `thinking` is enabled. This method will raise OutputParserException if tool calls are not generated. Consider disabling `thinking` or adjust your prompt to ensure the tool is called.";
      console.warn(d), u = this.bind({
        tools: f
      });
      const m = (b) => {
        if (!b.tool_calls || b.tool_calls.length === 0)
          throw new Error(d);
        return b;
      };
      u = u.pipe(m);
    } else
      u = this.bind({
        tools: f,
        tool_choice: {
          type: "tool",
          name: o
        }
      });
    if (!s)
      return u.pipe(l).withConfig({
        runName: "ChatAnthropicStructuredOutput"
      });
    const c = Mt.assign({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parsed: (d, m) => l.invoke(d.raw, m)
    }), h = Mt.assign({
      parsed: () => null
    }), p = c.withFallbacks({
      fallbacks: [h]
    });
    return dt.from([
      {
        raw: u
      },
      p
    ]).withConfig({
      runName: "StructuredOutputRunnable"
    });
  }
}
class OZ extends Xq {
}
var tr = {}, rb = {}, zf = {}, vv;
function Ee() {
  if (vv) return zf;
  vv = 1, Object.defineProperty(zf, "__esModule", { value: !0 }), zf.pathToFunc = e;
  const t = Object.prototype.hasOwnProperty;
  function e(n, a) {
    const r = /\{([a-zA-Z0-9_]+?)\}/g;
    return function(s = {}) {
      return n.replace(r, function(o, l) {
        if (!t.call(s, l))
          throw new Error(`Parameter '${l}' is required`);
        const f = s[l];
        if (typeof f != "string" && typeof f != "number")
          throw new Error(`Parameter '${l}' must be a string or number`);
        return a?.charEncoding === "percent" ? encodeURIComponent(`${f}`) : `${f}`;
      });
    };
  }
  return zf;
}
var Sv;
function N_() {
  return Sv || (Sv = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SDK_METADATA = t.ServerList = t.ServerEu = void 0, t.serverURLFromOptions = n;
    const e = /* @__PURE__ */ Ee();
    t.ServerEu = "eu", t.ServerList = {
      [t.ServerEu]: "https://api.mistral.ai"
    };
    function n(a) {
      let r = a.serverURL;
      const i = {};
      if (!r) {
        const o = a.server ?? t.ServerEu;
        r = t.ServerList[o] || "";
      }
      const s = (0, e.pathToFunc)(r)(i);
      return new URL(s);
    }
    t.SDK_METADATA = {
      language: "typescript",
      openapiDocVersion: "0.0.2",
      sdkVersion: "1.5.2",
      genVersion: "2.548.6",
      userAgent: "speakeasy-sdk/typescript 1.5.2 2.548.6 0.0.2 @mistralai/mistralai"
    };
  }(rb)), rb;
}
var Zf = {}, Ov;
function OT() {
  if (Ov) return Zf;
  Ov = 1, Object.defineProperty(Zf, "__esModule", { value: !0 }), Zf.readableStreamToArrayBuffer = t;
  async function t(e) {
    const n = e.getReader(), a = [];
    let r = 0, i = !1;
    for (; !i; ) {
      const { value: l, done: f } = await n.read();
      f ? i = !0 : (a.push(l), r += l.length);
    }
    const s = new Uint8Array(r);
    let o = 0;
    for (const l of a)
      s.set(l, o), o += l.length;
    return s.buffer;
  }
  return Zf;
}
var kc = {}, ja = {}, Fc = {}, Kf = {}, Dc = {}, jv;
function Qq() {
  if (jv) return Dc;
  jv = 1, Object.defineProperty(Dc, "__esModule", { value: !0 }), Dc.CustomUserAgentHook = void 0;
  const t = /* @__PURE__ */ N_();
  class e {
    beforeRequest(a, r) {
      const s = `mistral-client-typescript/${t.SDK_METADATA.sdkVersion}`;
      return r.headers.set("user-agent", s), r.headers.get("user-agent") || r.headers.set("x-mistral-user-agent", s), r;
    }
  }
  return Dc.CustomUserAgentHook = e, Dc;
}
var qc = {}, Pv;
function Yq() {
  if (Pv) return qc;
  Pv = 1, Object.defineProperty(qc, "__esModule", { value: !0 }), qc.DeprecationWarningHook = void 0;
  const t = "x-model-deprecation-timestamp";
  class e {
    afterSuccess(a, r) {
      return r.headers.has(t) && r.clone().json().then((i) => {
        const s = i.model;
        console.warn(`WARNING: The model ${s} is deprecated and will be removed on ${r.headers.get(t)}. Please refer to https://docs.mistral.ai/getting-started/models/#api-versioning for more information.`);
      }), r;
    }
  }
  return qc.DeprecationWarningHook = e, qc;
}
var Rv;
function eJ() {
  if (Rv) return Kf;
  Rv = 1, Object.defineProperty(Kf, "__esModule", { value: !0 }), Kf.initHooks = n;
  const t = /* @__PURE__ */ Qq(), e = /* @__PURE__ */ Yq();
  function n(a) {
    const r = new t.CustomUserAgentHook();
    a.registerBeforeRequestHook(r);
    const i = new e.DeprecationWarningHook();
    a.registerAfterSuccessHook(i);
  }
  return Kf;
}
var Cv;
function tJ() {
  if (Cv) return Fc;
  Cv = 1, Object.defineProperty(Fc, "__esModule", { value: !0 }), Fc.SDKHooks = void 0;
  const t = /* @__PURE__ */ eJ();
  class e {
    constructor() {
      this.sdkInitHooks = [], this.beforeCreateRequestHooks = [], this.beforeRequestHooks = [], this.afterSuccessHooks = [], this.afterErrorHooks = [];
      const a = [];
      for (const r of a)
        "sdkInit" in r && this.registerSDKInitHook(r), "beforeCreateRequest" in r && this.registerBeforeCreateRequestHook(r), "beforeRequest" in r && this.registerBeforeRequestHook(r), "afterSuccess" in r && this.registerAfterSuccessHook(r), "afterError" in r && this.registerAfterErrorHook(r);
      (0, t.initHooks)(this);
    }
    registerSDKInitHook(a) {
      this.sdkInitHooks.push(a);
    }
    registerBeforeCreateRequestHook(a) {
      this.beforeCreateRequestHooks.push(a);
    }
    registerBeforeRequestHook(a) {
      this.beforeRequestHooks.push(a);
    }
    registerAfterSuccessHook(a) {
      this.afterSuccessHooks.push(a);
    }
    registerAfterErrorHook(a) {
      this.afterErrorHooks.push(a);
    }
    sdkInit(a) {
      return this.sdkInitHooks.reduce((r, i) => i.sdkInit(r), a);
    }
    beforeCreateRequest(a, r) {
      let i = r;
      for (const s of this.beforeCreateRequestHooks)
        i = s.beforeCreateRequest(a, i);
      return i;
    }
    async beforeRequest(a, r) {
      let i = r;
      for (const s of this.beforeRequestHooks)
        i = await s.beforeRequest(a, i);
      return i;
    }
    async afterSuccess(a, r) {
      let i = r;
      for (const s of this.afterSuccessHooks)
        i = await s.afterSuccess(a, i);
      return i;
    }
    async afterError(a, r, i) {
      let s = r, o = i;
      for (const l of this.afterErrorHooks) {
        const f = await l.afterError(a, s, o);
        s = f.response, o = f.error;
      }
      return { response: s, error: o };
    }
  }
  return Fc.SDKHooks = e, Fc;
}
var Ht = {}, Tv;
function jT() {
  if (Tv) return Ht;
  Tv = 1, Object.defineProperty(Ht, "__esModule", { value: !0 }), Ht.ConnectionError = Ht.RequestTimeoutError = Ht.RequestAbortedError = Ht.InvalidRequestError = Ht.UnexpectedClientError = Ht.HTTPClientError = void 0;
  class t extends Error {
    constructor(o, l) {
      let f = o;
      l?.cause && (f += `: ${l.cause}`), super(f, l), this.name = "HTTPClientError", typeof this.cause > "u" && (this.cause = l?.cause);
    }
  }
  Ht.HTTPClientError = t;
  class e extends t {
    constructor() {
      super(...arguments), this.name = "UnexpectedClientError";
    }
  }
  Ht.UnexpectedClientError = e;
  class n extends t {
    constructor() {
      super(...arguments), this.name = "InvalidRequestError";
    }
  }
  Ht.InvalidRequestError = n;
  class a extends t {
    constructor() {
      super(...arguments), this.name = "RequestAbortedError";
    }
  }
  Ht.RequestAbortedError = a;
  class r extends t {
    constructor() {
      super(...arguments), this.name = "RequestTimeoutError";
    }
  }
  Ht.RequestTimeoutError = r;
  class i extends t {
    constructor() {
      super(...arguments), this.name = "ConnectionError";
    }
  }
  return Ht.ConnectionError = i, Ht;
}
var $o = {}, $v;
function Zn() {
  if ($v) return $o;
  $v = 1, Object.defineProperty($o, "__esModule", { value: !0 }), $o.OK = t, $o.ERR = e, $o.unwrap = n, $o.unwrapAsync = a;
  function t(r) {
    return { ok: !0, value: r };
  }
  function e(r) {
    return { ok: !1, error: r };
  }
  function n(r) {
    if (!r.ok)
      throw r.error;
    return r.value;
  }
  async function a(r) {
    const i = await r;
    if (!i.ok)
      throw i.error;
    return i.value;
  }
  return $o;
}
var mt = {}, nr = {}, Mo = {}, rr = {}, Hf = {}, ab = {}, Mv;
function Dp() {
  return Mv || (Mv = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.getParsedType = t.ZodParsedType = t.objectUtil = t.util = void 0;
    var e;
    (function(r) {
      r.assertEqual = (l) => l;
      function i(l) {
      }
      r.assertIs = i;
      function s(l) {
        throw new Error();
      }
      r.assertNever = s, r.arrayToEnum = (l) => {
        const f = {};
        for (const u of l)
          f[u] = u;
        return f;
      }, r.getValidEnumValues = (l) => {
        const f = r.objectKeys(l).filter((c) => typeof l[l[c]] != "number"), u = {};
        for (const c of f)
          u[c] = l[c];
        return r.objectValues(u);
      }, r.objectValues = (l) => r.objectKeys(l).map(function(f) {
        return l[f];
      }), r.objectKeys = typeof Object.keys == "function" ? (l) => Object.keys(l) : (l) => {
        const f = [];
        for (const u in l)
          Object.prototype.hasOwnProperty.call(l, u) && f.push(u);
        return f;
      }, r.find = (l, f) => {
        for (const u of l)
          if (f(u))
            return u;
      }, r.isInteger = typeof Number.isInteger == "function" ? (l) => Number.isInteger(l) : (l) => typeof l == "number" && isFinite(l) && Math.floor(l) === l;
      function o(l, f = " | ") {
        return l.map((u) => typeof u == "string" ? `'${u}'` : u).join(f);
      }
      r.joinValues = o, r.jsonStringifyReplacer = (l, f) => typeof f == "bigint" ? f.toString() : f;
    })(e || (t.util = e = {}));
    var n;
    (function(r) {
      r.mergeShapes = (i, s) => ({
        ...i,
        ...s
        // second overwrites first
      });
    })(n || (t.objectUtil = n = {})), t.ZodParsedType = e.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    const a = (r) => {
      switch (typeof r) {
        case "undefined":
          return t.ZodParsedType.undefined;
        case "string":
          return t.ZodParsedType.string;
        case "number":
          return isNaN(r) ? t.ZodParsedType.nan : t.ZodParsedType.number;
        case "boolean":
          return t.ZodParsedType.boolean;
        case "function":
          return t.ZodParsedType.function;
        case "bigint":
          return t.ZodParsedType.bigint;
        case "symbol":
          return t.ZodParsedType.symbol;
        case "object":
          return Array.isArray(r) ? t.ZodParsedType.array : r === null ? t.ZodParsedType.null : r.then && typeof r.then == "function" && r.catch && typeof r.catch == "function" ? t.ZodParsedType.promise : typeof Map < "u" && r instanceof Map ? t.ZodParsedType.map : typeof Set < "u" && r instanceof Set ? t.ZodParsedType.set : typeof Date < "u" && r instanceof Date ? t.ZodParsedType.date : t.ZodParsedType.object;
        default:
          return t.ZodParsedType.unknown;
      }
    };
    t.getParsedType = a;
  }(ab)), ab;
}
var Pa = {}, Av;
function k_() {
  if (Av) return Pa;
  Av = 1, Object.defineProperty(Pa, "__esModule", { value: !0 }), Pa.ZodError = Pa.quotelessJson = Pa.ZodIssueCode = void 0;
  const t = /* @__PURE__ */ Dp();
  Pa.ZodIssueCode = t.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const e = (a) => JSON.stringify(a, null, 2).replace(/"([^"]+)":/g, "$1:");
  Pa.quotelessJson = e;
  let n = class PT extends Error {
    get errors() {
      return this.issues;
    }
    constructor(r) {
      super(), this.issues = [], this.addIssue = (s) => {
        this.issues = [...this.issues, s];
      }, this.addIssues = (s = []) => {
        this.issues = [...this.issues, ...s];
      };
      const i = new.target.prototype;
      Object.setPrototypeOf ? Object.setPrototypeOf(this, i) : this.__proto__ = i, this.name = "ZodError", this.issues = r;
    }
    format(r) {
      const i = r || function(l) {
        return l.message;
      }, s = { _errors: [] }, o = (l) => {
        for (const f of l.issues)
          if (f.code === "invalid_union")
            f.unionErrors.map(o);
          else if (f.code === "invalid_return_type")
            o(f.returnTypeError);
          else if (f.code === "invalid_arguments")
            o(f.argumentsError);
          else if (f.path.length === 0)
            s._errors.push(i(f));
          else {
            let u = s, c = 0;
            for (; c < f.path.length; ) {
              const h = f.path[c];
              c === f.path.length - 1 ? (u[h] = u[h] || { _errors: [] }, u[h]._errors.push(i(f))) : u[h] = u[h] || { _errors: [] }, u = u[h], c++;
            }
          }
      };
      return o(this), s;
    }
    static assert(r) {
      if (!(r instanceof PT))
        throw new Error(`Not a ZodError: ${r}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, t.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(r = (i) => i.message) {
      const i = {}, s = [];
      for (const o of this.issues)
        o.path.length > 0 ? (i[o.path[0]] = i[o.path[0]] || [], i[o.path[0]].push(r(o))) : s.push(r(o));
      return { formErrors: s, fieldErrors: i };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  return Pa.ZodError = n, n.create = (a) => new n(a), Pa;
}
var Ev;
function RT() {
  if (Ev) return Hf;
  Ev = 1, Object.defineProperty(Hf, "__esModule", { value: !0 });
  const t = /* @__PURE__ */ Dp(), e = /* @__PURE__ */ k_(), n = (a, r) => {
    let i;
    switch (a.code) {
      case e.ZodIssueCode.invalid_type:
        a.received === t.ZodParsedType.undefined ? i = "Required" : i = `Expected ${a.expected}, received ${a.received}`;
        break;
      case e.ZodIssueCode.invalid_literal:
        i = `Invalid literal value, expected ${JSON.stringify(a.expected, t.util.jsonStringifyReplacer)}`;
        break;
      case e.ZodIssueCode.unrecognized_keys:
        i = `Unrecognized key(s) in object: ${t.util.joinValues(a.keys, ", ")}`;
        break;
      case e.ZodIssueCode.invalid_union:
        i = "Invalid input";
        break;
      case e.ZodIssueCode.invalid_union_discriminator:
        i = `Invalid discriminator value. Expected ${t.util.joinValues(a.options)}`;
        break;
      case e.ZodIssueCode.invalid_enum_value:
        i = `Invalid enum value. Expected ${t.util.joinValues(a.options)}, received '${a.received}'`;
        break;
      case e.ZodIssueCode.invalid_arguments:
        i = "Invalid function arguments";
        break;
      case e.ZodIssueCode.invalid_return_type:
        i = "Invalid function return type";
        break;
      case e.ZodIssueCode.invalid_date:
        i = "Invalid date";
        break;
      case e.ZodIssueCode.invalid_string:
        typeof a.validation == "object" ? "includes" in a.validation ? (i = `Invalid input: must include "${a.validation.includes}"`, typeof a.validation.position == "number" && (i = `${i} at one or more positions greater than or equal to ${a.validation.position}`)) : "startsWith" in a.validation ? i = `Invalid input: must start with "${a.validation.startsWith}"` : "endsWith" in a.validation ? i = `Invalid input: must end with "${a.validation.endsWith}"` : t.util.assertNever(a.validation) : a.validation !== "regex" ? i = `Invalid ${a.validation}` : i = "Invalid";
        break;
      case e.ZodIssueCode.too_small:
        a.type === "array" ? i = `Array must contain ${a.exact ? "exactly" : a.inclusive ? "at least" : "more than"} ${a.minimum} element(s)` : a.type === "string" ? i = `String must contain ${a.exact ? "exactly" : a.inclusive ? "at least" : "over"} ${a.minimum} character(s)` : a.type === "number" ? i = `Number must be ${a.exact ? "exactly equal to " : a.inclusive ? "greater than or equal to " : "greater than "}${a.minimum}` : a.type === "date" ? i = `Date must be ${a.exact ? "exactly equal to " : a.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(a.minimum))}` : i = "Invalid input";
        break;
      case e.ZodIssueCode.too_big:
        a.type === "array" ? i = `Array must contain ${a.exact ? "exactly" : a.inclusive ? "at most" : "less than"} ${a.maximum} element(s)` : a.type === "string" ? i = `String must contain ${a.exact ? "exactly" : a.inclusive ? "at most" : "under"} ${a.maximum} character(s)` : a.type === "number" ? i = `Number must be ${a.exact ? "exactly" : a.inclusive ? "less than or equal to" : "less than"} ${a.maximum}` : a.type === "bigint" ? i = `BigInt must be ${a.exact ? "exactly" : a.inclusive ? "less than or equal to" : "less than"} ${a.maximum}` : a.type === "date" ? i = `Date must be ${a.exact ? "exactly" : a.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(a.maximum))}` : i = "Invalid input";
        break;
      case e.ZodIssueCode.custom:
        i = "Invalid input";
        break;
      case e.ZodIssueCode.invalid_intersection_types:
        i = "Intersection results could not be merged";
        break;
      case e.ZodIssueCode.not_multiple_of:
        i = `Number must be a multiple of ${a.multipleOf}`;
        break;
      case e.ZodIssueCode.not_finite:
        i = "Number must be finite";
        break;
      default:
        i = r.defaultError, t.util.assertNever(a);
    }
    return { message: i };
  };
  return Hf.default = n, Hf;
}
var Iv;
function F_() {
  if (Iv) return rr;
  Iv = 1;
  var t = rr && rr.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(rr, "__esModule", { value: !0 }), rr.getErrorMap = rr.setErrorMap = rr.defaultErrorMap = void 0;
  const e = t(/* @__PURE__ */ RT());
  rr.defaultErrorMap = e.default;
  let n = e.default;
  function a(i) {
    n = i;
  }
  rr.setErrorMap = a;
  function r() {
    return n;
  }
  return rr.getErrorMap = r, rr;
}
var Jc = {}, Nv;
function CT() {
  return Nv || (Nv = 1, function(t) {
    var e = Jc && Jc.__importDefault || function(p) {
      return p && p.__esModule ? p : { default: p };
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.isAsync = t.isValid = t.isDirty = t.isAborted = t.OK = t.DIRTY = t.INVALID = t.ParseStatus = t.addIssueToContext = t.EMPTY_PATH = t.makeIssue = void 0;
    const n = /* @__PURE__ */ F_(), a = e(/* @__PURE__ */ RT()), r = (p) => {
      const { data: d, path: m, errorMaps: b, issueData: g } = p, _ = [...m, ...g.path || []], P = {
        ...g,
        path: _
      };
      if (g.message !== void 0)
        return {
          ...g,
          path: _,
          message: g.message
        };
      let C = "";
      const R = b.filter((T) => !!T).slice().reverse();
      for (const T of R)
        C = T(P, { data: d, defaultError: C }).message;
      return {
        ...g,
        path: _,
        message: C
      };
    };
    t.makeIssue = r, t.EMPTY_PATH = [];
    function i(p, d) {
      const m = (0, n.getErrorMap)(), b = (0, t.makeIssue)({
        issueData: d,
        data: p.data,
        path: p.path,
        errorMaps: [
          p.common.contextualErrorMap,
          // contextual error map is first priority
          p.schemaErrorMap,
          // then schema-bound map if available
          m,
          // then global override map
          m === a.default ? void 0 : a.default
          // then global default map
        ].filter((g) => !!g)
      });
      p.common.issues.push(b);
    }
    t.addIssueToContext = i;
    class s {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        this.value === "valid" && (this.value = "dirty");
      }
      abort() {
        this.value !== "aborted" && (this.value = "aborted");
      }
      static mergeArray(d, m) {
        const b = [];
        for (const g of m) {
          if (g.status === "aborted")
            return t.INVALID;
          g.status === "dirty" && d.dirty(), b.push(g.value);
        }
        return { status: d.value, value: b };
      }
      static async mergeObjectAsync(d, m) {
        const b = [];
        for (const g of m) {
          const _ = await g.key, P = await g.value;
          b.push({
            key: _,
            value: P
          });
        }
        return s.mergeObjectSync(d, b);
      }
      static mergeObjectSync(d, m) {
        const b = {};
        for (const g of m) {
          const { key: _, value: P } = g;
          if (_.status === "aborted" || P.status === "aborted")
            return t.INVALID;
          _.status === "dirty" && d.dirty(), P.status === "dirty" && d.dirty(), _.value !== "__proto__" && (typeof P.value < "u" || g.alwaysSet) && (b[_.value] = P.value);
        }
        return { status: d.value, value: b };
      }
    }
    t.ParseStatus = s, t.INVALID = Object.freeze({
      status: "aborted"
    });
    const o = (p) => ({ status: "dirty", value: p });
    t.DIRTY = o;
    const l = (p) => ({ status: "valid", value: p });
    t.OK = l;
    const f = (p) => p.status === "aborted";
    t.isAborted = f;
    const u = (p) => p.status === "dirty";
    t.isDirty = u;
    const c = (p) => p.status === "valid";
    t.isValid = c;
    const h = (p) => typeof Promise < "u" && p instanceof Promise;
    t.isAsync = h;
  }(Jc)), Jc;
}
var ib = {}, kv;
function nJ() {
  return kv || (kv = 1, Object.defineProperty(ib, "__esModule", { value: !0 })), ib;
}
var x = {}, Lc = {}, Fv;
function rJ() {
  if (Fv) return Lc;
  Fv = 1, Object.defineProperty(Lc, "__esModule", { value: !0 }), Lc.errorUtil = void 0;
  var t;
  return function(e) {
    e.errToObj = (n) => typeof n == "string" ? { message: n } : n || {}, e.toString = (n) => typeof n == "string" ? n : n?.message;
  }(t || (Lc.errorUtil = t = {})), Lc;
}
var Dv;
function aJ() {
  if (Dv) return x;
  Dv = 1;
  var t = x && x.__classPrivateFieldGet || function(D, y, j, E) {
    if (j === "a" && !E) throw new TypeError("Private accessor was defined without a getter");
    if (typeof y == "function" ? D !== y || !E : !y.has(D)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return j === "m" ? E : j === "a" ? E.call(D) : E ? E.value : y.get(D);
  }, e = x && x.__classPrivateFieldSet || function(D, y, j, E, q) {
    if (E === "m") throw new TypeError("Private method is not writable");
    if (E === "a" && !q) throw new TypeError("Private accessor was defined without a setter");
    if (typeof y == "function" ? D !== y || !q : !y.has(D)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return E === "a" ? q.call(D, j) : q ? q.value = j : y.set(D, j), j;
  }, n, a;
  Object.defineProperty(x, "__esModule", { value: !0 }), x.boolean = x.bigint = x.array = x.any = x.coerce = x.ZodFirstPartyTypeKind = x.late = x.ZodSchema = x.Schema = x.custom = x.ZodReadonly = x.ZodPipeline = x.ZodBranded = x.BRAND = x.ZodNaN = x.ZodCatch = x.ZodDefault = x.ZodNullable = x.ZodOptional = x.ZodTransformer = x.ZodEffects = x.ZodPromise = x.ZodNativeEnum = x.ZodEnum = x.ZodLiteral = x.ZodLazy = x.ZodFunction = x.ZodSet = x.ZodMap = x.ZodRecord = x.ZodTuple = x.ZodIntersection = x.ZodDiscriminatedUnion = x.ZodUnion = x.ZodObject = x.ZodArray = x.ZodVoid = x.ZodNever = x.ZodUnknown = x.ZodAny = x.ZodNull = x.ZodUndefined = x.ZodSymbol = x.ZodDate = x.ZodBoolean = x.ZodBigInt = x.ZodNumber = x.ZodString = x.datetimeRegex = x.ZodType = void 0, x.NEVER = x.void = x.unknown = x.union = x.undefined = x.tuple = x.transformer = x.symbol = x.string = x.strictObject = x.set = x.record = x.promise = x.preprocess = x.pipeline = x.ostring = x.optional = x.onumber = x.oboolean = x.object = x.number = x.nullable = x.null = x.never = x.nativeEnum = x.nan = x.map = x.literal = x.lazy = x.intersection = x.instanceof = x.function = x.enum = x.effect = x.discriminatedUnion = x.date = void 0;
  const r = /* @__PURE__ */ F_(), i = /* @__PURE__ */ rJ(), s = /* @__PURE__ */ CT(), o = /* @__PURE__ */ Dp(), l = /* @__PURE__ */ k_();
  class f {
    constructor(y, j, E, q) {
      this._cachedPath = [], this.parent = y, this.data = j, this._path = E, this._key = q;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
  }
  const u = (D, y) => {
    if ((0, s.isValid)(y))
      return { success: !0, data: y.value };
    if (!D.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        const j = new l.ZodError(D.common.issues);
        return this._error = j, this._error;
      }
    };
  };
  function c(D) {
    if (!D)
      return {};
    const { errorMap: y, invalid_type_error: j, required_error: E, description: q } = D;
    if (y && (j || E))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return y ? { errorMap: y, description: q } : { errorMap: (Q, W) => {
      var re, ne;
      const { message: le } = D;
      return Q.code === "invalid_enum_value" ? { message: le ?? W.defaultError } : typeof W.data > "u" ? { message: (re = le ?? E) !== null && re !== void 0 ? re : W.defaultError } : Q.code !== "invalid_type" ? { message: W.defaultError } : { message: (ne = le ?? j) !== null && ne !== void 0 ? ne : W.defaultError };
    }, description: q };
  }
  class h {
    get description() {
      return this._def.description;
    }
    _getType(y) {
      return (0, o.getParsedType)(y.data);
    }
    _getOrReturnCtx(y, j) {
      return j || {
        common: y.parent.common,
        data: y.data,
        parsedType: (0, o.getParsedType)(y.data),
        schemaErrorMap: this._def.errorMap,
        path: y.path,
        parent: y.parent
      };
    }
    _processInputParams(y) {
      return {
        status: new s.ParseStatus(),
        ctx: {
          common: y.parent.common,
          data: y.data,
          parsedType: (0, o.getParsedType)(y.data),
          schemaErrorMap: this._def.errorMap,
          path: y.path,
          parent: y.parent
        }
      };
    }
    _parseSync(y) {
      const j = this._parse(y);
      if ((0, s.isAsync)(j))
        throw new Error("Synchronous parse encountered promise.");
      return j;
    }
    _parseAsync(y) {
      const j = this._parse(y);
      return Promise.resolve(j);
    }
    parse(y, j) {
      const E = this.safeParse(y, j);
      if (E.success)
        return E.data;
      throw E.error;
    }
    safeParse(y, j) {
      var E;
      const q = {
        common: {
          issues: [],
          async: (E = j?.async) !== null && E !== void 0 ? E : !1,
          contextualErrorMap: j?.errorMap
        },
        path: j?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: y,
        parsedType: (0, o.getParsedType)(y)
      }, J = this._parseSync({ data: y, path: q.path, parent: q });
      return u(q, J);
    }
    "~validate"(y) {
      var j, E;
      const q = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: y,
        parsedType: (0, o.getParsedType)(y)
      };
      if (!this["~standard"].async)
        try {
          const J = this._parseSync({ data: y, path: [], parent: q });
          return (0, s.isValid)(J) ? {
            value: J.value
          } : {
            issues: q.common.issues
          };
        } catch (J) {
          !((E = (j = J?.message) === null || j === void 0 ? void 0 : j.toLowerCase()) === null || E === void 0) && E.includes("encountered") && (this["~standard"].async = !0), q.common = {
            issues: [],
            async: !0
          };
        }
      return this._parseAsync({ data: y, path: [], parent: q }).then((J) => (0, s.isValid)(J) ? {
        value: J.value
      } : {
        issues: q.common.issues
      });
    }
    async parseAsync(y, j) {
      const E = await this.safeParseAsync(y, j);
      if (E.success)
        return E.data;
      throw E.error;
    }
    async safeParseAsync(y, j) {
      const E = {
        common: {
          issues: [],
          contextualErrorMap: j?.errorMap,
          async: !0
        },
        path: j?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: y,
        parsedType: (0, o.getParsedType)(y)
      }, q = this._parse({ data: y, path: E.path, parent: E }), J = await ((0, s.isAsync)(q) ? q : Promise.resolve(q));
      return u(E, J);
    }
    refine(y, j) {
      const E = (q) => typeof j == "string" || typeof j > "u" ? { message: j } : typeof j == "function" ? j(q) : j;
      return this._refinement((q, J) => {
        const Q = y(q), W = () => J.addIssue({
          code: l.ZodIssueCode.custom,
          ...E(q)
        });
        return typeof Promise < "u" && Q instanceof Promise ? Q.then((re) => re ? !0 : (W(), !1)) : Q ? !0 : (W(), !1);
      });
    }
    refinement(y, j) {
      return this._refinement((E, q) => y(E) ? !0 : (q.addIssue(typeof j == "function" ? j(E, q) : j), !1));
    }
    _refinement(y) {
      return new F({
        schema: this,
        typeName: fe.ZodEffects,
        effect: { type: "refinement", refinement: y }
      });
    }
    superRefine(y) {
      return this._refinement(y);
    }
    constructor(y) {
      this.spa = this.safeParseAsync, this._def = y, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (j) => this["~validate"](j)
      };
    }
    optional() {
      return U.create(this, this._def);
    }
    nullable() {
      return z.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return pn.create(this);
    }
    promise() {
      return S.create(this, this._def);
    }
    or(y) {
      return Hn.create([this, y], this._def);
    }
    and(y) {
      return jo.create(this, y, this._def);
    }
    transform(y) {
      return new F({
        ...c(this._def),
        schema: this,
        typeName: fe.ZodEffects,
        effect: { type: "transform", transform: y }
      });
    }
    default(y) {
      const j = typeof y == "function" ? y : () => y;
      return new G({
        ...c(this._def),
        innerType: this,
        defaultValue: j,
        typeName: fe.ZodDefault
      });
    }
    brand() {
      return new xe({
        typeName: fe.ZodBranded,
        type: this,
        ...c(this._def)
      });
    }
    catch(y) {
      const j = typeof y == "function" ? y : () => y;
      return new pe({
        ...c(this._def),
        innerType: this,
        catchValue: j,
        typeName: fe.ZodCatch
      });
    }
    describe(y) {
      const j = this.constructor;
      return new j({
        ...this._def,
        description: y
      });
    }
    pipe(y) {
      return Ve.create(this, y);
    }
    readonly() {
      return $e.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  x.ZodType = h, x.Schema = h, x.ZodSchema = h;
  const p = /^c[^\s-]{8,}$/i, d = /^[0-9a-z]+$/, m = /^[0-9A-HJKMNP-TV-Z]{26}$/i, b = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, g = /^[a-z0-9_-]{21}$/i, _ = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, P = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, C = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, R = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
  let T;
  const O = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, A = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, M = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, I = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, N = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, w = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, k = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", L = new RegExp(`^${k}$`);
  function B(D) {
    let y = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return D.precision ? y = `${y}\\.\\d{${D.precision}}` : D.precision == null && (y = `${y}(\\.\\d+)?`), y;
  }
  function V(D) {
    return new RegExp(`^${B(D)}$`);
  }
  function ce(D) {
    let y = `${k}T${B(D)}`;
    const j = [];
    return j.push(D.local ? "Z?" : "Z"), D.offset && j.push("([+-]\\d{2}:?\\d{2})"), y = `${y}(${j.join("|")})`, new RegExp(`^${y}$`);
  }
  x.datetimeRegex = ce;
  function ie(D, y) {
    return !!((y === "v4" || !y) && O.test(D) || (y === "v6" || !y) && M.test(D));
  }
  function ut(D, y) {
    if (!_.test(D))
      return !1;
    try {
      const [j] = D.split("."), E = j.replace(/-/g, "+").replace(/_/g, "/").padEnd(j.length + (4 - j.length % 4) % 4, "="), q = JSON.parse(atob(E));
      return !(typeof q != "object" || q === null || !q.typ || !q.alg || y && q.alg !== y);
    } catch {
      return !1;
    }
  }
  function ba(D, y) {
    return !!((y === "v4" || !y) && A.test(D) || (y === "v6" || !y) && I.test(D));
  }
  class Ft extends h {
    _parse(y) {
      if (this._def.coerce && (y.data = String(y.data)), this._getType(y) !== o.ZodParsedType.string) {
        const J = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(J, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.string,
          received: J.parsedType
        }), s.INVALID;
      }
      const E = new s.ParseStatus();
      let q;
      for (const J of this._def.checks)
        if (J.kind === "min")
          y.data.length < J.value && (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            code: l.ZodIssueCode.too_small,
            minimum: J.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: J.message
          }), E.dirty());
        else if (J.kind === "max")
          y.data.length > J.value && (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            code: l.ZodIssueCode.too_big,
            maximum: J.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: J.message
          }), E.dirty());
        else if (J.kind === "length") {
          const Q = y.data.length > J.value, W = y.data.length < J.value;
          (Q || W) && (q = this._getOrReturnCtx(y, q), Q ? (0, s.addIssueToContext)(q, {
            code: l.ZodIssueCode.too_big,
            maximum: J.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: J.message
          }) : W && (0, s.addIssueToContext)(q, {
            code: l.ZodIssueCode.too_small,
            minimum: J.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: J.message
          }), E.dirty());
        } else if (J.kind === "email")
          C.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "email",
            code: l.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "emoji")
          T || (T = new RegExp(R, "u")), T.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "emoji",
            code: l.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "uuid")
          b.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "uuid",
            code: l.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "nanoid")
          g.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "nanoid",
            code: l.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "cuid")
          p.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "cuid",
            code: l.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "cuid2")
          d.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "cuid2",
            code: l.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "ulid")
          m.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "ulid",
            code: l.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "url")
          try {
            new URL(y.data);
          } catch {
            q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
              validation: "url",
              code: l.ZodIssueCode.invalid_string,
              message: J.message
            }), E.dirty();
          }
        else J.kind === "regex" ? (J.regex.lastIndex = 0, J.regex.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "regex",
          code: l.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty())) : J.kind === "trim" ? y.data = y.data.trim() : J.kind === "includes" ? y.data.includes(J.value, J.position) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: l.ZodIssueCode.invalid_string,
          validation: { includes: J.value, position: J.position },
          message: J.message
        }), E.dirty()) : J.kind === "toLowerCase" ? y.data = y.data.toLowerCase() : J.kind === "toUpperCase" ? y.data = y.data.toUpperCase() : J.kind === "startsWith" ? y.data.startsWith(J.value) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: l.ZodIssueCode.invalid_string,
          validation: { startsWith: J.value },
          message: J.message
        }), E.dirty()) : J.kind === "endsWith" ? y.data.endsWith(J.value) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: l.ZodIssueCode.invalid_string,
          validation: { endsWith: J.value },
          message: J.message
        }), E.dirty()) : J.kind === "datetime" ? ce(J).test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: l.ZodIssueCode.invalid_string,
          validation: "datetime",
          message: J.message
        }), E.dirty()) : J.kind === "date" ? L.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: l.ZodIssueCode.invalid_string,
          validation: "date",
          message: J.message
        }), E.dirty()) : J.kind === "time" ? V(J).test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: l.ZodIssueCode.invalid_string,
          validation: "time",
          message: J.message
        }), E.dirty()) : J.kind === "duration" ? P.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "duration",
          code: l.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty()) : J.kind === "ip" ? ie(y.data, J.version) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "ip",
          code: l.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty()) : J.kind === "jwt" ? ut(y.data, J.alg) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "jwt",
          code: l.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty()) : J.kind === "cidr" ? ba(y.data, J.version) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "cidr",
          code: l.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty()) : J.kind === "base64" ? N.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "base64",
          code: l.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty()) : J.kind === "base64url" ? w.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "base64url",
          code: l.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty()) : o.util.assertNever(J);
      return { status: E.value, value: y.data };
    }
    _regex(y, j, E) {
      return this.refinement((q) => y.test(q), {
        validation: j,
        code: l.ZodIssueCode.invalid_string,
        ...i.errorUtil.errToObj(E)
      });
    }
    _addCheck(y) {
      return new Ft({
        ...this._def,
        checks: [...this._def.checks, y]
      });
    }
    email(y) {
      return this._addCheck({ kind: "email", ...i.errorUtil.errToObj(y) });
    }
    url(y) {
      return this._addCheck({ kind: "url", ...i.errorUtil.errToObj(y) });
    }
    emoji(y) {
      return this._addCheck({ kind: "emoji", ...i.errorUtil.errToObj(y) });
    }
    uuid(y) {
      return this._addCheck({ kind: "uuid", ...i.errorUtil.errToObj(y) });
    }
    nanoid(y) {
      return this._addCheck({ kind: "nanoid", ...i.errorUtil.errToObj(y) });
    }
    cuid(y) {
      return this._addCheck({ kind: "cuid", ...i.errorUtil.errToObj(y) });
    }
    cuid2(y) {
      return this._addCheck({ kind: "cuid2", ...i.errorUtil.errToObj(y) });
    }
    ulid(y) {
      return this._addCheck({ kind: "ulid", ...i.errorUtil.errToObj(y) });
    }
    base64(y) {
      return this._addCheck({ kind: "base64", ...i.errorUtil.errToObj(y) });
    }
    base64url(y) {
      return this._addCheck({
        kind: "base64url",
        ...i.errorUtil.errToObj(y)
      });
    }
    jwt(y) {
      return this._addCheck({ kind: "jwt", ...i.errorUtil.errToObj(y) });
    }
    ip(y) {
      return this._addCheck({ kind: "ip", ...i.errorUtil.errToObj(y) });
    }
    cidr(y) {
      return this._addCheck({ kind: "cidr", ...i.errorUtil.errToObj(y) });
    }
    datetime(y) {
      var j, E;
      return typeof y == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        local: !1,
        message: y
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof y?.precision > "u" ? null : y?.precision,
        offset: (j = y?.offset) !== null && j !== void 0 ? j : !1,
        local: (E = y?.local) !== null && E !== void 0 ? E : !1,
        ...i.errorUtil.errToObj(y?.message)
      });
    }
    date(y) {
      return this._addCheck({ kind: "date", message: y });
    }
    time(y) {
      return typeof y == "string" ? this._addCheck({
        kind: "time",
        precision: null,
        message: y
      }) : this._addCheck({
        kind: "time",
        precision: typeof y?.precision > "u" ? null : y?.precision,
        ...i.errorUtil.errToObj(y?.message)
      });
    }
    duration(y) {
      return this._addCheck({ kind: "duration", ...i.errorUtil.errToObj(y) });
    }
    regex(y, j) {
      return this._addCheck({
        kind: "regex",
        regex: y,
        ...i.errorUtil.errToObj(j)
      });
    }
    includes(y, j) {
      return this._addCheck({
        kind: "includes",
        value: y,
        position: j?.position,
        ...i.errorUtil.errToObj(j?.message)
      });
    }
    startsWith(y, j) {
      return this._addCheck({
        kind: "startsWith",
        value: y,
        ...i.errorUtil.errToObj(j)
      });
    }
    endsWith(y, j) {
      return this._addCheck({
        kind: "endsWith",
        value: y,
        ...i.errorUtil.errToObj(j)
      });
    }
    min(y, j) {
      return this._addCheck({
        kind: "min",
        value: y,
        ...i.errorUtil.errToObj(j)
      });
    }
    max(y, j) {
      return this._addCheck({
        kind: "max",
        value: y,
        ...i.errorUtil.errToObj(j)
      });
    }
    length(y, j) {
      return this._addCheck({
        kind: "length",
        value: y,
        ...i.errorUtil.errToObj(j)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(y) {
      return this.min(1, i.errorUtil.errToObj(y));
    }
    trim() {
      return new Ft({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new Ft({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new Ft({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((y) => y.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((y) => y.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((y) => y.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((y) => y.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((y) => y.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((y) => y.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((y) => y.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((y) => y.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((y) => y.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((y) => y.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((y) => y.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((y) => y.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((y) => y.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((y) => y.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((y) => y.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((y) => y.kind === "base64url");
    }
    get minLength() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "min" && (y === null || j.value > y) && (y = j.value);
      return y;
    }
    get maxLength() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "max" && (y === null || j.value < y) && (y = j.value);
      return y;
    }
  }
  x.ZodString = Ft, Ft.create = (D) => {
    var y;
    return new Ft({
      checks: [],
      typeName: fe.ZodString,
      coerce: (y = D?.coerce) !== null && y !== void 0 ? y : !1,
      ...c(D)
    });
  };
  function wc(D, y) {
    const j = (D.toString().split(".")[1] || "").length, E = (y.toString().split(".")[1] || "").length, q = j > E ? j : E, J = parseInt(D.toFixed(q).replace(".", "")), Q = parseInt(y.toFixed(q).replace(".", ""));
    return J % Q / Math.pow(10, q);
  }
  class At extends h {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(y) {
      if (this._def.coerce && (y.data = Number(y.data)), this._getType(y) !== o.ZodParsedType.number) {
        const J = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(J, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.number,
          received: J.parsedType
        }), s.INVALID;
      }
      let E;
      const q = new s.ParseStatus();
      for (const J of this._def.checks)
        J.kind === "int" ? o.util.isInteger(y.data) || (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: J.message
        }), q.dirty()) : J.kind === "min" ? (J.inclusive ? y.data < J.value : y.data <= J.value) && (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.too_small,
          minimum: J.value,
          type: "number",
          inclusive: J.inclusive,
          exact: !1,
          message: J.message
        }), q.dirty()) : J.kind === "max" ? (J.inclusive ? y.data > J.value : y.data >= J.value) && (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.too_big,
          maximum: J.value,
          type: "number",
          inclusive: J.inclusive,
          exact: !1,
          message: J.message
        }), q.dirty()) : J.kind === "multipleOf" ? wc(y.data, J.value) !== 0 && (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.not_multiple_of,
          multipleOf: J.value,
          message: J.message
        }), q.dirty()) : J.kind === "finite" ? Number.isFinite(y.data) || (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.not_finite,
          message: J.message
        }), q.dirty()) : o.util.assertNever(J);
      return { status: q.value, value: y.data };
    }
    gte(y, j) {
      return this.setLimit("min", y, !0, i.errorUtil.toString(j));
    }
    gt(y, j) {
      return this.setLimit("min", y, !1, i.errorUtil.toString(j));
    }
    lte(y, j) {
      return this.setLimit("max", y, !0, i.errorUtil.toString(j));
    }
    lt(y, j) {
      return this.setLimit("max", y, !1, i.errorUtil.toString(j));
    }
    setLimit(y, j, E, q) {
      return new At({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: y,
            value: j,
            inclusive: E,
            message: i.errorUtil.toString(q)
          }
        ]
      });
    }
    _addCheck(y) {
      return new At({
        ...this._def,
        checks: [...this._def.checks, y]
      });
    }
    int(y) {
      return this._addCheck({
        kind: "int",
        message: i.errorUtil.toString(y)
      });
    }
    positive(y) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: i.errorUtil.toString(y)
      });
    }
    negative(y) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: i.errorUtil.toString(y)
      });
    }
    nonpositive(y) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: i.errorUtil.toString(y)
      });
    }
    nonnegative(y) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: i.errorUtil.toString(y)
      });
    }
    multipleOf(y, j) {
      return this._addCheck({
        kind: "multipleOf",
        value: y,
        message: i.errorUtil.toString(j)
      });
    }
    finite(y) {
      return this._addCheck({
        kind: "finite",
        message: i.errorUtil.toString(y)
      });
    }
    safe(y) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: i.errorUtil.toString(y)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: i.errorUtil.toString(y)
      });
    }
    get minValue() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "min" && (y === null || j.value > y) && (y = j.value);
      return y;
    }
    get maxValue() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "max" && (y === null || j.value < y) && (y = j.value);
      return y;
    }
    get isInt() {
      return !!this._def.checks.find((y) => y.kind === "int" || y.kind === "multipleOf" && o.util.isInteger(y.value));
    }
    get isFinite() {
      let y = null, j = null;
      for (const E of this._def.checks) {
        if (E.kind === "finite" || E.kind === "int" || E.kind === "multipleOf")
          return !0;
        E.kind === "min" ? (j === null || E.value > j) && (j = E.value) : E.kind === "max" && (y === null || E.value < y) && (y = E.value);
      }
      return Number.isFinite(j) && Number.isFinite(y);
    }
  }
  x.ZodNumber = At, At.create = (D) => new At({
    checks: [],
    typeName: fe.ZodNumber,
    coerce: D?.coerce || !1,
    ...c(D)
  });
  class Je extends h {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(y) {
      if (this._def.coerce)
        try {
          y.data = BigInt(y.data);
        } catch {
          return this._getInvalidInput(y);
        }
      if (this._getType(y) !== o.ZodParsedType.bigint)
        return this._getInvalidInput(y);
      let E;
      const q = new s.ParseStatus();
      for (const J of this._def.checks)
        J.kind === "min" ? (J.inclusive ? y.data < J.value : y.data <= J.value) && (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.too_small,
          type: "bigint",
          minimum: J.value,
          inclusive: J.inclusive,
          message: J.message
        }), q.dirty()) : J.kind === "max" ? (J.inclusive ? y.data > J.value : y.data >= J.value) && (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.too_big,
          type: "bigint",
          maximum: J.value,
          inclusive: J.inclusive,
          message: J.message
        }), q.dirty()) : J.kind === "multipleOf" ? y.data % J.value !== BigInt(0) && (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.not_multiple_of,
          multipleOf: J.value,
          message: J.message
        }), q.dirty()) : o.util.assertNever(J);
      return { status: q.value, value: y.data };
    }
    _getInvalidInput(y) {
      const j = this._getOrReturnCtx(y);
      return (0, s.addIssueToContext)(j, {
        code: l.ZodIssueCode.invalid_type,
        expected: o.ZodParsedType.bigint,
        received: j.parsedType
      }), s.INVALID;
    }
    gte(y, j) {
      return this.setLimit("min", y, !0, i.errorUtil.toString(j));
    }
    gt(y, j) {
      return this.setLimit("min", y, !1, i.errorUtil.toString(j));
    }
    lte(y, j) {
      return this.setLimit("max", y, !0, i.errorUtil.toString(j));
    }
    lt(y, j) {
      return this.setLimit("max", y, !1, i.errorUtil.toString(j));
    }
    setLimit(y, j, E, q) {
      return new Je({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: y,
            value: j,
            inclusive: E,
            message: i.errorUtil.toString(q)
          }
        ]
      });
    }
    _addCheck(y) {
      return new Je({
        ...this._def,
        checks: [...this._def.checks, y]
      });
    }
    positive(y) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: i.errorUtil.toString(y)
      });
    }
    negative(y) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: i.errorUtil.toString(y)
      });
    }
    nonpositive(y) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: i.errorUtil.toString(y)
      });
    }
    nonnegative(y) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: i.errorUtil.toString(y)
      });
    }
    multipleOf(y, j) {
      return this._addCheck({
        kind: "multipleOf",
        value: y,
        message: i.errorUtil.toString(j)
      });
    }
    get minValue() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "min" && (y === null || j.value > y) && (y = j.value);
      return y;
    }
    get maxValue() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "max" && (y === null || j.value < y) && (y = j.value);
      return y;
    }
  }
  x.ZodBigInt = Je, Je.create = (D) => {
    var y;
    return new Je({
      checks: [],
      typeName: fe.ZodBigInt,
      coerce: (y = D?.coerce) !== null && y !== void 0 ? y : !1,
      ...c(D)
    });
  };
  class Le extends h {
    _parse(y) {
      if (this._def.coerce && (y.data = !!y.data), this._getType(y) !== o.ZodParsedType.boolean) {
        const E = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.boolean,
          received: E.parsedType
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
  }
  x.ZodBoolean = Le, Le.create = (D) => new Le({
    typeName: fe.ZodBoolean,
    coerce: D?.coerce || !1,
    ...c(D)
  });
  class Yt extends h {
    _parse(y) {
      if (this._def.coerce && (y.data = new Date(y.data)), this._getType(y) !== o.ZodParsedType.date) {
        const J = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(J, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.date,
          received: J.parsedType
        }), s.INVALID;
      }
      if (isNaN(y.data.getTime())) {
        const J = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(J, {
          code: l.ZodIssueCode.invalid_date
        }), s.INVALID;
      }
      const E = new s.ParseStatus();
      let q;
      for (const J of this._def.checks)
        J.kind === "min" ? y.data.getTime() < J.value && (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: l.ZodIssueCode.too_small,
          message: J.message,
          inclusive: !0,
          exact: !1,
          minimum: J.value,
          type: "date"
        }), E.dirty()) : J.kind === "max" ? y.data.getTime() > J.value && (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: l.ZodIssueCode.too_big,
          message: J.message,
          inclusive: !0,
          exact: !1,
          maximum: J.value,
          type: "date"
        }), E.dirty()) : o.util.assertNever(J);
      return {
        status: E.value,
        value: new Date(y.data.getTime())
      };
    }
    _addCheck(y) {
      return new Yt({
        ...this._def,
        checks: [...this._def.checks, y]
      });
    }
    min(y, j) {
      return this._addCheck({
        kind: "min",
        value: y.getTime(),
        message: i.errorUtil.toString(j)
      });
    }
    max(y, j) {
      return this._addCheck({
        kind: "max",
        value: y.getTime(),
        message: i.errorUtil.toString(j)
      });
    }
    get minDate() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "min" && (y === null || j.value > y) && (y = j.value);
      return y != null ? new Date(y) : null;
    }
    get maxDate() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "max" && (y === null || j.value < y) && (y = j.value);
      return y != null ? new Date(y) : null;
    }
  }
  x.ZodDate = Yt, Yt.create = (D) => new Yt({
    checks: [],
    coerce: D?.coerce || !1,
    typeName: fe.ZodDate,
    ...c(D)
  });
  class Qe extends h {
    _parse(y) {
      if (this._getType(y) !== o.ZodParsedType.symbol) {
        const E = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.symbol,
          received: E.parsedType
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
  }
  x.ZodSymbol = Qe, Qe.create = (D) => new Qe({
    typeName: fe.ZodSymbol,
    ...c(D)
  });
  class Dt extends h {
    _parse(y) {
      if (this._getType(y) !== o.ZodParsedType.undefined) {
        const E = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.undefined,
          received: E.parsedType
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
  }
  x.ZodUndefined = Dt, Dt.create = (D) => new Dt({
    typeName: fe.ZodUndefined,
    ...c(D)
  });
  class Kn extends h {
    _parse(y) {
      if (this._getType(y) !== o.ZodParsedType.null) {
        const E = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.null,
          received: E.parsedType
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
  }
  x.ZodNull = Kn, Kn.create = (D) => new Kn({
    typeName: fe.ZodNull,
    ...c(D)
  });
  class ga extends h {
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(y) {
      return (0, s.OK)(y.data);
    }
  }
  x.ZodAny = ga, ga.create = (D) => new ga({
    typeName: fe.ZodAny,
    ...c(D)
  });
  class en extends h {
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(y) {
      return (0, s.OK)(y.data);
    }
  }
  x.ZodUnknown = en, en.create = (D) => new en({
    typeName: fe.ZodUnknown,
    ...c(D)
  });
  class hn extends h {
    _parse(y) {
      const j = this._getOrReturnCtx(y);
      return (0, s.addIssueToContext)(j, {
        code: l.ZodIssueCode.invalid_type,
        expected: o.ZodParsedType.never,
        received: j.parsedType
      }), s.INVALID;
    }
  }
  x.ZodNever = hn, hn.create = (D) => new hn({
    typeName: fe.ZodNever,
    ...c(D)
  });
  class So extends h {
    _parse(y) {
      if (this._getType(y) !== o.ZodParsedType.undefined) {
        const E = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.void,
          received: E.parsedType
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
  }
  x.ZodVoid = So, So.create = (D) => new So({
    typeName: fe.ZodVoid,
    ...c(D)
  });
  class pn extends h {
    _parse(y) {
      const { ctx: j, status: E } = this._processInputParams(y), q = this._def;
      if (j.parsedType !== o.ZodParsedType.array)
        return (0, s.addIssueToContext)(j, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.array,
          received: j.parsedType
        }), s.INVALID;
      if (q.exactLength !== null) {
        const Q = j.data.length > q.exactLength.value, W = j.data.length < q.exactLength.value;
        (Q || W) && ((0, s.addIssueToContext)(j, {
          code: Q ? l.ZodIssueCode.too_big : l.ZodIssueCode.too_small,
          minimum: W ? q.exactLength.value : void 0,
          maximum: Q ? q.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: q.exactLength.message
        }), E.dirty());
      }
      if (q.minLength !== null && j.data.length < q.minLength.value && ((0, s.addIssueToContext)(j, {
        code: l.ZodIssueCode.too_small,
        minimum: q.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: q.minLength.message
      }), E.dirty()), q.maxLength !== null && j.data.length > q.maxLength.value && ((0, s.addIssueToContext)(j, {
        code: l.ZodIssueCode.too_big,
        maximum: q.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: q.maxLength.message
      }), E.dirty()), j.common.async)
        return Promise.all([...j.data].map((Q, W) => q.type._parseAsync(new f(j, Q, j.path, W)))).then((Q) => s.ParseStatus.mergeArray(E, Q));
      const J = [...j.data].map((Q, W) => q.type._parseSync(new f(j, Q, j.path, W)));
      return s.ParseStatus.mergeArray(E, J);
    }
    get element() {
      return this._def.type;
    }
    min(y, j) {
      return new pn({
        ...this._def,
        minLength: { value: y, message: i.errorUtil.toString(j) }
      });
    }
    max(y, j) {
      return new pn({
        ...this._def,
        maxLength: { value: y, message: i.errorUtil.toString(j) }
      });
    }
    length(y, j) {
      return new pn({
        ...this._def,
        exactLength: { value: y, message: i.errorUtil.toString(j) }
      });
    }
    nonempty(y) {
      return this.min(1, y);
    }
  }
  x.ZodArray = pn, pn.create = (D, y) => new pn({
    type: D,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: fe.ZodArray,
    ...c(y)
  });
  function _a(D) {
    if (D instanceof qe) {
      const y = {};
      for (const j in D.shape) {
        const E = D.shape[j];
        y[j] = U.create(_a(E));
      }
      return new qe({
        ...D._def,
        shape: () => y
      });
    } else return D instanceof pn ? new pn({
      ...D._def,
      type: _a(D.element)
    }) : D instanceof U ? U.create(_a(D.unwrap())) : D instanceof z ? z.create(_a(D.unwrap())) : D instanceof In ? In.create(D.items.map((y) => _a(y))) : D;
  }
  class qe extends h {
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const y = this._def.shape(), j = o.util.objectKeys(y);
      return this._cached = { shape: y, keys: j };
    }
    _parse(y) {
      if (this._getType(y) !== o.ZodParsedType.object) {
        const ne = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(ne, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.object,
          received: ne.parsedType
        }), s.INVALID;
      }
      const { status: E, ctx: q } = this._processInputParams(y), { shape: J, keys: Q } = this._getCached(), W = [];
      if (!(this._def.catchall instanceof hn && this._def.unknownKeys === "strip"))
        for (const ne in q.data)
          Q.includes(ne) || W.push(ne);
      const re = [];
      for (const ne of Q) {
        const le = J[ne], zt = q.data[ne];
        re.push({
          key: { status: "valid", value: ne },
          value: le._parse(new f(q, zt, q.path, ne)),
          alwaysSet: ne in q.data
        });
      }
      if (this._def.catchall instanceof hn) {
        const ne = this._def.unknownKeys;
        if (ne === "passthrough")
          for (const le of W)
            re.push({
              key: { status: "valid", value: le },
              value: { status: "valid", value: q.data[le] }
            });
        else if (ne === "strict")
          W.length > 0 && ((0, s.addIssueToContext)(q, {
            code: l.ZodIssueCode.unrecognized_keys,
            keys: W
          }), E.dirty());
        else if (ne !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        const ne = this._def.catchall;
        for (const le of W) {
          const zt = q.data[le];
          re.push({
            key: { status: "valid", value: le },
            value: ne._parse(
              new f(q, zt, q.path, le)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: le in q.data
          });
        }
      }
      return q.common.async ? Promise.resolve().then(async () => {
        const ne = [];
        for (const le of re) {
          const zt = await le.key, cf = await le.value;
          ne.push({
            key: zt,
            value: cf,
            alwaysSet: le.alwaysSet
          });
        }
        return ne;
      }).then((ne) => s.ParseStatus.mergeObjectSync(E, ne)) : s.ParseStatus.mergeObjectSync(E, re);
    }
    get shape() {
      return this._def.shape();
    }
    strict(y) {
      return new qe({
        ...this._def,
        unknownKeys: "strict",
        ...y !== void 0 ? {
          errorMap: (j, E) => {
            var q, J, Q, W;
            const re = (Q = (J = (q = this._def).errorMap) === null || J === void 0 ? void 0 : J.call(q, j, E).message) !== null && Q !== void 0 ? Q : E.defaultError;
            return j.code === "unrecognized_keys" ? {
              message: (W = i.errorUtil.errToObj(y).message) !== null && W !== void 0 ? W : re
            } : {
              message: re
            };
          }
        } : {}
      });
    }
    strip() {
      return new qe({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new qe({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(y) {
      return new qe({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...y
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(y) {
      return new qe({
        unknownKeys: y._def.unknownKeys,
        catchall: y._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...y._def.shape()
        }),
        typeName: fe.ZodObject
      });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(y, j) {
      return this.augment({ [y]: j });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(y) {
      return new qe({
        ...this._def,
        catchall: y
      });
    }
    pick(y) {
      const j = {};
      return o.util.objectKeys(y).forEach((E) => {
        y[E] && this.shape[E] && (j[E] = this.shape[E]);
      }), new qe({
        ...this._def,
        shape: () => j
      });
    }
    omit(y) {
      const j = {};
      return o.util.objectKeys(this.shape).forEach((E) => {
        y[E] || (j[E] = this.shape[E]);
      }), new qe({
        ...this._def,
        shape: () => j
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return _a(this);
    }
    partial(y) {
      const j = {};
      return o.util.objectKeys(this.shape).forEach((E) => {
        const q = this.shape[E];
        y && !y[E] ? j[E] = q : j[E] = q.optional();
      }), new qe({
        ...this._def,
        shape: () => j
      });
    }
    required(y) {
      const j = {};
      return o.util.objectKeys(this.shape).forEach((E) => {
        if (y && !y[E])
          j[E] = this.shape[E];
        else {
          let J = this.shape[E];
          for (; J instanceof U; )
            J = J._def.innerType;
          j[E] = J;
        }
      }), new qe({
        ...this._def,
        shape: () => j
      });
    }
    keyof() {
      return uf(o.util.objectKeys(this.shape));
    }
  }
  x.ZodObject = qe, qe.create = (D, y) => new qe({
    shape: () => D,
    unknownKeys: "strip",
    catchall: hn.create(),
    typeName: fe.ZodObject,
    ...c(y)
  }), qe.strictCreate = (D, y) => new qe({
    shape: () => D,
    unknownKeys: "strict",
    catchall: hn.create(),
    typeName: fe.ZodObject,
    ...c(y)
  }), qe.lazycreate = (D, y) => new qe({
    shape: D,
    unknownKeys: "strip",
    catchall: hn.create(),
    typeName: fe.ZodObject,
    ...c(y)
  });
  class Hn extends h {
    _parse(y) {
      const { ctx: j } = this._processInputParams(y), E = this._def.options;
      function q(J) {
        for (const W of J)
          if (W.result.status === "valid")
            return W.result;
        for (const W of J)
          if (W.result.status === "dirty")
            return j.common.issues.push(...W.ctx.common.issues), W.result;
        const Q = J.map((W) => new l.ZodError(W.ctx.common.issues));
        return (0, s.addIssueToContext)(j, {
          code: l.ZodIssueCode.invalid_union,
          unionErrors: Q
        }), s.INVALID;
      }
      if (j.common.async)
        return Promise.all(E.map(async (J) => {
          const Q = {
            ...j,
            common: {
              ...j.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await J._parseAsync({
              data: j.data,
              path: j.path,
              parent: Q
            }),
            ctx: Q
          };
        })).then(q);
      {
        let J;
        const Q = [];
        for (const re of E) {
          const ne = {
            ...j,
            common: {
              ...j.common,
              issues: []
            },
            parent: null
          }, le = re._parseSync({
            data: j.data,
            path: j.path,
            parent: ne
          });
          if (le.status === "valid")
            return le;
          le.status === "dirty" && !J && (J = { result: le, ctx: ne }), ne.common.issues.length && Q.push(ne.common.issues);
        }
        if (J)
          return j.common.issues.push(...J.ctx.common.issues), J.result;
        const W = Q.map((re) => new l.ZodError(re));
        return (0, s.addIssueToContext)(j, {
          code: l.ZodIssueCode.invalid_union,
          unionErrors: W
        }), s.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  x.ZodUnion = Hn, Hn.create = (D, y) => new Hn({
    options: D,
    typeName: fe.ZodUnion,
    ...c(y)
  });
  const Gn = (D) => D instanceof Po ? Gn(D.schema) : D instanceof F ? Gn(D.innerType()) : D instanceof tn ? [D.value] : D instanceof $ ? D.options : D instanceof v ? o.util.objectValues(D.enum) : D instanceof G ? Gn(D._def.innerType) : D instanceof Dt ? [void 0] : D instanceof Kn ? [null] : D instanceof U ? [void 0, ...Gn(D.unwrap())] : D instanceof z ? [null, ...Gn(D.unwrap())] : D instanceof xe || D instanceof $e ? Gn(D.unwrap()) : D instanceof pe ? Gn(D._def.innerType) : [];
  class lu extends h {
    _parse(y) {
      const { ctx: j } = this._processInputParams(y);
      if (j.parsedType !== o.ZodParsedType.object)
        return (0, s.addIssueToContext)(j, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.object,
          received: j.parsedType
        }), s.INVALID;
      const E = this.discriminator, q = j.data[E], J = this.optionsMap.get(q);
      return J ? j.common.async ? J._parseAsync({
        data: j.data,
        path: j.path,
        parent: j
      }) : J._parseSync({
        data: j.data,
        path: j.path,
        parent: j
      }) : ((0, s.addIssueToContext)(j, {
        code: l.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [E]
      }), s.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(y, j, E) {
      const q = /* @__PURE__ */ new Map();
      for (const J of j) {
        const Q = Gn(J.shape[y]);
        if (!Q.length)
          throw new Error(`A discriminator value for key \`${y}\` could not be extracted from all schema options`);
        for (const W of Q) {
          if (q.has(W))
            throw new Error(`Discriminator property ${String(y)} has duplicate value ${String(W)}`);
          q.set(W, J);
        }
      }
      return new lu({
        typeName: fe.ZodDiscriminatedUnion,
        discriminator: y,
        options: j,
        optionsMap: q,
        ...c(E)
      });
    }
  }
  x.ZodDiscriminatedUnion = lu;
  function Oo(D, y) {
    const j = (0, o.getParsedType)(D), E = (0, o.getParsedType)(y);
    if (D === y)
      return { valid: !0, data: D };
    if (j === o.ZodParsedType.object && E === o.ZodParsedType.object) {
      const q = o.util.objectKeys(y), J = o.util.objectKeys(D).filter((W) => q.indexOf(W) !== -1), Q = { ...D, ...y };
      for (const W of J) {
        const re = Oo(D[W], y[W]);
        if (!re.valid)
          return { valid: !1 };
        Q[W] = re.data;
      }
      return { valid: !0, data: Q };
    } else if (j === o.ZodParsedType.array && E === o.ZodParsedType.array) {
      if (D.length !== y.length)
        return { valid: !1 };
      const q = [];
      for (let J = 0; J < D.length; J++) {
        const Q = D[J], W = y[J], re = Oo(Q, W);
        if (!re.valid)
          return { valid: !1 };
        q.push(re.data);
      }
      return { valid: !0, data: q };
    } else return j === o.ZodParsedType.date && E === o.ZodParsedType.date && +D == +y ? { valid: !0, data: D } : { valid: !1 };
  }
  class jo extends h {
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y), q = (J, Q) => {
        if ((0, s.isAborted)(J) || (0, s.isAborted)(Q))
          return s.INVALID;
        const W = Oo(J.value, Q.value);
        return W.valid ? (((0, s.isDirty)(J) || (0, s.isDirty)(Q)) && j.dirty(), { status: j.value, value: W.data }) : ((0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.invalid_intersection_types
        }), s.INVALID);
      };
      return E.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: E.data,
          path: E.path,
          parent: E
        }),
        this._def.right._parseAsync({
          data: E.data,
          path: E.path,
          parent: E
        })
      ]).then(([J, Q]) => q(J, Q)) : q(this._def.left._parseSync({
        data: E.data,
        path: E.path,
        parent: E
      }), this._def.right._parseSync({
        data: E.data,
        path: E.path,
        parent: E
      }));
    }
  }
  x.ZodIntersection = jo, jo.create = (D, y, j) => new jo({
    left: D,
    right: y,
    typeName: fe.ZodIntersection,
    ...c(j)
  });
  class In extends h {
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y);
      if (E.parsedType !== o.ZodParsedType.array)
        return (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.array,
          received: E.parsedType
        }), s.INVALID;
      if (E.data.length < this._def.items.length)
        return (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), s.INVALID;
      !this._def.rest && E.data.length > this._def.items.length && ((0, s.addIssueToContext)(E, {
        code: l.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), j.dirty());
      const J = [...E.data].map((Q, W) => {
        const re = this._def.items[W] || this._def.rest;
        return re ? re._parse(new f(E, Q, E.path, W)) : null;
      }).filter((Q) => !!Q);
      return E.common.async ? Promise.all(J).then((Q) => s.ParseStatus.mergeArray(j, Q)) : s.ParseStatus.mergeArray(j, J);
    }
    get items() {
      return this._def.items;
    }
    rest(y) {
      return new In({
        ...this._def,
        rest: y
      });
    }
  }
  x.ZodTuple = In, In.create = (D, y) => {
    if (!Array.isArray(D))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new In({
      items: D,
      typeName: fe.ZodTuple,
      rest: null,
      ...c(y)
    });
  };
  class Hs extends h {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y);
      if (E.parsedType !== o.ZodParsedType.object)
        return (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.object,
          received: E.parsedType
        }), s.INVALID;
      const q = [], J = this._def.keyType, Q = this._def.valueType;
      for (const W in E.data)
        q.push({
          key: J._parse(new f(E, W, E.path, W)),
          value: Q._parse(new f(E, E.data[W], E.path, W)),
          alwaysSet: W in E.data
        });
      return E.common.async ? s.ParseStatus.mergeObjectAsync(j, q) : s.ParseStatus.mergeObjectSync(j, q);
    }
    get element() {
      return this._def.valueType;
    }
    static create(y, j, E) {
      return j instanceof h ? new Hs({
        keyType: y,
        valueType: j,
        typeName: fe.ZodRecord,
        ...c(E)
      }) : new Hs({
        keyType: Ft.create(),
        valueType: y,
        typeName: fe.ZodRecord,
        ...c(j)
      });
    }
  }
  x.ZodRecord = Hs;
  class ya extends h {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y);
      if (E.parsedType !== o.ZodParsedType.map)
        return (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.map,
          received: E.parsedType
        }), s.INVALID;
      const q = this._def.keyType, J = this._def.valueType, Q = [...E.data.entries()].map(([W, re], ne) => ({
        key: q._parse(new f(E, W, E.path, [ne, "key"])),
        value: J._parse(new f(E, re, E.path, [ne, "value"]))
      }));
      if (E.common.async) {
        const W = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const re of Q) {
            const ne = await re.key, le = await re.value;
            if (ne.status === "aborted" || le.status === "aborted")
              return s.INVALID;
            (ne.status === "dirty" || le.status === "dirty") && j.dirty(), W.set(ne.value, le.value);
          }
          return { status: j.value, value: W };
        });
      } else {
        const W = /* @__PURE__ */ new Map();
        for (const re of Q) {
          const ne = re.key, le = re.value;
          if (ne.status === "aborted" || le.status === "aborted")
            return s.INVALID;
          (ne.status === "dirty" || le.status === "dirty") && j.dirty(), W.set(ne.value, le.value);
        }
        return { status: j.value, value: W };
      }
    }
  }
  x.ZodMap = ya, ya.create = (D, y, j) => new ya({
    valueType: y,
    keyType: D,
    typeName: fe.ZodMap,
    ...c(j)
  });
  class St extends h {
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y);
      if (E.parsedType !== o.ZodParsedType.set)
        return (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.set,
          received: E.parsedType
        }), s.INVALID;
      const q = this._def;
      q.minSize !== null && E.data.size < q.minSize.value && ((0, s.addIssueToContext)(E, {
        code: l.ZodIssueCode.too_small,
        minimum: q.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: q.minSize.message
      }), j.dirty()), q.maxSize !== null && E.data.size > q.maxSize.value && ((0, s.addIssueToContext)(E, {
        code: l.ZodIssueCode.too_big,
        maximum: q.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: q.maxSize.message
      }), j.dirty());
      const J = this._def.valueType;
      function Q(re) {
        const ne = /* @__PURE__ */ new Set();
        for (const le of re) {
          if (le.status === "aborted")
            return s.INVALID;
          le.status === "dirty" && j.dirty(), ne.add(le.value);
        }
        return { status: j.value, value: ne };
      }
      const W = [...E.data.values()].map((re, ne) => J._parse(new f(E, re, E.path, ne)));
      return E.common.async ? Promise.all(W).then((re) => Q(re)) : Q(W);
    }
    min(y, j) {
      return new St({
        ...this._def,
        minSize: { value: y, message: i.errorUtil.toString(j) }
      });
    }
    max(y, j) {
      return new St({
        ...this._def,
        maxSize: { value: y, message: i.errorUtil.toString(j) }
      });
    }
    size(y, j) {
      return this.min(y, j).max(y, j);
    }
    nonempty(y) {
      return this.min(1, y);
    }
  }
  x.ZodSet = St, St.create = (D, y) => new St({
    valueType: D,
    minSize: null,
    maxSize: null,
    typeName: fe.ZodSet,
    ...c(y)
  });
  class vr extends h {
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(y) {
      const { ctx: j } = this._processInputParams(y);
      if (j.parsedType !== o.ZodParsedType.function)
        return (0, s.addIssueToContext)(j, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.function,
          received: j.parsedType
        }), s.INVALID;
      function E(W, re) {
        return (0, s.makeIssue)({
          data: W,
          path: j.path,
          errorMaps: [
            j.common.contextualErrorMap,
            j.schemaErrorMap,
            (0, r.getErrorMap)(),
            r.defaultErrorMap
          ].filter((ne) => !!ne),
          issueData: {
            code: l.ZodIssueCode.invalid_arguments,
            argumentsError: re
          }
        });
      }
      function q(W, re) {
        return (0, s.makeIssue)({
          data: W,
          path: j.path,
          errorMaps: [
            j.common.contextualErrorMap,
            j.schemaErrorMap,
            (0, r.getErrorMap)(),
            r.defaultErrorMap
          ].filter((ne) => !!ne),
          issueData: {
            code: l.ZodIssueCode.invalid_return_type,
            returnTypeError: re
          }
        });
      }
      const J = { errorMap: j.common.contextualErrorMap }, Q = j.data;
      if (this._def.returns instanceof S) {
        const W = this;
        return (0, s.OK)(async function(...re) {
          const ne = new l.ZodError([]), le = await W._def.args.parseAsync(re, J).catch((rm) => {
            throw ne.addIssue(E(re, rm)), ne;
          }), zt = await Reflect.apply(Q, this, le);
          return await W._def.returns._def.type.parseAsync(zt, J).catch((rm) => {
            throw ne.addIssue(q(zt, rm)), ne;
          });
        });
      } else {
        const W = this;
        return (0, s.OK)(function(...re) {
          const ne = W._def.args.safeParse(re, J);
          if (!ne.success)
            throw new l.ZodError([E(re, ne.error)]);
          const le = Reflect.apply(Q, this, ne.data), zt = W._def.returns.safeParse(le, J);
          if (!zt.success)
            throw new l.ZodError([q(le, zt.error)]);
          return zt.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...y) {
      return new vr({
        ...this._def,
        args: In.create(y).rest(en.create())
      });
    }
    returns(y) {
      return new vr({
        ...this._def,
        returns: y
      });
    }
    implement(y) {
      return this.parse(y);
    }
    strictImplement(y) {
      return this.parse(y);
    }
    static create(y, j, E) {
      return new vr({
        args: y || In.create([]).rest(en.create()),
        returns: j || en.create(),
        typeName: fe.ZodFunction,
        ...c(E)
      });
    }
  }
  x.ZodFunction = vr;
  class Po extends h {
    get schema() {
      return this._def.getter();
    }
    _parse(y) {
      const { ctx: j } = this._processInputParams(y);
      return this._def.getter()._parse({ data: j.data, path: j.path, parent: j });
    }
  }
  x.ZodLazy = Po, Po.create = (D, y) => new Po({
    getter: D,
    typeName: fe.ZodLazy,
    ...c(y)
  });
  class tn extends h {
    _parse(y) {
      if (y.data !== this._def.value) {
        const j = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(j, {
          received: j.data,
          code: l.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), s.INVALID;
      }
      return { status: "valid", value: y.data };
    }
    get value() {
      return this._def.value;
    }
  }
  x.ZodLiteral = tn, tn.create = (D, y) => new tn({
    value: D,
    typeName: fe.ZodLiteral,
    ...c(y)
  });
  function uf(D, y) {
    return new $({
      values: D,
      typeName: fe.ZodEnum,
      ...c(y)
    });
  }
  class $ extends h {
    constructor() {
      super(...arguments), n.set(this, void 0);
    }
    _parse(y) {
      if (typeof y.data != "string") {
        const j = this._getOrReturnCtx(y), E = this._def.values;
        return (0, s.addIssueToContext)(j, {
          expected: o.util.joinValues(E),
          received: j.parsedType,
          code: l.ZodIssueCode.invalid_type
        }), s.INVALID;
      }
      if (t(this, n, "f") || e(this, n, new Set(this._def.values), "f"), !t(this, n, "f").has(y.data)) {
        const j = this._getOrReturnCtx(y), E = this._def.values;
        return (0, s.addIssueToContext)(j, {
          received: j.data,
          code: l.ZodIssueCode.invalid_enum_value,
          options: E
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const y = {};
      for (const j of this._def.values)
        y[j] = j;
      return y;
    }
    get Values() {
      const y = {};
      for (const j of this._def.values)
        y[j] = j;
      return y;
    }
    get Enum() {
      const y = {};
      for (const j of this._def.values)
        y[j] = j;
      return y;
    }
    extract(y, j = this._def) {
      return $.create(y, {
        ...this._def,
        ...j
      });
    }
    exclude(y, j = this._def) {
      return $.create(this.options.filter((E) => !y.includes(E)), {
        ...this._def,
        ...j
      });
    }
  }
  x.ZodEnum = $, n = /* @__PURE__ */ new WeakMap(), $.create = uf;
  class v extends h {
    constructor() {
      super(...arguments), a.set(this, void 0);
    }
    _parse(y) {
      const j = o.util.getValidEnumValues(this._def.values), E = this._getOrReturnCtx(y);
      if (E.parsedType !== o.ZodParsedType.string && E.parsedType !== o.ZodParsedType.number) {
        const q = o.util.objectValues(j);
        return (0, s.addIssueToContext)(E, {
          expected: o.util.joinValues(q),
          received: E.parsedType,
          code: l.ZodIssueCode.invalid_type
        }), s.INVALID;
      }
      if (t(this, a, "f") || e(this, a, new Set(o.util.getValidEnumValues(this._def.values)), "f"), !t(this, a, "f").has(y.data)) {
        const q = o.util.objectValues(j);
        return (0, s.addIssueToContext)(E, {
          received: E.data,
          code: l.ZodIssueCode.invalid_enum_value,
          options: q
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  x.ZodNativeEnum = v, a = /* @__PURE__ */ new WeakMap(), v.create = (D, y) => new v({
    values: D,
    typeName: fe.ZodNativeEnum,
    ...c(y)
  });
  class S extends h {
    unwrap() {
      return this._def.type;
    }
    _parse(y) {
      const { ctx: j } = this._processInputParams(y);
      if (j.parsedType !== o.ZodParsedType.promise && j.common.async === !1)
        return (0, s.addIssueToContext)(j, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.promise,
          received: j.parsedType
        }), s.INVALID;
      const E = j.parsedType === o.ZodParsedType.promise ? j.data : Promise.resolve(j.data);
      return (0, s.OK)(E.then((q) => this._def.type.parseAsync(q, {
        path: j.path,
        errorMap: j.common.contextualErrorMap
      })));
    }
  }
  x.ZodPromise = S, S.create = (D, y) => new S({
    type: D,
    typeName: fe.ZodPromise,
    ...c(y)
  });
  class F extends h {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === fe.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y), q = this._def.effect || null, J = {
        addIssue: (Q) => {
          (0, s.addIssueToContext)(E, Q), Q.fatal ? j.abort() : j.dirty();
        },
        get path() {
          return E.path;
        }
      };
      if (J.addIssue = J.addIssue.bind(J), q.type === "preprocess") {
        const Q = q.transform(E.data, J);
        if (E.common.async)
          return Promise.resolve(Q).then(async (W) => {
            if (j.value === "aborted")
              return s.INVALID;
            const re = await this._def.schema._parseAsync({
              data: W,
              path: E.path,
              parent: E
            });
            return re.status === "aborted" ? s.INVALID : re.status === "dirty" || j.value === "dirty" ? (0, s.DIRTY)(re.value) : re;
          });
        {
          if (j.value === "aborted")
            return s.INVALID;
          const W = this._def.schema._parseSync({
            data: Q,
            path: E.path,
            parent: E
          });
          return W.status === "aborted" ? s.INVALID : W.status === "dirty" || j.value === "dirty" ? (0, s.DIRTY)(W.value) : W;
        }
      }
      if (q.type === "refinement") {
        const Q = (W) => {
          const re = q.refinement(W, J);
          if (E.common.async)
            return Promise.resolve(re);
          if (re instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return W;
        };
        if (E.common.async === !1) {
          const W = this._def.schema._parseSync({
            data: E.data,
            path: E.path,
            parent: E
          });
          return W.status === "aborted" ? s.INVALID : (W.status === "dirty" && j.dirty(), Q(W.value), { status: j.value, value: W.value });
        } else
          return this._def.schema._parseAsync({ data: E.data, path: E.path, parent: E }).then((W) => W.status === "aborted" ? s.INVALID : (W.status === "dirty" && j.dirty(), Q(W.value).then(() => ({ status: j.value, value: W.value }))));
      }
      if (q.type === "transform")
        if (E.common.async === !1) {
          const Q = this._def.schema._parseSync({
            data: E.data,
            path: E.path,
            parent: E
          });
          if (!(0, s.isValid)(Q))
            return Q;
          const W = q.transform(Q.value, J);
          if (W instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: j.value, value: W };
        } else
          return this._def.schema._parseAsync({ data: E.data, path: E.path, parent: E }).then((Q) => (0, s.isValid)(Q) ? Promise.resolve(q.transform(Q.value, J)).then((W) => ({ status: j.value, value: W })) : Q);
      o.util.assertNever(q);
    }
  }
  x.ZodEffects = F, x.ZodTransformer = F, F.create = (D, y, j) => new F({
    schema: D,
    typeName: fe.ZodEffects,
    effect: y,
    ...c(j)
  }), F.createWithPreprocess = (D, y, j) => new F({
    schema: y,
    effect: { type: "preprocess", transform: D },
    typeName: fe.ZodEffects,
    ...c(j)
  });
  class U extends h {
    _parse(y) {
      return this._getType(y) === o.ZodParsedType.undefined ? (0, s.OK)(void 0) : this._def.innerType._parse(y);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  x.ZodOptional = U, U.create = (D, y) => new U({
    innerType: D,
    typeName: fe.ZodOptional,
    ...c(y)
  });
  class z extends h {
    _parse(y) {
      return this._getType(y) === o.ZodParsedType.null ? (0, s.OK)(null) : this._def.innerType._parse(y);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  x.ZodNullable = z, z.create = (D, y) => new z({
    innerType: D,
    typeName: fe.ZodNullable,
    ...c(y)
  });
  class G extends h {
    _parse(y) {
      const { ctx: j } = this._processInputParams(y);
      let E = j.data;
      return j.parsedType === o.ZodParsedType.undefined && (E = this._def.defaultValue()), this._def.innerType._parse({
        data: E,
        path: j.path,
        parent: j
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  x.ZodDefault = G, G.create = (D, y) => new G({
    innerType: D,
    typeName: fe.ZodDefault,
    defaultValue: typeof y.default == "function" ? y.default : () => y.default,
    ...c(y)
  });
  class pe extends h {
    _parse(y) {
      const { ctx: j } = this._processInputParams(y), E = {
        ...j,
        common: {
          ...j.common,
          issues: []
        }
      }, q = this._def.innerType._parse({
        data: E.data,
        path: E.path,
        parent: {
          ...E
        }
      });
      return (0, s.isAsync)(q) ? q.then((J) => ({
        status: "valid",
        value: J.status === "valid" ? J.value : this._def.catchValue({
          get error() {
            return new l.ZodError(E.common.issues);
          },
          input: E.data
        })
      })) : {
        status: "valid",
        value: q.status === "valid" ? q.value : this._def.catchValue({
          get error() {
            return new l.ZodError(E.common.issues);
          },
          input: E.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  x.ZodCatch = pe, pe.create = (D, y) => new pe({
    innerType: D,
    typeName: fe.ZodCatch,
    catchValue: typeof y.catch == "function" ? y.catch : () => y.catch,
    ...c(y)
  });
  class He extends h {
    _parse(y) {
      if (this._getType(y) !== o.ZodParsedType.nan) {
        const E = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(E, {
          code: l.ZodIssueCode.invalid_type,
          expected: o.ZodParsedType.nan,
          received: E.parsedType
        }), s.INVALID;
      }
      return { status: "valid", value: y.data };
    }
  }
  x.ZodNaN = He, He.create = (D) => new He({
    typeName: fe.ZodNaN,
    ...c(D)
  }), x.BRAND = Symbol("zod_brand");
  class xe extends h {
    _parse(y) {
      const { ctx: j } = this._processInputParams(y), E = j.data;
      return this._def.type._parse({
        data: E,
        path: j.path,
        parent: j
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  x.ZodBranded = xe;
  class Ve extends h {
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y);
      if (E.common.async)
        return (async () => {
          const J = await this._def.in._parseAsync({
            data: E.data,
            path: E.path,
            parent: E
          });
          return J.status === "aborted" ? s.INVALID : J.status === "dirty" ? (j.dirty(), (0, s.DIRTY)(J.value)) : this._def.out._parseAsync({
            data: J.value,
            path: E.path,
            parent: E
          });
        })();
      {
        const q = this._def.in._parseSync({
          data: E.data,
          path: E.path,
          parent: E
        });
        return q.status === "aborted" ? s.INVALID : q.status === "dirty" ? (j.dirty(), {
          status: "dirty",
          value: q.value
        }) : this._def.out._parseSync({
          data: q.value,
          path: E.path,
          parent: E
        });
      }
    }
    static create(y, j) {
      return new Ve({
        in: y,
        out: j,
        typeName: fe.ZodPipeline
      });
    }
  }
  x.ZodPipeline = Ve;
  class $e extends h {
    _parse(y) {
      const j = this._def.innerType._parse(y), E = (q) => ((0, s.isValid)(q) && (q.value = Object.freeze(q.value)), q);
      return (0, s.isAsync)(j) ? j.then((q) => E(q)) : E(j);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  x.ZodReadonly = $e, $e.create = (D, y) => new $e({
    innerType: D,
    typeName: fe.ZodReadonly,
    ...c(y)
  });
  function Ry(D, y) {
    const j = typeof D == "function" ? D(y) : typeof D == "string" ? { message: D } : D;
    return typeof j == "string" ? { message: j } : j;
  }
  function Cy(D, y = {}, j) {
    return D ? ga.create().superRefine((E, q) => {
      var J, Q;
      const W = D(E);
      if (W instanceof Promise)
        return W.then((re) => {
          var ne, le;
          if (!re) {
            const zt = Ry(y, E), cf = (le = (ne = zt.fatal) !== null && ne !== void 0 ? ne : j) !== null && le !== void 0 ? le : !0;
            q.addIssue({ code: "custom", ...zt, fatal: cf });
          }
        });
      if (!W) {
        const re = Ry(y, E), ne = (Q = (J = re.fatal) !== null && J !== void 0 ? J : j) !== null && Q !== void 0 ? Q : !0;
        q.addIssue({ code: "custom", ...re, fatal: ne });
      }
    }) : ga.create();
  }
  x.custom = Cy, x.late = {
    object: qe.lazycreate
  };
  var fe;
  (function(D) {
    D.ZodString = "ZodString", D.ZodNumber = "ZodNumber", D.ZodNaN = "ZodNaN", D.ZodBigInt = "ZodBigInt", D.ZodBoolean = "ZodBoolean", D.ZodDate = "ZodDate", D.ZodSymbol = "ZodSymbol", D.ZodUndefined = "ZodUndefined", D.ZodNull = "ZodNull", D.ZodAny = "ZodAny", D.ZodUnknown = "ZodUnknown", D.ZodNever = "ZodNever", D.ZodVoid = "ZodVoid", D.ZodArray = "ZodArray", D.ZodObject = "ZodObject", D.ZodUnion = "ZodUnion", D.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", D.ZodIntersection = "ZodIntersection", D.ZodTuple = "ZodTuple", D.ZodRecord = "ZodRecord", D.ZodMap = "ZodMap", D.ZodSet = "ZodSet", D.ZodFunction = "ZodFunction", D.ZodLazy = "ZodLazy", D.ZodLiteral = "ZodLiteral", D.ZodEnum = "ZodEnum", D.ZodEffects = "ZodEffects", D.ZodNativeEnum = "ZodNativeEnum", D.ZodOptional = "ZodOptional", D.ZodNullable = "ZodNullable", D.ZodDefault = "ZodDefault", D.ZodCatch = "ZodCatch", D.ZodPromise = "ZodPromise", D.ZodBranded = "ZodBranded", D.ZodPipeline = "ZodPipeline", D.ZodReadonly = "ZodReadonly";
  })(fe || (x.ZodFirstPartyTypeKind = fe = {}));
  const pA = (D, y = {
    message: `Input not instance of ${D.name}`
  }) => Cy((j) => j instanceof D, y);
  x.instanceof = pA;
  const Ty = Ft.create;
  x.string = Ty;
  const $y = At.create;
  x.number = $y;
  const mA = He.create;
  x.nan = mA;
  const bA = Je.create;
  x.bigint = bA;
  const My = Le.create;
  x.boolean = My;
  const gA = Yt.create;
  x.date = gA;
  const _A = Qe.create;
  x.symbol = _A;
  const yA = Dt.create;
  x.undefined = yA;
  const wA = Kn.create;
  x.null = wA;
  const vA = ga.create;
  x.any = vA;
  const SA = en.create;
  x.unknown = SA;
  const OA = hn.create;
  x.never = OA;
  const jA = So.create;
  x.void = jA;
  const PA = pn.create;
  x.array = PA;
  const RA = qe.create;
  x.object = RA;
  const CA = qe.strictCreate;
  x.strictObject = CA;
  const TA = Hn.create;
  x.union = TA;
  const $A = lu.create;
  x.discriminatedUnion = $A;
  const MA = jo.create;
  x.intersection = MA;
  const AA = In.create;
  x.tuple = AA;
  const EA = Hs.create;
  x.record = EA;
  const IA = ya.create;
  x.map = IA;
  const NA = St.create;
  x.set = NA;
  const kA = vr.create;
  x.function = kA;
  const FA = Po.create;
  x.lazy = FA;
  const DA = tn.create;
  x.literal = DA;
  const qA = $.create;
  x.enum = qA;
  const JA = v.create;
  x.nativeEnum = JA;
  const LA = S.create;
  x.promise = LA;
  const Ay = F.create;
  x.effect = Ay, x.transformer = Ay;
  const UA = U.create;
  x.optional = UA;
  const BA = z.create;
  x.nullable = BA;
  const xA = F.createWithPreprocess;
  x.preprocess = xA;
  const VA = Ve.create;
  x.pipeline = VA;
  const zA = () => Ty().optional();
  x.ostring = zA;
  const ZA = () => $y().optional();
  x.onumber = ZA;
  const KA = () => My().optional();
  return x.oboolean = KA, x.coerce = {
    string: (D) => Ft.create({ ...D, coerce: !0 }),
    number: (D) => At.create({ ...D, coerce: !0 }),
    boolean: (D) => Le.create({
      ...D,
      coerce: !0
    }),
    bigint: (D) => Je.create({ ...D, coerce: !0 }),
    date: (D) => Yt.create({ ...D, coerce: !0 })
  }, x.NEVER = s.INVALID, x;
}
var qv;
function Jv() {
  return qv || (qv = 1, function(t) {
    var e = Mo && Mo.__createBinding || (Object.create ? function(a, r, i, s) {
      s === void 0 && (s = i);
      var o = Object.getOwnPropertyDescriptor(r, i);
      (!o || ("get" in o ? !r.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
        return r[i];
      } }), Object.defineProperty(a, s, o);
    } : function(a, r, i, s) {
      s === void 0 && (s = i), a[s] = r[i];
    }), n = Mo && Mo.__exportStar || function(a, r) {
      for (var i in a) i !== "default" && !Object.prototype.hasOwnProperty.call(r, i) && e(r, a, i);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(/* @__PURE__ */ F_(), t), n(/* @__PURE__ */ CT(), t), n(/* @__PURE__ */ nJ(), t), n(/* @__PURE__ */ Dp(), t), n(/* @__PURE__ */ aJ(), t), n(/* @__PURE__ */ k_(), t);
  }(Mo)), Mo;
}
var Lv;
function H() {
  return Lv || (Lv = 1, function(t) {
    var e = nr && nr.__createBinding || (Object.create ? function(s, o, l, f) {
      f === void 0 && (f = l);
      var u = Object.getOwnPropertyDescriptor(o, l);
      (!u || ("get" in u ? !o.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
        return o[l];
      } }), Object.defineProperty(s, f, u);
    } : function(s, o, l, f) {
      f === void 0 && (f = l), s[f] = o[l];
    }), n = nr && nr.__setModuleDefault || (Object.create ? function(s, o) {
      Object.defineProperty(s, "default", { enumerable: !0, value: o });
    } : function(s, o) {
      s.default = o;
    }), a = nr && nr.__importStar || function(s) {
      if (s && s.__esModule) return s;
      var o = {};
      if (s != null) for (var l in s) l !== "default" && Object.prototype.hasOwnProperty.call(s, l) && e(o, s, l);
      return n(o, s), o;
    }, r = nr && nr.__exportStar || function(s, o) {
      for (var l in s) l !== "default" && !Object.prototype.hasOwnProperty.call(o, l) && e(o, s, l);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.z = void 0;
    const i = a(/* @__PURE__ */ Jv());
    t.z = i, r(/* @__PURE__ */ Jv(), t), t.default = i;
  }(nr)), nr;
}
var Uv;
function TT() {
  if (Uv) return mt;
  Uv = 1;
  var t = mt && mt.__createBinding || (Object.create ? function(u, c, h, p) {
    p === void 0 && (p = h);
    var d = Object.getOwnPropertyDescriptor(c, h);
    (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return c[h];
    } }), Object.defineProperty(u, p, d);
  } : function(u, c, h, p) {
    p === void 0 && (p = h), u[p] = c[h];
  }), e = mt && mt.__setModuleDefault || (Object.create ? function(u, c) {
    Object.defineProperty(u, "default", { enumerable: !0, value: c });
  } : function(u, c) {
    u.default = c;
  }), n = mt && mt.__importStar || function(u) {
    if (u && u.__esModule) return u;
    var c = {};
    if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && t(c, u, h);
    return e(c, u), c;
  };
  Object.defineProperty(mt, "__esModule", { value: !0 }), mt.zodInbound = mt.zodOutbound = void 0, mt.bytesToBase64 = r, mt.bytesFromBase64 = i, mt.stringToBytes = s, mt.stringFromBytes = o, mt.stringToBase64 = l, mt.stringFromBase64 = f;
  const a = n(/* @__PURE__ */ H());
  function r(u) {
    return btoa(String.fromCodePoint(...u));
  }
  function i(u) {
    return Uint8Array.from(atob(u), (c) => c.charCodeAt(0));
  }
  function s(u) {
    return new TextEncoder().encode(u);
  }
  function o(u) {
    return new TextDecoder().decode(u);
  }
  function l(u) {
    return r(s(u));
  }
  function f(u) {
    return o(i(u));
  }
  return mt.zodOutbound = a.instanceof(Uint8Array).or(a.string().transform(s)), mt.zodInbound = a.instanceof(Uint8Array).or(a.string().transform(i)), mt;
}
var sb = {}, Gf = {}, Bv;
function $T() {
  if (Bv) return Gf;
  Bv = 1, Object.defineProperty(Gf, "__esModule", { value: !0 }), Gf.isPlainObject = t;
  function t(e) {
    if (typeof e != "object" || e === null)
      return !1;
    const n = Object.getPrototypeOf(e);
    return (n === null || n === Object.prototype || Object.getPrototypeOf(n) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
  }
  return Gf;
}
var xv;
function Ne() {
  return xv || (xv = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.encodeDeepObjectQuery = t.encodePipeDelimitedQuery = t.encodeSpaceDelimitedQuery = t.encodeFormQuery = t.encodeJSONQuery = t.encodeSimple = t.encodePipeDelimited = t.encodeSpaceDelimited = t.encodeForm = t.EncodingError = void 0, t.encodeMatrix = r, t.encodeLabel = i, t.encodeBodyForm = o, t.encodeDeepObject = l, t.encodeDeepObjectObject = f, t.encodeJSON = u, t.queryJoin = g, t.queryEncoder = _, t.appendForm = P;
    const e = /* @__PURE__ */ TT(), n = /* @__PURE__ */ $T();
    class a extends Error {
      constructor(R) {
        super(R), this.name = "EncodingError";
      }
    }
    t.EncodingError = a;
    function r(C, R, T) {
      let O = "";
      const A = T?.explode ? h(C, R) : [[C, R]];
      if (A.every(([N, w]) => w == null))
        return;
      const M = (N) => T?.charEncoding === "percent" ? encodeURIComponent(N) : N, I = (N) => M(p(N));
      return A.forEach(([N, w]) => {
        let k = "", L = null;
        if (w == null || (Array.isArray(w) ? L = m(w, (V) => `${I(V)}`)?.join(",") : (0, n.isPlainObject)(w) ? L = b(Object.entries(w), ([ce, ie]) => `,${M(ce)},${I(ie)}`)?.join("").slice(1) : L = `${I(w)}`, L == null))
          return;
        const B = M(N);
        k = `${B}=${L}`, k === `${B}=` && (k = k.slice(0, -1)), k && (O += `;${k}`);
      }), O;
    }
    function i(C, R, T) {
      let O = "";
      const A = T?.explode ? h(C, R) : [[C, R]];
      if (A.every(([N, w]) => w == null))
        return;
      const M = (N) => T?.charEncoding === "percent" ? encodeURIComponent(N) : N, I = (N) => M(p(N));
      return A.forEach(([N, w]) => {
        let k = "";
        w != null && (Array.isArray(w) ? k = m(w, (L) => `${I(L)}`)?.join(".") : (0, n.isPlainObject)(w) ? k = b(Object.entries(w), ([B, V]) => `.${M(B)}.${I(V)}`)?.join("").slice(1) : k = `${T?.explode && (0, n.isPlainObject)(R) ? `${M(N)}=` : ""}${I(w)}`, O += k == null ? "" : `.${k}`);
      }), O;
    }
    function s(C) {
      return (R, T, O) => {
        let A = "";
        const M = O?.explode ? h(R, T) : [[R, T]];
        if (M.every(([k, L]) => L == null))
          return;
        const I = (k) => O?.charEncoding === "percent" ? encodeURIComponent(k) : k, N = (k) => I(p(k)), w = I(C);
        return M.forEach(([k, L]) => {
          let B = "", V = null;
          L != null && (Array.isArray(L) ? V = m(L, (ce) => `${N(ce)}`)?.join(w) : (0, n.isPlainObject)(L) ? V = b(Object.entries(L), ([ce, ie]) => `${I(ce)}${w}${N(ie)}`)?.join(w) : V = `${N(L)}`, V != null && (B = `${I(k)}=${V}`, !(!B || B === "=") && (A += `&${B}`)));
        }), A.slice(1);
      };
    }
    t.encodeForm = s(","), t.encodeSpaceDelimited = s(" "), t.encodePipeDelimited = s("|");
    function o(C, R, T) {
      let O = "";
      const A = T?.explode ? h(C, R) : [[C, R]], M = (N) => T?.charEncoding === "percent" ? encodeURIComponent(N) : N, I = (N) => M(p(N));
      return A.forEach(([N, w]) => {
        let k = "", L = "";
        w != null && (Array.isArray(w) || (0, n.isPlainObject)(w) ? L = JSON.stringify(w, d) : L = `${I(w)}`, k = `${M(N)}=${L}`, !(!k || k === "=") && (O += `&${k}`));
      }), O.slice(1);
    }
    function l(C, R, T) {
      if (R != null) {
        if (!(0, n.isPlainObject)(R))
          throw new a(`Value of parameter '${C}' which uses deepObject encoding must be an object or null`);
        return f(C, R, T);
      }
    }
    function f(C, R, T) {
      if (R == null)
        return;
      let O = "";
      const A = (M) => T?.charEncoding === "percent" ? encodeURIComponent(M) : M;
      if (!(0, n.isPlainObject)(R))
        throw new a(`Expected parameter '${C}' to be an object.`);
      return Object.entries(R).forEach(([M, I]) => {
        if (I == null)
          return;
        const N = `${C}[${M}]`;
        if ((0, n.isPlainObject)(I)) {
          const L = f(N, I, T);
          O += L == null ? "" : `&${L}`;
          return;
        }
        const w = Array.isArray(I) ? I : [I], k = m(w, (L) => `${A(N)}=${A(p(L))}`)?.join("&");
        O += k == null ? "" : `&${k}`;
      }), O.slice(1);
    }
    function u(C, R, T) {
      if (typeof R > "u")
        return;
      const O = (M) => T?.charEncoding === "percent" ? encodeURIComponent(M) : M, A = O(JSON.stringify(R, d));
      return T?.explode ? A : `${O(C)}=${A}`;
    }
    const c = (C, R, T) => {
      let O = "";
      const A = T?.explode ? h(C, R) : [[C, R]];
      if (A.every(([N, w]) => w == null))
        return;
      const M = (N) => T?.charEncoding === "percent" ? encodeURIComponent(N) : N, I = (N) => M(p(N));
      return A.forEach(([N, w]) => {
        let k = "";
        w != null && (Array.isArray(w) ? k = m(w, (L) => `${I(L)}`)?.join(",") : (0, n.isPlainObject)(w) ? k = b(Object.entries(w), ([B, V]) => `,${M(B)},${I(V)}`)?.join("").slice(1) : k = `${T?.explode && (0, n.isPlainObject)(R) ? `${N}=` : ""}${I(w)}`, O += k ? `,${k}` : "");
      }), O.slice(1);
    };
    t.encodeSimple = c;
    function h(C, R) {
      return Array.isArray(R) ? R.map((T) => [C, T]) : (0, n.isPlainObject)(R) ? Object.entries(R ?? {}).map(([O, A]) => [O, A]) : [[C, R]];
    }
    function p(C) {
      return C == null ? "" : C instanceof Date ? C.toISOString() : C instanceof Uint8Array ? (0, e.bytesToBase64)(C) : typeof C == "object" ? JSON.stringify(C, d) : `${C}`;
    }
    function d(C, R) {
      return R instanceof Uint8Array ? (0, e.bytesToBase64)(R) : R;
    }
    function m(C, R) {
      const T = C.reduce((O, A) => {
        if (A == null)
          return O;
        const M = R(A);
        return M == null || O.push(M), O;
      }, []);
      return T.length ? T : null;
    }
    function b(C, R) {
      const T = [];
      for (const [O, A] of C) {
        if (A == null)
          continue;
        const M = R([O, A]);
        M != null && T.push(M);
      }
      return T.length ? T : null;
    }
    function g(...C) {
      return C.filter(Boolean).join("&");
    }
    function _(C) {
      return function(T, O) {
        const A = {
          ...O,
          explode: O?.explode ?? !0,
          charEncoding: O?.charEncoding ?? "percent"
        }, M = Object.entries(T).map(([I, N]) => C(I, N, A));
        return g(...M);
      };
    }
    t.encodeJSONQuery = _(u), t.encodeFormQuery = _(t.encodeForm), t.encodeSpaceDelimitedQuery = _(t.encodeSpaceDelimited), t.encodePipeDelimitedQuery = _(t.encodePipeDelimited), t.encodeDeepObjectQuery = _(l);
    function P(C, R, T, O) {
      T != null && (T instanceof Blob && O ? C.append(R, T, O) : T instanceof Blob ? C.append(R, T) : C.append(R, String(T)));
    }
  }(sb)), sb;
}
var Ra = {}, Wf = {}, Vv;
function iJ() {
  if (Vv) return Wf;
  Vv = 1, Object.defineProperty(Wf, "__esModule", { value: !0 }), Wf.dlv = t;
  function t(e, n, a, r, i) {
    for (n = Array.isArray(n) ? n : n.split("."), r = 0; r < n.length; r++) {
      const s = n[r];
      e = s != null && e ? e[s] : i;
    }
    return e === i ? a : e;
  }
  return Wf;
}
var zv;
function MT() {
  return zv || (zv = 1, function(t) {
    var e = Ra && Ra.__createBinding || (Object.create ? function(f, u, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(u, c);
      (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, u, c, h) {
      h === void 0 && (h = c), f[h] = u[c];
    }), n = Ra && Ra.__setModuleDefault || (Object.create ? function(f, u) {
      Object.defineProperty(f, "default", { enumerable: !0, value: u });
    } : function(f, u) {
      f.default = u;
    }), a = Ra && Ra.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var u = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(u, f, c);
      return n(u, f), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.envSchema = void 0, t.env = o, t.resetEnv = l;
    const r = /* @__PURE__ */ iJ(), i = a(/* @__PURE__ */ H());
    t.envSchema = i.object({
      MISTRAL_API_KEY: i.string().optional(),
      MISTRAL_DEBUG: i.coerce.boolean().optional()
    });
    let s;
    function o() {
      return s || (s = t.envSchema.parse((0, r.dlv)(globalThis, "process.env") ?? (0, r.dlv)(globalThis, "Deno.env") ?? {}), s);
    }
    function l() {
      s = void 0;
    }
  }(Ra)), Ra;
}
var ar = {}, Zv;
function qp() {
  if (Zv) return ar;
  Zv = 1, Object.defineProperty(ar, "__esModule", { value: !0 }), ar.HTTPClient = void 0, ar.matchContentType = a, ar.matchStatusCode = i, ar.matchResponse = s, ar.isConnectionError = o, ar.isTimeoutError = l, ar.isAbortError = f;
  const t = (u, c) => c == null ? fetch(u) : fetch(u, c);
  class e {
    constructor(c = {}) {
      this.options = c, this.requestHooks = [], this.requestErrorHooks = [], this.responseHooks = [], this.fetcher = c.fetcher || t;
    }
    async request(c) {
      let h = c;
      for (const p of this.requestHooks) {
        const d = await p(h);
        d && (h = d);
      }
      try {
        const p = await this.fetcher(h);
        for (const d of this.responseHooks)
          await d(p, h);
        return p;
      } catch (p) {
        for (const d of this.requestErrorHooks)
          await d(p, h);
        throw p;
      }
    }
    addHook(...c) {
      if (c[0] === "beforeRequest")
        this.requestHooks.push(c[1]);
      else if (c[0] === "requestError")
        this.requestErrorHooks.push(c[1]);
      else if (c[0] === "response")
        this.responseHooks.push(c[1]);
      else
        throw new Error(`Invalid hook type: ${c[0]}`);
      return this;
    }
    removeHook(...c) {
      let h;
      if (c[0] === "beforeRequest")
        h = this.requestHooks;
      else if (c[0] === "requestError")
        h = this.requestErrorHooks;
      else if (c[0] === "response")
        h = this.responseHooks;
      else
        throw new Error(`Invalid hook type: ${c[0]}`);
      const p = h.findIndex((d) => d === c[1]);
      return p >= 0 && h.splice(p, 1), this;
    }
    clone() {
      const c = new e(this.options);
      return c.requestHooks = this.requestHooks.slice(), c.requestErrorHooks = this.requestErrorHooks.slice(), c.responseHooks = this.responseHooks.slice(), c;
    }
  }
  ar.HTTPClient = e;
  const n = /\s*;\s*/g;
  function a(u, c) {
    if (c === "*")
      return !0;
    let h = u.headers.get("content-type")?.trim() || "application/octet-stream";
    h = h.toLowerCase();
    const p = c.toLowerCase().trim().split(n), [d = "", ...m] = p;
    if (d.split("/").length !== 2)
      return !1;
    const b = h.split(n), [g = "", ..._] = b, [P = "", C = ""] = g.split("/");
    if (!P || !C || d !== "*/*" && g !== d && `${P}/*` !== d && `*/${C}` !== d || _.length < m.length)
      return !1;
    const R = new Set(_);
    for (const T of m)
      if (!R.has(T))
        return !1;
    return !0;
  }
  const r = new RegExp("^[0-9]xx$", "i");
  function i(u, c) {
    const h = `${u.status}`, p = Array.isArray(c) ? c : [c];
    return p.length ? p.some((d) => {
      const m = `${d}`;
      if (m === "default")
        return !0;
      if (!r.test(`${m}`))
        return m === h;
      const b = m.charAt(0);
      if (!b)
        throw new Error("Invalid status code range");
      const g = h.charAt(0);
      if (!g)
        throw new Error(`Invalid response status code: ${h}`);
      return g === b;
    }) : !1;
  }
  function s(u, c, h) {
    return i(u, c) && a(u, h);
  }
  function o(u) {
    if (typeof u != "object" || u == null)
      return !1;
    const c = u instanceof TypeError && u.message.toLowerCase().startsWith("failed to fetch"), h = u instanceof TypeError && u.message.toLowerCase().startsWith("fetch failed"), p = "name" in u && u.name === "ConnectionError", d = "code" in u && typeof u.code == "string" && u.code.toLowerCase() === "econnreset";
    return c || h || d || p;
  }
  function l(u) {
    if (typeof u != "object" || u == null)
      return !1;
    const c = "name" in u && u.name === "TimeoutError", h = "code" in u && u.code === 23, p = "code" in u && typeof u.code == "string" && u.code.toLowerCase() === "econnaborted";
    return c || h || p;
  }
  function f(u) {
    if (typeof u != "object" || u == null)
      return !1;
    const c = "name" in u && u.name === "AbortError", h = "code" in u && u.code === 20, p = "code" in u && typeof u.code == "string" && u.code.toLowerCase() === "econnaborted";
    return c || h || p;
  }
  return ar;
}
var no = {}, Kv;
function sJ() {
  if (Kv) return no;
  Kv = 1, Object.defineProperty(no, "__esModule", { value: !0 }), no.TemporaryError = no.PermanentError = void 0, no.retry = r;
  const t = /* @__PURE__ */ qp(), e = {
    initialInterval: 500,
    maxInterval: 6e4,
    exponent: 1.5,
    maxElapsedTime: 36e5
  };
  class n extends Error {
    constructor(h, p) {
      let d = h;
      p?.cause && (d += `: ${p.cause}`), super(d, p), this.name = "PermanentError", typeof this.cause > "u" && (this.cause = p?.cause), Object.setPrototypeOf(this, n.prototype);
    }
  }
  no.PermanentError = n;
  class a extends Error {
    constructor(h, p) {
      super(h), this.response = p, this.name = "TemporaryError", Object.setPrototypeOf(this, a.prototype);
    }
  }
  no.TemporaryError = a;
  async function r(c, h) {
    switch (h.config.strategy) {
      case "backoff":
        return l(i(c, {
          statusCodes: h.statusCodes,
          retryConnectionErrors: !!h.config.retryConnectionErrors
        }), h.config.backoff ?? e);
      default:
        return await c();
    }
  }
  function i(c, h) {
    return async () => {
      try {
        const p = await c();
        if (o(p, h.statusCodes))
          throw new a("Response failed with retryable status code", p);
        return p;
      } catch (p) {
        throw p instanceof a || h.retryConnectionErrors && ((0, t.isTimeoutError)(p) || (0, t.isConnectionError)(p)) ? p : new n("Permanent error", { cause: p });
      }
    };
  }
  const s = new RegExp("^[0-9]xx$", "i");
  function o(c, h) {
    const p = `${c.status}`;
    return h.some((d) => {
      if (!s.test(d))
        return d === p;
      const m = d.charAt(0);
      if (!m)
        throw new Error("Invalid status code range");
      const b = p.charAt(0);
      if (!b)
        throw new Error(`Invalid response status code: ${p}`);
      return b === m;
    });
  }
  async function l(c, h) {
    const { maxElapsedTime: p, initialInterval: d, exponent: m, maxInterval: b } = h, g = Date.now();
    let _ = 0;
    for (; ; )
      try {
        return await c();
      } catch (P) {
        if (P instanceof n)
          throw P.cause;
        if (Date.now() - g > p) {
          if (P instanceof a)
            return P.response;
          throw P;
        }
        let R = 0;
        P instanceof a && (R = f(P.response)), R <= 0 && (R = d * Math.pow(_, m) + Math.random() * 1e3);
        const T = Math.min(R, b);
        await u(T), _++;
      }
  }
  function f(c) {
    const h = c.headers.get("retry-after") || "";
    if (!h)
      return 0;
    const p = Number(h);
    if (Number.isInteger(p))
      return p * 1e3;
    const d = Date.parse(h);
    if (Number.isInteger(d)) {
      const m = d - Date.now();
      return m > 0 ? Math.ceil(m) : 0;
    }
    return 0;
  }
  async function u(c) {
    return new Promise((h) => setTimeout(h, c));
  }
  return no;
}
var Hv;
function Mn() {
  if (Hv) return ja;
  Hv = 1;
  var t = ja && ja.__classPrivateFieldSet || function(R, T, O, A, M) {
    if (A === "m") throw new TypeError("Private method is not writable");
    if (A === "a" && !M) throw new TypeError("Private accessor was defined without a setter");
    if (typeof T == "function" ? R !== T || !M : !T.has(R)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return A === "a" ? M.call(R, O) : M ? M.value = O : T.set(R, O), O;
  }, e = ja && ja.__classPrivateFieldGet || function(R, T, O, A) {
    if (O === "a" && !A) throw new TypeError("Private accessor was defined without a getter");
    if (typeof T == "function" ? R !== T || !A : !T.has(R)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return O === "m" ? A : O === "a" ? A.call(R) : A ? A.value : T.get(R);
  }, n, a, r;
  Object.defineProperty(ja, "__esModule", { value: !0 }), ja.ClientSDK = void 0;
  const i = /* @__PURE__ */ tJ(), s = /* @__PURE__ */ jT(), o = /* @__PURE__ */ Zn(), l = /* @__PURE__ */ TT(), f = /* @__PURE__ */ N_(), u = /* @__PURE__ */ Ne(), c = /* @__PURE__ */ MT(), h = /* @__PURE__ */ qp(), p = /* @__PURE__ */ sJ(), d = typeof globalThis > "u" ? null : globalThis, b = typeof d == "object" && d != null && "importScripts" in d && typeof d.importScripts == "function" || typeof navigator < "u" && "serviceWorker" in navigator || typeof window == "object" && typeof window.document < "u";
  class g {
    constructor(T = {}) {
      n.set(this, void 0), a.set(this, void 0), r.set(this, void 0);
      const O = T;
      typeof O == "object" && O != null && "hooks" in O && O.hooks instanceof i.SDKHooks ? t(this, a, O.hooks, "f") : t(this, a, new i.SDKHooks(), "f"), this._options = { ...T, hooks: e(this, a, "f") };
      const A = (0, f.serverURLFromOptions)(T);
      A && (A.pathname = A.pathname.replace(/\/+$/, "") + "/");
      const { baseURL: M, client: I } = e(this, a, "f").sdkInit({
        baseURL: A,
        client: T.httpClient || new h.HTTPClient()
      });
      this._baseURL = M, t(this, n, I, "f"), t(this, r, T.debugLogger, "f"), !e(this, r, "f") && (0, c.env)().MISTRAL_DEBUG && t(this, r, console, "f");
    }
    _createRequest(T, O, A) {
      const { method: M, path: I, query: N, headers: w, security: k } = O, L = O.baseURL ?? this._baseURL;
      if (!L)
        return (0, o.ERR)(new s.InvalidRequestError("No base URL provided for operation"));
      const B = new URL(L), V = new URL(I, B);
      I && (B.pathname += B.pathname.endsWith("/") ? "" : "/", B.pathname += V.pathname.replace(/^\/+/, ""));
      let ce = N || "";
      const ie = [];
      for (const [Qe, Dt] of Object.entries(k?.queryParams || {})) {
        const Kn = (0, u.encodeForm)(Qe, Dt, { charEncoding: "percent" });
        typeof Kn < "u" && ie.push(Kn);
      }
      if (ie.length && (ce += `&${ie.join("&")}`), ce) {
        const Qe = ce.startsWith("&") ? ce.slice(1) : ce;
        B.search = `?${Qe}`;
      }
      const ut = new Headers(w), ba = k?.basic.username, Ft = k?.basic.password;
      if (ba != null || Ft != null) {
        const Qe = (0, l.stringToBase64)([ba || "", Ft || ""].join(":"));
        ut.set("Authorization", `Basic ${Qe}`);
      }
      const wc = new Headers(k?.headers || {});
      for (const [Qe, Dt] of wc)
        ut.set(Qe, Dt);
      let At = ut.get("cookie") || "";
      for (const [Qe, Dt] of Object.entries(k?.cookies || {}))
        At += `; ${Qe}=${Dt}`;
      At = At.startsWith("; ") ? At.slice(2) : At, ut.set("cookie", At);
      const Je = new Headers(A?.fetchOptions?.headers);
      for (const [Qe, Dt] of Je)
        ut.set(Qe, Dt);
      b || ut.set(O.uaHeader ?? "user-agent", f.SDK_METADATA.userAgent);
      let Le = A?.fetchOptions;
      if (!Le?.signal && O.timeoutMs && O.timeoutMs > 0) {
        const Qe = AbortSignal.timeout(O.timeoutMs);
        Le ? Le.signal = Qe : Le = { signal: Qe };
      }
      O.body instanceof ReadableStream && (Le || (Le = {}), Object.assign(Le, { duplex: "half" }));
      let Yt;
      try {
        Yt = e(this, a, "f").beforeCreateRequest(T, {
          url: B,
          options: {
            ...Le,
            body: O.body ?? null,
            headers: ut,
            method: M
          }
        });
      } catch (Qe) {
        return (0, o.ERR)(new s.UnexpectedClientError("Create request hook failed to execute", {
          cause: Qe
        }));
      }
      return (0, o.OK)(new Request(Yt.url, Yt.options));
    }
    async _do(T, O) {
      const { context: A, errorCodes: M } = O;
      return (0, p.retry)(async () => {
        const I = await e(this, a, "f").beforeRequest(A, T.clone());
        await P(e(this, r, "f"), I).catch((w) => e(this, r, "f")?.log("Failed to log request:", w));
        let N = await e(this, n, "f").request(I);
        try {
          if ((0, h.matchStatusCode)(N, M)) {
            const w = await e(this, a, "f").afterError(A, N, null);
            if (w.error)
              throw w.error;
            N = w.response || N;
          } else
            N = await e(this, a, "f").afterSuccess(A, N);
        } finally {
          await C(e(this, r, "f"), N, I).catch((w) => e(this, r, "f")?.log("Failed to log response:", w));
        }
        return N;
      }, { config: O.retryConfig, statusCodes: O.retryCodes }).then((I) => (0, o.OK)(I), (I) => {
        switch (!0) {
          case (0, h.isAbortError)(I):
            return (0, o.ERR)(new s.RequestAbortedError("Request aborted by client", {
              cause: I
            }));
          case (0, h.isTimeoutError)(I):
            return (0, o.ERR)(new s.RequestTimeoutError("Request timed out", { cause: I }));
          case (0, h.isConnectionError)(I):
            return (0, o.ERR)(new s.ConnectionError("Unable to make request", { cause: I }));
          default:
            return (0, o.ERR)(new s.UnexpectedClientError("Unexpected HTTP client error", {
              cause: I
            }));
        }
      });
    }
  }
  ja.ClientSDK = g, n = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  const _ = /^application\/(?:.{0,100}\+)?json/;
  async function P(R, T) {
    if (!R)
      return;
    const O = T.headers.get("content-type"), A = O?.split(";")[0] || "";
    R.group(`> Request: ${T.method} ${T.url}`), R.group("Headers:");
    for (const [M, I] of T.headers.entries())
      R.log(`${M}: ${I}`);
    switch (R.groupEnd(), R.group("Body:"), !0) {
      case _.test(A):
        R.log(await T.clone().json());
        break;
      case A.startsWith("text/"):
        R.log(await T.clone().text());
        break;
      case A === "multipart/form-data": {
        const M = await T.clone().formData();
        for (const [I, N] of M) {
          const w = N instanceof Blob ? "<Blob>" : N;
          R.log(`${I}: ${w}`);
        }
        break;
      }
      default:
        R.log(`<${O}>`);
        break;
    }
    R.groupEnd(), R.groupEnd();
  }
  async function C(R, T, O) {
    if (!R)
      return;
    const A = T.headers.get("content-type"), M = A?.split(";")[0] || "";
    R.group(`< Response: ${O.method} ${O.url}`), R.log("Status Code:", T.status, T.statusText), R.group("Headers:");
    for (const [I, N] of T.headers.entries())
      R.log(`${I}: ${N}`);
    switch (R.groupEnd(), R.group("Body:"), !0) {
      case ((0, h.matchContentType)(T, "application/json") || _.test(M)):
        R.log(await T.clone().json());
        break;
      case (0, h.matchContentType)(T, "text/event-stream"):
        R.log(`<${A}>`);
        break;
      case (0, h.matchContentType)(T, "text/*"):
        R.log(await T.clone().text());
        break;
      case (0, h.matchContentType)(T, "multipart/form-data"): {
        const I = await T.clone().formData();
        for (const [N, w] of I) {
          const k = w instanceof Blob ? "<Blob>" : w;
          R.log(`${N}: ${k}`);
        }
        break;
      }
      default:
        R.log(`<${A}>`);
        break;
    }
    R.groupEnd(), R.groupEnd();
  }
  return ja;
}
var Uc = {}, Or = {}, bt = {}, Bc = {}, Gv;
function AT() {
  if (Gv) return Bc;
  Gv = 1, Object.defineProperty(Bc, "__esModule", { value: !0 }), Bc.SDKError = void 0;
  class t extends Error {
    constructor(n, a, r = "") {
      const i = a.status, s = a.headers.get("content-type") || "", o = r.length > 0 ? `
${r}` : "";
      super(`${n}: Status ${i} Content-Type ${s} Body ${o}`), this.rawResponse = a, this.body = r, this.statusCode = i, this.contentType = s, this.name = "SDKError";
    }
  }
  return Bc.SDKError = t, Bc;
}
var yu = {}, Wv;
function Jp() {
  if (Wv) return yu;
  Wv = 1, Object.defineProperty(yu, "__esModule", { value: !0 }), yu.EventStream = void 0, yu.discardSentinel = l;
  const t = 10, e = 13, n = /* @__PURE__ */ new Set([t, e]), a = [
    new Uint8Array([e, t, e, t]),
    new Uint8Array([e, e]),
    new Uint8Array([t, t])
  ];
  class r {
    constructor(c) {
      this.stream = c.stream, this.decoder = c.decoder;
    }
    async *[Symbol.asyncIterator]() {
      const c = this.stream.getReader();
      let h = new Uint8Array([]), p = 0;
      try {
        for (; ; ) {
          const { done: d, value: m } = await c.read();
          if (d)
            break;
          const b = new Uint8Array(h.length + m.length);
          b.set(h), b.set(m, h.length), h = b;
          for (let g = p; g < h.length; g++) {
            const _ = i(h, g);
            if (_ == null)
              continue;
            const P = h.slice(p, g);
            p = g + _.length;
            const C = o(P, this.decoder);
            C != null && (yield C);
          }
          p > 0 && (h = h.slice(p), p = 0);
        }
        if (h.length > 0) {
          const d = o(h, this.decoder);
          d != null && (yield d);
        }
      } catch (d) {
        if (d instanceof Error && d.name === "AbortError")
          return;
        throw d;
      } finally {
        c.releaseLock();
      }
    }
  }
  yu.EventStream = r;
  function i(u, c) {
    const h = u[c], p = u[c + 1];
    if (h == null || p == null || !n.has(h) || !n.has(p))
      return null;
    for (const d of a) {
      const m = s(c, u, d);
      if (m != null)
        return m;
    }
    return null;
  }
  function s(u, c, h) {
    if (h.length > c.length - u)
      return null;
    for (let p = 0; p < h.length; p++)
      if (c[u + p] !== h[p])
        return null;
    return h;
  }
  function o(u, c) {
    if (!u.length)
      return null;
    const d = new TextDecoder().decode(u).split(/\r?\n|\r/g);
    let m = !1;
    const b = {};
    for (const g of d) {
      if (!g)
        continue;
      const _ = g.indexOf(":");
      if (_ === 0)
        continue;
      const P = _ > 0 ? g.substring(0, _) : "";
      let C = _ > 0 ? g.substring(_ + 1) : "";
      switch (C.charAt(0) === " " && (C = C.substring(1)), P) {
        case "event": {
          m = !0, b.event = C;
          break;
        }
        case "data": {
          m = !0, b.data ?? (b.data = ""), b.data += C + `
`;
          break;
        }
        case "id": {
          m = !0, b.id = C;
          break;
        }
        case "retry": {
          const R = parseInt(C, 10);
          Number.isNaN(R) || (m = !0, b.retry = R);
          break;
        }
      }
    }
    return m ? (b.data != null && (b.data = b.data.slice(0, -1)), c(b)) : null;
  }
  function l(u, c) {
    return new ReadableStream({
      async start(h) {
        let p = new Uint8Array([]), d = 0, m = !1, b = !1;
        const g = u.getReader();
        try {
          for (; !m; ) {
            const _ = await g.read(), P = _.value;
            if (m = m || _.done, b || typeof P > "u")
              continue;
            const C = new Uint8Array(p.length + P.length);
            C.set(p), C.set(P, p.length), p = C;
            for (let R = d; R < p.length; R++) {
              const T = i(p, R);
              if (T == null)
                continue;
              const O = d, A = p.slice(O, R);
              d = R + T.length, o(A, f)?.data === c ? (h.enqueue(p.slice(0, O)), b = !0) : (h.enqueue(p.slice(0, d)), p = p.slice(d), d = 0);
            }
          }
        } catch (_) {
          h.error(_);
        } finally {
          h.close(), g.releaseLock();
        }
      }
    });
  }
  function f(u) {
    return u;
  }
  return yu;
}
var wu = {}, Fn = {}, Xv;
function ET() {
  if (Xv) return Fn;
  Xv = 1;
  var t = Fn && Fn.__createBinding || (Object.create ? function(s, o, l, f) {
    f === void 0 && (f = l);
    var u = Object.getOwnPropertyDescriptor(o, l);
    (!u || ("get" in u ? !o.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
      return o[l];
    } }), Object.defineProperty(s, f, u);
  } : function(s, o, l, f) {
    f === void 0 && (f = l), s[f] = o[l];
  }), e = Fn && Fn.__setModuleDefault || (Object.create ? function(s, o) {
    Object.defineProperty(s, "default", { enumerable: !0, value: o });
  } : function(s, o) {
    s.default = o;
  }), n = Fn && Fn.__importStar || function(s) {
    if (s && s.__esModule) return s;
    var o = {};
    if (s != null) for (var l in s) l !== "default" && Object.prototype.hasOwnProperty.call(s, l) && t(o, s, l);
    return e(o, s), o;
  };
  Object.defineProperty(Fn, "__esModule", { value: !0 }), Fn.SDKValidationError = void 0, Fn.formatZodError = i;
  const a = n(/* @__PURE__ */ H());
  class r extends Error {
    constructor(o, l, f) {
      super(`${o}: ${l}`), this.name = "SDKValidationError", this.cause = l, this.rawValue = f, this.rawMessage = o;
    }
    /**
     * Return a pretty-formatted error message if the underlying validation error
     * is a ZodError or some other recognized error type, otherwise return the
     * default error message.
     */
    pretty() {
      return this.cause instanceof a.ZodError ? `${this.rawMessage}
${i(this.cause)}` : this.toString();
    }
  }
  Fn.SDKValidationError = r;
  function i(s, o = 0) {
    let l = "  ".repeat(o);
    l = o > 0 ? `${l}` : l, l += " ".repeat(o);
    let f = "";
    const u = (p) => f += `
${l}${p}`, c = s.issues.length, h = c === 1 ? `${c} issue found` : `${c} issues found`;
    c && u(` ${h}:`);
    for (const p of s.issues) {
      let d = p.path.join(".");
      switch (d = d ? `<root>.${d}` : "<root>", u(`  [${d}]: ${p.message} (${p.code})`), p.code) {
        case "invalid_literal":
        case "invalid_type": {
          u(`     Want: ${p.expected}`), u(`      Got: ${p.received}`);
          break;
        }
        case "unrecognized_keys": {
          u(`     Keys: ${p.keys.join(", ")}`);
          break;
        }
        case "invalid_enum_value": {
          u(`     Allowed: ${p.options.join(", ")}`), u(`         Got: ${p.received}`);
          break;
        }
        case "invalid_union_discriminator": {
          u(`     Allowed: ${p.options.join(", ")}`);
          break;
        }
        case "invalid_union": {
          const m = p.unionErrors.length;
          u(`    Attemped to deserialize into one of ${m} union members:`), p.unionErrors.forEach((b, g) => {
            u(`    Member ${g + 1} of ${m}`), u(`${i(b, o + 1)}`);
          });
        }
      }
    }
    return s.issues.length && u("*"), f.slice(1);
  }
  return Fn;
}
var Qv;
function Z() {
  if (Qv) return wu;
  Qv = 1, Object.defineProperty(wu, "__esModule", { value: !0 }), wu.parse = a, wu.safeParse = r, wu.collectExtraKeys = i;
  const t = /* @__PURE__ */ H(), e = /* @__PURE__ */ ET(), n = /* @__PURE__ */ Zn();
  function a(s, o, l) {
    try {
      return o(s);
    } catch (f) {
      throw f instanceof t.ZodError ? new e.SDKValidationError(l, f, s) : f;
    }
  }
  function r(s, o, l) {
    try {
      return (0, n.OK)(o(s));
    } catch (f) {
      return (0, n.ERR)(new e.SDKValidationError(l, f, s));
    }
  }
  function i(s, o, l) {
    return s.transform((f) => {
      const u = {}, { shape: c } = s;
      for (const [h] of Object.entries(f)) {
        if (h in c)
          continue;
        const p = f[h];
        typeof p > "u" || (u[h] = p, delete f[h]);
      }
      return l && Object.keys(u).length === 0 ? f : { ...f, [o]: u };
    });
  }
  return wu;
}
var Yv;
function ke() {
  if (Yv) return bt;
  Yv = 1, Object.defineProperty(bt, "__esModule", { value: !0 }), bt.jsonErr = s, bt.json = o, bt.textErr = l, bt.text = f, bt.bytesErr = u, bt.bytes = c, bt.streamErr = h, bt.stream = p, bt.sseErr = d, bt.sse = m, bt.nilErr = b, bt.nil = g, bt.fail = _, bt.match = P, bt.unpackHeaders = R, bt.discardResponseBody = T;
  const t = /* @__PURE__ */ AT(), e = /* @__PURE__ */ Jp(), n = /* @__PURE__ */ qp(), a = /* @__PURE__ */ $T(), r = /* @__PURE__ */ Z(), i = {
    json: "application/json",
    text: "text/plain",
    bytes: "application/octet-stream",
    stream: "application/octet-stream",
    sse: "text/event-stream",
    nil: "*",
    fail: "*"
  };
  function s(O, A, M) {
    return { ...M, err: !0, enc: "json", codes: O, schema: A };
  }
  function o(O, A, M) {
    return { ...M, enc: "json", codes: O, schema: A };
  }
  function l(O, A, M) {
    return { ...M, err: !0, enc: "text", codes: O, schema: A };
  }
  function f(O, A, M) {
    return { ...M, enc: "text", codes: O, schema: A };
  }
  function u(O, A, M) {
    return { ...M, err: !0, enc: "bytes", codes: O, schema: A };
  }
  function c(O, A, M) {
    return { ...M, enc: "bytes", codes: O, schema: A };
  }
  function h(O, A, M) {
    return { ...M, err: !0, enc: "stream", codes: O, schema: A };
  }
  function p(O, A, M) {
    return { ...M, enc: "stream", codes: O, schema: A };
  }
  function d(O, A, M) {
    return { ...M, err: !0, enc: "sse", codes: O, schema: A };
  }
  function m(O, A, M) {
    return { ...M, enc: "sse", codes: O, schema: A };
  }
  function b(O, A, M) {
    return { ...M, err: !0, enc: "nil", codes: O, schema: A };
  }
  function g(O, A, M) {
    return { ...M, enc: "nil", codes: O, schema: A };
  }
  function _(O) {
    return { enc: "fail", codes: O };
  }
  function P(...O) {
    return async function(M, I) {
      let N, w;
      for (const V of O) {
        const { codes: ce } = V, ie = "ctype" in V ? V.ctype : i[V.enc];
        if (ie && (0, n.matchResponse)(M, ce, ie)) {
          w = V;
          break;
        } else if (!ie && (0, n.matchStatusCode)(M, ce)) {
          w = V;
          break;
        }
      }
      if (!w) {
        const V = await M.text();
        return [{
          ok: !1,
          error: new t.SDKError("Unexpected API response status or content-type", M, V)
        }, V];
      }
      const k = w.enc;
      switch (k) {
        case "json":
          N = await M.json();
          break;
        case "bytes":
          N = new Uint8Array(await M.arrayBuffer());
          break;
        case "stream":
          N = M.body;
          break;
        case "text":
          N = await M.text();
          break;
        case "sse":
          N = M.body && w.sseSentinel ? (0, e.discardSentinel)(M.body, w.sseSentinel) : M.body;
          break;
        case "nil":
          N = await T(M);
          break;
        case "fail":
          N = await M.text();
          break;
        default:
          throw new Error(`Unsupported response type: ${k}`);
      }
      if (w.enc === "fail")
        return [{
          ok: !1,
          error: new t.SDKError("API error occurred", M, typeof N == "string" ? N : "")
        }, N];
      const L = w.key || I?.resultKey;
      let B;
      if ("err" in w ? B = {
        ...I?.extraFields,
        ...w.hdrs ? { Headers: R(M.headers) } : null,
        ...(0, a.isPlainObject)(N) ? N : null
      } : L ? B = {
        ...I?.extraFields,
        ...w.hdrs ? { Headers: R(M.headers) } : null,
        [L]: N
      } : w.hdrs ? B = {
        ...I?.extraFields,
        ...w.hdrs ? { Headers: R(M.headers) } : null,
        ...(0, a.isPlainObject)(N) ? N : null
      } : B = N, "err" in w) {
        const V = (0, r.safeParse)(B, (ce) => w.schema.parse(ce), "Response validation failed");
        return [V.ok ? { ok: !1, error: V.value } : V, N];
      } else
        return [
          (0, r.safeParse)(B, (V) => w.schema.parse(V), "Response validation failed"),
          N
        ];
    };
  }
  const C = /, */;
  function R(O) {
    const A = {};
    for (const [M, I] of O.entries())
      A[M] = I.split(C);
    return A;
  }
  async function T(O) {
    const A = O.body?.getReader();
    if (A != null)
      try {
        let M = !1;
        for (; !M; )
          M = (await A.read()).done;
      } finally {
        A.releaseLock();
      }
  }
  return bt;
}
var Ca = {}, eS;
function X() {
  if (eS) return Ca;
  eS = 1, Object.defineProperty(Ca, "__esModule", { value: !0 }), Ca.invariant = e, Ca.remap = n, Ca.combineSignals = a, Ca.abortSignalAny = r, Ca.compactMap = i, Ca.allRequired = s;
  class t extends Error {
    constructor(l) {
      super(l), this.name = "InvariantError";
    }
  }
  function e(o, l) {
    if (!o)
      throw new t(l);
  }
  function n(o, l) {
    let f = {};
    if (!Object.keys(l).length)
      return f = o, f;
    for (const [u, c] of Object.entries(o)) {
      const h = l[u];
      h !== null && (f[h ?? u] = c);
    }
    return f;
  }
  function a(...o) {
    const l = [];
    for (const f of o)
      f && l.push(f);
    switch (l.length) {
      case 0:
      case 1:
        return l[0] || null;
      default:
        return "any" in AbortSignal && typeof AbortSignal.any == "function" ? AbortSignal.any(l) : r(l);
    }
  }
  function r(o) {
    const l = new AbortController(), f = l.signal;
    if (!o.length)
      return l.signal;
    if (o.length === 1)
      return o[0] || l.signal;
    for (const p of o)
      if (p.aborted)
        return p;
    function u() {
      l.abort(this.reason), h();
    }
    const c = [];
    function h() {
      for (const p of c) {
        const d = p.deref();
        d && d.removeEventListener("abort", u);
      }
    }
    for (const p of o)
      c.push(new WeakRef(p)), p.addEventListener("abort", u);
    return f;
  }
  function i(o) {
    const l = {};
    for (const [f, u] of Object.entries(o))
      typeof u < "u" && (l[f] = u);
    return l;
  }
  function s(o) {
    if (!Object.values(o).every((l) => l == null))
      return o;
  }
  return Ca;
}
var jr = {}, tS;
function Fe() {
  if (tS) return jr;
  tS = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.SecurityError = jr.SecurityErrorCode = void 0, jr.resolveSecurity = a, jr.resolveGlobalSecurity = s, jr.extractSecurity = o;
  const t = /* @__PURE__ */ MT();
  var e;
  (function(l) {
    l.Incomplete = "incomplete", l.UnrecognisedSecurityType = "unrecognized_security_type";
  })(e || (jr.SecurityErrorCode = e = {}));
  class n extends Error {
    constructor(f, u) {
      super(u), this.code = f, this.name = "SecurityError";
    }
    static incomplete() {
      return new n(e.Incomplete, "Security requirements not met in order to perform the operation");
    }
    static unrecognizedType(f) {
      return new n(e.UnrecognisedSecurityType, `Unrecognised security type: ${f}`);
    }
  }
  jr.SecurityError = n;
  function a(...l) {
    const f = {
      basic: {},
      headers: {},
      queryParams: {},
      cookies: {},
      oauth2: { type: "none" }
    }, u = l.find((c) => c.every((h) => {
      if (h.value == null)
        return !1;
      if (h.type === "http:basic")
        return h.value.username != null || h.value.password != null;
      if (h.type === "http:custom")
        return null;
      if (h.type === "oauth2:password")
        return typeof h.value == "string" && !!h.value;
      if (h.type === "oauth2:client_credentials")
        return h.value.clientID != null || h.value.clientSecret != null;
      if (typeof h.value == "string")
        return !!h.value;
      throw new Error(`Unrecognized security type: ${h.type} (value type: ${typeof h.value})`);
    }));
    return u == null ? null : (u.forEach((c) => {
      if (c.value == null)
        return;
      const { type: h } = c;
      switch (h) {
        case "apiKey:header":
          f.headers[c.fieldName] = c.value;
          break;
        case "apiKey:query":
          f.queryParams[c.fieldName] = c.value;
          break;
        case "apiKey:cookie":
          f.cookies[c.fieldName] = c.value;
          break;
        case "http:basic":
          r(f, c);
          break;
        case "http:custom":
          break;
        case "http:bearer":
          i(f, c);
          break;
        case "oauth2":
          i(f, c);
          break;
        case "oauth2:password":
          i(f, c);
          break;
        case "oauth2:client_credentials":
          break;
        case "openIdConnect":
          i(f, c);
          break;
        default:
          throw n.unrecognizedType(h);
      }
    }), f);
  }
  function r(l, f) {
    f.value != null && (l.basic = f.value);
  }
  function i(l, f) {
    if (typeof f.value != "string" || !f.value)
      return;
    let u = f.value;
    u.slice(0, 7).toLowerCase() !== "bearer " && (u = `Bearer ${u}`), l.headers[f.fieldName] = u;
  }
  function s(l) {
    return a([
      {
        fieldName: "Authorization",
        type: "http:bearer",
        value: l?.apiKey ?? (0, t.env)().MISTRAL_API_KEY
      }
    ]);
  }
  async function o(l) {
    if (l != null)
      return typeof l == "function" ? l() : l;
  }
  return jr;
}
var Ao = {}, Ta = {}, $a = {}, Ma = {}, Aa = {}, nS;
function D_() {
  return nS || (nS = 1, function(t) {
    var e = Aa && Aa.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Aa && Aa.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Aa && Aa.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.DocumentURLChunk$ = t.DocumentURLChunk$outboundSchema = t.DocumentURLChunk$inboundSchema = t.DocumentURLChunkType$ = t.DocumentURLChunkType$outboundSchema = t.DocumentURLChunkType$inboundSchema = t.DocumentURLChunkType = void 0, t.documentURLChunkToJSON = f, t.documentURLChunkFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.DocumentURLChunkType = {
      DocumentUrl: "document_url"
    }, t.DocumentURLChunkType$inboundSchema = r.nativeEnum(t.DocumentURLChunkType), t.DocumentURLChunkType$outboundSchema = t.DocumentURLChunkType$inboundSchema;
    var o;
    (function(c) {
      c.inboundSchema = t.DocumentURLChunkType$inboundSchema, c.outboundSchema = t.DocumentURLChunkType$outboundSchema;
    })(o || (t.DocumentURLChunkType$ = o = {})), t.DocumentURLChunk$inboundSchema = r.object({
      document_url: r.string(),
      document_name: r.nullable(r.string()).optional(),
      type: t.DocumentURLChunkType$inboundSchema.default("document_url")
    }).transform((c) => (0, i.remap)(c, {
      document_url: "documentUrl",
      document_name: "documentName"
    })), t.DocumentURLChunk$outboundSchema = r.object({
      documentUrl: r.string(),
      documentName: r.nullable(r.string()).optional(),
      type: t.DocumentURLChunkType$outboundSchema.default("document_url")
    }).transform((c) => (0, i.remap)(c, {
      documentUrl: "document_url",
      documentName: "document_name"
    }));
    var l;
    (function(c) {
      c.inboundSchema = t.DocumentURLChunk$inboundSchema, c.outboundSchema = t.DocumentURLChunk$outboundSchema;
    })(l || (t.DocumentURLChunk$ = l = {}));
    function f(c) {
      return JSON.stringify(t.DocumentURLChunk$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, s.safeParse)(c, (h) => t.DocumentURLChunk$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'DocumentURLChunk' from JSON");
    }
  }(Aa)), Aa;
}
var Ea = {}, Ia = {}, rS;
function IT() {
  return rS || (rS = 1, function(t) {
    var e = Ia && Ia.__createBinding || (Object.create ? function(f, u, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(u, c);
      (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, u, c, h) {
      h === void 0 && (h = c), f[h] = u[c];
    }), n = Ia && Ia.__setModuleDefault || (Object.create ? function(f, u) {
      Object.defineProperty(f, "default", { enumerable: !0, value: u });
    } : function(f, u) {
      f.default = u;
    }), a = Ia && Ia.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var u = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(u, f, c);
      return n(u, f), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ImageURL$ = t.ImageURL$outboundSchema = t.ImageURL$inboundSchema = void 0, t.imageURLToJSON = o, t.imageURLFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.ImageURL$inboundSchema = r.object({
      url: r.string(),
      detail: r.nullable(r.string()).optional()
    }), t.ImageURL$outboundSchema = r.object({
      url: r.string(),
      detail: r.nullable(r.string()).optional()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.ImageURL$inboundSchema, f.outboundSchema = t.ImageURL$outboundSchema;
    })(s || (t.ImageURL$ = s = {}));
    function o(f) {
      return JSON.stringify(t.ImageURL$outboundSchema.parse(f));
    }
    function l(f) {
      return (0, i.safeParse)(f, (u) => t.ImageURL$inboundSchema.parse(JSON.parse(u)), "Failed to parse 'ImageURL' from JSON");
    }
  }(Ia)), Ia;
}
var aS;
function q_() {
  return aS || (aS = 1, function(t) {
    var e = Ea && Ea.__createBinding || (Object.create ? function(m, b, g, _) {
      _ === void 0 && (_ = g);
      var P = Object.getOwnPropertyDescriptor(b, g);
      (!P || ("get" in P ? !b.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
        return b[g];
      } }), Object.defineProperty(m, _, P);
    } : function(m, b, g, _) {
      _ === void 0 && (_ = g), m[_] = b[g];
    }), n = Ea && Ea.__setModuleDefault || (Object.create ? function(m, b) {
      Object.defineProperty(m, "default", { enumerable: !0, value: b });
    } : function(m, b) {
      m.default = b;
    }), a = Ea && Ea.__importStar || function(m) {
      if (m && m.__esModule) return m;
      var b = {};
      if (m != null) for (var g in m) g !== "default" && Object.prototype.hasOwnProperty.call(m, g) && e(b, m, g);
      return n(b, m), b;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ImageURLChunk$ = t.ImageURLChunk$outboundSchema = t.ImageURLChunk$inboundSchema = t.ImageURLChunkType$ = t.ImageURLChunkType$outboundSchema = t.ImageURLChunkType$inboundSchema = t.ImageURLChunkImageURL$ = t.ImageURLChunkImageURL$outboundSchema = t.ImageURLChunkImageURL$inboundSchema = t.ImageURLChunkType = void 0, t.imageURLChunkImageURLToJSON = f, t.imageURLChunkImageURLFromJSON = u, t.imageURLChunkToJSON = p, t.imageURLChunkFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ IT();
    t.ImageURLChunkType = {
      ImageUrl: "image_url"
    }, t.ImageURLChunkImageURL$inboundSchema = r.union([o.ImageURL$inboundSchema, r.string()]), t.ImageURLChunkImageURL$outboundSchema = r.union([o.ImageURL$outboundSchema, r.string()]);
    var l;
    (function(m) {
      m.inboundSchema = t.ImageURLChunkImageURL$inboundSchema, m.outboundSchema = t.ImageURLChunkImageURL$outboundSchema;
    })(l || (t.ImageURLChunkImageURL$ = l = {}));
    function f(m) {
      return JSON.stringify(t.ImageURLChunkImageURL$outboundSchema.parse(m));
    }
    function u(m) {
      return (0, s.safeParse)(m, (b) => t.ImageURLChunkImageURL$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'ImageURLChunkImageURL' from JSON");
    }
    t.ImageURLChunkType$inboundSchema = r.nativeEnum(t.ImageURLChunkType), t.ImageURLChunkType$outboundSchema = t.ImageURLChunkType$inboundSchema;
    var c;
    (function(m) {
      m.inboundSchema = t.ImageURLChunkType$inboundSchema, m.outboundSchema = t.ImageURLChunkType$outboundSchema;
    })(c || (t.ImageURLChunkType$ = c = {})), t.ImageURLChunk$inboundSchema = r.object({
      image_url: r.union([o.ImageURL$inboundSchema, r.string()]),
      type: t.ImageURLChunkType$inboundSchema.default("image_url")
    }).transform((m) => (0, i.remap)(m, {
      image_url: "imageUrl"
    })), t.ImageURLChunk$outboundSchema = r.object({
      imageUrl: r.union([o.ImageURL$outboundSchema, r.string()]),
      type: t.ImageURLChunkType$outboundSchema.default("image_url")
    }).transform((m) => (0, i.remap)(m, {
      imageUrl: "image_url"
    }));
    var h;
    (function(m) {
      m.inboundSchema = t.ImageURLChunk$inboundSchema, m.outboundSchema = t.ImageURLChunk$outboundSchema;
    })(h || (t.ImageURLChunk$ = h = {}));
    function p(m) {
      return JSON.stringify(t.ImageURLChunk$outboundSchema.parse(m));
    }
    function d(m) {
      return (0, s.safeParse)(m, (b) => t.ImageURLChunk$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'ImageURLChunk' from JSON");
    }
  }(Ea)), Ea;
}
var Na = {}, iS;
function NT() {
  return iS || (iS = 1, function(t) {
    var e = Na && Na.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Na && Na.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Na && Na.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ReferenceChunk$ = t.ReferenceChunk$outboundSchema = t.ReferenceChunk$inboundSchema = t.ReferenceChunkType$ = t.ReferenceChunkType$outboundSchema = t.ReferenceChunkType$inboundSchema = t.ReferenceChunkType = void 0, t.referenceChunkToJSON = f, t.referenceChunkFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.ReferenceChunkType = {
      Reference: "reference"
    }, t.ReferenceChunkType$inboundSchema = r.nativeEnum(t.ReferenceChunkType), t.ReferenceChunkType$outboundSchema = t.ReferenceChunkType$inboundSchema;
    var o;
    (function(c) {
      c.inboundSchema = t.ReferenceChunkType$inboundSchema, c.outboundSchema = t.ReferenceChunkType$outboundSchema;
    })(o || (t.ReferenceChunkType$ = o = {})), t.ReferenceChunk$inboundSchema = r.object({
      reference_ids: r.array(r.number().int()),
      type: t.ReferenceChunkType$inboundSchema.default("reference")
    }).transform((c) => (0, i.remap)(c, {
      reference_ids: "referenceIds"
    })), t.ReferenceChunk$outboundSchema = r.object({
      referenceIds: r.array(r.number().int()),
      type: t.ReferenceChunkType$outboundSchema.default("reference")
    }).transform((c) => (0, i.remap)(c, {
      referenceIds: "reference_ids"
    }));
    var l;
    (function(c) {
      c.inboundSchema = t.ReferenceChunk$inboundSchema, c.outboundSchema = t.ReferenceChunk$outboundSchema;
    })(l || (t.ReferenceChunk$ = l = {}));
    function f(c) {
      return JSON.stringify(t.ReferenceChunk$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, s.safeParse)(c, (h) => t.ReferenceChunk$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'ReferenceChunk' from JSON");
    }
  }(Na)), Na;
}
var ka = {}, sS;
function J_() {
  return sS || (sS = 1, function(t) {
    var e = ka && ka.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = ka && ka.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = ka && ka.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.TextChunk$ = t.TextChunk$outboundSchema = t.TextChunk$inboundSchema = t.TextChunkType$ = t.TextChunkType$outboundSchema = t.TextChunkType$inboundSchema = t.TextChunkType = void 0, t.textChunkToJSON = l, t.textChunkFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.TextChunkType = {
      Text: "text"
    }, t.TextChunkType$inboundSchema = r.nativeEnum(t.TextChunkType), t.TextChunkType$outboundSchema = t.TextChunkType$inboundSchema;
    var s;
    (function(u) {
      u.inboundSchema = t.TextChunkType$inboundSchema, u.outboundSchema = t.TextChunkType$outboundSchema;
    })(s || (t.TextChunkType$ = s = {})), t.TextChunk$inboundSchema = r.object({
      text: r.string(),
      type: t.TextChunkType$inboundSchema.default("text")
    }), t.TextChunk$outboundSchema = r.object({
      text: r.string(),
      type: t.TextChunkType$outboundSchema.default("text")
    });
    var o;
    (function(u) {
      u.inboundSchema = t.TextChunk$inboundSchema, u.outboundSchema = t.TextChunk$outboundSchema;
    })(o || (t.TextChunk$ = o = {}));
    function l(u) {
      return JSON.stringify(t.TextChunk$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, i.safeParse)(u, (c) => t.TextChunk$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'TextChunk' from JSON");
    }
  }(ka)), ka;
}
var oS;
function Xd() {
  return oS || (oS = 1, function(t) {
    var e = Ma && Ma.__createBinding || (Object.create ? function(p, d, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(d, m);
      (!g || ("get" in g ? !d.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return d[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, d, m, b) {
      b === void 0 && (b = m), p[b] = d[m];
    }), n = Ma && Ma.__setModuleDefault || (Object.create ? function(p, d) {
      Object.defineProperty(p, "default", { enumerable: !0, value: d });
    } : function(p, d) {
      p.default = d;
    }), a = Ma && Ma.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(d, p, m);
      return n(d, p), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ContentChunk$ = t.ContentChunk$outboundSchema = t.ContentChunk$inboundSchema = void 0, t.contentChunkToJSON = c, t.contentChunkFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ D_(), o = /* @__PURE__ */ q_(), l = /* @__PURE__ */ NT(), f = /* @__PURE__ */ J_();
    t.ContentChunk$inboundSchema = r.union([
      o.ImageURLChunk$inboundSchema.and(r.object({ type: r.literal("image_url") }).transform((p) => ({
        type: p.type
      }))),
      f.TextChunk$inboundSchema.and(r.object({ type: r.literal("text") }).transform((p) => ({ type: p.type }))),
      l.ReferenceChunk$inboundSchema.and(r.object({ type: r.literal("reference") }).transform((p) => ({
        type: p.type
      }))),
      s.DocumentURLChunk$inboundSchema.and(r.object({ type: r.literal("document_url") }).transform((p) => ({
        type: p.type
      })))
    ]), t.ContentChunk$outboundSchema = r.union([
      o.ImageURLChunk$outboundSchema.and(r.object({ type: r.literal("image_url") }).transform((p) => ({
        type: p.type
      }))),
      f.TextChunk$outboundSchema.and(r.object({ type: r.literal("text") }).transform((p) => ({ type: p.type }))),
      l.ReferenceChunk$outboundSchema.and(r.object({ type: r.literal("reference") }).transform((p) => ({
        type: p.type
      }))),
      s.DocumentURLChunk$outboundSchema.and(r.object({ type: r.literal("document_url") }).transform((p) => ({
        type: p.type
      })))
    ]);
    var u;
    (function(p) {
      p.inboundSchema = t.ContentChunk$inboundSchema, p.outboundSchema = t.ContentChunk$outboundSchema;
    })(u || (t.ContentChunk$ = u = {}));
    function c(p) {
      return JSON.stringify(t.ContentChunk$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, i.safeParse)(p, (d) => t.ContentChunk$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'ContentChunk' from JSON");
    }
  }(Ma)), Ma;
}
var Fa = {}, Da = {}, uS;
function kT() {
  return uS || (uS = 1, function(t) {
    var e = Da && Da.__createBinding || (Object.create ? function(h, p, d, m) {
      m === void 0 && (m = d);
      var b = Object.getOwnPropertyDescriptor(p, d);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[d];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, d, m) {
      m === void 0 && (m = d), h[m] = p[d];
    }), n = Da && Da.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = Da && Da.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var d in h) d !== "default" && Object.prototype.hasOwnProperty.call(h, d) && e(p, h, d);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FunctionCall$ = t.FunctionCall$outboundSchema = t.FunctionCall$inboundSchema = t.Arguments$ = t.Arguments$outboundSchema = t.Arguments$inboundSchema = void 0, t.argumentsToJSON = o, t.argumentsFromJSON = l, t.functionCallToJSON = u, t.functionCallFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.Arguments$inboundSchema = r.union([r.record(r.any()), r.string()]), t.Arguments$outboundSchema = r.union([r.record(r.any()), r.string()]);
    var s;
    (function(h) {
      h.inboundSchema = t.Arguments$inboundSchema, h.outboundSchema = t.Arguments$outboundSchema;
    })(s || (t.Arguments$ = s = {}));
    function o(h) {
      return JSON.stringify(t.Arguments$outboundSchema.parse(h));
    }
    function l(h) {
      return (0, i.safeParse)(h, (p) => t.Arguments$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'Arguments' from JSON");
    }
    t.FunctionCall$inboundSchema = r.object({
      name: r.string(),
      arguments: r.union([r.record(r.any()), r.string()])
    }), t.FunctionCall$outboundSchema = r.object({
      name: r.string(),
      arguments: r.union([r.record(r.any()), r.string()])
    });
    var f;
    (function(h) {
      h.inboundSchema = t.FunctionCall$inboundSchema, h.outboundSchema = t.FunctionCall$outboundSchema;
    })(f || (t.FunctionCall$ = f = {}));
    function u(h) {
      return JSON.stringify(t.FunctionCall$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, i.safeParse)(h, (p) => t.FunctionCall$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'FunctionCall' from JSON");
    }
  }(Da)), Da;
}
var qa = {}, Xf = {}, cS;
function iu() {
  if (cS) return Xf;
  cS = 1, Object.defineProperty(Xf, "__esModule", { value: !0 }), Xf.catchUnrecognizedEnum = t;
  function t(e) {
    return e;
  }
  return Xf;
}
var lS;
function Lp() {
  return lS || (lS = 1, function(t) {
    var e = qa && qa.__createBinding || (Object.create ? function(o, l, f, u) {
      u === void 0 && (u = f);
      var c = Object.getOwnPropertyDescriptor(l, f);
      (!c || ("get" in c ? !l.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return l[f];
      } }), Object.defineProperty(o, u, c);
    } : function(o, l, f, u) {
      u === void 0 && (u = f), o[u] = l[f];
    }), n = qa && qa.__setModuleDefault || (Object.create ? function(o, l) {
      Object.defineProperty(o, "default", { enumerable: !0, value: l });
    } : function(o, l) {
      o.default = l;
    }), a = qa && qa.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var l = {};
      if (o != null) for (var f in o) f !== "default" && Object.prototype.hasOwnProperty.call(o, f) && e(l, o, f);
      return n(l, o), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ToolTypes$ = t.ToolTypes$outboundSchema = t.ToolTypes$inboundSchema = t.ToolTypes = void 0;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ iu();
    t.ToolTypes = {
      Function: "function"
    }, t.ToolTypes$inboundSchema = r.union([
      r.nativeEnum(t.ToolTypes),
      r.string().transform(i.catchUnrecognizedEnum)
    ]), t.ToolTypes$outboundSchema = r.union([
      r.nativeEnum(t.ToolTypes),
      r.string().and(r.custom())
    ]);
    var s;
    (function(o) {
      o.inboundSchema = t.ToolTypes$inboundSchema, o.outboundSchema = t.ToolTypes$outboundSchema;
    })(s || (t.ToolTypes$ = s = {}));
  }(qa)), qa;
}
var dS;
function L_() {
  return dS || (dS = 1, function(t) {
    var e = Fa && Fa.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Fa && Fa.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Fa && Fa.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ToolCall$ = t.ToolCall$outboundSchema = t.ToolCall$inboundSchema = void 0, t.toolCallToJSON = f, t.toolCallFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ kT(), o = /* @__PURE__ */ Lp();
    t.ToolCall$inboundSchema = r.object({
      id: r.string().default("null"),
      type: o.ToolTypes$inboundSchema.optional(),
      function: s.FunctionCall$inboundSchema,
      index: r.number().int().default(0)
    }), t.ToolCall$outboundSchema = r.object({
      id: r.string().default("null"),
      type: o.ToolTypes$outboundSchema.optional(),
      function: s.FunctionCall$outboundSchema,
      index: r.number().int().default(0)
    });
    var l;
    (function(c) {
      c.inboundSchema = t.ToolCall$inboundSchema, c.outboundSchema = t.ToolCall$outboundSchema;
    })(l || (t.ToolCall$ = l = {}));
    function f(c) {
      return JSON.stringify(t.ToolCall$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, i.safeParse)(c, (h) => t.ToolCall$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'ToolCall' from JSON");
    }
  }(Fa)), Fa;
}
var fS;
function su() {
  return fS || (fS = 1, function(t) {
    var e = $a && $a.__createBinding || (Object.create ? function(b, g, _, P) {
      P === void 0 && (P = _);
      var C = Object.getOwnPropertyDescriptor(g, _);
      (!C || ("get" in C ? !g.__esModule : C.writable || C.configurable)) && (C = { enumerable: !0, get: function() {
        return g[_];
      } }), Object.defineProperty(b, P, C);
    } : function(b, g, _, P) {
      P === void 0 && (P = _), b[P] = g[_];
    }), n = $a && $a.__setModuleDefault || (Object.create ? function(b, g) {
      Object.defineProperty(b, "default", { enumerable: !0, value: g });
    } : function(b, g) {
      b.default = g;
    }), a = $a && $a.__importStar || function(b) {
      if (b && b.__esModule) return b;
      var g = {};
      if (b != null) for (var _ in b) _ !== "default" && Object.prototype.hasOwnProperty.call(b, _) && e(g, b, _);
      return n(g, b), g;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.AssistantMessage$ = t.AssistantMessage$outboundSchema = t.AssistantMessage$inboundSchema = t.AssistantMessageRole$ = t.AssistantMessageRole$outboundSchema = t.AssistantMessageRole$inboundSchema = t.AssistantMessageContent$ = t.AssistantMessageContent$outboundSchema = t.AssistantMessageContent$inboundSchema = t.AssistantMessageRole = void 0, t.assistantMessageContentToJSON = u, t.assistantMessageContentFromJSON = c, t.assistantMessageToJSON = d, t.assistantMessageFromJSON = m;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Xd(), l = /* @__PURE__ */ L_();
    t.AssistantMessageRole = {
      Assistant: "assistant"
    }, t.AssistantMessageContent$inboundSchema = r.union([r.string(), r.array(o.ContentChunk$inboundSchema)]), t.AssistantMessageContent$outboundSchema = r.union([r.string(), r.array(o.ContentChunk$outboundSchema)]);
    var f;
    (function(b) {
      b.inboundSchema = t.AssistantMessageContent$inboundSchema, b.outboundSchema = t.AssistantMessageContent$outboundSchema;
    })(f || (t.AssistantMessageContent$ = f = {}));
    function u(b) {
      return JSON.stringify(t.AssistantMessageContent$outboundSchema.parse(b));
    }
    function c(b) {
      return (0, s.safeParse)(b, (g) => t.AssistantMessageContent$inboundSchema.parse(JSON.parse(g)), "Failed to parse 'AssistantMessageContent' from JSON");
    }
    t.AssistantMessageRole$inboundSchema = r.nativeEnum(t.AssistantMessageRole), t.AssistantMessageRole$outboundSchema = t.AssistantMessageRole$inboundSchema;
    var h;
    (function(b) {
      b.inboundSchema = t.AssistantMessageRole$inboundSchema, b.outboundSchema = t.AssistantMessageRole$outboundSchema;
    })(h || (t.AssistantMessageRole$ = h = {})), t.AssistantMessage$inboundSchema = r.object({
      content: r.nullable(r.union([r.string(), r.array(o.ContentChunk$inboundSchema)])).optional(),
      tool_calls: r.nullable(r.array(l.ToolCall$inboundSchema)).optional(),
      prefix: r.boolean().default(!1),
      role: t.AssistantMessageRole$inboundSchema.default("assistant")
    }).transform((b) => (0, i.remap)(b, {
      tool_calls: "toolCalls"
    })), t.AssistantMessage$outboundSchema = r.object({
      content: r.nullable(r.union([r.string(), r.array(o.ContentChunk$outboundSchema)])).optional(),
      toolCalls: r.nullable(r.array(l.ToolCall$outboundSchema)).optional(),
      prefix: r.boolean().default(!1),
      role: t.AssistantMessageRole$outboundSchema.default("assistant")
    }).transform((b) => (0, i.remap)(b, {
      toolCalls: "tool_calls"
    }));
    var p;
    (function(b) {
      b.inboundSchema = t.AssistantMessage$inboundSchema, b.outboundSchema = t.AssistantMessage$outboundSchema;
    })(p || (t.AssistantMessage$ = p = {}));
    function d(b) {
      return JSON.stringify(t.AssistantMessage$outboundSchema.parse(b));
    }
    function m(b) {
      return (0, s.safeParse)(b, (g) => t.AssistantMessage$inboundSchema.parse(JSON.parse(g)), "Failed to parse 'AssistantMessage' from JSON");
    }
  }($a)), $a;
}
var Ja = {}, hS;
function Qd() {
  return hS || (hS = 1, function(t) {
    var e = Ja && Ja.__createBinding || (Object.create ? function(f, u, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(u, c);
      (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, u, c, h) {
      h === void 0 && (h = c), f[h] = u[c];
    }), n = Ja && Ja.__setModuleDefault || (Object.create ? function(f, u) {
      Object.defineProperty(f, "default", { enumerable: !0, value: u });
    } : function(f, u) {
      f.default = u;
    }), a = Ja && Ja.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var u = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(u, f, c);
      return n(u, f), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Prediction$ = t.Prediction$outboundSchema = t.Prediction$inboundSchema = void 0, t.predictionToJSON = o, t.predictionFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.Prediction$inboundSchema = r.object({
      type: r.literal("content").default("content"),
      content: r.string().default("")
    }), t.Prediction$outboundSchema = r.object({
      type: r.literal("content").default("content"),
      content: r.string().default("")
    });
    var s;
    (function(f) {
      f.inboundSchema = t.Prediction$inboundSchema, f.outboundSchema = t.Prediction$outboundSchema;
    })(s || (t.Prediction$ = s = {}));
    function o(f) {
      return JSON.stringify(t.Prediction$outboundSchema.parse(f));
    }
    function l(f) {
      return (0, i.safeParse)(f, (u) => t.Prediction$inboundSchema.parse(JSON.parse(u)), "Failed to parse 'Prediction' from JSON");
    }
  }(Ja)), Ja;
}
var La = {}, Ua = {}, pS;
function FT() {
  return pS || (pS = 1, function(t) {
    var e = Ua && Ua.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Ua && Ua.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Ua && Ua.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JsonSchema$ = t.JsonSchema$outboundSchema = t.JsonSchema$inboundSchema = void 0, t.jsonSchemaToJSON = l, t.jsonSchemaFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JsonSchema$inboundSchema = r.object({
      name: r.string(),
      description: r.nullable(r.string()).optional(),
      schema: r.record(r.any()),
      strict: r.boolean().default(!1)
    }).transform((u) => (0, i.remap)(u, {
      schema: "schemaDefinition"
    })), t.JsonSchema$outboundSchema = r.object({
      name: r.string(),
      description: r.nullable(r.string()).optional(),
      schemaDefinition: r.record(r.any()),
      strict: r.boolean().default(!1)
    }).transform((u) => (0, i.remap)(u, {
      schemaDefinition: "schema"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.JsonSchema$inboundSchema, u.outboundSchema = t.JsonSchema$outboundSchema;
    })(o || (t.JsonSchema$ = o = {}));
    function l(u) {
      return JSON.stringify(t.JsonSchema$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.JsonSchema$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JsonSchema' from JSON");
    }
  }(Ua)), Ua;
}
var Ba = {}, mS;
function DT() {
  return mS || (mS = 1, function(t) {
    var e = Ba && Ba.__createBinding || (Object.create ? function(s, o, l, f) {
      f === void 0 && (f = l);
      var u = Object.getOwnPropertyDescriptor(o, l);
      (!u || ("get" in u ? !o.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
        return o[l];
      } }), Object.defineProperty(s, f, u);
    } : function(s, o, l, f) {
      f === void 0 && (f = l), s[f] = o[l];
    }), n = Ba && Ba.__setModuleDefault || (Object.create ? function(s, o) {
      Object.defineProperty(s, "default", { enumerable: !0, value: o });
    } : function(s, o) {
      s.default = o;
    }), a = Ba && Ba.__importStar || function(s) {
      if (s && s.__esModule) return s;
      var o = {};
      if (s != null) for (var l in s) l !== "default" && Object.prototype.hasOwnProperty.call(s, l) && e(o, s, l);
      return n(o, s), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ResponseFormats$ = t.ResponseFormats$outboundSchema = t.ResponseFormats$inboundSchema = t.ResponseFormats = void 0;
    const r = a(/* @__PURE__ */ H());
    t.ResponseFormats = {
      Text: "text",
      JsonObject: "json_object",
      JsonSchema: "json_schema"
    }, t.ResponseFormats$inboundSchema = r.nativeEnum(t.ResponseFormats), t.ResponseFormats$outboundSchema = t.ResponseFormats$inboundSchema;
    var i;
    (function(s) {
      s.inboundSchema = t.ResponseFormats$inboundSchema, s.outboundSchema = t.ResponseFormats$outboundSchema;
    })(i || (t.ResponseFormats$ = i = {}));
  }(Ba)), Ba;
}
var bS;
function Yd() {
  return bS || (bS = 1, function(t) {
    var e = La && La.__createBinding || (Object.create ? function(h, p, d, m) {
      m === void 0 && (m = d);
      var b = Object.getOwnPropertyDescriptor(p, d);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[d];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, d, m) {
      m === void 0 && (m = d), h[m] = p[d];
    }), n = La && La.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = La && La.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var d in h) d !== "default" && Object.prototype.hasOwnProperty.call(h, d) && e(p, h, d);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ResponseFormat$ = t.ResponseFormat$outboundSchema = t.ResponseFormat$inboundSchema = void 0, t.responseFormatToJSON = u, t.responseFormatFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ FT(), l = /* @__PURE__ */ DT();
    t.ResponseFormat$inboundSchema = r.object({
      type: l.ResponseFormats$inboundSchema.optional(),
      json_schema: r.nullable(o.JsonSchema$inboundSchema).optional()
    }).transform((h) => (0, i.remap)(h, {
      json_schema: "jsonSchema"
    })), t.ResponseFormat$outboundSchema = r.object({
      type: l.ResponseFormats$outboundSchema.optional(),
      jsonSchema: r.nullable(o.JsonSchema$outboundSchema).optional()
    }).transform((h) => (0, i.remap)(h, {
      jsonSchema: "json_schema"
    }));
    var f;
    (function(h) {
      h.inboundSchema = t.ResponseFormat$inboundSchema, h.outboundSchema = t.ResponseFormat$outboundSchema;
    })(f || (t.ResponseFormat$ = f = {}));
    function u(h) {
      return JSON.stringify(t.ResponseFormat$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, s.safeParse)(h, (p) => t.ResponseFormat$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'ResponseFormat' from JSON");
    }
  }(La)), La;
}
var xa = {}, gS;
function hc() {
  return gS || (gS = 1, function(t) {
    var e = xa && xa.__createBinding || (Object.create ? function(d, m, b, g) {
      g === void 0 && (g = b);
      var _ = Object.getOwnPropertyDescriptor(m, b);
      (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
        return m[b];
      } }), Object.defineProperty(d, g, _);
    } : function(d, m, b, g) {
      g === void 0 && (g = b), d[g] = m[b];
    }), n = xa && xa.__setModuleDefault || (Object.create ? function(d, m) {
      Object.defineProperty(d, "default", { enumerable: !0, value: m });
    } : function(d, m) {
      d.default = m;
    }), a = xa && xa.__importStar || function(d) {
      if (d && d.__esModule) return d;
      var m = {};
      if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && e(m, d, b);
      return n(m, d), m;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SystemMessage$ = t.SystemMessage$outboundSchema = t.SystemMessage$inboundSchema = t.Role$ = t.Role$outboundSchema = t.Role$inboundSchema = t.SystemMessageContent$ = t.SystemMessageContent$outboundSchema = t.SystemMessageContent$inboundSchema = t.Role = void 0, t.systemMessageContentToJSON = l, t.systemMessageContentFromJSON = f, t.systemMessageToJSON = h, t.systemMessageFromJSON = p;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ J_();
    t.Role = {
      System: "system"
    }, t.SystemMessageContent$inboundSchema = r.union([r.string(), r.array(s.TextChunk$inboundSchema)]), t.SystemMessageContent$outboundSchema = r.union([r.string(), r.array(s.TextChunk$outboundSchema)]);
    var o;
    (function(d) {
      d.inboundSchema = t.SystemMessageContent$inboundSchema, d.outboundSchema = t.SystemMessageContent$outboundSchema;
    })(o || (t.SystemMessageContent$ = o = {}));
    function l(d) {
      return JSON.stringify(t.SystemMessageContent$outboundSchema.parse(d));
    }
    function f(d) {
      return (0, i.safeParse)(d, (m) => t.SystemMessageContent$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'SystemMessageContent' from JSON");
    }
    t.Role$inboundSchema = r.nativeEnum(t.Role), t.Role$outboundSchema = t.Role$inboundSchema;
    var u;
    (function(d) {
      d.inboundSchema = t.Role$inboundSchema, d.outboundSchema = t.Role$outboundSchema;
    })(u || (t.Role$ = u = {})), t.SystemMessage$inboundSchema = r.object({
      content: r.union([r.string(), r.array(s.TextChunk$inboundSchema)]),
      role: t.Role$inboundSchema.default("system")
    }), t.SystemMessage$outboundSchema = r.object({
      content: r.union([r.string(), r.array(s.TextChunk$outboundSchema)]),
      role: t.Role$outboundSchema.default("system")
    });
    var c;
    (function(d) {
      d.inboundSchema = t.SystemMessage$inboundSchema, d.outboundSchema = t.SystemMessage$outboundSchema;
    })(c || (t.SystemMessage$ = c = {}));
    function h(d) {
      return JSON.stringify(t.SystemMessage$outboundSchema.parse(d));
    }
    function p(d) {
      return (0, i.safeParse)(d, (m) => t.SystemMessage$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'SystemMessage' from JSON");
    }
  }(xa)), xa;
}
var Va = {}, za = {}, _S;
function qT() {
  return _S || (_S = 1, function(t) {
    var e = za && za.__createBinding || (Object.create ? function(f, u, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(u, c);
      (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, u, c, h) {
      h === void 0 && (h = c), f[h] = u[c];
    }), n = za && za.__setModuleDefault || (Object.create ? function(f, u) {
      Object.defineProperty(f, "default", { enumerable: !0, value: u });
    } : function(f, u) {
      f.default = u;
    }), a = za && za.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var u = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(u, f, c);
      return n(u, f), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FunctionT$ = t.FunctionT$outboundSchema = t.FunctionT$inboundSchema = void 0, t.functionToJSON = o, t.functionFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.FunctionT$inboundSchema = r.object({
      name: r.string(),
      description: r.string().default(""),
      strict: r.boolean().default(!1),
      parameters: r.record(r.any())
    }), t.FunctionT$outboundSchema = r.object({
      name: r.string(),
      description: r.string().default(""),
      strict: r.boolean().default(!1),
      parameters: r.record(r.any())
    });
    var s;
    (function(f) {
      f.inboundSchema = t.FunctionT$inboundSchema, f.outboundSchema = t.FunctionT$outboundSchema;
    })(s || (t.FunctionT$ = s = {}));
    function o(f) {
      return JSON.stringify(t.FunctionT$outboundSchema.parse(f));
    }
    function l(f) {
      return (0, i.safeParse)(f, (u) => t.FunctionT$inboundSchema.parse(JSON.parse(u)), "Failed to parse 'FunctionT' from JSON");
    }
  }(za)), za;
}
var yS;
function ef() {
  return yS || (yS = 1, function(t) {
    var e = Va && Va.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Va && Va.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Va && Va.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Tool$ = t.Tool$outboundSchema = t.Tool$inboundSchema = void 0, t.toolToJSON = f, t.toolFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ qT(), o = /* @__PURE__ */ Lp();
    t.Tool$inboundSchema = r.object({
      type: o.ToolTypes$inboundSchema.optional(),
      function: s.FunctionT$inboundSchema
    }), t.Tool$outboundSchema = r.object({
      type: o.ToolTypes$outboundSchema.optional(),
      function: s.FunctionT$outboundSchema
    });
    var l;
    (function(c) {
      c.inboundSchema = t.Tool$inboundSchema, c.outboundSchema = t.Tool$outboundSchema;
    })(l || (t.Tool$ = l = {}));
    function f(c) {
      return JSON.stringify(t.Tool$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, i.safeParse)(c, (h) => t.Tool$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'Tool' from JSON");
    }
  }(Va)), Va;
}
var Za = {}, Ka = {}, wS;
function JT() {
  return wS || (wS = 1, function(t) {
    var e = Ka && Ka.__createBinding || (Object.create ? function(f, u, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(u, c);
      (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, u, c, h) {
      h === void 0 && (h = c), f[h] = u[c];
    }), n = Ka && Ka.__setModuleDefault || (Object.create ? function(f, u) {
      Object.defineProperty(f, "default", { enumerable: !0, value: u });
    } : function(f, u) {
      f.default = u;
    }), a = Ka && Ka.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var u = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(u, f, c);
      return n(u, f), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FunctionName$ = t.FunctionName$outboundSchema = t.FunctionName$inboundSchema = void 0, t.functionNameToJSON = o, t.functionNameFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.FunctionName$inboundSchema = r.object({
      name: r.string()
    }), t.FunctionName$outboundSchema = r.object({
      name: r.string()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.FunctionName$inboundSchema, f.outboundSchema = t.FunctionName$outboundSchema;
    })(s || (t.FunctionName$ = s = {}));
    function o(f) {
      return JSON.stringify(t.FunctionName$outboundSchema.parse(f));
    }
    function l(f) {
      return (0, i.safeParse)(f, (u) => t.FunctionName$inboundSchema.parse(JSON.parse(u)), "Failed to parse 'FunctionName' from JSON");
    }
  }(Ka)), Ka;
}
var vS;
function tf() {
  return vS || (vS = 1, function(t) {
    var e = Za && Za.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Za && Za.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Za && Za.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ToolChoice$ = t.ToolChoice$outboundSchema = t.ToolChoice$inboundSchema = void 0, t.toolChoiceToJSON = f, t.toolChoiceFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ JT(), o = /* @__PURE__ */ Lp();
    t.ToolChoice$inboundSchema = r.object({
      type: o.ToolTypes$inboundSchema.optional(),
      function: s.FunctionName$inboundSchema
    }), t.ToolChoice$outboundSchema = r.object({
      type: o.ToolTypes$outboundSchema.optional(),
      function: s.FunctionName$outboundSchema
    });
    var l;
    (function(c) {
      c.inboundSchema = t.ToolChoice$inboundSchema, c.outboundSchema = t.ToolChoice$outboundSchema;
    })(l || (t.ToolChoice$ = l = {}));
    function f(c) {
      return JSON.stringify(t.ToolChoice$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, i.safeParse)(c, (h) => t.ToolChoice$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'ToolChoice' from JSON");
    }
  }(Za)), Za;
}
var Ha = {}, SS;
function nf() {
  return SS || (SS = 1, function(t) {
    var e = Ha && Ha.__createBinding || (Object.create ? function(s, o, l, f) {
      f === void 0 && (f = l);
      var u = Object.getOwnPropertyDescriptor(o, l);
      (!u || ("get" in u ? !o.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
        return o[l];
      } }), Object.defineProperty(s, f, u);
    } : function(s, o, l, f) {
      f === void 0 && (f = l), s[f] = o[l];
    }), n = Ha && Ha.__setModuleDefault || (Object.create ? function(s, o) {
      Object.defineProperty(s, "default", { enumerable: !0, value: o });
    } : function(s, o) {
      s.default = o;
    }), a = Ha && Ha.__importStar || function(s) {
      if (s && s.__esModule) return s;
      var o = {};
      if (s != null) for (var l in s) l !== "default" && Object.prototype.hasOwnProperty.call(s, l) && e(o, s, l);
      return n(o, s), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ToolChoiceEnum$ = t.ToolChoiceEnum$outboundSchema = t.ToolChoiceEnum$inboundSchema = t.ToolChoiceEnum = void 0;
    const r = a(/* @__PURE__ */ H());
    t.ToolChoiceEnum = {
      Auto: "auto",
      None: "none",
      Any: "any",
      Required: "required"
    }, t.ToolChoiceEnum$inboundSchema = r.nativeEnum(t.ToolChoiceEnum), t.ToolChoiceEnum$outboundSchema = t.ToolChoiceEnum$inboundSchema;
    var i;
    (function(s) {
      s.inboundSchema = t.ToolChoiceEnum$inboundSchema, s.outboundSchema = t.ToolChoiceEnum$outboundSchema;
    })(i || (t.ToolChoiceEnum$ = i = {}));
  }(Ha)), Ha;
}
var Ga = {}, OS;
function pc() {
  return OS || (OS = 1, function(t) {
    var e = Ga && Ga.__createBinding || (Object.create ? function(m, b, g, _) {
      _ === void 0 && (_ = g);
      var P = Object.getOwnPropertyDescriptor(b, g);
      (!P || ("get" in P ? !b.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
        return b[g];
      } }), Object.defineProperty(m, _, P);
    } : function(m, b, g, _) {
      _ === void 0 && (_ = g), m[_] = b[g];
    }), n = Ga && Ga.__setModuleDefault || (Object.create ? function(m, b) {
      Object.defineProperty(m, "default", { enumerable: !0, value: b });
    } : function(m, b) {
      m.default = b;
    }), a = Ga && Ga.__importStar || function(m) {
      if (m && m.__esModule) return m;
      var b = {};
      if (m != null) for (var g in m) g !== "default" && Object.prototype.hasOwnProperty.call(m, g) && e(b, m, g);
      return n(b, m), b;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ToolMessage$ = t.ToolMessage$outboundSchema = t.ToolMessage$inboundSchema = t.ToolMessageRole$ = t.ToolMessageRole$outboundSchema = t.ToolMessageRole$inboundSchema = t.ToolMessageContent$ = t.ToolMessageContent$outboundSchema = t.ToolMessageContent$inboundSchema = t.ToolMessageRole = void 0, t.toolMessageContentToJSON = f, t.toolMessageContentFromJSON = u, t.toolMessageToJSON = p, t.toolMessageFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Xd();
    t.ToolMessageRole = {
      Tool: "tool"
    }, t.ToolMessageContent$inboundSchema = r.union([r.string(), r.array(o.ContentChunk$inboundSchema)]), t.ToolMessageContent$outboundSchema = r.union([r.string(), r.array(o.ContentChunk$outboundSchema)]);
    var l;
    (function(m) {
      m.inboundSchema = t.ToolMessageContent$inboundSchema, m.outboundSchema = t.ToolMessageContent$outboundSchema;
    })(l || (t.ToolMessageContent$ = l = {}));
    function f(m) {
      return JSON.stringify(t.ToolMessageContent$outboundSchema.parse(m));
    }
    function u(m) {
      return (0, s.safeParse)(m, (b) => t.ToolMessageContent$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'ToolMessageContent' from JSON");
    }
    t.ToolMessageRole$inboundSchema = r.nativeEnum(t.ToolMessageRole), t.ToolMessageRole$outboundSchema = t.ToolMessageRole$inboundSchema;
    var c;
    (function(m) {
      m.inboundSchema = t.ToolMessageRole$inboundSchema, m.outboundSchema = t.ToolMessageRole$outboundSchema;
    })(c || (t.ToolMessageRole$ = c = {})), t.ToolMessage$inboundSchema = r.object({
      content: r.nullable(r.union([r.string(), r.array(o.ContentChunk$inboundSchema)])),
      tool_call_id: r.nullable(r.string()).optional(),
      name: r.nullable(r.string()).optional(),
      role: t.ToolMessageRole$inboundSchema.default("tool")
    }).transform((m) => (0, i.remap)(m, {
      tool_call_id: "toolCallId"
    })), t.ToolMessage$outboundSchema = r.object({
      content: r.nullable(r.union([r.string(), r.array(o.ContentChunk$outboundSchema)])),
      toolCallId: r.nullable(r.string()).optional(),
      name: r.nullable(r.string()).optional(),
      role: t.ToolMessageRole$outboundSchema.default("tool")
    }).transform((m) => (0, i.remap)(m, {
      toolCallId: "tool_call_id"
    }));
    var h;
    (function(m) {
      m.inboundSchema = t.ToolMessage$inboundSchema, m.outboundSchema = t.ToolMessage$outboundSchema;
    })(h || (t.ToolMessage$ = h = {}));
    function p(m) {
      return JSON.stringify(t.ToolMessage$outboundSchema.parse(m));
    }
    function d(m) {
      return (0, s.safeParse)(m, (b) => t.ToolMessage$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'ToolMessage' from JSON");
    }
  }(Ga)), Ga;
}
var Wa = {}, jS;
function mc() {
  return jS || (jS = 1, function(t) {
    var e = Wa && Wa.__createBinding || (Object.create ? function(d, m, b, g) {
      g === void 0 && (g = b);
      var _ = Object.getOwnPropertyDescriptor(m, b);
      (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
        return m[b];
      } }), Object.defineProperty(d, g, _);
    } : function(d, m, b, g) {
      g === void 0 && (g = b), d[g] = m[b];
    }), n = Wa && Wa.__setModuleDefault || (Object.create ? function(d, m) {
      Object.defineProperty(d, "default", { enumerable: !0, value: m });
    } : function(d, m) {
      d.default = m;
    }), a = Wa && Wa.__importStar || function(d) {
      if (d && d.__esModule) return d;
      var m = {};
      if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && e(m, d, b);
      return n(m, d), m;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.UserMessage$ = t.UserMessage$outboundSchema = t.UserMessage$inboundSchema = t.UserMessageRole$ = t.UserMessageRole$outboundSchema = t.UserMessageRole$inboundSchema = t.UserMessageContent$ = t.UserMessageContent$outboundSchema = t.UserMessageContent$inboundSchema = t.UserMessageRole = void 0, t.userMessageContentToJSON = l, t.userMessageContentFromJSON = f, t.userMessageToJSON = h, t.userMessageFromJSON = p;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ Xd();
    t.UserMessageRole = {
      User: "user"
    }, t.UserMessageContent$inboundSchema = r.union([r.string(), r.array(s.ContentChunk$inboundSchema)]), t.UserMessageContent$outboundSchema = r.union([r.string(), r.array(s.ContentChunk$outboundSchema)]);
    var o;
    (function(d) {
      d.inboundSchema = t.UserMessageContent$inboundSchema, d.outboundSchema = t.UserMessageContent$outboundSchema;
    })(o || (t.UserMessageContent$ = o = {}));
    function l(d) {
      return JSON.stringify(t.UserMessageContent$outboundSchema.parse(d));
    }
    function f(d) {
      return (0, i.safeParse)(d, (m) => t.UserMessageContent$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'UserMessageContent' from JSON");
    }
    t.UserMessageRole$inboundSchema = r.nativeEnum(t.UserMessageRole), t.UserMessageRole$outboundSchema = t.UserMessageRole$inboundSchema;
    var u;
    (function(d) {
      d.inboundSchema = t.UserMessageRole$inboundSchema, d.outboundSchema = t.UserMessageRole$outboundSchema;
    })(u || (t.UserMessageRole$ = u = {})), t.UserMessage$inboundSchema = r.object({
      content: r.nullable(r.union([r.string(), r.array(s.ContentChunk$inboundSchema)])),
      role: t.UserMessageRole$inboundSchema.default("user")
    }), t.UserMessage$outboundSchema = r.object({
      content: r.nullable(r.union([r.string(), r.array(s.ContentChunk$outboundSchema)])),
      role: t.UserMessageRole$outboundSchema.default("user")
    });
    var c;
    (function(d) {
      d.inboundSchema = t.UserMessage$inboundSchema, d.outboundSchema = t.UserMessage$outboundSchema;
    })(c || (t.UserMessage$ = c = {}));
    function h(d) {
      return JSON.stringify(t.UserMessage$outboundSchema.parse(d));
    }
    function p(d) {
      return (0, i.safeParse)(d, (m) => t.UserMessage$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'UserMessage' from JSON");
    }
  }(Wa)), Wa;
}
var PS;
function oJ() {
  return PS || (PS = 1, function(t) {
    var e = Ta && Ta.__createBinding || (Object.create ? function(w, k, L, B) {
      B === void 0 && (B = L);
      var V = Object.getOwnPropertyDescriptor(k, L);
      (!V || ("get" in V ? !k.__esModule : V.writable || V.configurable)) && (V = { enumerable: !0, get: function() {
        return k[L];
      } }), Object.defineProperty(w, B, V);
    } : function(w, k, L, B) {
      B === void 0 && (B = L), w[B] = k[L];
    }), n = Ta && Ta.__setModuleDefault || (Object.create ? function(w, k) {
      Object.defineProperty(w, "default", { enumerable: !0, value: k });
    } : function(w, k) {
      w.default = k;
    }), a = Ta && Ta.__importStar || function(w) {
      if (w && w.__esModule) return w;
      var k = {};
      if (w != null) for (var L in w) L !== "default" && Object.prototype.hasOwnProperty.call(w, L) && e(k, w, L);
      return n(k, w), k;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.AgentsCompletionRequest$ = t.AgentsCompletionRequest$outboundSchema = t.AgentsCompletionRequest$inboundSchema = t.AgentsCompletionRequestToolChoice$ = t.AgentsCompletionRequestToolChoice$outboundSchema = t.AgentsCompletionRequestToolChoice$inboundSchema = t.AgentsCompletionRequestMessages$ = t.AgentsCompletionRequestMessages$outboundSchema = t.AgentsCompletionRequestMessages$inboundSchema = t.AgentsCompletionRequestStop$ = t.AgentsCompletionRequestStop$outboundSchema = t.AgentsCompletionRequestStop$inboundSchema = void 0, t.agentsCompletionRequestStopToJSON = g, t.agentsCompletionRequestStopFromJSON = _, t.agentsCompletionRequestMessagesToJSON = C, t.agentsCompletionRequestMessagesFromJSON = R, t.agentsCompletionRequestToolChoiceToJSON = O, t.agentsCompletionRequestToolChoiceFromJSON = A, t.agentsCompletionRequestToJSON = I, t.agentsCompletionRequestFromJSON = N;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ su(), l = /* @__PURE__ */ Qd(), f = /* @__PURE__ */ Yd(), u = /* @__PURE__ */ hc(), c = /* @__PURE__ */ ef(), h = /* @__PURE__ */ tf(), p = /* @__PURE__ */ nf(), d = /* @__PURE__ */ pc(), m = /* @__PURE__ */ mc();
    t.AgentsCompletionRequestStop$inboundSchema = r.union([r.string(), r.array(r.string())]), t.AgentsCompletionRequestStop$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var b;
    (function(w) {
      w.inboundSchema = t.AgentsCompletionRequestStop$inboundSchema, w.outboundSchema = t.AgentsCompletionRequestStop$outboundSchema;
    })(b || (t.AgentsCompletionRequestStop$ = b = {}));
    function g(w) {
      return JSON.stringify(t.AgentsCompletionRequestStop$outboundSchema.parse(w));
    }
    function _(w) {
      return (0, s.safeParse)(w, (k) => t.AgentsCompletionRequestStop$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'AgentsCompletionRequestStop' from JSON");
    }
    t.AgentsCompletionRequestMessages$inboundSchema = r.union([
      u.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
        role: w.role
      }))),
      m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({ role: w.role }))),
      o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
        role: w.role
      }))),
      d.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({ role: w.role })))
    ]), t.AgentsCompletionRequestMessages$outboundSchema = r.union([
      u.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
        role: w.role
      }))),
      m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({ role: w.role }))),
      o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
        role: w.role
      }))),
      d.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({ role: w.role })))
    ]);
    var P;
    (function(w) {
      w.inboundSchema = t.AgentsCompletionRequestMessages$inboundSchema, w.outboundSchema = t.AgentsCompletionRequestMessages$outboundSchema;
    })(P || (t.AgentsCompletionRequestMessages$ = P = {}));
    function C(w) {
      return JSON.stringify(t.AgentsCompletionRequestMessages$outboundSchema.parse(w));
    }
    function R(w) {
      return (0, s.safeParse)(w, (k) => t.AgentsCompletionRequestMessages$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'AgentsCompletionRequestMessages' from JSON");
    }
    t.AgentsCompletionRequestToolChoice$inboundSchema = r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]), t.AgentsCompletionRequestToolChoice$outboundSchema = r.union([h.ToolChoice$outboundSchema, p.ToolChoiceEnum$outboundSchema]);
    var T;
    (function(w) {
      w.inboundSchema = t.AgentsCompletionRequestToolChoice$inboundSchema, w.outboundSchema = t.AgentsCompletionRequestToolChoice$outboundSchema;
    })(T || (t.AgentsCompletionRequestToolChoice$ = T = {}));
    function O(w) {
      return JSON.stringify(t.AgentsCompletionRequestToolChoice$outboundSchema.parse(w));
    }
    function A(w) {
      return (0, s.safeParse)(w, (k) => t.AgentsCompletionRequestToolChoice$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'AgentsCompletionRequestToolChoice' from JSON");
    }
    t.AgentsCompletionRequest$inboundSchema = r.object({
      max_tokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!1),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      random_seed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        u.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
          role: w.role
        }))),
        m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({
          role: w.role
        }))),
        o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
          role: w.role
        }))),
        d.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({
          role: w.role
        })))
      ])),
      response_format: f.ResponseFormat$inboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$inboundSchema)).optional(),
      tool_choice: r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]).optional(),
      presence_penalty: r.number().optional(),
      frequency_penalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: l.Prediction$inboundSchema.optional(),
      agent_id: r.string()
    }).transform((w) => (0, i.remap)(w, {
      max_tokens: "maxTokens",
      random_seed: "randomSeed",
      response_format: "responseFormat",
      tool_choice: "toolChoice",
      presence_penalty: "presencePenalty",
      frequency_penalty: "frequencyPenalty",
      agent_id: "agentId"
    })), t.AgentsCompletionRequest$outboundSchema = r.object({
      maxTokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!1),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      randomSeed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        u.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
          role: w.role
        }))),
        m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({
          role: w.role
        }))),
        o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
          role: w.role
        }))),
        d.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({
          role: w.role
        })))
      ])),
      responseFormat: f.ResponseFormat$outboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$outboundSchema)).optional(),
      toolChoice: r.union([
        h.ToolChoice$outboundSchema,
        p.ToolChoiceEnum$outboundSchema
      ]).optional(),
      presencePenalty: r.number().optional(),
      frequencyPenalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: l.Prediction$outboundSchema.optional(),
      agentId: r.string()
    }).transform((w) => (0, i.remap)(w, {
      maxTokens: "max_tokens",
      randomSeed: "random_seed",
      responseFormat: "response_format",
      toolChoice: "tool_choice",
      presencePenalty: "presence_penalty",
      frequencyPenalty: "frequency_penalty",
      agentId: "agent_id"
    }));
    var M;
    (function(w) {
      w.inboundSchema = t.AgentsCompletionRequest$inboundSchema, w.outboundSchema = t.AgentsCompletionRequest$outboundSchema;
    })(M || (t.AgentsCompletionRequest$ = M = {}));
    function I(w) {
      return JSON.stringify(t.AgentsCompletionRequest$outboundSchema.parse(w));
    }
    function N(w) {
      return (0, s.safeParse)(w, (k) => t.AgentsCompletionRequest$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'AgentsCompletionRequest' from JSON");
    }
  }(Ta)), Ta;
}
var Xa = {}, RS;
function uJ() {
  return RS || (RS = 1, function(t) {
    var e = Xa && Xa.__createBinding || (Object.create ? function(w, k, L, B) {
      B === void 0 && (B = L);
      var V = Object.getOwnPropertyDescriptor(k, L);
      (!V || ("get" in V ? !k.__esModule : V.writable || V.configurable)) && (V = { enumerable: !0, get: function() {
        return k[L];
      } }), Object.defineProperty(w, B, V);
    } : function(w, k, L, B) {
      B === void 0 && (B = L), w[B] = k[L];
    }), n = Xa && Xa.__setModuleDefault || (Object.create ? function(w, k) {
      Object.defineProperty(w, "default", { enumerable: !0, value: k });
    } : function(w, k) {
      w.default = k;
    }), a = Xa && Xa.__importStar || function(w) {
      if (w && w.__esModule) return w;
      var k = {};
      if (w != null) for (var L in w) L !== "default" && Object.prototype.hasOwnProperty.call(w, L) && e(k, w, L);
      return n(k, w), k;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.AgentsCompletionStreamRequest$ = t.AgentsCompletionStreamRequest$outboundSchema = t.AgentsCompletionStreamRequest$inboundSchema = t.AgentsCompletionStreamRequestToolChoice$ = t.AgentsCompletionStreamRequestToolChoice$outboundSchema = t.AgentsCompletionStreamRequestToolChoice$inboundSchema = t.AgentsCompletionStreamRequestMessages$ = t.AgentsCompletionStreamRequestMessages$outboundSchema = t.AgentsCompletionStreamRequestMessages$inboundSchema = t.AgentsCompletionStreamRequestStop$ = t.AgentsCompletionStreamRequestStop$outboundSchema = t.AgentsCompletionStreamRequestStop$inboundSchema = void 0, t.agentsCompletionStreamRequestStopToJSON = g, t.agentsCompletionStreamRequestStopFromJSON = _, t.agentsCompletionStreamRequestMessagesToJSON = C, t.agentsCompletionStreamRequestMessagesFromJSON = R, t.agentsCompletionStreamRequestToolChoiceToJSON = O, t.agentsCompletionStreamRequestToolChoiceFromJSON = A, t.agentsCompletionStreamRequestToJSON = I, t.agentsCompletionStreamRequestFromJSON = N;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ su(), l = /* @__PURE__ */ Qd(), f = /* @__PURE__ */ Yd(), u = /* @__PURE__ */ hc(), c = /* @__PURE__ */ ef(), h = /* @__PURE__ */ tf(), p = /* @__PURE__ */ nf(), d = /* @__PURE__ */ pc(), m = /* @__PURE__ */ mc();
    t.AgentsCompletionStreamRequestStop$inboundSchema = r.union([r.string(), r.array(r.string())]), t.AgentsCompletionStreamRequestStop$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var b;
    (function(w) {
      w.inboundSchema = t.AgentsCompletionStreamRequestStop$inboundSchema, w.outboundSchema = t.AgentsCompletionStreamRequestStop$outboundSchema;
    })(b || (t.AgentsCompletionStreamRequestStop$ = b = {}));
    function g(w) {
      return JSON.stringify(t.AgentsCompletionStreamRequestStop$outboundSchema.parse(w));
    }
    function _(w) {
      return (0, s.safeParse)(w, (k) => t.AgentsCompletionStreamRequestStop$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'AgentsCompletionStreamRequestStop' from JSON");
    }
    t.AgentsCompletionStreamRequestMessages$inboundSchema = r.union([
      u.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
        role: w.role
      }))),
      m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({ role: w.role }))),
      o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
        role: w.role
      }))),
      d.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({ role: w.role })))
    ]), t.AgentsCompletionStreamRequestMessages$outboundSchema = r.union([
      u.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
        role: w.role
      }))),
      m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({ role: w.role }))),
      o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
        role: w.role
      }))),
      d.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({ role: w.role })))
    ]);
    var P;
    (function(w) {
      w.inboundSchema = t.AgentsCompletionStreamRequestMessages$inboundSchema, w.outboundSchema = t.AgentsCompletionStreamRequestMessages$outboundSchema;
    })(P || (t.AgentsCompletionStreamRequestMessages$ = P = {}));
    function C(w) {
      return JSON.stringify(t.AgentsCompletionStreamRequestMessages$outboundSchema.parse(w));
    }
    function R(w) {
      return (0, s.safeParse)(w, (k) => t.AgentsCompletionStreamRequestMessages$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'AgentsCompletionStreamRequestMessages' from JSON");
    }
    t.AgentsCompletionStreamRequestToolChoice$inboundSchema = r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]), t.AgentsCompletionStreamRequestToolChoice$outboundSchema = r.union([h.ToolChoice$outboundSchema, p.ToolChoiceEnum$outboundSchema]);
    var T;
    (function(w) {
      w.inboundSchema = t.AgentsCompletionStreamRequestToolChoice$inboundSchema, w.outboundSchema = t.AgentsCompletionStreamRequestToolChoice$outboundSchema;
    })(T || (t.AgentsCompletionStreamRequestToolChoice$ = T = {}));
    function O(w) {
      return JSON.stringify(t.AgentsCompletionStreamRequestToolChoice$outboundSchema.parse(w));
    }
    function A(w) {
      return (0, s.safeParse)(w, (k) => t.AgentsCompletionStreamRequestToolChoice$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'AgentsCompletionStreamRequestToolChoice' from JSON");
    }
    t.AgentsCompletionStreamRequest$inboundSchema = r.object({
      max_tokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!0),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      random_seed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        u.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
          role: w.role
        }))),
        m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({
          role: w.role
        }))),
        o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
          role: w.role
        }))),
        d.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({
          role: w.role
        })))
      ])),
      response_format: f.ResponseFormat$inboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$inboundSchema)).optional(),
      tool_choice: r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]).optional(),
      presence_penalty: r.number().optional(),
      frequency_penalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: l.Prediction$inboundSchema.optional(),
      agent_id: r.string()
    }).transform((w) => (0, i.remap)(w, {
      max_tokens: "maxTokens",
      random_seed: "randomSeed",
      response_format: "responseFormat",
      tool_choice: "toolChoice",
      presence_penalty: "presencePenalty",
      frequency_penalty: "frequencyPenalty",
      agent_id: "agentId"
    })), t.AgentsCompletionStreamRequest$outboundSchema = r.object({
      maxTokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!0),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      randomSeed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        u.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
          role: w.role
        }))),
        m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({
          role: w.role
        }))),
        o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
          role: w.role
        }))),
        d.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({
          role: w.role
        })))
      ])),
      responseFormat: f.ResponseFormat$outboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$outboundSchema)).optional(),
      toolChoice: r.union([
        h.ToolChoice$outboundSchema,
        p.ToolChoiceEnum$outboundSchema
      ]).optional(),
      presencePenalty: r.number().optional(),
      frequencyPenalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: l.Prediction$outboundSchema.optional(),
      agentId: r.string()
    }).transform((w) => (0, i.remap)(w, {
      maxTokens: "max_tokens",
      randomSeed: "random_seed",
      responseFormat: "response_format",
      toolChoice: "tool_choice",
      presencePenalty: "presence_penalty",
      frequencyPenalty: "frequency_penalty",
      agentId: "agent_id"
    }));
    var M;
    (function(w) {
      w.inboundSchema = t.AgentsCompletionStreamRequest$inboundSchema, w.outboundSchema = t.AgentsCompletionStreamRequest$outboundSchema;
    })(M || (t.AgentsCompletionStreamRequest$ = M = {}));
    function I(w) {
      return JSON.stringify(t.AgentsCompletionStreamRequest$outboundSchema.parse(w));
    }
    function N(w) {
      return (0, s.safeParse)(w, (k) => t.AgentsCompletionStreamRequest$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'AgentsCompletionStreamRequest' from JSON");
    }
  }(Xa)), Xa;
}
var Qa = {}, CS;
function LT() {
  return CS || (CS = 1, function(t) {
    var e = Qa && Qa.__createBinding || (Object.create ? function(o, l, f, u) {
      u === void 0 && (u = f);
      var c = Object.getOwnPropertyDescriptor(l, f);
      (!c || ("get" in c ? !l.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return l[f];
      } }), Object.defineProperty(o, u, c);
    } : function(o, l, f, u) {
      u === void 0 && (u = f), o[u] = l[f];
    }), n = Qa && Qa.__setModuleDefault || (Object.create ? function(o, l) {
      Object.defineProperty(o, "default", { enumerable: !0, value: l });
    } : function(o, l) {
      o.default = l;
    }), a = Qa && Qa.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var l = {};
      if (o != null) for (var f in o) f !== "default" && Object.prototype.hasOwnProperty.call(o, f) && e(l, o, f);
      return n(l, o), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ApiEndpoint$ = t.ApiEndpoint$outboundSchema = t.ApiEndpoint$inboundSchema = t.ApiEndpoint = void 0;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ iu();
    t.ApiEndpoint = {
      RootV1ChatCompletions: "/v1/chat/completions",
      RootV1Embeddings: "/v1/embeddings",
      RootV1FimCompletions: "/v1/fim/completions",
      RootV1Moderations: "/v1/moderations",
      RootV1ChatModerations: "/v1/chat/moderations"
    }, t.ApiEndpoint$inboundSchema = r.union([
      r.nativeEnum(t.ApiEndpoint),
      r.string().transform(i.catchUnrecognizedEnum)
    ]), t.ApiEndpoint$outboundSchema = r.union([
      r.nativeEnum(t.ApiEndpoint),
      r.string().and(r.custom())
    ]);
    var s;
    (function(o) {
      o.inboundSchema = t.ApiEndpoint$inboundSchema, o.outboundSchema = t.ApiEndpoint$outboundSchema;
    })(s || (t.ApiEndpoint$ = s = {}));
  }(Qa)), Qa;
}
var Ya = {}, TS;
function cJ() {
  return TS || (TS = 1, function(t) {
    var e = Ya && Ya.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Ya && Ya.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Ya && Ya.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ArchiveFTModelOut$ = t.ArchiveFTModelOut$outboundSchema = t.ArchiveFTModelOut$inboundSchema = t.ArchiveFTModelOutObject$ = t.ArchiveFTModelOutObject$outboundSchema = t.ArchiveFTModelOutObject$inboundSchema = t.ArchiveFTModelOutObject = void 0, t.archiveFTModelOutToJSON = l, t.archiveFTModelOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.ArchiveFTModelOutObject = {
      Model: "model"
    }, t.ArchiveFTModelOutObject$inboundSchema = r.nativeEnum(t.ArchiveFTModelOutObject), t.ArchiveFTModelOutObject$outboundSchema = t.ArchiveFTModelOutObject$inboundSchema;
    var s;
    (function(u) {
      u.inboundSchema = t.ArchiveFTModelOutObject$inboundSchema, u.outboundSchema = t.ArchiveFTModelOutObject$outboundSchema;
    })(s || (t.ArchiveFTModelOutObject$ = s = {})), t.ArchiveFTModelOut$inboundSchema = r.object({
      id: r.string(),
      object: r.literal("model").default("model"),
      archived: r.boolean().default(!0)
    }), t.ArchiveFTModelOut$outboundSchema = r.object({
      id: r.string(),
      object: r.literal("model").default("model"),
      archived: r.boolean().default(!0)
    });
    var o;
    (function(u) {
      u.inboundSchema = t.ArchiveFTModelOut$inboundSchema, u.outboundSchema = t.ArchiveFTModelOut$outboundSchema;
    })(o || (t.ArchiveFTModelOut$ = o = {}));
    function l(u) {
      return JSON.stringify(t.ArchiveFTModelOut$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, i.safeParse)(u, (c) => t.ArchiveFTModelOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'ArchiveFTModelOut' from JSON");
    }
  }(Ya)), Ya;
}
var ei = {}, ti = {}, $S;
function U_() {
  return $S || ($S = 1, function(t) {
    var e = ti && ti.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = ti && ti.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = ti && ti.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ModelCapabilities$ = t.ModelCapabilities$outboundSchema = t.ModelCapabilities$inboundSchema = void 0, t.modelCapabilitiesToJSON = l, t.modelCapabilitiesFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.ModelCapabilities$inboundSchema = r.object({
      completion_chat: r.boolean().default(!0),
      completion_fim: r.boolean().default(!1),
      function_calling: r.boolean().default(!0),
      fine_tuning: r.boolean().default(!1),
      vision: r.boolean().default(!1)
    }).transform((u) => (0, i.remap)(u, {
      completion_chat: "completionChat",
      completion_fim: "completionFim",
      function_calling: "functionCalling",
      fine_tuning: "fineTuning"
    })), t.ModelCapabilities$outboundSchema = r.object({
      completionChat: r.boolean().default(!0),
      completionFim: r.boolean().default(!1),
      functionCalling: r.boolean().default(!0),
      fineTuning: r.boolean().default(!1),
      vision: r.boolean().default(!1)
    }).transform((u) => (0, i.remap)(u, {
      completionChat: "completion_chat",
      completionFim: "completion_fim",
      functionCalling: "function_calling",
      fineTuning: "fine_tuning"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.ModelCapabilities$inboundSchema, u.outboundSchema = t.ModelCapabilities$outboundSchema;
    })(o || (t.ModelCapabilities$ = o = {}));
    function l(u) {
      return JSON.stringify(t.ModelCapabilities$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.ModelCapabilities$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'ModelCapabilities' from JSON");
    }
  }(ti)), ti;
}
var MS;
function UT() {
  return MS || (MS = 1, function(t) {
    var e = ei && ei.__createBinding || (Object.create ? function(h, p, d, m) {
      m === void 0 && (m = d);
      var b = Object.getOwnPropertyDescriptor(p, d);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[d];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, d, m) {
      m === void 0 && (m = d), h[m] = p[d];
    }), n = ei && ei.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = ei && ei.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var d in h) d !== "default" && Object.prototype.hasOwnProperty.call(h, d) && e(p, h, d);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseModelCard$ = t.BaseModelCard$outboundSchema = t.BaseModelCard$inboundSchema = t.Type$ = t.Type$outboundSchema = t.Type$inboundSchema = t.Type = void 0, t.baseModelCardToJSON = u, t.baseModelCardFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ U_();
    t.Type = {
      Base: "base"
    }, t.Type$inboundSchema = r.nativeEnum(t.Type), t.Type$outboundSchema = t.Type$inboundSchema;
    var l;
    (function(h) {
      h.inboundSchema = t.Type$inboundSchema, h.outboundSchema = t.Type$outboundSchema;
    })(l || (t.Type$ = l = {})), t.BaseModelCard$inboundSchema = r.object({
      id: r.string(),
      object: r.string().default("model"),
      created: r.number().int().optional(),
      owned_by: r.string().default("mistralai"),
      capabilities: o.ModelCapabilities$inboundSchema,
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional(),
      max_context_length: r.number().int().default(32768),
      aliases: r.array(r.string()).optional(),
      deprecation: r.nullable(r.string().datetime({ offset: !0 }).transform((h) => new Date(h))).optional(),
      default_model_temperature: r.nullable(r.number()).optional(),
      type: r.literal("base").default("base")
    }).transform((h) => (0, i.remap)(h, {
      owned_by: "ownedBy",
      max_context_length: "maxContextLength",
      default_model_temperature: "defaultModelTemperature"
    })), t.BaseModelCard$outboundSchema = r.object({
      id: r.string(),
      object: r.string().default("model"),
      created: r.number().int().optional(),
      ownedBy: r.string().default("mistralai"),
      capabilities: o.ModelCapabilities$outboundSchema,
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional(),
      maxContextLength: r.number().int().default(32768),
      aliases: r.array(r.string()).optional(),
      deprecation: r.nullable(r.date().transform((h) => h.toISOString())).optional(),
      defaultModelTemperature: r.nullable(r.number()).optional(),
      type: r.literal("base").default("base")
    }).transform((h) => (0, i.remap)(h, {
      ownedBy: "owned_by",
      maxContextLength: "max_context_length",
      defaultModelTemperature: "default_model_temperature"
    }));
    var f;
    (function(h) {
      h.inboundSchema = t.BaseModelCard$inboundSchema, h.outboundSchema = t.BaseModelCard$outboundSchema;
    })(f || (t.BaseModelCard$ = f = {}));
    function u(h) {
      return JSON.stringify(t.BaseModelCard$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, s.safeParse)(h, (p) => t.BaseModelCard$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'BaseModelCard' from JSON");
    }
  }(ei)), ei;
}
var ni = {}, AS;
function BT() {
  return AS || (AS = 1, function(t) {
    var e = ni && ni.__createBinding || (Object.create ? function(f, u, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(u, c);
      (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, u, c, h) {
      h === void 0 && (h = c), f[h] = u[c];
    }), n = ni && ni.__setModuleDefault || (Object.create ? function(f, u) {
      Object.defineProperty(f, "default", { enumerable: !0, value: u });
    } : function(f, u) {
      f.default = u;
    }), a = ni && ni.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var u = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(u, f, c);
      return n(u, f), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.BatchError$ = t.BatchError$outboundSchema = t.BatchError$inboundSchema = void 0, t.batchErrorToJSON = o, t.batchErrorFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.BatchError$inboundSchema = r.object({
      message: r.string(),
      count: r.number().int().default(1)
    }), t.BatchError$outboundSchema = r.object({
      message: r.string(),
      count: r.number().int().default(1)
    });
    var s;
    (function(f) {
      f.inboundSchema = t.BatchError$inboundSchema, f.outboundSchema = t.BatchError$outboundSchema;
    })(s || (t.BatchError$ = s = {}));
    function o(f) {
      return JSON.stringify(t.BatchError$outboundSchema.parse(f));
    }
    function l(f) {
      return (0, i.safeParse)(f, (u) => t.BatchError$inboundSchema.parse(JSON.parse(u)), "Failed to parse 'BatchError' from JSON");
    }
  }(ni)), ni;
}
var ri = {}, ES;
function lJ() {
  return ES || (ES = 1, function(t) {
    var e = ri && ri.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = ri && ri.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = ri && ri.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.BatchJobIn$ = t.BatchJobIn$outboundSchema = t.BatchJobIn$inboundSchema = void 0, t.batchJobInToJSON = f, t.batchJobInFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ LT();
    t.BatchJobIn$inboundSchema = r.object({
      input_files: r.array(r.string()),
      endpoint: o.ApiEndpoint$inboundSchema,
      model: r.string(),
      metadata: r.nullable(r.record(r.string())).optional(),
      timeout_hours: r.number().int().default(24)
    }).transform((c) => (0, i.remap)(c, {
      input_files: "inputFiles",
      timeout_hours: "timeoutHours"
    })), t.BatchJobIn$outboundSchema = r.object({
      inputFiles: r.array(r.string()),
      endpoint: o.ApiEndpoint$outboundSchema,
      model: r.string(),
      metadata: r.nullable(r.record(r.string())).optional(),
      timeoutHours: r.number().int().default(24)
    }).transform((c) => (0, i.remap)(c, {
      inputFiles: "input_files",
      timeoutHours: "timeout_hours"
    }));
    var l;
    (function(c) {
      c.inboundSchema = t.BatchJobIn$inboundSchema, c.outboundSchema = t.BatchJobIn$outboundSchema;
    })(l || (t.BatchJobIn$ = l = {}));
    function f(c) {
      return JSON.stringify(t.BatchJobIn$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, s.safeParse)(c, (h) => t.BatchJobIn$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'BatchJobIn' from JSON");
    }
  }(ri)), ri;
}
var ai = {}, ii = {}, IS;
function xT() {
  return IS || (IS = 1, function(t) {
    var e = ii && ii.__createBinding || (Object.create ? function(s, o, l, f) {
      f === void 0 && (f = l);
      var u = Object.getOwnPropertyDescriptor(o, l);
      (!u || ("get" in u ? !o.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
        return o[l];
      } }), Object.defineProperty(s, f, u);
    } : function(s, o, l, f) {
      f === void 0 && (f = l), s[f] = o[l];
    }), n = ii && ii.__setModuleDefault || (Object.create ? function(s, o) {
      Object.defineProperty(s, "default", { enumerable: !0, value: o });
    } : function(s, o) {
      s.default = o;
    }), a = ii && ii.__importStar || function(s) {
      if (s && s.__esModule) return s;
      var o = {};
      if (s != null) for (var l in s) l !== "default" && Object.prototype.hasOwnProperty.call(s, l) && e(o, s, l);
      return n(o, s), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.BatchJobStatus$ = t.BatchJobStatus$outboundSchema = t.BatchJobStatus$inboundSchema = t.BatchJobStatus = void 0;
    const r = a(/* @__PURE__ */ H());
    t.BatchJobStatus = {
      Queued: "QUEUED",
      Running: "RUNNING",
      Success: "SUCCESS",
      Failed: "FAILED",
      TimeoutExceeded: "TIMEOUT_EXCEEDED",
      CancellationRequested: "CANCELLATION_REQUESTED",
      Cancelled: "CANCELLED"
    }, t.BatchJobStatus$inboundSchema = r.nativeEnum(t.BatchJobStatus), t.BatchJobStatus$outboundSchema = t.BatchJobStatus$inboundSchema;
    var i;
    (function(s) {
      s.inboundSchema = t.BatchJobStatus$inboundSchema, s.outboundSchema = t.BatchJobStatus$outboundSchema;
    })(i || (t.BatchJobStatus$ = i = {}));
  }(ii)), ii;
}
var NS;
function VT() {
  return NS || (NS = 1, function(t) {
    var e = ai && ai.__createBinding || (Object.create ? function(p, d, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(d, m);
      (!g || ("get" in g ? !d.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return d[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, d, m, b) {
      b === void 0 && (b = m), p[b] = d[m];
    }), n = ai && ai.__setModuleDefault || (Object.create ? function(p, d) {
      Object.defineProperty(p, "default", { enumerable: !0, value: d });
    } : function(p, d) {
      p.default = d;
    }), a = ai && ai.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(d, p, m);
      return n(d, p), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.BatchJobOut$ = t.BatchJobOut$outboundSchema = t.BatchJobOut$inboundSchema = t.BatchJobOutObject$ = t.BatchJobOutObject$outboundSchema = t.BatchJobOutObject$inboundSchema = t.BatchJobOutObject = void 0, t.batchJobOutToJSON = c, t.batchJobOutFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ BT(), l = /* @__PURE__ */ xT();
    t.BatchJobOutObject = {
      Batch: "batch"
    }, t.BatchJobOutObject$inboundSchema = r.nativeEnum(t.BatchJobOutObject), t.BatchJobOutObject$outboundSchema = t.BatchJobOutObject$inboundSchema;
    var f;
    (function(p) {
      p.inboundSchema = t.BatchJobOutObject$inboundSchema, p.outboundSchema = t.BatchJobOutObject$outboundSchema;
    })(f || (t.BatchJobOutObject$ = f = {})), t.BatchJobOut$inboundSchema = r.object({
      id: r.string(),
      object: r.literal("batch").default("batch"),
      input_files: r.array(r.string()),
      metadata: r.nullable(r.record(r.any())).optional(),
      endpoint: r.string(),
      model: r.string(),
      output_file: r.nullable(r.string()).optional(),
      error_file: r.nullable(r.string()).optional(),
      errors: r.array(o.BatchError$inboundSchema),
      status: l.BatchJobStatus$inboundSchema,
      created_at: r.number().int(),
      total_requests: r.number().int(),
      completed_requests: r.number().int(),
      succeeded_requests: r.number().int(),
      failed_requests: r.number().int(),
      started_at: r.nullable(r.number().int()).optional(),
      completed_at: r.nullable(r.number().int()).optional()
    }).transform((p) => (0, i.remap)(p, {
      input_files: "inputFiles",
      output_file: "outputFile",
      error_file: "errorFile",
      created_at: "createdAt",
      total_requests: "totalRequests",
      completed_requests: "completedRequests",
      succeeded_requests: "succeededRequests",
      failed_requests: "failedRequests",
      started_at: "startedAt",
      completed_at: "completedAt"
    })), t.BatchJobOut$outboundSchema = r.object({
      id: r.string(),
      object: r.literal("batch").default("batch"),
      inputFiles: r.array(r.string()),
      metadata: r.nullable(r.record(r.any())).optional(),
      endpoint: r.string(),
      model: r.string(),
      outputFile: r.nullable(r.string()).optional(),
      errorFile: r.nullable(r.string()).optional(),
      errors: r.array(o.BatchError$outboundSchema),
      status: l.BatchJobStatus$outboundSchema,
      createdAt: r.number().int(),
      totalRequests: r.number().int(),
      completedRequests: r.number().int(),
      succeededRequests: r.number().int(),
      failedRequests: r.number().int(),
      startedAt: r.nullable(r.number().int()).optional(),
      completedAt: r.nullable(r.number().int()).optional()
    }).transform((p) => (0, i.remap)(p, {
      inputFiles: "input_files",
      outputFile: "output_file",
      errorFile: "error_file",
      createdAt: "created_at",
      totalRequests: "total_requests",
      completedRequests: "completed_requests",
      succeededRequests: "succeeded_requests",
      failedRequests: "failed_requests",
      startedAt: "started_at",
      completedAt: "completed_at"
    }));
    var u;
    (function(p) {
      p.inboundSchema = t.BatchJobOut$inboundSchema, p.outboundSchema = t.BatchJobOut$outboundSchema;
    })(u || (t.BatchJobOut$ = u = {}));
    function c(p) {
      return JSON.stringify(t.BatchJobOut$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (d) => t.BatchJobOut$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'BatchJobOut' from JSON");
    }
  }(ai)), ai;
}
var si = {}, kS;
function dJ() {
  return kS || (kS = 1, function(t) {
    var e = si && si.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = si && si.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = si && si.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.BatchJobsOut$ = t.BatchJobsOut$outboundSchema = t.BatchJobsOut$inboundSchema = t.BatchJobsOutObject$ = t.BatchJobsOutObject$outboundSchema = t.BatchJobsOutObject$inboundSchema = t.BatchJobsOutObject = void 0, t.batchJobsOutToJSON = f, t.batchJobsOutFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ VT();
    t.BatchJobsOutObject = {
      List: "list"
    }, t.BatchJobsOutObject$inboundSchema = r.nativeEnum(t.BatchJobsOutObject), t.BatchJobsOutObject$outboundSchema = t.BatchJobsOutObject$inboundSchema;
    var o;
    (function(c) {
      c.inboundSchema = t.BatchJobsOutObject$inboundSchema, c.outboundSchema = t.BatchJobsOutObject$outboundSchema;
    })(o || (t.BatchJobsOutObject$ = o = {})), t.BatchJobsOut$inboundSchema = r.object({
      data: r.array(s.BatchJobOut$inboundSchema).optional(),
      object: r.literal("list").default("list"),
      total: r.number().int()
    }), t.BatchJobsOut$outboundSchema = r.object({
      data: r.array(s.BatchJobOut$outboundSchema).optional(),
      object: r.literal("list").default("list"),
      total: r.number().int()
    });
    var l;
    (function(c) {
      c.inboundSchema = t.BatchJobsOut$inboundSchema, c.outboundSchema = t.BatchJobsOut$outboundSchema;
    })(l || (t.BatchJobsOut$ = l = {}));
    function f(c) {
      return JSON.stringify(t.BatchJobsOut$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, i.safeParse)(c, (h) => t.BatchJobsOut$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'BatchJobsOut' from JSON");
    }
  }(si)), si;
}
var oi = {}, FS;
function B_() {
  return FS || (FS = 1, function(t) {
    var e = oi && oi.__createBinding || (Object.create ? function(p, d, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(d, m);
      (!g || ("get" in g ? !d.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return d[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, d, m, b) {
      b === void 0 && (b = m), p[b] = d[m];
    }), n = oi && oi.__setModuleDefault || (Object.create ? function(p, d) {
      Object.defineProperty(p, "default", { enumerable: !0, value: d });
    } : function(p, d) {
      p.default = d;
    }), a = oi && oi.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(d, p, m);
      return n(d, p), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ChatCompletionChoice$ = t.ChatCompletionChoice$outboundSchema = t.ChatCompletionChoice$inboundSchema = t.FinishReason$ = t.FinishReason$outboundSchema = t.FinishReason$inboundSchema = t.FinishReason = void 0, t.chatCompletionChoiceToJSON = c, t.chatCompletionChoiceFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ iu(), l = /* @__PURE__ */ su();
    t.FinishReason = {
      Stop: "stop",
      Length: "length",
      ModelLength: "model_length",
      Error: "error",
      ToolCalls: "tool_calls"
    }, t.FinishReason$inboundSchema = r.union([
      r.nativeEnum(t.FinishReason),
      r.string().transform(o.catchUnrecognizedEnum)
    ]), t.FinishReason$outboundSchema = r.union([
      r.nativeEnum(t.FinishReason),
      r.string().and(r.custom())
    ]);
    var f;
    (function(p) {
      p.inboundSchema = t.FinishReason$inboundSchema, p.outboundSchema = t.FinishReason$outboundSchema;
    })(f || (t.FinishReason$ = f = {})), t.ChatCompletionChoice$inboundSchema = r.object({
      index: r.number().int(),
      message: l.AssistantMessage$inboundSchema,
      finish_reason: t.FinishReason$inboundSchema
    }).transform((p) => (0, i.remap)(p, {
      finish_reason: "finishReason"
    })), t.ChatCompletionChoice$outboundSchema = r.object({
      index: r.number().int(),
      message: l.AssistantMessage$outboundSchema,
      finishReason: t.FinishReason$outboundSchema
    }).transform((p) => (0, i.remap)(p, {
      finishReason: "finish_reason"
    }));
    var u;
    (function(p) {
      p.inboundSchema = t.ChatCompletionChoice$inboundSchema, p.outboundSchema = t.ChatCompletionChoice$outboundSchema;
    })(u || (t.ChatCompletionChoice$ = u = {}));
    function c(p) {
      return JSON.stringify(t.ChatCompletionChoice$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (d) => t.ChatCompletionChoice$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'ChatCompletionChoice' from JSON");
    }
  }(oi)), oi;
}
var ui = {}, DS;
function fJ() {
  return DS || (DS = 1, function(t) {
    var e = ui && ui.__createBinding || (Object.create ? function(w, k, L, B) {
      B === void 0 && (B = L);
      var V = Object.getOwnPropertyDescriptor(k, L);
      (!V || ("get" in V ? !k.__esModule : V.writable || V.configurable)) && (V = { enumerable: !0, get: function() {
        return k[L];
      } }), Object.defineProperty(w, B, V);
    } : function(w, k, L, B) {
      B === void 0 && (B = L), w[B] = k[L];
    }), n = ui && ui.__setModuleDefault || (Object.create ? function(w, k) {
      Object.defineProperty(w, "default", { enumerable: !0, value: k });
    } : function(w, k) {
      w.default = k;
    }), a = ui && ui.__importStar || function(w) {
      if (w && w.__esModule) return w;
      var k = {};
      if (w != null) for (var L in w) L !== "default" && Object.prototype.hasOwnProperty.call(w, L) && e(k, w, L);
      return n(k, w), k;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ChatCompletionRequest$ = t.ChatCompletionRequest$outboundSchema = t.ChatCompletionRequest$inboundSchema = t.ChatCompletionRequestToolChoice$ = t.ChatCompletionRequestToolChoice$outboundSchema = t.ChatCompletionRequestToolChoice$inboundSchema = t.Messages$ = t.Messages$outboundSchema = t.Messages$inboundSchema = t.Stop$ = t.Stop$outboundSchema = t.Stop$inboundSchema = void 0, t.stopToJSON = g, t.stopFromJSON = _, t.messagesToJSON = C, t.messagesFromJSON = R, t.chatCompletionRequestToolChoiceToJSON = O, t.chatCompletionRequestToolChoiceFromJSON = A, t.chatCompletionRequestToJSON = I, t.chatCompletionRequestFromJSON = N;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ su(), l = /* @__PURE__ */ Qd(), f = /* @__PURE__ */ Yd(), u = /* @__PURE__ */ hc(), c = /* @__PURE__ */ ef(), h = /* @__PURE__ */ tf(), p = /* @__PURE__ */ nf(), d = /* @__PURE__ */ pc(), m = /* @__PURE__ */ mc();
    t.Stop$inboundSchema = r.union([r.string(), r.array(r.string())]), t.Stop$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var b;
    (function(w) {
      w.inboundSchema = t.Stop$inboundSchema, w.outboundSchema = t.Stop$outboundSchema;
    })(b || (t.Stop$ = b = {}));
    function g(w) {
      return JSON.stringify(t.Stop$outboundSchema.parse(w));
    }
    function _(w) {
      return (0, s.safeParse)(w, (k) => t.Stop$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'Stop' from JSON");
    }
    t.Messages$inboundSchema = r.union([
      u.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
        role: w.role
      }))),
      m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({ role: w.role }))),
      o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
        role: w.role
      }))),
      d.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({ role: w.role })))
    ]), t.Messages$outboundSchema = r.union([
      u.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
        role: w.role
      }))),
      m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({ role: w.role }))),
      o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
        role: w.role
      }))),
      d.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({ role: w.role })))
    ]);
    var P;
    (function(w) {
      w.inboundSchema = t.Messages$inboundSchema, w.outboundSchema = t.Messages$outboundSchema;
    })(P || (t.Messages$ = P = {}));
    function C(w) {
      return JSON.stringify(t.Messages$outboundSchema.parse(w));
    }
    function R(w) {
      return (0, s.safeParse)(w, (k) => t.Messages$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'Messages' from JSON");
    }
    t.ChatCompletionRequestToolChoice$inboundSchema = r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]), t.ChatCompletionRequestToolChoice$outboundSchema = r.union([h.ToolChoice$outboundSchema, p.ToolChoiceEnum$outboundSchema]);
    var T;
    (function(w) {
      w.inboundSchema = t.ChatCompletionRequestToolChoice$inboundSchema, w.outboundSchema = t.ChatCompletionRequestToolChoice$outboundSchema;
    })(T || (t.ChatCompletionRequestToolChoice$ = T = {}));
    function O(w) {
      return JSON.stringify(t.ChatCompletionRequestToolChoice$outboundSchema.parse(w));
    }
    function A(w) {
      return (0, s.safeParse)(w, (k) => t.ChatCompletionRequestToolChoice$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'ChatCompletionRequestToolChoice' from JSON");
    }
    t.ChatCompletionRequest$inboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      top_p: r.number().optional(),
      max_tokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!1),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      random_seed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        u.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
          role: w.role
        }))),
        m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({
          role: w.role
        }))),
        o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
          role: w.role
        }))),
        d.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({
          role: w.role
        })))
      ])),
      response_format: f.ResponseFormat$inboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$inboundSchema)).optional(),
      tool_choice: r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]).optional(),
      presence_penalty: r.number().optional(),
      frequency_penalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: l.Prediction$inboundSchema.optional(),
      safe_prompt: r.boolean().optional()
    }).transform((w) => (0, i.remap)(w, {
      top_p: "topP",
      max_tokens: "maxTokens",
      random_seed: "randomSeed",
      response_format: "responseFormat",
      tool_choice: "toolChoice",
      presence_penalty: "presencePenalty",
      frequency_penalty: "frequencyPenalty",
      safe_prompt: "safePrompt"
    })), t.ChatCompletionRequest$outboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      topP: r.number().optional(),
      maxTokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!1),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      randomSeed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        u.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
          role: w.role
        }))),
        m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({
          role: w.role
        }))),
        o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
          role: w.role
        }))),
        d.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({
          role: w.role
        })))
      ])),
      responseFormat: f.ResponseFormat$outboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$outboundSchema)).optional(),
      toolChoice: r.union([
        h.ToolChoice$outboundSchema,
        p.ToolChoiceEnum$outboundSchema
      ]).optional(),
      presencePenalty: r.number().optional(),
      frequencyPenalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: l.Prediction$outboundSchema.optional(),
      safePrompt: r.boolean().optional()
    }).transform((w) => (0, i.remap)(w, {
      topP: "top_p",
      maxTokens: "max_tokens",
      randomSeed: "random_seed",
      responseFormat: "response_format",
      toolChoice: "tool_choice",
      presencePenalty: "presence_penalty",
      frequencyPenalty: "frequency_penalty",
      safePrompt: "safe_prompt"
    }));
    var M;
    (function(w) {
      w.inboundSchema = t.ChatCompletionRequest$inboundSchema, w.outboundSchema = t.ChatCompletionRequest$outboundSchema;
    })(M || (t.ChatCompletionRequest$ = M = {}));
    function I(w) {
      return JSON.stringify(t.ChatCompletionRequest$outboundSchema.parse(w));
    }
    function N(w) {
      return (0, s.safeParse)(w, (k) => t.ChatCompletionRequest$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'ChatCompletionRequest' from JSON");
    }
  }(ui)), ui;
}
var ci = {}, li = {}, qS;
function rf() {
  return qS || (qS = 1, function(t) {
    var e = li && li.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = li && li.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = li && li.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.UsageInfo$ = t.UsageInfo$outboundSchema = t.UsageInfo$inboundSchema = void 0, t.usageInfoToJSON = l, t.usageInfoFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.UsageInfo$inboundSchema = r.object({
      prompt_tokens: r.number().int(),
      completion_tokens: r.number().int(),
      total_tokens: r.number().int()
    }).transform((u) => (0, i.remap)(u, {
      prompt_tokens: "promptTokens",
      completion_tokens: "completionTokens",
      total_tokens: "totalTokens"
    })), t.UsageInfo$outboundSchema = r.object({
      promptTokens: r.number().int(),
      completionTokens: r.number().int(),
      totalTokens: r.number().int()
    }).transform((u) => (0, i.remap)(u, {
      promptTokens: "prompt_tokens",
      completionTokens: "completion_tokens",
      totalTokens: "total_tokens"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.UsageInfo$inboundSchema, u.outboundSchema = t.UsageInfo$outboundSchema;
    })(o || (t.UsageInfo$ = o = {}));
    function l(u) {
      return JSON.stringify(t.UsageInfo$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.UsageInfo$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'UsageInfo' from JSON");
    }
  }(li)), li;
}
var JS;
function hJ() {
  return JS || (JS = 1, function(t) {
    var e = ci && ci.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = ci && ci.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = ci && ci.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ChatCompletionResponse$ = t.ChatCompletionResponse$outboundSchema = t.ChatCompletionResponse$inboundSchema = void 0, t.chatCompletionResponseToJSON = f, t.chatCompletionResponseFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ B_(), o = /* @__PURE__ */ rf();
    t.ChatCompletionResponse$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      model: r.string(),
      usage: o.UsageInfo$inboundSchema,
      created: r.number().int().optional(),
      choices: r.array(s.ChatCompletionChoice$inboundSchema).optional()
    }), t.ChatCompletionResponse$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      model: r.string(),
      usage: o.UsageInfo$outboundSchema,
      created: r.number().int().optional(),
      choices: r.array(s.ChatCompletionChoice$outboundSchema).optional()
    });
    var l;
    (function(c) {
      c.inboundSchema = t.ChatCompletionResponse$inboundSchema, c.outboundSchema = t.ChatCompletionResponse$outboundSchema;
    })(l || (t.ChatCompletionResponse$ = l = {}));
    function f(c) {
      return JSON.stringify(t.ChatCompletionResponse$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, i.safeParse)(c, (h) => t.ChatCompletionResponse$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'ChatCompletionResponse' from JSON");
    }
  }(ci)), ci;
}
var di = {}, LS;
function pJ() {
  return LS || (LS = 1, function(t) {
    var e = di && di.__createBinding || (Object.create ? function(w, k, L, B) {
      B === void 0 && (B = L);
      var V = Object.getOwnPropertyDescriptor(k, L);
      (!V || ("get" in V ? !k.__esModule : V.writable || V.configurable)) && (V = { enumerable: !0, get: function() {
        return k[L];
      } }), Object.defineProperty(w, B, V);
    } : function(w, k, L, B) {
      B === void 0 && (B = L), w[B] = k[L];
    }), n = di && di.__setModuleDefault || (Object.create ? function(w, k) {
      Object.defineProperty(w, "default", { enumerable: !0, value: k });
    } : function(w, k) {
      w.default = k;
    }), a = di && di.__importStar || function(w) {
      if (w && w.__esModule) return w;
      var k = {};
      if (w != null) for (var L in w) L !== "default" && Object.prototype.hasOwnProperty.call(w, L) && e(k, w, L);
      return n(k, w), k;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ChatCompletionStreamRequest$ = t.ChatCompletionStreamRequest$outboundSchema = t.ChatCompletionStreamRequest$inboundSchema = t.ChatCompletionStreamRequestToolChoice$ = t.ChatCompletionStreamRequestToolChoice$outboundSchema = t.ChatCompletionStreamRequestToolChoice$inboundSchema = t.ChatCompletionStreamRequestMessages$ = t.ChatCompletionStreamRequestMessages$outboundSchema = t.ChatCompletionStreamRequestMessages$inboundSchema = t.ChatCompletionStreamRequestStop$ = t.ChatCompletionStreamRequestStop$outboundSchema = t.ChatCompletionStreamRequestStop$inboundSchema = void 0, t.chatCompletionStreamRequestStopToJSON = g, t.chatCompletionStreamRequestStopFromJSON = _, t.chatCompletionStreamRequestMessagesToJSON = C, t.chatCompletionStreamRequestMessagesFromJSON = R, t.chatCompletionStreamRequestToolChoiceToJSON = O, t.chatCompletionStreamRequestToolChoiceFromJSON = A, t.chatCompletionStreamRequestToJSON = I, t.chatCompletionStreamRequestFromJSON = N;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ su(), l = /* @__PURE__ */ Qd(), f = /* @__PURE__ */ Yd(), u = /* @__PURE__ */ hc(), c = /* @__PURE__ */ ef(), h = /* @__PURE__ */ tf(), p = /* @__PURE__ */ nf(), d = /* @__PURE__ */ pc(), m = /* @__PURE__ */ mc();
    t.ChatCompletionStreamRequestStop$inboundSchema = r.union([r.string(), r.array(r.string())]), t.ChatCompletionStreamRequestStop$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var b;
    (function(w) {
      w.inboundSchema = t.ChatCompletionStreamRequestStop$inboundSchema, w.outboundSchema = t.ChatCompletionStreamRequestStop$outboundSchema;
    })(b || (t.ChatCompletionStreamRequestStop$ = b = {}));
    function g(w) {
      return JSON.stringify(t.ChatCompletionStreamRequestStop$outboundSchema.parse(w));
    }
    function _(w) {
      return (0, s.safeParse)(w, (k) => t.ChatCompletionStreamRequestStop$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'ChatCompletionStreamRequestStop' from JSON");
    }
    t.ChatCompletionStreamRequestMessages$inboundSchema = r.union([
      u.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
        role: w.role
      }))),
      m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({ role: w.role }))),
      o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
        role: w.role
      }))),
      d.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({ role: w.role })))
    ]), t.ChatCompletionStreamRequestMessages$outboundSchema = r.union([
      u.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
        role: w.role
      }))),
      m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({ role: w.role }))),
      o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
        role: w.role
      }))),
      d.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({ role: w.role })))
    ]);
    var P;
    (function(w) {
      w.inboundSchema = t.ChatCompletionStreamRequestMessages$inboundSchema, w.outboundSchema = t.ChatCompletionStreamRequestMessages$outboundSchema;
    })(P || (t.ChatCompletionStreamRequestMessages$ = P = {}));
    function C(w) {
      return JSON.stringify(t.ChatCompletionStreamRequestMessages$outboundSchema.parse(w));
    }
    function R(w) {
      return (0, s.safeParse)(w, (k) => t.ChatCompletionStreamRequestMessages$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'ChatCompletionStreamRequestMessages' from JSON");
    }
    t.ChatCompletionStreamRequestToolChoice$inboundSchema = r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]), t.ChatCompletionStreamRequestToolChoice$outboundSchema = r.union([h.ToolChoice$outboundSchema, p.ToolChoiceEnum$outboundSchema]);
    var T;
    (function(w) {
      w.inboundSchema = t.ChatCompletionStreamRequestToolChoice$inboundSchema, w.outboundSchema = t.ChatCompletionStreamRequestToolChoice$outboundSchema;
    })(T || (t.ChatCompletionStreamRequestToolChoice$ = T = {}));
    function O(w) {
      return JSON.stringify(t.ChatCompletionStreamRequestToolChoice$outboundSchema.parse(w));
    }
    function A(w) {
      return (0, s.safeParse)(w, (k) => t.ChatCompletionStreamRequestToolChoice$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'ChatCompletionStreamRequestToolChoice' from JSON");
    }
    t.ChatCompletionStreamRequest$inboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      top_p: r.number().optional(),
      max_tokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!0),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      random_seed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        u.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
          role: w.role
        }))),
        m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({
          role: w.role
        }))),
        o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
          role: w.role
        }))),
        d.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({
          role: w.role
        })))
      ])),
      response_format: f.ResponseFormat$inboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$inboundSchema)).optional(),
      tool_choice: r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]).optional(),
      presence_penalty: r.number().optional(),
      frequency_penalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: l.Prediction$inboundSchema.optional(),
      safe_prompt: r.boolean().optional()
    }).transform((w) => (0, i.remap)(w, {
      top_p: "topP",
      max_tokens: "maxTokens",
      random_seed: "randomSeed",
      response_format: "responseFormat",
      tool_choice: "toolChoice",
      presence_penalty: "presencePenalty",
      frequency_penalty: "frequencyPenalty",
      safe_prompt: "safePrompt"
    })), t.ChatCompletionStreamRequest$outboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      topP: r.number().optional(),
      maxTokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!0),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      randomSeed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        u.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((w) => ({
          role: w.role
        }))),
        m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((w) => ({
          role: w.role
        }))),
        o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((w) => ({
          role: w.role
        }))),
        d.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((w) => ({
          role: w.role
        })))
      ])),
      responseFormat: f.ResponseFormat$outboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$outboundSchema)).optional(),
      toolChoice: r.union([
        h.ToolChoice$outboundSchema,
        p.ToolChoiceEnum$outboundSchema
      ]).optional(),
      presencePenalty: r.number().optional(),
      frequencyPenalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: l.Prediction$outboundSchema.optional(),
      safePrompt: r.boolean().optional()
    }).transform((w) => (0, i.remap)(w, {
      topP: "top_p",
      maxTokens: "max_tokens",
      randomSeed: "random_seed",
      responseFormat: "response_format",
      toolChoice: "tool_choice",
      presencePenalty: "presence_penalty",
      frequencyPenalty: "frequency_penalty",
      safePrompt: "safe_prompt"
    }));
    var M;
    (function(w) {
      w.inboundSchema = t.ChatCompletionStreamRequest$inboundSchema, w.outboundSchema = t.ChatCompletionStreamRequest$outboundSchema;
    })(M || (t.ChatCompletionStreamRequest$ = M = {}));
    function I(w) {
      return JSON.stringify(t.ChatCompletionStreamRequest$outboundSchema.parse(w));
    }
    function N(w) {
      return (0, s.safeParse)(w, (k) => t.ChatCompletionStreamRequest$inboundSchema.parse(JSON.parse(k)), "Failed to parse 'ChatCompletionStreamRequest' from JSON");
    }
  }(di)), di;
}
var fi = {}, US;
function mJ() {
  return US || (US = 1, function(t) {
    var e = fi && fi.__createBinding || (Object.create ? function(O, A, M, I) {
      I === void 0 && (I = M);
      var N = Object.getOwnPropertyDescriptor(A, M);
      (!N || ("get" in N ? !A.__esModule : N.writable || N.configurable)) && (N = { enumerable: !0, get: function() {
        return A[M];
      } }), Object.defineProperty(O, I, N);
    } : function(O, A, M, I) {
      I === void 0 && (I = M), O[I] = A[M];
    }), n = fi && fi.__setModuleDefault || (Object.create ? function(O, A) {
      Object.defineProperty(O, "default", { enumerable: !0, value: A });
    } : function(O, A) {
      O.default = A;
    }), a = fi && fi.__importStar || function(O) {
      if (O && O.__esModule) return O;
      var A = {};
      if (O != null) for (var M in O) M !== "default" && Object.prototype.hasOwnProperty.call(O, M) && e(A, O, M);
      return n(A, O), A;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ChatModerationRequest$ = t.ChatModerationRequest$outboundSchema = t.ChatModerationRequest$inboundSchema = t.ChatModerationRequestInputs$ = t.ChatModerationRequestInputs$outboundSchema = t.ChatModerationRequestInputs$inboundSchema = t.One$ = t.One$outboundSchema = t.One$inboundSchema = t.Two$ = t.Two$outboundSchema = t.Two$inboundSchema = void 0, t.twoToJSON = h, t.twoFromJSON = p, t.oneToJSON = m, t.oneFromJSON = b, t.chatModerationRequestInputsToJSON = _, t.chatModerationRequestInputsFromJSON = P, t.chatModerationRequestToJSON = R, t.chatModerationRequestFromJSON = T;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ su(), l = /* @__PURE__ */ hc(), f = /* @__PURE__ */ pc(), u = /* @__PURE__ */ mc();
    t.Two$inboundSchema = r.union([
      l.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
        role: O.role
      }))),
      u.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
        role: O.role
      }))),
      o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
        role: O.role
      }))),
      f.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
        role: O.role
      })))
    ]), t.Two$outboundSchema = r.union([
      l.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
        role: O.role
      }))),
      u.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
        role: O.role
      }))),
      o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
        role: O.role
      }))),
      f.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
        role: O.role
      })))
    ]);
    var c;
    (function(O) {
      O.inboundSchema = t.Two$inboundSchema, O.outboundSchema = t.Two$outboundSchema;
    })(c || (t.Two$ = c = {}));
    function h(O) {
      return JSON.stringify(t.Two$outboundSchema.parse(O));
    }
    function p(O) {
      return (0, s.safeParse)(O, (A) => t.Two$inboundSchema.parse(JSON.parse(A)), "Failed to parse 'Two' from JSON");
    }
    t.One$inboundSchema = r.union([
      l.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
        role: O.role
      }))),
      u.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
        role: O.role
      }))),
      o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
        role: O.role
      }))),
      f.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
        role: O.role
      })))
    ]), t.One$outboundSchema = r.union([
      l.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
        role: O.role
      }))),
      u.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
        role: O.role
      }))),
      o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
        role: O.role
      }))),
      f.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
        role: O.role
      })))
    ]);
    var d;
    (function(O) {
      O.inboundSchema = t.One$inboundSchema, O.outboundSchema = t.One$outboundSchema;
    })(d || (t.One$ = d = {}));
    function m(O) {
      return JSON.stringify(t.One$outboundSchema.parse(O));
    }
    function b(O) {
      return (0, s.safeParse)(O, (A) => t.One$inboundSchema.parse(JSON.parse(A)), "Failed to parse 'One' from JSON");
    }
    t.ChatModerationRequestInputs$inboundSchema = r.union([
      r.array(r.union([
        l.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
          role: O.role
        }))),
        u.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
          role: O.role
        }))),
        o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
          role: O.role
        }))),
        f.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
          role: O.role
        })))
      ])),
      r.array(r.array(r.union([
        l.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
          role: O.role
        }))),
        u.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
          role: O.role
        }))),
        o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
          role: O.role
        }))),
        f.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
          role: O.role
        })))
      ])))
    ]), t.ChatModerationRequestInputs$outboundSchema = r.union([
      r.array(r.union([
        l.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
          role: O.role
        }))),
        u.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
          role: O.role
        }))),
        o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
          role: O.role
        }))),
        f.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
          role: O.role
        })))
      ])),
      r.array(r.array(r.union([
        l.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
          role: O.role
        }))),
        u.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
          role: O.role
        }))),
        o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
          role: O.role
        }))),
        f.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
          role: O.role
        })))
      ])))
    ]);
    var g;
    (function(O) {
      O.inboundSchema = t.ChatModerationRequestInputs$inboundSchema, O.outboundSchema = t.ChatModerationRequestInputs$outboundSchema;
    })(g || (t.ChatModerationRequestInputs$ = g = {}));
    function _(O) {
      return JSON.stringify(t.ChatModerationRequestInputs$outboundSchema.parse(O));
    }
    function P(O) {
      return (0, s.safeParse)(O, (A) => t.ChatModerationRequestInputs$inboundSchema.parse(JSON.parse(A)), "Failed to parse 'ChatModerationRequestInputs' from JSON");
    }
    t.ChatModerationRequest$inboundSchema = r.object({
      model: r.string(),
      input: r.union([
        r.array(r.union([
          l.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
            role: O.role
          }))),
          u.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
            role: O.role
          }))),
          o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
            role: O.role
          }))),
          f.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
            role: O.role
          })))
        ])),
        r.array(r.array(r.union([
          l.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
            role: O.role
          }))),
          u.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
            role: O.role
          }))),
          o.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
            role: O.role
          }))),
          f.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
            role: O.role
          })))
        ])))
      ]),
      truncate_for_context_length: r.boolean().default(!1)
    }).transform((O) => (0, i.remap)(O, {
      input: "inputs",
      truncate_for_context_length: "truncateForContextLength"
    })), t.ChatModerationRequest$outboundSchema = r.object({
      model: r.string(),
      inputs: r.union([
        r.array(r.union([
          l.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
            role: O.role
          }))),
          u.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
            role: O.role
          }))),
          o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
            role: O.role
          }))),
          f.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
            role: O.role
          })))
        ])),
        r.array(r.array(r.union([
          l.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
            role: O.role
          }))),
          u.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
            role: O.role
          }))),
          o.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
            role: O.role
          }))),
          f.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
            role: O.role
          })))
        ])))
      ]),
      truncateForContextLength: r.boolean().default(!1)
    }).transform((O) => (0, i.remap)(O, {
      inputs: "input",
      truncateForContextLength: "truncate_for_context_length"
    }));
    var C;
    (function(O) {
      O.inboundSchema = t.ChatModerationRequest$inboundSchema, O.outboundSchema = t.ChatModerationRequest$outboundSchema;
    })(C || (t.ChatModerationRequest$ = C = {}));
    function R(O) {
      return JSON.stringify(t.ChatModerationRequest$outboundSchema.parse(O));
    }
    function T(O) {
      return (0, s.safeParse)(O, (A) => t.ChatModerationRequest$inboundSchema.parse(JSON.parse(A)), "Failed to parse 'ChatModerationRequest' from JSON");
    }
  }(fi)), fi;
}
var hi = {}, pi = {}, BS;
function zT() {
  return BS || (BS = 1, function(t) {
    var e = pi && pi.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = pi && pi.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = pi && pi.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.MetricOut$ = t.MetricOut$outboundSchema = t.MetricOut$inboundSchema = void 0, t.metricOutToJSON = l, t.metricOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.MetricOut$inboundSchema = r.object({
      train_loss: r.nullable(r.number()).optional(),
      valid_loss: r.nullable(r.number()).optional(),
      valid_mean_token_accuracy: r.nullable(r.number()).optional()
    }).transform((u) => (0, i.remap)(u, {
      train_loss: "trainLoss",
      valid_loss: "validLoss",
      valid_mean_token_accuracy: "validMeanTokenAccuracy"
    })), t.MetricOut$outboundSchema = r.object({
      trainLoss: r.nullable(r.number()).optional(),
      validLoss: r.nullable(r.number()).optional(),
      validMeanTokenAccuracy: r.nullable(r.number()).optional()
    }).transform((u) => (0, i.remap)(u, {
      trainLoss: "train_loss",
      validLoss: "valid_loss",
      validMeanTokenAccuracy: "valid_mean_token_accuracy"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.MetricOut$inboundSchema, u.outboundSchema = t.MetricOut$outboundSchema;
    })(o || (t.MetricOut$ = o = {}));
    function l(u) {
      return JSON.stringify(t.MetricOut$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.MetricOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'MetricOut' from JSON");
    }
  }(pi)), pi;
}
var xS;
function ZT() {
  return xS || (xS = 1, function(t) {
    var e = hi && hi.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = hi && hi.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = hi && hi.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CheckpointOut$ = t.CheckpointOut$outboundSchema = t.CheckpointOut$inboundSchema = void 0, t.checkpointOutToJSON = f, t.checkpointOutFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ zT();
    t.CheckpointOut$inboundSchema = r.object({
      metrics: o.MetricOut$inboundSchema,
      step_number: r.number().int(),
      created_at: r.number().int()
    }).transform((c) => (0, i.remap)(c, {
      step_number: "stepNumber",
      created_at: "createdAt"
    })), t.CheckpointOut$outboundSchema = r.object({
      metrics: o.MetricOut$outboundSchema,
      stepNumber: r.number().int(),
      createdAt: r.number().int()
    }).transform((c) => (0, i.remap)(c, {
      stepNumber: "step_number",
      createdAt: "created_at"
    }));
    var l;
    (function(c) {
      c.inboundSchema = t.CheckpointOut$inboundSchema, c.outboundSchema = t.CheckpointOut$outboundSchema;
    })(l || (t.CheckpointOut$ = l = {}));
    function f(c) {
      return JSON.stringify(t.CheckpointOut$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, s.safeParse)(c, (h) => t.CheckpointOut$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'CheckpointOut' from JSON");
    }
  }(hi)), hi;
}
var mi = {}, VS;
function KT() {
  return VS || (VS = 1, function(t) {
    var e = mi && mi.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = mi && mi.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = mi && mi.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ClassificationObject$ = t.ClassificationObject$outboundSchema = t.ClassificationObject$inboundSchema = void 0, t.classificationObjectToJSON = l, t.classificationObjectFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.ClassificationObject$inboundSchema = r.object({
      categories: r.record(r.boolean()).optional(),
      category_scores: r.record(r.number()).optional()
    }).transform((u) => (0, i.remap)(u, {
      category_scores: "categoryScores"
    })), t.ClassificationObject$outboundSchema = r.object({
      categories: r.record(r.boolean()).optional(),
      categoryScores: r.record(r.number()).optional()
    }).transform((u) => (0, i.remap)(u, {
      categoryScores: "category_scores"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.ClassificationObject$inboundSchema, u.outboundSchema = t.ClassificationObject$outboundSchema;
    })(o || (t.ClassificationObject$ = o = {}));
    function l(u) {
      return JSON.stringify(t.ClassificationObject$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.ClassificationObject$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'ClassificationObject' from JSON");
    }
  }(mi)), mi;
}
var bi = {}, zS;
function bJ() {
  return zS || (zS = 1, function(t) {
    var e = bi && bi.__createBinding || (Object.create ? function(p, d, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(d, m);
      (!g || ("get" in g ? !d.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return d[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, d, m, b) {
      b === void 0 && (b = m), p[b] = d[m];
    }), n = bi && bi.__setModuleDefault || (Object.create ? function(p, d) {
      Object.defineProperty(p, "default", { enumerable: !0, value: d });
    } : function(p, d) {
      p.default = d;
    }), a = bi && bi.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(d, p, m);
      return n(d, p), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ClassificationRequest$ = t.ClassificationRequest$outboundSchema = t.ClassificationRequest$inboundSchema = t.ClassificationRequestInputs$ = t.ClassificationRequestInputs$outboundSchema = t.ClassificationRequestInputs$inboundSchema = void 0, t.classificationRequestInputsToJSON = l, t.classificationRequestInputsFromJSON = f, t.classificationRequestToJSON = c, t.classificationRequestFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.ClassificationRequestInputs$inboundSchema = r.union([r.string(), r.array(r.string())]), t.ClassificationRequestInputs$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var o;
    (function(p) {
      p.inboundSchema = t.ClassificationRequestInputs$inboundSchema, p.outboundSchema = t.ClassificationRequestInputs$outboundSchema;
    })(o || (t.ClassificationRequestInputs$ = o = {}));
    function l(p) {
      return JSON.stringify(t.ClassificationRequestInputs$outboundSchema.parse(p));
    }
    function f(p) {
      return (0, s.safeParse)(p, (d) => t.ClassificationRequestInputs$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'ClassificationRequestInputs' from JSON");
    }
    t.ClassificationRequest$inboundSchema = r.object({
      model: r.string(),
      input: r.union([r.string(), r.array(r.string())])
    }).transform((p) => (0, i.remap)(p, {
      input: "inputs"
    })), t.ClassificationRequest$outboundSchema = r.object({
      model: r.string(),
      inputs: r.union([r.string(), r.array(r.string())])
    }).transform((p) => (0, i.remap)(p, {
      inputs: "input"
    }));
    var u;
    (function(p) {
      p.inboundSchema = t.ClassificationRequest$inboundSchema, p.outboundSchema = t.ClassificationRequest$outboundSchema;
    })(u || (t.ClassificationRequest$ = u = {}));
    function c(p) {
      return JSON.stringify(t.ClassificationRequest$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (d) => t.ClassificationRequest$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'ClassificationRequest' from JSON");
    }
  }(bi)), bi;
}
var gi = {}, ZS;
function gJ() {
  return ZS || (ZS = 1, function(t) {
    var e = gi && gi.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = gi && gi.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = gi && gi.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ClassificationResponse$ = t.ClassificationResponse$outboundSchema = t.ClassificationResponse$inboundSchema = void 0, t.classificationResponseToJSON = l, t.classificationResponseFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ KT();
    t.ClassificationResponse$inboundSchema = r.object({
      id: r.string().optional(),
      model: r.string().optional(),
      results: r.array(s.ClassificationObject$inboundSchema).optional()
    }), t.ClassificationResponse$outboundSchema = r.object({
      id: r.string().optional(),
      model: r.string().optional(),
      results: r.array(s.ClassificationObject$outboundSchema).optional()
    });
    var o;
    (function(u) {
      u.inboundSchema = t.ClassificationResponse$inboundSchema, u.outboundSchema = t.ClassificationResponse$outboundSchema;
    })(o || (t.ClassificationResponse$ = o = {}));
    function l(u) {
      return JSON.stringify(t.ClassificationResponse$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, i.safeParse)(u, (c) => t.ClassificationResponse$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'ClassificationResponse' from JSON");
    }
  }(gi)), gi;
}
var _i = {}, yi = {}, wi = {}, KS;
function HT() {
  return KS || (KS = 1, function(t) {
    var e = wi && wi.__createBinding || (Object.create ? function(m, b, g, _) {
      _ === void 0 && (_ = g);
      var P = Object.getOwnPropertyDescriptor(b, g);
      (!P || ("get" in P ? !b.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
        return b[g];
      } }), Object.defineProperty(m, _, P);
    } : function(m, b, g, _) {
      _ === void 0 && (_ = g), m[_] = b[g];
    }), n = wi && wi.__setModuleDefault || (Object.create ? function(m, b) {
      Object.defineProperty(m, "default", { enumerable: !0, value: b });
    } : function(m, b) {
      m.default = b;
    }), a = wi && wi.__importStar || function(m) {
      if (m && m.__esModule) return m;
      var b = {};
      if (m != null) for (var g in m) g !== "default" && Object.prototype.hasOwnProperty.call(m, g) && e(b, m, g);
      return n(b, m), b;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.DeltaMessage$ = t.DeltaMessage$outboundSchema = t.DeltaMessage$inboundSchema = t.Content$ = t.Content$outboundSchema = t.Content$inboundSchema = void 0, t.contentToJSON = u, t.contentFromJSON = c, t.deltaMessageToJSON = p, t.deltaMessageFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Xd(), l = /* @__PURE__ */ L_();
    t.Content$inboundSchema = r.union([r.string(), r.array(o.ContentChunk$inboundSchema)]), t.Content$outboundSchema = r.union([r.string(), r.array(o.ContentChunk$outboundSchema)]);
    var f;
    (function(m) {
      m.inboundSchema = t.Content$inboundSchema, m.outboundSchema = t.Content$outboundSchema;
    })(f || (t.Content$ = f = {}));
    function u(m) {
      return JSON.stringify(t.Content$outboundSchema.parse(m));
    }
    function c(m) {
      return (0, s.safeParse)(m, (b) => t.Content$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'Content' from JSON");
    }
    t.DeltaMessage$inboundSchema = r.object({
      role: r.nullable(r.string()).optional(),
      content: r.nullable(r.union([r.string(), r.array(o.ContentChunk$inboundSchema)])).optional(),
      tool_calls: r.nullable(r.array(l.ToolCall$inboundSchema)).optional()
    }).transform((m) => (0, i.remap)(m, {
      tool_calls: "toolCalls"
    })), t.DeltaMessage$outboundSchema = r.object({
      role: r.nullable(r.string()).optional(),
      content: r.nullable(r.union([r.string(), r.array(o.ContentChunk$outboundSchema)])).optional(),
      toolCalls: r.nullable(r.array(l.ToolCall$outboundSchema)).optional()
    }).transform((m) => (0, i.remap)(m, {
      toolCalls: "tool_calls"
    }));
    var h;
    (function(m) {
      m.inboundSchema = t.DeltaMessage$inboundSchema, m.outboundSchema = t.DeltaMessage$outboundSchema;
    })(h || (t.DeltaMessage$ = h = {}));
    function p(m) {
      return JSON.stringify(t.DeltaMessage$outboundSchema.parse(m));
    }
    function d(m) {
      return (0, s.safeParse)(m, (b) => t.DeltaMessage$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'DeltaMessage' from JSON");
    }
  }(wi)), wi;
}
var HS;
function GT() {
  return HS || (HS = 1, function(t) {
    var e = yi && yi.__createBinding || (Object.create ? function(p, d, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(d, m);
      (!g || ("get" in g ? !d.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return d[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, d, m, b) {
      b === void 0 && (b = m), p[b] = d[m];
    }), n = yi && yi.__setModuleDefault || (Object.create ? function(p, d) {
      Object.defineProperty(p, "default", { enumerable: !0, value: d });
    } : function(p, d) {
      p.default = d;
    }), a = yi && yi.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(d, p, m);
      return n(d, p), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CompletionResponseStreamChoice$ = t.CompletionResponseStreamChoice$outboundSchema = t.CompletionResponseStreamChoice$inboundSchema = t.CompletionResponseStreamChoiceFinishReason$ = t.CompletionResponseStreamChoiceFinishReason$outboundSchema = t.CompletionResponseStreamChoiceFinishReason$inboundSchema = t.CompletionResponseStreamChoiceFinishReason = void 0, t.completionResponseStreamChoiceToJSON = c, t.completionResponseStreamChoiceFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ iu(), l = /* @__PURE__ */ HT();
    t.CompletionResponseStreamChoiceFinishReason = {
      Stop: "stop",
      Length: "length",
      Error: "error",
      ToolCalls: "tool_calls"
    }, t.CompletionResponseStreamChoiceFinishReason$inboundSchema = r.union([
      r.nativeEnum(t.CompletionResponseStreamChoiceFinishReason),
      r.string().transform(o.catchUnrecognizedEnum)
    ]), t.CompletionResponseStreamChoiceFinishReason$outboundSchema = r.union([
      r.nativeEnum(t.CompletionResponseStreamChoiceFinishReason),
      r.string().and(r.custom())
    ]);
    var f;
    (function(p) {
      p.inboundSchema = t.CompletionResponseStreamChoiceFinishReason$inboundSchema, p.outboundSchema = t.CompletionResponseStreamChoiceFinishReason$outboundSchema;
    })(f || (t.CompletionResponseStreamChoiceFinishReason$ = f = {})), t.CompletionResponseStreamChoice$inboundSchema = r.object({
      index: r.number().int(),
      delta: l.DeltaMessage$inboundSchema,
      finish_reason: r.nullable(t.CompletionResponseStreamChoiceFinishReason$inboundSchema)
    }).transform((p) => (0, i.remap)(p, {
      finish_reason: "finishReason"
    })), t.CompletionResponseStreamChoice$outboundSchema = r.object({
      index: r.number().int(),
      delta: l.DeltaMessage$outboundSchema,
      finishReason: r.nullable(t.CompletionResponseStreamChoiceFinishReason$outboundSchema)
    }).transform((p) => (0, i.remap)(p, {
      finishReason: "finish_reason"
    }));
    var u;
    (function(p) {
      p.inboundSchema = t.CompletionResponseStreamChoice$inboundSchema, p.outboundSchema = t.CompletionResponseStreamChoice$outboundSchema;
    })(u || (t.CompletionResponseStreamChoice$ = u = {}));
    function c(p) {
      return JSON.stringify(t.CompletionResponseStreamChoice$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (d) => t.CompletionResponseStreamChoice$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'CompletionResponseStreamChoice' from JSON");
    }
  }(yi)), yi;
}
var GS;
function WT() {
  return GS || (GS = 1, function(t) {
    var e = _i && _i.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = _i && _i.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = _i && _i.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CompletionChunk$ = t.CompletionChunk$outboundSchema = t.CompletionChunk$inboundSchema = void 0, t.completionChunkToJSON = f, t.completionChunkFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ GT(), o = /* @__PURE__ */ rf();
    t.CompletionChunk$inboundSchema = r.object({
      id: r.string(),
      object: r.string().optional(),
      created: r.number().int().optional(),
      model: r.string(),
      usage: o.UsageInfo$inboundSchema.optional(),
      choices: r.array(s.CompletionResponseStreamChoice$inboundSchema)
    }), t.CompletionChunk$outboundSchema = r.object({
      id: r.string(),
      object: r.string().optional(),
      created: r.number().int().optional(),
      model: r.string(),
      usage: o.UsageInfo$outboundSchema.optional(),
      choices: r.array(s.CompletionResponseStreamChoice$outboundSchema)
    });
    var l;
    (function(c) {
      c.inboundSchema = t.CompletionChunk$inboundSchema, c.outboundSchema = t.CompletionChunk$outboundSchema;
    })(l || (t.CompletionChunk$ = l = {}));
    function f(c) {
      return JSON.stringify(t.CompletionChunk$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, i.safeParse)(c, (h) => t.CompletionChunk$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'CompletionChunk' from JSON");
    }
  }(_i)), _i;
}
var vi = {}, WS;
function _J() {
  return WS || (WS = 1, function(t) {
    var e = vi && vi.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = vi && vi.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = vi && vi.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CompletionEvent$ = t.CompletionEvent$outboundSchema = t.CompletionEvent$inboundSchema = void 0, t.completionEventToJSON = l, t.completionEventFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ WT();
    t.CompletionEvent$inboundSchema = r.object({
      data: r.string().transform((u, c) => {
        try {
          return JSON.parse(u);
        } catch (h) {
          return c.addIssue({
            code: r.ZodIssueCode.custom,
            message: `malformed json: ${h}`
          }), r.NEVER;
        }
      }).pipe(s.CompletionChunk$inboundSchema)
    }), t.CompletionEvent$outboundSchema = r.object({
      data: s.CompletionChunk$outboundSchema
    });
    var o;
    (function(u) {
      u.inboundSchema = t.CompletionEvent$inboundSchema, u.outboundSchema = t.CompletionEvent$outboundSchema;
    })(o || (t.CompletionEvent$ = o = {}));
    function l(u) {
      return JSON.stringify(t.CompletionEvent$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, i.safeParse)(u, (c) => t.CompletionEvent$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'CompletionEvent' from JSON");
    }
  }(vi)), vi;
}
var Si = {}, XS;
function yJ() {
  return XS || (XS = 1, function(t) {
    var e = Si && Si.__createBinding || (Object.create ? function(f, u, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(u, c);
      (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, u, c, h) {
      h === void 0 && (h = c), f[h] = u[c];
    }), n = Si && Si.__setModuleDefault || (Object.create ? function(f, u) {
      Object.defineProperty(f, "default", { enumerable: !0, value: u });
    } : function(f, u) {
      f.default = u;
    }), a = Si && Si.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var u = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(u, f, c);
      return n(u, f), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.DeleteFileOut$ = t.DeleteFileOut$outboundSchema = t.DeleteFileOut$inboundSchema = void 0, t.deleteFileOutToJSON = o, t.deleteFileOutFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.DeleteFileOut$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      deleted: r.boolean()
    }), t.DeleteFileOut$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      deleted: r.boolean()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.DeleteFileOut$inboundSchema, f.outboundSchema = t.DeleteFileOut$outboundSchema;
    })(s || (t.DeleteFileOut$ = s = {}));
    function o(f) {
      return JSON.stringify(t.DeleteFileOut$outboundSchema.parse(f));
    }
    function l(f) {
      return (0, i.safeParse)(f, (u) => t.DeleteFileOut$inboundSchema.parse(JSON.parse(u)), "Failed to parse 'DeleteFileOut' from JSON");
    }
  }(Si)), Si;
}
var Oi = {}, QS;
function wJ() {
  return QS || (QS = 1, function(t) {
    var e = Oi && Oi.__createBinding || (Object.create ? function(f, u, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(u, c);
      (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, u, c, h) {
      h === void 0 && (h = c), f[h] = u[c];
    }), n = Oi && Oi.__setModuleDefault || (Object.create ? function(f, u) {
      Object.defineProperty(f, "default", { enumerable: !0, value: u });
    } : function(f, u) {
      f.default = u;
    }), a = Oi && Oi.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var u = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(u, f, c);
      return n(u, f), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.DeleteModelOut$ = t.DeleteModelOut$outboundSchema = t.DeleteModelOut$inboundSchema = void 0, t.deleteModelOutToJSON = o, t.deleteModelOutFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.DeleteModelOut$inboundSchema = r.object({
      id: r.string(),
      object: r.string().default("model"),
      deleted: r.boolean().default(!0)
    }), t.DeleteModelOut$outboundSchema = r.object({
      id: r.string(),
      object: r.string().default("model"),
      deleted: r.boolean().default(!0)
    });
    var s;
    (function(f) {
      f.inboundSchema = t.DeleteModelOut$inboundSchema, f.outboundSchema = t.DeleteModelOut$outboundSchema;
    })(s || (t.DeleteModelOut$ = s = {}));
    function o(f) {
      return JSON.stringify(t.DeleteModelOut$outboundSchema.parse(f));
    }
    function l(f) {
      return (0, i.safeParse)(f, (u) => t.DeleteModelOut$inboundSchema.parse(JSON.parse(u)), "Failed to parse 'DeleteModelOut' from JSON");
    }
  }(Oi)), Oi;
}
var ji = {}, Pi = {}, YS;
function XT() {
  return YS || (YS = 1, function(t) {
    var e = Pi && Pi.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Pi && Pi.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Pi && Pi.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.EventOut$ = t.EventOut$outboundSchema = t.EventOut$inboundSchema = void 0, t.eventOutToJSON = l, t.eventOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.EventOut$inboundSchema = r.object({
      name: r.string(),
      data: r.nullable(r.record(r.any())).optional(),
      created_at: r.number().int()
    }).transform((u) => (0, i.remap)(u, {
      created_at: "createdAt"
    })), t.EventOut$outboundSchema = r.object({
      name: r.string(),
      data: r.nullable(r.record(r.any())).optional(),
      createdAt: r.number().int()
    }).transform((u) => (0, i.remap)(u, {
      createdAt: "created_at"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.EventOut$inboundSchema, u.outboundSchema = t.EventOut$outboundSchema;
    })(o || (t.EventOut$ = o = {}));
    function l(u) {
      return JSON.stringify(t.EventOut$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.EventOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'EventOut' from JSON");
    }
  }(Pi)), Pi;
}
var Ri = {}, eO;
function x_() {
  return eO || (eO = 1, function(t) {
    var e = Ri && Ri.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Ri && Ri.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Ri && Ri.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.GithubRepositoryOut$ = t.GithubRepositoryOut$outboundSchema = t.GithubRepositoryOut$inboundSchema = t.GithubRepositoryOutType$ = t.GithubRepositoryOutType$outboundSchema = t.GithubRepositoryOutType$inboundSchema = t.GithubRepositoryOutType = void 0, t.githubRepositoryOutToJSON = f, t.githubRepositoryOutFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.GithubRepositoryOutType = {
      Github: "github"
    }, t.GithubRepositoryOutType$inboundSchema = r.nativeEnum(t.GithubRepositoryOutType), t.GithubRepositoryOutType$outboundSchema = t.GithubRepositoryOutType$inboundSchema;
    var o;
    (function(c) {
      c.inboundSchema = t.GithubRepositoryOutType$inboundSchema, c.outboundSchema = t.GithubRepositoryOutType$outboundSchema;
    })(o || (t.GithubRepositoryOutType$ = o = {})), t.GithubRepositoryOut$inboundSchema = r.object({
      type: r.literal("github").default("github"),
      name: r.string(),
      owner: r.string(),
      ref: r.nullable(r.string()).optional(),
      weight: r.number().default(1),
      commit_id: r.string()
    }).transform((c) => (0, i.remap)(c, {
      commit_id: "commitId"
    })), t.GithubRepositoryOut$outboundSchema = r.object({
      type: r.literal("github").default("github"),
      name: r.string(),
      owner: r.string(),
      ref: r.nullable(r.string()).optional(),
      weight: r.number().default(1),
      commitId: r.string()
    }).transform((c) => (0, i.remap)(c, {
      commitId: "commit_id"
    }));
    var l;
    (function(c) {
      c.inboundSchema = t.GithubRepositoryOut$inboundSchema, c.outboundSchema = t.GithubRepositoryOut$outboundSchema;
    })(l || (t.GithubRepositoryOut$ = l = {}));
    function f(c) {
      return JSON.stringify(t.GithubRepositoryOut$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, s.safeParse)(c, (h) => t.GithubRepositoryOut$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'GithubRepositoryOut' from JSON");
    }
  }(Ri)), Ri;
}
var Ci = {}, tO;
function V_() {
  return tO || (tO = 1, function(t) {
    var e = Ci && Ci.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Ci && Ci.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Ci && Ci.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobMetadataOut$ = t.JobMetadataOut$outboundSchema = t.JobMetadataOut$inboundSchema = void 0, t.jobMetadataOutToJSON = l, t.jobMetadataOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobMetadataOut$inboundSchema = r.object({
      expected_duration_seconds: r.nullable(r.number().int()).optional(),
      cost: r.nullable(r.number()).optional(),
      cost_currency: r.nullable(r.string()).optional(),
      train_tokens_per_step: r.nullable(r.number().int()).optional(),
      train_tokens: r.nullable(r.number().int()).optional(),
      data_tokens: r.nullable(r.number().int()).optional(),
      estimated_start_time: r.nullable(r.number().int()).optional()
    }).transform((u) => (0, i.remap)(u, {
      expected_duration_seconds: "expectedDurationSeconds",
      cost_currency: "costCurrency",
      train_tokens_per_step: "trainTokensPerStep",
      train_tokens: "trainTokens",
      data_tokens: "dataTokens",
      estimated_start_time: "estimatedStartTime"
    })), t.JobMetadataOut$outboundSchema = r.object({
      expectedDurationSeconds: r.nullable(r.number().int()).optional(),
      cost: r.nullable(r.number()).optional(),
      costCurrency: r.nullable(r.string()).optional(),
      trainTokensPerStep: r.nullable(r.number().int()).optional(),
      trainTokens: r.nullable(r.number().int()).optional(),
      dataTokens: r.nullable(r.number().int()).optional(),
      estimatedStartTime: r.nullable(r.number().int()).optional()
    }).transform((u) => (0, i.remap)(u, {
      expectedDurationSeconds: "expected_duration_seconds",
      costCurrency: "cost_currency",
      trainTokensPerStep: "train_tokens_per_step",
      trainTokens: "train_tokens",
      dataTokens: "data_tokens",
      estimatedStartTime: "estimated_start_time"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.JobMetadataOut$inboundSchema, u.outboundSchema = t.JobMetadataOut$outboundSchema;
    })(o || (t.JobMetadataOut$ = o = {}));
    function l(u) {
      return JSON.stringify(t.JobMetadataOut$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.JobMetadataOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobMetadataOut' from JSON");
    }
  }(Ci)), Ci;
}
var Ti = {}, nO;
function z_() {
  return nO || (nO = 1, function(t) {
    var e = Ti && Ti.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Ti && Ti.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Ti && Ti.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.TrainingParameters$ = t.TrainingParameters$outboundSchema = t.TrainingParameters$inboundSchema = void 0, t.trainingParametersToJSON = l, t.trainingParametersFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.TrainingParameters$inboundSchema = r.object({
      training_steps: r.nullable(r.number().int()).optional(),
      learning_rate: r.number().default(1e-4),
      weight_decay: r.nullable(r.number()).optional(),
      warmup_fraction: r.nullable(r.number()).optional(),
      epochs: r.nullable(r.number()).optional(),
      fim_ratio: r.nullable(r.number()).optional(),
      seq_len: r.nullable(r.number().int()).optional()
    }).transform((u) => (0, i.remap)(u, {
      training_steps: "trainingSteps",
      learning_rate: "learningRate",
      weight_decay: "weightDecay",
      warmup_fraction: "warmupFraction",
      fim_ratio: "fimRatio",
      seq_len: "seqLen"
    })), t.TrainingParameters$outboundSchema = r.object({
      trainingSteps: r.nullable(r.number().int()).optional(),
      learningRate: r.number().default(1e-4),
      weightDecay: r.nullable(r.number()).optional(),
      warmupFraction: r.nullable(r.number()).optional(),
      epochs: r.nullable(r.number()).optional(),
      fimRatio: r.nullable(r.number()).optional(),
      seqLen: r.nullable(r.number().int()).optional()
    }).transform((u) => (0, i.remap)(u, {
      trainingSteps: "training_steps",
      learningRate: "learning_rate",
      weightDecay: "weight_decay",
      warmupFraction: "warmup_fraction",
      fimRatio: "fim_ratio",
      seqLen: "seq_len"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.TrainingParameters$inboundSchema, u.outboundSchema = t.TrainingParameters$outboundSchema;
    })(o || (t.TrainingParameters$ = o = {}));
    function l(u) {
      return JSON.stringify(t.TrainingParameters$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.TrainingParameters$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'TrainingParameters' from JSON");
    }
  }(Ti)), Ti;
}
var $i = {}, rO;
function Z_() {
  return rO || (rO = 1, function(t) {
    var e = $i && $i.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = $i && $i.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = $i && $i.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.WandbIntegrationOut$ = t.WandbIntegrationOut$outboundSchema = t.WandbIntegrationOut$inboundSchema = t.WandbIntegrationOutType$ = t.WandbIntegrationOutType$outboundSchema = t.WandbIntegrationOutType$inboundSchema = t.WandbIntegrationOutType = void 0, t.wandbIntegrationOutToJSON = f, t.wandbIntegrationOutFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.WandbIntegrationOutType = {
      Wandb: "wandb"
    }, t.WandbIntegrationOutType$inboundSchema = r.nativeEnum(t.WandbIntegrationOutType), t.WandbIntegrationOutType$outboundSchema = t.WandbIntegrationOutType$inboundSchema;
    var o;
    (function(c) {
      c.inboundSchema = t.WandbIntegrationOutType$inboundSchema, c.outboundSchema = t.WandbIntegrationOutType$outboundSchema;
    })(o || (t.WandbIntegrationOutType$ = o = {})), t.WandbIntegrationOut$inboundSchema = r.object({
      type: r.literal("wandb").default("wandb"),
      project: r.string(),
      name: r.nullable(r.string()).optional(),
      run_name: r.nullable(r.string()).optional()
    }).transform((c) => (0, i.remap)(c, {
      run_name: "runName"
    })), t.WandbIntegrationOut$outboundSchema = r.object({
      type: r.literal("wandb").default("wandb"),
      project: r.string(),
      name: r.nullable(r.string()).optional(),
      runName: r.nullable(r.string()).optional()
    }).transform((c) => (0, i.remap)(c, {
      runName: "run_name"
    }));
    var l;
    (function(c) {
      c.inboundSchema = t.WandbIntegrationOut$inboundSchema, c.outboundSchema = t.WandbIntegrationOut$outboundSchema;
    })(l || (t.WandbIntegrationOut$ = l = {}));
    function f(c) {
      return JSON.stringify(t.WandbIntegrationOut$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, s.safeParse)(c, (h) => t.WandbIntegrationOut$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'WandbIntegrationOut' from JSON");
    }
  }($i)), $i;
}
var aO;
function vJ() {
  return aO || (aO = 1, function(t) {
    var e = ji && ji.__createBinding || (Object.create ? function(A, M, I, N) {
      N === void 0 && (N = I);
      var w = Object.getOwnPropertyDescriptor(M, I);
      (!w || ("get" in w ? !M.__esModule : w.writable || w.configurable)) && (w = { enumerable: !0, get: function() {
        return M[I];
      } }), Object.defineProperty(A, N, w);
    } : function(A, M, I, N) {
      N === void 0 && (N = I), A[N] = M[I];
    }), n = ji && ji.__setModuleDefault || (Object.create ? function(A, M) {
      Object.defineProperty(A, "default", { enumerable: !0, value: M });
    } : function(A, M) {
      A.default = M;
    }), a = ji && ji.__importStar || function(A) {
      if (A && A.__esModule) return A;
      var M = {};
      if (A != null) for (var I in A) I !== "default" && Object.prototype.hasOwnProperty.call(A, I) && e(M, A, I);
      return n(M, A), M;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.DetailedJobOut$ = t.DetailedJobOut$outboundSchema = t.DetailedJobOut$inboundSchema = t.DetailedJobOutRepositories$ = t.DetailedJobOutRepositories$outboundSchema = t.DetailedJobOutRepositories$inboundSchema = t.DetailedJobOutIntegrations$ = t.DetailedJobOutIntegrations$outboundSchema = t.DetailedJobOutIntegrations$inboundSchema = t.DetailedJobOutObject$ = t.DetailedJobOutObject$outboundSchema = t.DetailedJobOutObject$inboundSchema = t.DetailedJobOutStatus$ = t.DetailedJobOutStatus$outboundSchema = t.DetailedJobOutStatus$inboundSchema = t.DetailedJobOutObject = t.DetailedJobOutStatus = void 0, t.detailedJobOutIntegrationsToJSON = b, t.detailedJobOutIntegrationsFromJSON = g, t.detailedJobOutRepositoriesToJSON = P, t.detailedJobOutRepositoriesFromJSON = C, t.detailedJobOutToJSON = T, t.detailedJobOutFromJSON = O;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ ZT(), l = /* @__PURE__ */ XT(), f = /* @__PURE__ */ x_(), u = /* @__PURE__ */ V_(), c = /* @__PURE__ */ z_(), h = /* @__PURE__ */ Z_();
    t.DetailedJobOutStatus = {
      Queued: "QUEUED",
      Started: "STARTED",
      Validating: "VALIDATING",
      Validated: "VALIDATED",
      Running: "RUNNING",
      FailedValidation: "FAILED_VALIDATION",
      Failed: "FAILED",
      Success: "SUCCESS",
      Cancelled: "CANCELLED",
      CancellationRequested: "CANCELLATION_REQUESTED"
    }, t.DetailedJobOutObject = {
      Job: "job"
    }, t.DetailedJobOutStatus$inboundSchema = r.nativeEnum(t.DetailedJobOutStatus), t.DetailedJobOutStatus$outboundSchema = t.DetailedJobOutStatus$inboundSchema;
    var p;
    (function(A) {
      A.inboundSchema = t.DetailedJobOutStatus$inboundSchema, A.outboundSchema = t.DetailedJobOutStatus$outboundSchema;
    })(p || (t.DetailedJobOutStatus$ = p = {})), t.DetailedJobOutObject$inboundSchema = r.nativeEnum(t.DetailedJobOutObject), t.DetailedJobOutObject$outboundSchema = t.DetailedJobOutObject$inboundSchema;
    var d;
    (function(A) {
      A.inboundSchema = t.DetailedJobOutObject$inboundSchema, A.outboundSchema = t.DetailedJobOutObject$outboundSchema;
    })(d || (t.DetailedJobOutObject$ = d = {})), t.DetailedJobOutIntegrations$inboundSchema = h.WandbIntegrationOut$inboundSchema, t.DetailedJobOutIntegrations$outboundSchema = h.WandbIntegrationOut$outboundSchema;
    var m;
    (function(A) {
      A.inboundSchema = t.DetailedJobOutIntegrations$inboundSchema, A.outboundSchema = t.DetailedJobOutIntegrations$outboundSchema;
    })(m || (t.DetailedJobOutIntegrations$ = m = {}));
    function b(A) {
      return JSON.stringify(t.DetailedJobOutIntegrations$outboundSchema.parse(A));
    }
    function g(A) {
      return (0, s.safeParse)(A, (M) => t.DetailedJobOutIntegrations$inboundSchema.parse(JSON.parse(M)), "Failed to parse 'DetailedJobOutIntegrations' from JSON");
    }
    t.DetailedJobOutRepositories$inboundSchema = f.GithubRepositoryOut$inboundSchema, t.DetailedJobOutRepositories$outboundSchema = f.GithubRepositoryOut$outboundSchema;
    var _;
    (function(A) {
      A.inboundSchema = t.DetailedJobOutRepositories$inboundSchema, A.outboundSchema = t.DetailedJobOutRepositories$outboundSchema;
    })(_ || (t.DetailedJobOutRepositories$ = _ = {}));
    function P(A) {
      return JSON.stringify(t.DetailedJobOutRepositories$outboundSchema.parse(A));
    }
    function C(A) {
      return (0, s.safeParse)(A, (M) => t.DetailedJobOutRepositories$inboundSchema.parse(JSON.parse(M)), "Failed to parse 'DetailedJobOutRepositories' from JSON");
    }
    t.DetailedJobOut$inboundSchema = r.object({
      id: r.string(),
      auto_start: r.boolean(),
      hyperparameters: c.TrainingParameters$inboundSchema,
      model: r.string(),
      status: t.DetailedJobOutStatus$inboundSchema,
      job_type: r.string(),
      created_at: r.number().int(),
      modified_at: r.number().int(),
      training_files: r.array(r.string()),
      validation_files: r.nullable(r.array(r.string())).optional(),
      object: r.literal("job").default("job"),
      fine_tuned_model: r.nullable(r.string()).optional(),
      suffix: r.nullable(r.string()).optional(),
      integrations: r.nullable(r.array(h.WandbIntegrationOut$inboundSchema)).optional(),
      trained_tokens: r.nullable(r.number().int()).optional(),
      repositories: r.array(f.GithubRepositoryOut$inboundSchema).optional(),
      metadata: r.nullable(u.JobMetadataOut$inboundSchema).optional(),
      events: r.array(l.EventOut$inboundSchema).optional(),
      checkpoints: r.array(o.CheckpointOut$inboundSchema).optional()
    }).transform((A) => (0, i.remap)(A, {
      auto_start: "autoStart",
      job_type: "jobType",
      created_at: "createdAt",
      modified_at: "modifiedAt",
      training_files: "trainingFiles",
      validation_files: "validationFiles",
      fine_tuned_model: "fineTunedModel",
      trained_tokens: "trainedTokens"
    })), t.DetailedJobOut$outboundSchema = r.object({
      id: r.string(),
      autoStart: r.boolean(),
      hyperparameters: c.TrainingParameters$outboundSchema,
      model: r.string(),
      status: t.DetailedJobOutStatus$outboundSchema,
      jobType: r.string(),
      createdAt: r.number().int(),
      modifiedAt: r.number().int(),
      trainingFiles: r.array(r.string()),
      validationFiles: r.nullable(r.array(r.string())).optional(),
      object: r.literal("job").default("job"),
      fineTunedModel: r.nullable(r.string()).optional(),
      suffix: r.nullable(r.string()).optional(),
      integrations: r.nullable(r.array(h.WandbIntegrationOut$outboundSchema)).optional(),
      trainedTokens: r.nullable(r.number().int()).optional(),
      repositories: r.array(f.GithubRepositoryOut$outboundSchema).optional(),
      metadata: r.nullable(u.JobMetadataOut$outboundSchema).optional(),
      events: r.array(l.EventOut$outboundSchema).optional(),
      checkpoints: r.array(o.CheckpointOut$outboundSchema).optional()
    }).transform((A) => (0, i.remap)(A, {
      autoStart: "auto_start",
      jobType: "job_type",
      createdAt: "created_at",
      modifiedAt: "modified_at",
      trainingFiles: "training_files",
      validationFiles: "validation_files",
      fineTunedModel: "fine_tuned_model",
      trainedTokens: "trained_tokens"
    }));
    var R;
    (function(A) {
      A.inboundSchema = t.DetailedJobOut$inboundSchema, A.outboundSchema = t.DetailedJobOut$outboundSchema;
    })(R || (t.DetailedJobOut$ = R = {}));
    function T(A) {
      return JSON.stringify(t.DetailedJobOut$outboundSchema.parse(A));
    }
    function O(A) {
      return (0, s.safeParse)(A, (M) => t.DetailedJobOut$inboundSchema.parse(JSON.parse(M)), "Failed to parse 'DetailedJobOut' from JSON");
    }
  }(ji)), ji;
}
var Mi = {}, iO;
function SJ() {
  return iO || (iO = 1, function(t) {
    var e = Mi && Mi.__createBinding || (Object.create ? function(p, d, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(d, m);
      (!g || ("get" in g ? !d.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return d[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, d, m, b) {
      b === void 0 && (b = m), p[b] = d[m];
    }), n = Mi && Mi.__setModuleDefault || (Object.create ? function(p, d) {
      Object.defineProperty(p, "default", { enumerable: !0, value: d });
    } : function(p, d) {
      p.default = d;
    }), a = Mi && Mi.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(d, p, m);
      return n(d, p), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.EmbeddingRequest$ = t.EmbeddingRequest$outboundSchema = t.EmbeddingRequest$inboundSchema = t.Inputs$ = t.Inputs$outboundSchema = t.Inputs$inboundSchema = void 0, t.inputsToJSON = l, t.inputsFromJSON = f, t.embeddingRequestToJSON = c, t.embeddingRequestFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.Inputs$inboundSchema = r.union([r.string(), r.array(r.string())]), t.Inputs$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var o;
    (function(p) {
      p.inboundSchema = t.Inputs$inboundSchema, p.outboundSchema = t.Inputs$outboundSchema;
    })(o || (t.Inputs$ = o = {}));
    function l(p) {
      return JSON.stringify(t.Inputs$outboundSchema.parse(p));
    }
    function f(p) {
      return (0, s.safeParse)(p, (d) => t.Inputs$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'Inputs' from JSON");
    }
    t.EmbeddingRequest$inboundSchema = r.object({
      model: r.string().default("mistral-embed"),
      input: r.union([r.string(), r.array(r.string())])
    }).transform((p) => (0, i.remap)(p, {
      input: "inputs"
    })), t.EmbeddingRequest$outboundSchema = r.object({
      model: r.string().default("mistral-embed"),
      inputs: r.union([r.string(), r.array(r.string())])
    }).transform((p) => (0, i.remap)(p, {
      inputs: "input"
    }));
    var u;
    (function(p) {
      p.inboundSchema = t.EmbeddingRequest$inboundSchema, p.outboundSchema = t.EmbeddingRequest$outboundSchema;
    })(u || (t.EmbeddingRequest$ = u = {}));
    function c(p) {
      return JSON.stringify(t.EmbeddingRequest$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (d) => t.EmbeddingRequest$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'EmbeddingRequest' from JSON");
    }
  }(Mi)), Mi;
}
var Ai = {}, Ei = {}, sO;
function QT() {
  return sO || (sO = 1, function(t) {
    var e = Ei && Ei.__createBinding || (Object.create ? function(f, u, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(u, c);
      (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, u, c, h) {
      h === void 0 && (h = c), f[h] = u[c];
    }), n = Ei && Ei.__setModuleDefault || (Object.create ? function(f, u) {
      Object.defineProperty(f, "default", { enumerable: !0, value: u });
    } : function(f, u) {
      f.default = u;
    }), a = Ei && Ei.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var u = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(u, f, c);
      return n(u, f), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.EmbeddingResponseData$ = t.EmbeddingResponseData$outboundSchema = t.EmbeddingResponseData$inboundSchema = void 0, t.embeddingResponseDataToJSON = o, t.embeddingResponseDataFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.EmbeddingResponseData$inboundSchema = r.object({
      object: r.string().optional(),
      embedding: r.array(r.number()).optional(),
      index: r.number().int().optional()
    }), t.EmbeddingResponseData$outboundSchema = r.object({
      object: r.string().optional(),
      embedding: r.array(r.number()).optional(),
      index: r.number().int().optional()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.EmbeddingResponseData$inboundSchema, f.outboundSchema = t.EmbeddingResponseData$outboundSchema;
    })(s || (t.EmbeddingResponseData$ = s = {}));
    function o(f) {
      return JSON.stringify(t.EmbeddingResponseData$outboundSchema.parse(f));
    }
    function l(f) {
      return (0, i.safeParse)(f, (u) => t.EmbeddingResponseData$inboundSchema.parse(JSON.parse(u)), "Failed to parse 'EmbeddingResponseData' from JSON");
    }
  }(Ei)), Ei;
}
var oO;
function OJ() {
  return oO || (oO = 1, function(t) {
    var e = Ai && Ai.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Ai && Ai.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Ai && Ai.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.EmbeddingResponse$ = t.EmbeddingResponse$outboundSchema = t.EmbeddingResponse$inboundSchema = void 0, t.embeddingResponseToJSON = f, t.embeddingResponseFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ QT(), o = /* @__PURE__ */ rf();
    t.EmbeddingResponse$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      model: r.string(),
      usage: o.UsageInfo$inboundSchema,
      data: r.array(s.EmbeddingResponseData$inboundSchema)
    }), t.EmbeddingResponse$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      model: r.string(),
      usage: o.UsageInfo$outboundSchema,
      data: r.array(s.EmbeddingResponseData$outboundSchema)
    });
    var l;
    (function(c) {
      c.inboundSchema = t.EmbeddingResponse$inboundSchema, c.outboundSchema = t.EmbeddingResponse$outboundSchema;
    })(l || (t.EmbeddingResponse$ = l = {}));
    function f(c) {
      return JSON.stringify(t.EmbeddingResponse$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, i.safeParse)(c, (h) => t.EmbeddingResponse$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'EmbeddingResponse' from JSON");
    }
  }(Ai)), Ai;
}
var Ii = {}, uO;
function Up() {
  return uO || (uO = 1, function(t) {
    var e = Ii && Ii.__createBinding || (Object.create ? function(o, l, f, u) {
      u === void 0 && (u = f);
      var c = Object.getOwnPropertyDescriptor(l, f);
      (!c || ("get" in c ? !l.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return l[f];
      } }), Object.defineProperty(o, u, c);
    } : function(o, l, f, u) {
      u === void 0 && (u = f), o[u] = l[f];
    }), n = Ii && Ii.__setModuleDefault || (Object.create ? function(o, l) {
      Object.defineProperty(o, "default", { enumerable: !0, value: l });
    } : function(o, l) {
      o.default = l;
    }), a = Ii && Ii.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var l = {};
      if (o != null) for (var f in o) f !== "default" && Object.prototype.hasOwnProperty.call(o, f) && e(l, o, f);
      return n(l, o), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilePurpose$ = t.FilePurpose$outboundSchema = t.FilePurpose$inboundSchema = t.FilePurpose = void 0;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ iu();
    t.FilePurpose = {
      FineTune: "fine-tune",
      Batch: "batch",
      Ocr: "ocr"
    }, t.FilePurpose$inboundSchema = r.union([
      r.nativeEnum(t.FilePurpose),
      r.string().transform(i.catchUnrecognizedEnum)
    ]), t.FilePurpose$outboundSchema = r.union([
      r.nativeEnum(t.FilePurpose),
      r.string().and(r.custom())
    ]);
    var s;
    (function(o) {
      o.inboundSchema = t.FilePurpose$inboundSchema, o.outboundSchema = t.FilePurpose$outboundSchema;
    })(s || (t.FilePurpose$ = s = {}));
  }(Ii)), Ii;
}
var Ni = {}, ki = {}, cO;
function Bp() {
  return cO || (cO = 1, function(t) {
    var e = ki && ki.__createBinding || (Object.create ? function(o, l, f, u) {
      u === void 0 && (u = f);
      var c = Object.getOwnPropertyDescriptor(l, f);
      (!c || ("get" in c ? !l.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return l[f];
      } }), Object.defineProperty(o, u, c);
    } : function(o, l, f, u) {
      u === void 0 && (u = f), o[u] = l[f];
    }), n = ki && ki.__setModuleDefault || (Object.create ? function(o, l) {
      Object.defineProperty(o, "default", { enumerable: !0, value: l });
    } : function(o, l) {
      o.default = l;
    }), a = ki && ki.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var l = {};
      if (o != null) for (var f in o) f !== "default" && Object.prototype.hasOwnProperty.call(o, f) && e(l, o, f);
      return n(l, o), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SampleType$ = t.SampleType$outboundSchema = t.SampleType$inboundSchema = t.SampleType = void 0;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ iu();
    t.SampleType = {
      Pretrain: "pretrain",
      Instruct: "instruct",
      BatchRequest: "batch_request",
      BatchResult: "batch_result",
      BatchError: "batch_error"
    }, t.SampleType$inboundSchema = r.union([
      r.nativeEnum(t.SampleType),
      r.string().transform(i.catchUnrecognizedEnum)
    ]), t.SampleType$outboundSchema = r.union([
      r.nativeEnum(t.SampleType),
      r.string().and(r.custom())
    ]);
    var s;
    (function(o) {
      o.inboundSchema = t.SampleType$inboundSchema, o.outboundSchema = t.SampleType$outboundSchema;
    })(s || (t.SampleType$ = s = {}));
  }(ki)), ki;
}
var Fi = {}, lO;
function xp() {
  return lO || (lO = 1, function(t) {
    var e = Fi && Fi.__createBinding || (Object.create ? function(o, l, f, u) {
      u === void 0 && (u = f);
      var c = Object.getOwnPropertyDescriptor(l, f);
      (!c || ("get" in c ? !l.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return l[f];
      } }), Object.defineProperty(o, u, c);
    } : function(o, l, f, u) {
      u === void 0 && (u = f), o[u] = l[f];
    }), n = Fi && Fi.__setModuleDefault || (Object.create ? function(o, l) {
      Object.defineProperty(o, "default", { enumerable: !0, value: l });
    } : function(o, l) {
      o.default = l;
    }), a = Fi && Fi.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var l = {};
      if (o != null) for (var f in o) f !== "default" && Object.prototype.hasOwnProperty.call(o, f) && e(l, o, f);
      return n(l, o), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Source$ = t.Source$outboundSchema = t.Source$inboundSchema = t.Source = void 0;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ iu();
    t.Source = {
      Upload: "upload",
      Repository: "repository",
      Mistral: "mistral"
    }, t.Source$inboundSchema = r.union([
      r.nativeEnum(t.Source),
      r.string().transform(i.catchUnrecognizedEnum)
    ]), t.Source$outboundSchema = r.union([
      r.nativeEnum(t.Source),
      r.string().and(r.custom())
    ]);
    var s;
    (function(o) {
      o.inboundSchema = t.Source$inboundSchema, o.outboundSchema = t.Source$outboundSchema;
    })(s || (t.Source$ = s = {}));
  }(Fi)), Fi;
}
var dO;
function YT() {
  return dO || (dO = 1, function(t) {
    var e = Ni && Ni.__createBinding || (Object.create ? function(p, d, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(d, m);
      (!g || ("get" in g ? !d.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return d[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, d, m, b) {
      b === void 0 && (b = m), p[b] = d[m];
    }), n = Ni && Ni.__setModuleDefault || (Object.create ? function(p, d) {
      Object.defineProperty(p, "default", { enumerable: !0, value: d });
    } : function(p, d) {
      p.default = d;
    }), a = Ni && Ni.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(d, p, m);
      return n(d, p), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FileSchema$ = t.FileSchema$outboundSchema = t.FileSchema$inboundSchema = void 0, t.fileSchemaToJSON = c, t.fileSchemaFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Up(), l = /* @__PURE__ */ Bp(), f = /* @__PURE__ */ xp();
    t.FileSchema$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      bytes: r.number().int(),
      created_at: r.number().int(),
      filename: r.string(),
      purpose: o.FilePurpose$inboundSchema,
      sample_type: l.SampleType$inboundSchema,
      num_lines: r.nullable(r.number().int()).optional(),
      source: f.Source$inboundSchema
    }).transform((p) => (0, i.remap)(p, {
      bytes: "sizeBytes",
      created_at: "createdAt",
      sample_type: "sampleType",
      num_lines: "numLines"
    })), t.FileSchema$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      sizeBytes: r.number().int(),
      createdAt: r.number().int(),
      filename: r.string(),
      purpose: o.FilePurpose$outboundSchema,
      sampleType: l.SampleType$outboundSchema,
      numLines: r.nullable(r.number().int()).optional(),
      source: f.Source$outboundSchema
    }).transform((p) => (0, i.remap)(p, {
      sizeBytes: "bytes",
      createdAt: "created_at",
      sampleType: "sample_type",
      numLines: "num_lines"
    }));
    var u;
    (function(p) {
      p.inboundSchema = t.FileSchema$inboundSchema, p.outboundSchema = t.FileSchema$outboundSchema;
    })(u || (t.FileSchema$ = u = {}));
    function c(p) {
      return JSON.stringify(t.FileSchema$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (d) => t.FileSchema$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'FileSchema' from JSON");
    }
  }(Ni)), Ni;
}
var Di = {}, fO;
function jJ() {
  return fO || (fO = 1, function(t) {
    var e = Di && Di.__createBinding || (Object.create ? function(f, u, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(u, c);
      (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, u, c, h) {
      h === void 0 && (h = c), f[h] = u[c];
    }), n = Di && Di.__setModuleDefault || (Object.create ? function(f, u) {
      Object.defineProperty(f, "default", { enumerable: !0, value: u });
    } : function(f, u) {
      f.default = u;
    }), a = Di && Di.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var u = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(u, f, c);
      return n(u, f), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FileSignedURL$ = t.FileSignedURL$outboundSchema = t.FileSignedURL$inboundSchema = void 0, t.fileSignedURLToJSON = o, t.fileSignedURLFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.FileSignedURL$inboundSchema = r.object({
      url: r.string()
    }), t.FileSignedURL$outboundSchema = r.object({
      url: r.string()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.FileSignedURL$inboundSchema, f.outboundSchema = t.FileSignedURL$outboundSchema;
    })(s || (t.FileSignedURL$ = s = {}));
    function o(f) {
      return JSON.stringify(t.FileSignedURL$outboundSchema.parse(f));
    }
    function l(f) {
      return (0, i.safeParse)(f, (u) => t.FileSignedURL$inboundSchema.parse(JSON.parse(u)), "Failed to parse 'FileSignedURL' from JSON");
    }
  }(Di)), Di;
}
var qi = {}, hO;
function PJ() {
  return hO || (hO = 1, function(t) {
    var e = qi && qi.__createBinding || (Object.create ? function(p, d, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(d, m);
      (!g || ("get" in g ? !d.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return d[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, d, m, b) {
      b === void 0 && (b = m), p[b] = d[m];
    }), n = qi && qi.__setModuleDefault || (Object.create ? function(p, d) {
      Object.defineProperty(p, "default", { enumerable: !0, value: d });
    } : function(p, d) {
      p.default = d;
    }), a = qi && qi.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(d, p, m);
      return n(d, p), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FIMCompletionRequest$ = t.FIMCompletionRequest$outboundSchema = t.FIMCompletionRequest$inboundSchema = t.FIMCompletionRequestStop$ = t.FIMCompletionRequestStop$outboundSchema = t.FIMCompletionRequestStop$inboundSchema = void 0, t.fimCompletionRequestStopToJSON = l, t.fimCompletionRequestStopFromJSON = f, t.fimCompletionRequestToJSON = c, t.fimCompletionRequestFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FIMCompletionRequestStop$inboundSchema = r.union([r.string(), r.array(r.string())]), t.FIMCompletionRequestStop$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var o;
    (function(p) {
      p.inboundSchema = t.FIMCompletionRequestStop$inboundSchema, p.outboundSchema = t.FIMCompletionRequestStop$outboundSchema;
    })(o || (t.FIMCompletionRequestStop$ = o = {}));
    function l(p) {
      return JSON.stringify(t.FIMCompletionRequestStop$outboundSchema.parse(p));
    }
    function f(p) {
      return (0, s.safeParse)(p, (d) => t.FIMCompletionRequestStop$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'FIMCompletionRequestStop' from JSON");
    }
    t.FIMCompletionRequest$inboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      top_p: r.number().default(1),
      max_tokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!1),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      random_seed: r.nullable(r.number().int()).optional(),
      prompt: r.string(),
      suffix: r.nullable(r.string()).optional(),
      min_tokens: r.nullable(r.number().int()).optional()
    }).transform((p) => (0, i.remap)(p, {
      top_p: "topP",
      max_tokens: "maxTokens",
      random_seed: "randomSeed",
      min_tokens: "minTokens"
    })), t.FIMCompletionRequest$outboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      topP: r.number().default(1),
      maxTokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!1),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      randomSeed: r.nullable(r.number().int()).optional(),
      prompt: r.string(),
      suffix: r.nullable(r.string()).optional(),
      minTokens: r.nullable(r.number().int()).optional()
    }).transform((p) => (0, i.remap)(p, {
      topP: "top_p",
      maxTokens: "max_tokens",
      randomSeed: "random_seed",
      minTokens: "min_tokens"
    }));
    var u;
    (function(p) {
      p.inboundSchema = t.FIMCompletionRequest$inboundSchema, p.outboundSchema = t.FIMCompletionRequest$outboundSchema;
    })(u || (t.FIMCompletionRequest$ = u = {}));
    function c(p) {
      return JSON.stringify(t.FIMCompletionRequest$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (d) => t.FIMCompletionRequest$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'FIMCompletionRequest' from JSON");
    }
  }(qi)), qi;
}
var Ji = {}, pO;
function RJ() {
  return pO || (pO = 1, function(t) {
    var e = Ji && Ji.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Ji && Ji.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Ji && Ji.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FIMCompletionResponse$ = t.FIMCompletionResponse$outboundSchema = t.FIMCompletionResponse$inboundSchema = void 0, t.fimCompletionResponseToJSON = f, t.fimCompletionResponseFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ B_(), o = /* @__PURE__ */ rf();
    t.FIMCompletionResponse$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      model: r.string(),
      usage: o.UsageInfo$inboundSchema,
      created: r.number().int().optional(),
      choices: r.array(s.ChatCompletionChoice$inboundSchema).optional()
    }), t.FIMCompletionResponse$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      model: r.string(),
      usage: o.UsageInfo$outboundSchema,
      created: r.number().int().optional(),
      choices: r.array(s.ChatCompletionChoice$outboundSchema).optional()
    });
    var l;
    (function(c) {
      c.inboundSchema = t.FIMCompletionResponse$inboundSchema, c.outboundSchema = t.FIMCompletionResponse$outboundSchema;
    })(l || (t.FIMCompletionResponse$ = l = {}));
    function f(c) {
      return JSON.stringify(t.FIMCompletionResponse$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, i.safeParse)(c, (h) => t.FIMCompletionResponse$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'FIMCompletionResponse' from JSON");
    }
  }(Ji)), Ji;
}
var Li = {}, mO;
function CJ() {
  return mO || (mO = 1, function(t) {
    var e = Li && Li.__createBinding || (Object.create ? function(p, d, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(d, m);
      (!g || ("get" in g ? !d.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return d[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, d, m, b) {
      b === void 0 && (b = m), p[b] = d[m];
    }), n = Li && Li.__setModuleDefault || (Object.create ? function(p, d) {
      Object.defineProperty(p, "default", { enumerable: !0, value: d });
    } : function(p, d) {
      p.default = d;
    }), a = Li && Li.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(d, p, m);
      return n(d, p), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FIMCompletionStreamRequest$ = t.FIMCompletionStreamRequest$outboundSchema = t.FIMCompletionStreamRequest$inboundSchema = t.FIMCompletionStreamRequestStop$ = t.FIMCompletionStreamRequestStop$outboundSchema = t.FIMCompletionStreamRequestStop$inboundSchema = void 0, t.fimCompletionStreamRequestStopToJSON = l, t.fimCompletionStreamRequestStopFromJSON = f, t.fimCompletionStreamRequestToJSON = c, t.fimCompletionStreamRequestFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FIMCompletionStreamRequestStop$inboundSchema = r.union([r.string(), r.array(r.string())]), t.FIMCompletionStreamRequestStop$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var o;
    (function(p) {
      p.inboundSchema = t.FIMCompletionStreamRequestStop$inboundSchema, p.outboundSchema = t.FIMCompletionStreamRequestStop$outboundSchema;
    })(o || (t.FIMCompletionStreamRequestStop$ = o = {}));
    function l(p) {
      return JSON.stringify(t.FIMCompletionStreamRequestStop$outboundSchema.parse(p));
    }
    function f(p) {
      return (0, s.safeParse)(p, (d) => t.FIMCompletionStreamRequestStop$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'FIMCompletionStreamRequestStop' from JSON");
    }
    t.FIMCompletionStreamRequest$inboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      top_p: r.number().default(1),
      max_tokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!0),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      random_seed: r.nullable(r.number().int()).optional(),
      prompt: r.string(),
      suffix: r.nullable(r.string()).optional(),
      min_tokens: r.nullable(r.number().int()).optional()
    }).transform((p) => (0, i.remap)(p, {
      top_p: "topP",
      max_tokens: "maxTokens",
      random_seed: "randomSeed",
      min_tokens: "minTokens"
    })), t.FIMCompletionStreamRequest$outboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      topP: r.number().default(1),
      maxTokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!0),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      randomSeed: r.nullable(r.number().int()).optional(),
      prompt: r.string(),
      suffix: r.nullable(r.string()).optional(),
      minTokens: r.nullable(r.number().int()).optional()
    }).transform((p) => (0, i.remap)(p, {
      topP: "top_p",
      maxTokens: "max_tokens",
      randomSeed: "random_seed",
      minTokens: "min_tokens"
    }));
    var u;
    (function(p) {
      p.inboundSchema = t.FIMCompletionStreamRequest$inboundSchema, p.outboundSchema = t.FIMCompletionStreamRequest$outboundSchema;
    })(u || (t.FIMCompletionStreamRequest$ = u = {}));
    function c(p) {
      return JSON.stringify(t.FIMCompletionStreamRequest$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (d) => t.FIMCompletionStreamRequest$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'FIMCompletionStreamRequest' from JSON");
    }
  }(Li)), Li;
}
var Ui = {}, bO;
function e$() {
  return bO || (bO = 1, function(t) {
    var e = Ui && Ui.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Ui && Ui.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Ui && Ui.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FTModelCapabilitiesOut$ = t.FTModelCapabilitiesOut$outboundSchema = t.FTModelCapabilitiesOut$inboundSchema = void 0, t.ftModelCapabilitiesOutToJSON = l, t.ftModelCapabilitiesOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FTModelCapabilitiesOut$inboundSchema = r.object({
      completion_chat: r.boolean().default(!0),
      completion_fim: r.boolean().default(!1),
      function_calling: r.boolean().default(!1),
      fine_tuning: r.boolean().default(!1)
    }).transform((u) => (0, i.remap)(u, {
      completion_chat: "completionChat",
      completion_fim: "completionFim",
      function_calling: "functionCalling",
      fine_tuning: "fineTuning"
    })), t.FTModelCapabilitiesOut$outboundSchema = r.object({
      completionChat: r.boolean().default(!0),
      completionFim: r.boolean().default(!1),
      functionCalling: r.boolean().default(!1),
      fineTuning: r.boolean().default(!1)
    }).transform((u) => (0, i.remap)(u, {
      completionChat: "completion_chat",
      completionFim: "completion_fim",
      functionCalling: "function_calling",
      fineTuning: "fine_tuning"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.FTModelCapabilitiesOut$inboundSchema, u.outboundSchema = t.FTModelCapabilitiesOut$outboundSchema;
    })(o || (t.FTModelCapabilitiesOut$ = o = {}));
    function l(u) {
      return JSON.stringify(t.FTModelCapabilitiesOut$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.FTModelCapabilitiesOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'FTModelCapabilitiesOut' from JSON");
    }
  }(Ui)), Ui;
}
var Bi = {}, gO;
function t$() {
  return gO || (gO = 1, function(t) {
    var e = Bi && Bi.__createBinding || (Object.create ? function(h, p, d, m) {
      m === void 0 && (m = d);
      var b = Object.getOwnPropertyDescriptor(p, d);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[d];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, d, m) {
      m === void 0 && (m = d), h[m] = p[d];
    }), n = Bi && Bi.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = Bi && Bi.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var d in h) d !== "default" && Object.prototype.hasOwnProperty.call(h, d) && e(p, h, d);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FTModelCard$ = t.FTModelCard$outboundSchema = t.FTModelCard$inboundSchema = t.FTModelCardType$ = t.FTModelCardType$outboundSchema = t.FTModelCardType$inboundSchema = t.FTModelCardType = void 0, t.ftModelCardToJSON = u, t.ftModelCardFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ U_();
    t.FTModelCardType = {
      FineTuned: "fine-tuned"
    }, t.FTModelCardType$inboundSchema = r.nativeEnum(t.FTModelCardType), t.FTModelCardType$outboundSchema = t.FTModelCardType$inboundSchema;
    var l;
    (function(h) {
      h.inboundSchema = t.FTModelCardType$inboundSchema, h.outboundSchema = t.FTModelCardType$outboundSchema;
    })(l || (t.FTModelCardType$ = l = {})), t.FTModelCard$inboundSchema = r.object({
      id: r.string(),
      object: r.string().default("model"),
      created: r.number().int().optional(),
      owned_by: r.string().default("mistralai"),
      capabilities: o.ModelCapabilities$inboundSchema,
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional(),
      max_context_length: r.number().int().default(32768),
      aliases: r.array(r.string()).optional(),
      deprecation: r.nullable(r.string().datetime({ offset: !0 }).transform((h) => new Date(h))).optional(),
      default_model_temperature: r.nullable(r.number()).optional(),
      type: r.literal("fine-tuned").default("fine-tuned"),
      job: r.string(),
      root: r.string(),
      archived: r.boolean().default(!1)
    }).transform((h) => (0, i.remap)(h, {
      owned_by: "ownedBy",
      max_context_length: "maxContextLength",
      default_model_temperature: "defaultModelTemperature"
    })), t.FTModelCard$outboundSchema = r.object({
      id: r.string(),
      object: r.string().default("model"),
      created: r.number().int().optional(),
      ownedBy: r.string().default("mistralai"),
      capabilities: o.ModelCapabilities$outboundSchema,
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional(),
      maxContextLength: r.number().int().default(32768),
      aliases: r.array(r.string()).optional(),
      deprecation: r.nullable(r.date().transform((h) => h.toISOString())).optional(),
      defaultModelTemperature: r.nullable(r.number()).optional(),
      type: r.literal("fine-tuned").default("fine-tuned"),
      job: r.string(),
      root: r.string(),
      archived: r.boolean().default(!1)
    }).transform((h) => (0, i.remap)(h, {
      ownedBy: "owned_by",
      maxContextLength: "max_context_length",
      defaultModelTemperature: "default_model_temperature"
    }));
    var f;
    (function(h) {
      h.inboundSchema = t.FTModelCard$inboundSchema, h.outboundSchema = t.FTModelCard$outboundSchema;
    })(f || (t.FTModelCard$ = f = {}));
    function u(h) {
      return JSON.stringify(t.FTModelCard$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, s.safeParse)(h, (p) => t.FTModelCard$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'FTModelCard' from JSON");
    }
  }(Bi)), Bi;
}
var xi = {}, _O;
function TJ() {
  return _O || (_O = 1, function(t) {
    var e = xi && xi.__createBinding || (Object.create ? function(h, p, d, m) {
      m === void 0 && (m = d);
      var b = Object.getOwnPropertyDescriptor(p, d);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[d];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, d, m) {
      m === void 0 && (m = d), h[m] = p[d];
    }), n = xi && xi.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = xi && xi.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var d in h) d !== "default" && Object.prototype.hasOwnProperty.call(h, d) && e(p, h, d);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FTModelOut$ = t.FTModelOut$outboundSchema = t.FTModelOut$inboundSchema = t.FTModelOutObject$ = t.FTModelOutObject$outboundSchema = t.FTModelOutObject$inboundSchema = t.FTModelOutObject = void 0, t.ftModelOutToJSON = u, t.ftModelOutFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ e$();
    t.FTModelOutObject = {
      Model: "model"
    }, t.FTModelOutObject$inboundSchema = r.nativeEnum(t.FTModelOutObject), t.FTModelOutObject$outboundSchema = t.FTModelOutObject$inboundSchema;
    var l;
    (function(h) {
      h.inboundSchema = t.FTModelOutObject$inboundSchema, h.outboundSchema = t.FTModelOutObject$outboundSchema;
    })(l || (t.FTModelOutObject$ = l = {})), t.FTModelOut$inboundSchema = r.object({
      id: r.string(),
      object: r.literal("model").default("model"),
      created: r.number().int(),
      owned_by: r.string(),
      root: r.string(),
      archived: r.boolean(),
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional(),
      capabilities: o.FTModelCapabilitiesOut$inboundSchema,
      max_context_length: r.number().int().default(32768),
      aliases: r.array(r.string()).optional(),
      job: r.string()
    }).transform((h) => (0, i.remap)(h, {
      owned_by: "ownedBy",
      max_context_length: "maxContextLength"
    })), t.FTModelOut$outboundSchema = r.object({
      id: r.string(),
      object: r.literal("model").default("model"),
      created: r.number().int(),
      ownedBy: r.string(),
      root: r.string(),
      archived: r.boolean(),
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional(),
      capabilities: o.FTModelCapabilitiesOut$outboundSchema,
      maxContextLength: r.number().int().default(32768),
      aliases: r.array(r.string()).optional(),
      job: r.string()
    }).transform((h) => (0, i.remap)(h, {
      ownedBy: "owned_by",
      maxContextLength: "max_context_length"
    }));
    var f;
    (function(h) {
      h.inboundSchema = t.FTModelOut$inboundSchema, h.outboundSchema = t.FTModelOut$outboundSchema;
    })(f || (t.FTModelOut$ = f = {}));
    function u(h) {
      return JSON.stringify(t.FTModelOut$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, s.safeParse)(h, (p) => t.FTModelOut$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'FTModelOut' from JSON");
    }
  }(xi)), xi;
}
var Vi = {}, yO;
function n$() {
  return yO || (yO = 1, function(t) {
    var e = Vi && Vi.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Vi && Vi.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Vi && Vi.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.GithubRepositoryIn$ = t.GithubRepositoryIn$outboundSchema = t.GithubRepositoryIn$inboundSchema = t.GithubRepositoryInType$ = t.GithubRepositoryInType$outboundSchema = t.GithubRepositoryInType$inboundSchema = t.GithubRepositoryInType = void 0, t.githubRepositoryInToJSON = l, t.githubRepositoryInFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.GithubRepositoryInType = {
      Github: "github"
    }, t.GithubRepositoryInType$inboundSchema = r.nativeEnum(t.GithubRepositoryInType), t.GithubRepositoryInType$outboundSchema = t.GithubRepositoryInType$inboundSchema;
    var s;
    (function(u) {
      u.inboundSchema = t.GithubRepositoryInType$inboundSchema, u.outboundSchema = t.GithubRepositoryInType$outboundSchema;
    })(s || (t.GithubRepositoryInType$ = s = {})), t.GithubRepositoryIn$inboundSchema = r.object({
      type: r.literal("github").default("github"),
      name: r.string(),
      owner: r.string(),
      ref: r.nullable(r.string()).optional(),
      weight: r.number().default(1),
      token: r.string()
    }), t.GithubRepositoryIn$outboundSchema = r.object({
      type: r.literal("github").default("github"),
      name: r.string(),
      owner: r.string(),
      ref: r.nullable(r.string()).optional(),
      weight: r.number().default(1),
      token: r.string()
    });
    var o;
    (function(u) {
      u.inboundSchema = t.GithubRepositoryIn$inboundSchema, u.outboundSchema = t.GithubRepositoryIn$outboundSchema;
    })(o || (t.GithubRepositoryIn$ = o = {}));
    function l(u) {
      return JSON.stringify(t.GithubRepositoryIn$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, i.safeParse)(u, (c) => t.GithubRepositoryIn$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'GithubRepositoryIn' from JSON");
    }
  }(Vi)), Vi;
}
var zi = {}, Zi = {}, wO;
function r$() {
  return wO || (wO = 1, function(t) {
    var e = Zi && Zi.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Zi && Zi.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Zi && Zi.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.TrainingFile$ = t.TrainingFile$outboundSchema = t.TrainingFile$inboundSchema = void 0, t.trainingFileToJSON = l, t.trainingFileFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.TrainingFile$inboundSchema = r.object({
      file_id: r.string(),
      weight: r.number().default(1)
    }).transform((u) => (0, i.remap)(u, {
      file_id: "fileId"
    })), t.TrainingFile$outboundSchema = r.object({
      fileId: r.string(),
      weight: r.number().default(1)
    }).transform((u) => (0, i.remap)(u, {
      fileId: "file_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.TrainingFile$inboundSchema, u.outboundSchema = t.TrainingFile$outboundSchema;
    })(o || (t.TrainingFile$ = o = {}));
    function l(u) {
      return JSON.stringify(t.TrainingFile$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.TrainingFile$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'TrainingFile' from JSON");
    }
  }(Zi)), Zi;
}
var Ki = {}, vO;
function a$() {
  return vO || (vO = 1, function(t) {
    var e = Ki && Ki.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Ki && Ki.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Ki && Ki.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.TrainingParametersIn$ = t.TrainingParametersIn$outboundSchema = t.TrainingParametersIn$inboundSchema = void 0, t.trainingParametersInToJSON = l, t.trainingParametersInFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.TrainingParametersIn$inboundSchema = r.object({
      training_steps: r.nullable(r.number().int()).optional(),
      learning_rate: r.number().default(1e-4),
      weight_decay: r.nullable(r.number()).optional(),
      warmup_fraction: r.nullable(r.number()).optional(),
      epochs: r.nullable(r.number()).optional(),
      fim_ratio: r.nullable(r.number()).optional(),
      seq_len: r.nullable(r.number().int()).optional()
    }).transform((u) => (0, i.remap)(u, {
      training_steps: "trainingSteps",
      learning_rate: "learningRate",
      weight_decay: "weightDecay",
      warmup_fraction: "warmupFraction",
      fim_ratio: "fimRatio",
      seq_len: "seqLen"
    })), t.TrainingParametersIn$outboundSchema = r.object({
      trainingSteps: r.nullable(r.number().int()).optional(),
      learningRate: r.number().default(1e-4),
      weightDecay: r.nullable(r.number()).optional(),
      warmupFraction: r.nullable(r.number()).optional(),
      epochs: r.nullable(r.number()).optional(),
      fimRatio: r.nullable(r.number()).optional(),
      seqLen: r.nullable(r.number().int()).optional()
    }).transform((u) => (0, i.remap)(u, {
      trainingSteps: "training_steps",
      learningRate: "learning_rate",
      weightDecay: "weight_decay",
      warmupFraction: "warmup_fraction",
      fimRatio: "fim_ratio",
      seqLen: "seq_len"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.TrainingParametersIn$inboundSchema, u.outboundSchema = t.TrainingParametersIn$outboundSchema;
    })(o || (t.TrainingParametersIn$ = o = {}));
    function l(u) {
      return JSON.stringify(t.TrainingParametersIn$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.TrainingParametersIn$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'TrainingParametersIn' from JSON");
    }
  }(Ki)), Ki;
}
var Hi = {}, SO;
function i$() {
  return SO || (SO = 1, function(t) {
    var e = Hi && Hi.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Hi && Hi.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Hi && Hi.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.WandbIntegration$ = t.WandbIntegration$outboundSchema = t.WandbIntegration$inboundSchema = t.WandbIntegrationType$ = t.WandbIntegrationType$outboundSchema = t.WandbIntegrationType$inboundSchema = t.WandbIntegrationType = void 0, t.wandbIntegrationToJSON = f, t.wandbIntegrationFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.WandbIntegrationType = {
      Wandb: "wandb"
    }, t.WandbIntegrationType$inboundSchema = r.nativeEnum(t.WandbIntegrationType), t.WandbIntegrationType$outboundSchema = t.WandbIntegrationType$inboundSchema;
    var o;
    (function(c) {
      c.inboundSchema = t.WandbIntegrationType$inboundSchema, c.outboundSchema = t.WandbIntegrationType$outboundSchema;
    })(o || (t.WandbIntegrationType$ = o = {})), t.WandbIntegration$inboundSchema = r.object({
      type: r.literal("wandb").default("wandb"),
      project: r.string(),
      name: r.nullable(r.string()).optional(),
      api_key: r.string(),
      run_name: r.nullable(r.string()).optional()
    }).transform((c) => (0, i.remap)(c, {
      api_key: "apiKey",
      run_name: "runName"
    })), t.WandbIntegration$outboundSchema = r.object({
      type: r.literal("wandb").default("wandb"),
      project: r.string(),
      name: r.nullable(r.string()).optional(),
      apiKey: r.string(),
      runName: r.nullable(r.string()).optional()
    }).transform((c) => (0, i.remap)(c, {
      apiKey: "api_key",
      runName: "run_name"
    }));
    var l;
    (function(c) {
      c.inboundSchema = t.WandbIntegration$inboundSchema, c.outboundSchema = t.WandbIntegration$outboundSchema;
    })(l || (t.WandbIntegration$ = l = {}));
    function f(c) {
      return JSON.stringify(t.WandbIntegration$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, s.safeParse)(c, (h) => t.WandbIntegration$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'WandbIntegration' from JSON");
    }
  }(Hi)), Hi;
}
var OO;
function $J() {
  return OO || (OO = 1, function(t) {
    var e = zi && zi.__createBinding || (Object.create ? function(C, R, T, O) {
      O === void 0 && (O = T);
      var A = Object.getOwnPropertyDescriptor(R, T);
      (!A || ("get" in A ? !R.__esModule : A.writable || A.configurable)) && (A = { enumerable: !0, get: function() {
        return R[T];
      } }), Object.defineProperty(C, O, A);
    } : function(C, R, T, O) {
      O === void 0 && (O = T), C[O] = R[T];
    }), n = zi && zi.__setModuleDefault || (Object.create ? function(C, R) {
      Object.defineProperty(C, "default", { enumerable: !0, value: R });
    } : function(C, R) {
      C.default = R;
    }), a = zi && zi.__importStar || function(C) {
      if (C && C.__esModule) return C;
      var R = {};
      if (C != null) for (var T in C) T !== "default" && Object.prototype.hasOwnProperty.call(C, T) && e(R, C, T);
      return n(R, C), R;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobIn$ = t.JobIn$outboundSchema = t.JobIn$inboundSchema = t.JobInRepositories$ = t.JobInRepositories$outboundSchema = t.JobInRepositories$inboundSchema = t.JobInIntegrations$ = t.JobInIntegrations$outboundSchema = t.JobInIntegrations$inboundSchema = void 0, t.jobInIntegrationsToJSON = h, t.jobInIntegrationsFromJSON = p, t.jobInRepositoriesToJSON = m, t.jobInRepositoriesFromJSON = b, t.jobInToJSON = _, t.jobInFromJSON = P;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ n$(), l = /* @__PURE__ */ r$(), f = /* @__PURE__ */ a$(), u = /* @__PURE__ */ i$();
    t.JobInIntegrations$inboundSchema = u.WandbIntegration$inboundSchema, t.JobInIntegrations$outboundSchema = u.WandbIntegration$outboundSchema;
    var c;
    (function(C) {
      C.inboundSchema = t.JobInIntegrations$inboundSchema, C.outboundSchema = t.JobInIntegrations$outboundSchema;
    })(c || (t.JobInIntegrations$ = c = {}));
    function h(C) {
      return JSON.stringify(t.JobInIntegrations$outboundSchema.parse(C));
    }
    function p(C) {
      return (0, s.safeParse)(C, (R) => t.JobInIntegrations$inboundSchema.parse(JSON.parse(R)), "Failed to parse 'JobInIntegrations' from JSON");
    }
    t.JobInRepositories$inboundSchema = o.GithubRepositoryIn$inboundSchema, t.JobInRepositories$outboundSchema = o.GithubRepositoryIn$outboundSchema;
    var d;
    (function(C) {
      C.inboundSchema = t.JobInRepositories$inboundSchema, C.outboundSchema = t.JobInRepositories$outboundSchema;
    })(d || (t.JobInRepositories$ = d = {}));
    function m(C) {
      return JSON.stringify(t.JobInRepositories$outboundSchema.parse(C));
    }
    function b(C) {
      return (0, s.safeParse)(C, (R) => t.JobInRepositories$inboundSchema.parse(JSON.parse(R)), "Failed to parse 'JobInRepositories' from JSON");
    }
    t.JobIn$inboundSchema = r.object({
      model: r.string(),
      training_files: r.array(l.TrainingFile$inboundSchema).optional(),
      validation_files: r.nullable(r.array(r.string())).optional(),
      hyperparameters: f.TrainingParametersIn$inboundSchema,
      suffix: r.nullable(r.string()).optional(),
      integrations: r.nullable(r.array(u.WandbIntegration$inboundSchema)).optional(),
      repositories: r.array(o.GithubRepositoryIn$inboundSchema).optional(),
      auto_start: r.boolean().optional()
    }).transform((C) => (0, i.remap)(C, {
      training_files: "trainingFiles",
      validation_files: "validationFiles",
      auto_start: "autoStart"
    })), t.JobIn$outboundSchema = r.object({
      model: r.string(),
      trainingFiles: r.array(l.TrainingFile$outboundSchema).optional(),
      validationFiles: r.nullable(r.array(r.string())).optional(),
      hyperparameters: f.TrainingParametersIn$outboundSchema,
      suffix: r.nullable(r.string()).optional(),
      integrations: r.nullable(r.array(u.WandbIntegration$outboundSchema)).optional(),
      repositories: r.array(o.GithubRepositoryIn$outboundSchema).optional(),
      autoStart: r.boolean().optional()
    }).transform((C) => (0, i.remap)(C, {
      trainingFiles: "training_files",
      validationFiles: "validation_files",
      autoStart: "auto_start"
    }));
    var g;
    (function(C) {
      C.inboundSchema = t.JobIn$inboundSchema, C.outboundSchema = t.JobIn$outboundSchema;
    })(g || (t.JobIn$ = g = {}));
    function _(C) {
      return JSON.stringify(t.JobIn$outboundSchema.parse(C));
    }
    function P(C) {
      return (0, s.safeParse)(C, (R) => t.JobIn$inboundSchema.parse(JSON.parse(R)), "Failed to parse 'JobIn' from JSON");
    }
  }(zi)), zi;
}
var Gi = {}, jO;
function s$() {
  return jO || (jO = 1, function(t) {
    var e = Gi && Gi.__createBinding || (Object.create ? function(T, O, A, M) {
      M === void 0 && (M = A);
      var I = Object.getOwnPropertyDescriptor(O, A);
      (!I || ("get" in I ? !O.__esModule : I.writable || I.configurable)) && (I = { enumerable: !0, get: function() {
        return O[A];
      } }), Object.defineProperty(T, M, I);
    } : function(T, O, A, M) {
      M === void 0 && (M = A), T[M] = O[A];
    }), n = Gi && Gi.__setModuleDefault || (Object.create ? function(T, O) {
      Object.defineProperty(T, "default", { enumerable: !0, value: O });
    } : function(T, O) {
      T.default = O;
    }), a = Gi && Gi.__importStar || function(T) {
      if (T && T.__esModule) return T;
      var O = {};
      if (T != null) for (var A in T) A !== "default" && Object.prototype.hasOwnProperty.call(T, A) && e(O, T, A);
      return n(O, T), O;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobOut$ = t.JobOut$outboundSchema = t.JobOut$inboundSchema = t.Repositories$ = t.Repositories$outboundSchema = t.Repositories$inboundSchema = t.Integrations$ = t.Integrations$outboundSchema = t.Integrations$inboundSchema = t.ObjectT$ = t.ObjectT$outboundSchema = t.ObjectT$inboundSchema = t.Status$ = t.Status$outboundSchema = t.Status$inboundSchema = t.ObjectT = t.Status = void 0, t.integrationsToJSON = d, t.integrationsFromJSON = m, t.repositoriesToJSON = g, t.repositoriesFromJSON = _, t.jobOutToJSON = C, t.jobOutFromJSON = R;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ x_(), l = /* @__PURE__ */ V_(), f = /* @__PURE__ */ z_(), u = /* @__PURE__ */ Z_();
    t.Status = {
      Queued: "QUEUED",
      Started: "STARTED",
      Validating: "VALIDATING",
      Validated: "VALIDATED",
      Running: "RUNNING",
      FailedValidation: "FAILED_VALIDATION",
      Failed: "FAILED",
      Success: "SUCCESS",
      Cancelled: "CANCELLED",
      CancellationRequested: "CANCELLATION_REQUESTED"
    }, t.ObjectT = {
      Job: "job"
    }, t.Status$inboundSchema = r.nativeEnum(t.Status), t.Status$outboundSchema = t.Status$inboundSchema;
    var c;
    (function(T) {
      T.inboundSchema = t.Status$inboundSchema, T.outboundSchema = t.Status$outboundSchema;
    })(c || (t.Status$ = c = {})), t.ObjectT$inboundSchema = r.nativeEnum(t.ObjectT), t.ObjectT$outboundSchema = t.ObjectT$inboundSchema;
    var h;
    (function(T) {
      T.inboundSchema = t.ObjectT$inboundSchema, T.outboundSchema = t.ObjectT$outboundSchema;
    })(h || (t.ObjectT$ = h = {})), t.Integrations$inboundSchema = u.WandbIntegrationOut$inboundSchema, t.Integrations$outboundSchema = u.WandbIntegrationOut$outboundSchema;
    var p;
    (function(T) {
      T.inboundSchema = t.Integrations$inboundSchema, T.outboundSchema = t.Integrations$outboundSchema;
    })(p || (t.Integrations$ = p = {}));
    function d(T) {
      return JSON.stringify(t.Integrations$outboundSchema.parse(T));
    }
    function m(T) {
      return (0, s.safeParse)(T, (O) => t.Integrations$inboundSchema.parse(JSON.parse(O)), "Failed to parse 'Integrations' from JSON");
    }
    t.Repositories$inboundSchema = o.GithubRepositoryOut$inboundSchema, t.Repositories$outboundSchema = o.GithubRepositoryOut$outboundSchema;
    var b;
    (function(T) {
      T.inboundSchema = t.Repositories$inboundSchema, T.outboundSchema = t.Repositories$outboundSchema;
    })(b || (t.Repositories$ = b = {}));
    function g(T) {
      return JSON.stringify(t.Repositories$outboundSchema.parse(T));
    }
    function _(T) {
      return (0, s.safeParse)(T, (O) => t.Repositories$inboundSchema.parse(JSON.parse(O)), "Failed to parse 'Repositories' from JSON");
    }
    t.JobOut$inboundSchema = r.object({
      id: r.string(),
      auto_start: r.boolean(),
      hyperparameters: f.TrainingParameters$inboundSchema,
      model: r.string(),
      status: t.Status$inboundSchema,
      job_type: r.string(),
      created_at: r.number().int(),
      modified_at: r.number().int(),
      training_files: r.array(r.string()),
      validation_files: r.nullable(r.array(r.string())).optional(),
      object: r.literal("job").default("job"),
      fine_tuned_model: r.nullable(r.string()).optional(),
      suffix: r.nullable(r.string()).optional(),
      integrations: r.nullable(r.array(u.WandbIntegrationOut$inboundSchema)).optional(),
      trained_tokens: r.nullable(r.number().int()).optional(),
      repositories: r.array(o.GithubRepositoryOut$inboundSchema).optional(),
      metadata: r.nullable(l.JobMetadataOut$inboundSchema).optional()
    }).transform((T) => (0, i.remap)(T, {
      auto_start: "autoStart",
      job_type: "jobType",
      created_at: "createdAt",
      modified_at: "modifiedAt",
      training_files: "trainingFiles",
      validation_files: "validationFiles",
      fine_tuned_model: "fineTunedModel",
      trained_tokens: "trainedTokens"
    })), t.JobOut$outboundSchema = r.object({
      id: r.string(),
      autoStart: r.boolean(),
      hyperparameters: f.TrainingParameters$outboundSchema,
      model: r.string(),
      status: t.Status$outboundSchema,
      jobType: r.string(),
      createdAt: r.number().int(),
      modifiedAt: r.number().int(),
      trainingFiles: r.array(r.string()),
      validationFiles: r.nullable(r.array(r.string())).optional(),
      object: r.literal("job").default("job"),
      fineTunedModel: r.nullable(r.string()).optional(),
      suffix: r.nullable(r.string()).optional(),
      integrations: r.nullable(r.array(u.WandbIntegrationOut$outboundSchema)).optional(),
      trainedTokens: r.nullable(r.number().int()).optional(),
      repositories: r.array(o.GithubRepositoryOut$outboundSchema).optional(),
      metadata: r.nullable(l.JobMetadataOut$outboundSchema).optional()
    }).transform((T) => (0, i.remap)(T, {
      autoStart: "auto_start",
      jobType: "job_type",
      createdAt: "created_at",
      modifiedAt: "modified_at",
      trainingFiles: "training_files",
      validationFiles: "validation_files",
      fineTunedModel: "fine_tuned_model",
      trainedTokens: "trained_tokens"
    }));
    var P;
    (function(T) {
      T.inboundSchema = t.JobOut$inboundSchema, T.outboundSchema = t.JobOut$outboundSchema;
    })(P || (t.JobOut$ = P = {}));
    function C(T) {
      return JSON.stringify(t.JobOut$outboundSchema.parse(T));
    }
    function R(T) {
      return (0, s.safeParse)(T, (O) => t.JobOut$inboundSchema.parse(JSON.parse(O)), "Failed to parse 'JobOut' from JSON");
    }
  }(Gi)), Gi;
}
var Wi = {}, PO;
function MJ() {
  return PO || (PO = 1, function(t) {
    var e = Wi && Wi.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Wi && Wi.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Wi && Wi.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsOut$ = t.JobsOut$outboundSchema = t.JobsOut$inboundSchema = t.JobsOutObject$ = t.JobsOutObject$outboundSchema = t.JobsOutObject$inboundSchema = t.JobsOutObject = void 0, t.jobsOutToJSON = f, t.jobsOutFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ s$();
    t.JobsOutObject = {
      List: "list"
    }, t.JobsOutObject$inboundSchema = r.nativeEnum(t.JobsOutObject), t.JobsOutObject$outboundSchema = t.JobsOutObject$inboundSchema;
    var o;
    (function(c) {
      c.inboundSchema = t.JobsOutObject$inboundSchema, c.outboundSchema = t.JobsOutObject$outboundSchema;
    })(o || (t.JobsOutObject$ = o = {})), t.JobsOut$inboundSchema = r.object({
      data: r.array(s.JobOut$inboundSchema).optional(),
      object: r.literal("list").default("list"),
      total: r.number().int()
    }), t.JobsOut$outboundSchema = r.object({
      data: r.array(s.JobOut$outboundSchema).optional(),
      object: r.literal("list").default("list"),
      total: r.number().int()
    });
    var l;
    (function(c) {
      c.inboundSchema = t.JobsOut$inboundSchema, c.outboundSchema = t.JobsOut$outboundSchema;
    })(l || (t.JobsOut$ = l = {}));
    function f(c) {
      return JSON.stringify(t.JobsOut$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, i.safeParse)(c, (h) => t.JobsOut$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'JobsOut' from JSON");
    }
  }(Wi)), Wi;
}
var Xi = {}, RO;
function AJ() {
  return RO || (RO = 1, function(t) {
    var e = Xi && Xi.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Xi && Xi.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Xi && Xi.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.LegacyJobMetadataOut$ = t.LegacyJobMetadataOut$outboundSchema = t.LegacyJobMetadataOut$inboundSchema = t.LegacyJobMetadataOutObject$ = t.LegacyJobMetadataOutObject$outboundSchema = t.LegacyJobMetadataOutObject$inboundSchema = t.LegacyJobMetadataOutObject = void 0, t.legacyJobMetadataOutToJSON = f, t.legacyJobMetadataOutFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.LegacyJobMetadataOutObject = {
      JobMetadata: "job.metadata"
    }, t.LegacyJobMetadataOutObject$inboundSchema = r.nativeEnum(t.LegacyJobMetadataOutObject), t.LegacyJobMetadataOutObject$outboundSchema = t.LegacyJobMetadataOutObject$inboundSchema;
    var o;
    (function(c) {
      c.inboundSchema = t.LegacyJobMetadataOutObject$inboundSchema, c.outboundSchema = t.LegacyJobMetadataOutObject$outboundSchema;
    })(o || (t.LegacyJobMetadataOutObject$ = o = {})), t.LegacyJobMetadataOut$inboundSchema = r.object({
      expected_duration_seconds: r.nullable(r.number().int()).optional(),
      cost: r.nullable(r.number()).optional(),
      cost_currency: r.nullable(r.string()).optional(),
      train_tokens_per_step: r.nullable(r.number().int()).optional(),
      train_tokens: r.nullable(r.number().int()).optional(),
      data_tokens: r.nullable(r.number().int()).optional(),
      estimated_start_time: r.nullable(r.number().int()).optional(),
      deprecated: r.boolean().default(!0),
      details: r.string(),
      epochs: r.nullable(r.number()).optional(),
      training_steps: r.nullable(r.number().int()).optional(),
      object: r.literal("job.metadata").default("job.metadata")
    }).transform((c) => (0, i.remap)(c, {
      expected_duration_seconds: "expectedDurationSeconds",
      cost_currency: "costCurrency",
      train_tokens_per_step: "trainTokensPerStep",
      train_tokens: "trainTokens",
      data_tokens: "dataTokens",
      estimated_start_time: "estimatedStartTime",
      training_steps: "trainingSteps"
    })), t.LegacyJobMetadataOut$outboundSchema = r.object({
      expectedDurationSeconds: r.nullable(r.number().int()).optional(),
      cost: r.nullable(r.number()).optional(),
      costCurrency: r.nullable(r.string()).optional(),
      trainTokensPerStep: r.nullable(r.number().int()).optional(),
      trainTokens: r.nullable(r.number().int()).optional(),
      dataTokens: r.nullable(r.number().int()).optional(),
      estimatedStartTime: r.nullable(r.number().int()).optional(),
      deprecated: r.boolean().default(!0),
      details: r.string(),
      epochs: r.nullable(r.number()).optional(),
      trainingSteps: r.nullable(r.number().int()).optional(),
      object: r.literal("job.metadata").default("job.metadata")
    }).transform((c) => (0, i.remap)(c, {
      expectedDurationSeconds: "expected_duration_seconds",
      costCurrency: "cost_currency",
      trainTokensPerStep: "train_tokens_per_step",
      trainTokens: "train_tokens",
      dataTokens: "data_tokens",
      estimatedStartTime: "estimated_start_time",
      trainingSteps: "training_steps"
    }));
    var l;
    (function(c) {
      c.inboundSchema = t.LegacyJobMetadataOut$inboundSchema, c.outboundSchema = t.LegacyJobMetadataOut$outboundSchema;
    })(l || (t.LegacyJobMetadataOut$ = l = {}));
    function f(c) {
      return JSON.stringify(t.LegacyJobMetadataOut$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, s.safeParse)(c, (h) => t.LegacyJobMetadataOut$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'LegacyJobMetadataOut' from JSON");
    }
  }(Xi)), Xi;
}
var Qi = {}, CO;
function EJ() {
  return CO || (CO = 1, function(t) {
    var e = Qi && Qi.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Qi && Qi.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Qi && Qi.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ListFilesOut$ = t.ListFilesOut$outboundSchema = t.ListFilesOut$inboundSchema = void 0, t.listFilesOutToJSON = l, t.listFilesOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ YT();
    t.ListFilesOut$inboundSchema = r.object({
      data: r.array(s.FileSchema$inboundSchema),
      object: r.string(),
      total: r.number().int()
    }), t.ListFilesOut$outboundSchema = r.object({
      data: r.array(s.FileSchema$outboundSchema),
      object: r.string(),
      total: r.number().int()
    });
    var o;
    (function(u) {
      u.inboundSchema = t.ListFilesOut$inboundSchema, u.outboundSchema = t.ListFilesOut$outboundSchema;
    })(o || (t.ListFilesOut$ = o = {}));
    function l(u) {
      return JSON.stringify(t.ListFilesOut$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, i.safeParse)(u, (c) => t.ListFilesOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'ListFilesOut' from JSON");
    }
  }(Qi)), Qi;
}
var Yi = {}, TO;
function IJ() {
  return TO || (TO = 1, function(t) {
    var e = Yi && Yi.__createBinding || (Object.create ? function(d, m, b, g) {
      g === void 0 && (g = b);
      var _ = Object.getOwnPropertyDescriptor(m, b);
      (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
        return m[b];
      } }), Object.defineProperty(d, g, _);
    } : function(d, m, b, g) {
      g === void 0 && (g = b), d[g] = m[b];
    }), n = Yi && Yi.__setModuleDefault || (Object.create ? function(d, m) {
      Object.defineProperty(d, "default", { enumerable: !0, value: m });
    } : function(d, m) {
      d.default = m;
    }), a = Yi && Yi.__importStar || function(d) {
      if (d && d.__esModule) return d;
      var m = {};
      if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && e(m, d, b);
      return n(m, d), m;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ModelList$ = t.ModelList$outboundSchema = t.ModelList$inboundSchema = t.Data$ = t.Data$outboundSchema = t.Data$inboundSchema = void 0, t.dataToJSON = f, t.dataFromJSON = u, t.modelListToJSON = h, t.modelListFromJSON = p;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ UT(), o = /* @__PURE__ */ t$();
    t.Data$inboundSchema = r.union([
      s.BaseModelCard$inboundSchema.and(r.object({ type: r.literal("base") }).transform((d) => ({
        type: d.type
      }))),
      o.FTModelCard$inboundSchema.and(r.object({ type: r.literal("fine-tuned") }).transform((d) => ({
        type: d.type
      })))
    ]), t.Data$outboundSchema = r.union([
      s.BaseModelCard$outboundSchema.and(r.object({ type: r.literal("base") }).transform((d) => ({
        type: d.type
      }))),
      o.FTModelCard$outboundSchema.and(r.object({ type: r.literal("fine-tuned") }).transform((d) => ({
        type: d.type
      })))
    ]);
    var l;
    (function(d) {
      d.inboundSchema = t.Data$inboundSchema, d.outboundSchema = t.Data$outboundSchema;
    })(l || (t.Data$ = l = {}));
    function f(d) {
      return JSON.stringify(t.Data$outboundSchema.parse(d));
    }
    function u(d) {
      return (0, i.safeParse)(d, (m) => t.Data$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'Data' from JSON");
    }
    t.ModelList$inboundSchema = r.object({
      object: r.string().default("list"),
      data: r.array(r.union([
        s.BaseModelCard$inboundSchema.and(r.object({ type: r.literal("base") }).transform((d) => ({
          type: d.type
        }))),
        o.FTModelCard$inboundSchema.and(r.object({ type: r.literal("fine-tuned") }).transform((d) => ({
          type: d.type
        })))
      ])).optional()
    }), t.ModelList$outboundSchema = r.object({
      object: r.string().default("list"),
      data: r.array(r.union([
        s.BaseModelCard$outboundSchema.and(r.object({ type: r.literal("base") }).transform((d) => ({
          type: d.type
        }))),
        o.FTModelCard$outboundSchema.and(r.object({ type: r.literal("fine-tuned") }).transform((d) => ({
          type: d.type
        })))
      ])).optional()
    });
    var c;
    (function(d) {
      d.inboundSchema = t.ModelList$inboundSchema, d.outboundSchema = t.ModelList$outboundSchema;
    })(c || (t.ModelList$ = c = {}));
    function h(d) {
      return JSON.stringify(t.ModelList$outboundSchema.parse(d));
    }
    function p(d) {
      return (0, i.safeParse)(d, (m) => t.ModelList$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'ModelList' from JSON");
    }
  }(Yi)), Yi;
}
var es = {}, $O;
function o$() {
  return $O || ($O = 1, function(t) {
    var e = es && es.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = es && es.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = es && es.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.OCRImageObject$ = t.OCRImageObject$outboundSchema = t.OCRImageObject$inboundSchema = void 0, t.ocrImageObjectToJSON = l, t.ocrImageObjectFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.OCRImageObject$inboundSchema = r.object({
      id: r.string(),
      top_left_x: r.nullable(r.number().int()),
      top_left_y: r.nullable(r.number().int()),
      bottom_right_x: r.nullable(r.number().int()),
      bottom_right_y: r.nullable(r.number().int()),
      image_base64: r.nullable(r.string()).optional()
    }).transform((u) => (0, i.remap)(u, {
      top_left_x: "topLeftX",
      top_left_y: "topLeftY",
      bottom_right_x: "bottomRightX",
      bottom_right_y: "bottomRightY",
      image_base64: "imageBase64"
    })), t.OCRImageObject$outboundSchema = r.object({
      id: r.string(),
      topLeftX: r.nullable(r.number().int()),
      topLeftY: r.nullable(r.number().int()),
      bottomRightX: r.nullable(r.number().int()),
      bottomRightY: r.nullable(r.number().int()),
      imageBase64: r.nullable(r.string()).optional()
    }).transform((u) => (0, i.remap)(u, {
      topLeftX: "top_left_x",
      topLeftY: "top_left_y",
      bottomRightX: "bottom_right_x",
      bottomRightY: "bottom_right_y",
      imageBase64: "image_base64"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.OCRImageObject$inboundSchema, u.outboundSchema = t.OCRImageObject$outboundSchema;
    })(o || (t.OCRImageObject$ = o = {}));
    function l(u) {
      return JSON.stringify(t.OCRImageObject$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.OCRImageObject$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'OCRImageObject' from JSON");
    }
  }(es)), es;
}
var ts = {}, MO;
function u$() {
  return MO || (MO = 1, function(t) {
    var e = ts && ts.__createBinding || (Object.create ? function(f, u, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(u, c);
      (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, u, c, h) {
      h === void 0 && (h = c), f[h] = u[c];
    }), n = ts && ts.__setModuleDefault || (Object.create ? function(f, u) {
      Object.defineProperty(f, "default", { enumerable: !0, value: u });
    } : function(f, u) {
      f.default = u;
    }), a = ts && ts.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var u = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(u, f, c);
      return n(u, f), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.OCRPageDimensions$ = t.OCRPageDimensions$outboundSchema = t.OCRPageDimensions$inboundSchema = void 0, t.ocrPageDimensionsToJSON = o, t.ocrPageDimensionsFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.OCRPageDimensions$inboundSchema = r.object({
      dpi: r.number().int(),
      height: r.number().int(),
      width: r.number().int()
    }), t.OCRPageDimensions$outboundSchema = r.object({
      dpi: r.number().int(),
      height: r.number().int(),
      width: r.number().int()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.OCRPageDimensions$inboundSchema, f.outboundSchema = t.OCRPageDimensions$outboundSchema;
    })(s || (t.OCRPageDimensions$ = s = {}));
    function o(f) {
      return JSON.stringify(t.OCRPageDimensions$outboundSchema.parse(f));
    }
    function l(f) {
      return (0, i.safeParse)(f, (u) => t.OCRPageDimensions$inboundSchema.parse(JSON.parse(u)), "Failed to parse 'OCRPageDimensions' from JSON");
    }
  }(ts)), ts;
}
var ns = {}, AO;
function c$() {
  return AO || (AO = 1, function(t) {
    var e = ns && ns.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = ns && ns.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = ns && ns.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.OCRPageObject$ = t.OCRPageObject$outboundSchema = t.OCRPageObject$inboundSchema = void 0, t.ocrPageObjectToJSON = f, t.ocrPageObjectFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ o$(), o = /* @__PURE__ */ u$();
    t.OCRPageObject$inboundSchema = r.object({
      index: r.number().int(),
      markdown: r.string(),
      images: r.array(s.OCRImageObject$inboundSchema),
      dimensions: r.nullable(o.OCRPageDimensions$inboundSchema)
    }), t.OCRPageObject$outboundSchema = r.object({
      index: r.number().int(),
      markdown: r.string(),
      images: r.array(s.OCRImageObject$outboundSchema),
      dimensions: r.nullable(o.OCRPageDimensions$outboundSchema)
    });
    var l;
    (function(c) {
      c.inboundSchema = t.OCRPageObject$inboundSchema, c.outboundSchema = t.OCRPageObject$outboundSchema;
    })(l || (t.OCRPageObject$ = l = {}));
    function f(c) {
      return JSON.stringify(t.OCRPageObject$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, i.safeParse)(c, (h) => t.OCRPageObject$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'OCRPageObject' from JSON");
    }
  }(ns)), ns;
}
var rs = {}, EO;
function NJ() {
  return EO || (EO = 1, function(t) {
    var e = rs && rs.__createBinding || (Object.create ? function(m, b, g, _) {
      _ === void 0 && (_ = g);
      var P = Object.getOwnPropertyDescriptor(b, g);
      (!P || ("get" in P ? !b.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
        return b[g];
      } }), Object.defineProperty(m, _, P);
    } : function(m, b, g, _) {
      _ === void 0 && (_ = g), m[_] = b[g];
    }), n = rs && rs.__setModuleDefault || (Object.create ? function(m, b) {
      Object.defineProperty(m, "default", { enumerable: !0, value: b });
    } : function(m, b) {
      m.default = b;
    }), a = rs && rs.__importStar || function(m) {
      if (m && m.__esModule) return m;
      var b = {};
      if (m != null) for (var g in m) g !== "default" && Object.prototype.hasOwnProperty.call(m, g) && e(b, m, g);
      return n(b, m), b;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.OCRRequest$ = t.OCRRequest$outboundSchema = t.OCRRequest$inboundSchema = t.Document$ = t.Document$outboundSchema = t.Document$inboundSchema = void 0, t.documentToJSON = u, t.documentFromJSON = c, t.ocrRequestToJSON = p, t.ocrRequestFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ D_(), l = /* @__PURE__ */ q_();
    t.Document$inboundSchema = r.union([l.ImageURLChunk$inboundSchema, o.DocumentURLChunk$inboundSchema]), t.Document$outboundSchema = r.union([l.ImageURLChunk$outboundSchema, o.DocumentURLChunk$outboundSchema]);
    var f;
    (function(m) {
      m.inboundSchema = t.Document$inboundSchema, m.outboundSchema = t.Document$outboundSchema;
    })(f || (t.Document$ = f = {}));
    function u(m) {
      return JSON.stringify(t.Document$outboundSchema.parse(m));
    }
    function c(m) {
      return (0, s.safeParse)(m, (b) => t.Document$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'Document' from JSON");
    }
    t.OCRRequest$inboundSchema = r.object({
      model: r.nullable(r.string()),
      id: r.string().optional(),
      document: r.union([
        l.ImageURLChunk$inboundSchema,
        o.DocumentURLChunk$inboundSchema
      ]),
      pages: r.nullable(r.array(r.number().int())).optional(),
      include_image_base64: r.nullable(r.boolean()).optional(),
      image_limit: r.nullable(r.number().int()).optional(),
      image_min_size: r.nullable(r.number().int()).optional()
    }).transform((m) => (0, i.remap)(m, {
      include_image_base64: "includeImageBase64",
      image_limit: "imageLimit",
      image_min_size: "imageMinSize"
    })), t.OCRRequest$outboundSchema = r.object({
      model: r.nullable(r.string()),
      id: r.string().optional(),
      document: r.union([
        l.ImageURLChunk$outboundSchema,
        o.DocumentURLChunk$outboundSchema
      ]),
      pages: r.nullable(r.array(r.number().int())).optional(),
      includeImageBase64: r.nullable(r.boolean()).optional(),
      imageLimit: r.nullable(r.number().int()).optional(),
      imageMinSize: r.nullable(r.number().int()).optional()
    }).transform((m) => (0, i.remap)(m, {
      includeImageBase64: "include_image_base64",
      imageLimit: "image_limit",
      imageMinSize: "image_min_size"
    }));
    var h;
    (function(m) {
      m.inboundSchema = t.OCRRequest$inboundSchema, m.outboundSchema = t.OCRRequest$outboundSchema;
    })(h || (t.OCRRequest$ = h = {}));
    function p(m) {
      return JSON.stringify(t.OCRRequest$outboundSchema.parse(m));
    }
    function d(m) {
      return (0, s.safeParse)(m, (b) => t.OCRRequest$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'OCRRequest' from JSON");
    }
  }(rs)), rs;
}
var as = {}, is = {}, IO;
function l$() {
  return IO || (IO = 1, function(t) {
    var e = is && is.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = is && is.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = is && is.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.OCRUsageInfo$ = t.OCRUsageInfo$outboundSchema = t.OCRUsageInfo$inboundSchema = void 0, t.ocrUsageInfoToJSON = l, t.ocrUsageInfoFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.OCRUsageInfo$inboundSchema = r.object({
      pages_processed: r.number().int(),
      doc_size_bytes: r.nullable(r.number().int()).optional()
    }).transform((u) => (0, i.remap)(u, {
      pages_processed: "pagesProcessed",
      doc_size_bytes: "docSizeBytes"
    })), t.OCRUsageInfo$outboundSchema = r.object({
      pagesProcessed: r.number().int(),
      docSizeBytes: r.nullable(r.number().int()).optional()
    }).transform((u) => (0, i.remap)(u, {
      pagesProcessed: "pages_processed",
      docSizeBytes: "doc_size_bytes"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.OCRUsageInfo$inboundSchema, u.outboundSchema = t.OCRUsageInfo$outboundSchema;
    })(o || (t.OCRUsageInfo$ = o = {}));
    function l(u) {
      return JSON.stringify(t.OCRUsageInfo$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.OCRUsageInfo$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'OCRUsageInfo' from JSON");
    }
  }(is)), is;
}
var NO;
function kJ() {
  return NO || (NO = 1, function(t) {
    var e = as && as.__createBinding || (Object.create ? function(h, p, d, m) {
      m === void 0 && (m = d);
      var b = Object.getOwnPropertyDescriptor(p, d);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[d];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, d, m) {
      m === void 0 && (m = d), h[m] = p[d];
    }), n = as && as.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = as && as.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var d in h) d !== "default" && Object.prototype.hasOwnProperty.call(h, d) && e(p, h, d);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.OCRResponse$ = t.OCRResponse$outboundSchema = t.OCRResponse$inboundSchema = void 0, t.ocrResponseToJSON = u, t.ocrResponseFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ c$(), l = /* @__PURE__ */ l$();
    t.OCRResponse$inboundSchema = r.object({
      pages: r.array(o.OCRPageObject$inboundSchema),
      model: r.string(),
      usage_info: l.OCRUsageInfo$inboundSchema
    }).transform((h) => (0, i.remap)(h, {
      usage_info: "usageInfo"
    })), t.OCRResponse$outboundSchema = r.object({
      pages: r.array(o.OCRPageObject$outboundSchema),
      model: r.string(),
      usageInfo: l.OCRUsageInfo$outboundSchema
    }).transform((h) => (0, i.remap)(h, {
      usageInfo: "usage_info"
    }));
    var f;
    (function(h) {
      h.inboundSchema = t.OCRResponse$inboundSchema, h.outboundSchema = t.OCRResponse$outboundSchema;
    })(f || (t.OCRResponse$ = f = {}));
    function u(h) {
      return JSON.stringify(t.OCRResponse$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, s.safeParse)(h, (p) => t.OCRResponse$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'OCRResponse' from JSON");
    }
  }(as)), as;
}
var ss = {}, kO;
function FJ() {
  return kO || (kO = 1, function(t) {
    var e = ss && ss.__createBinding || (Object.create ? function(p, d, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(d, m);
      (!g || ("get" in g ? !d.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return d[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, d, m, b) {
      b === void 0 && (b = m), p[b] = d[m];
    }), n = ss && ss.__setModuleDefault || (Object.create ? function(p, d) {
      Object.defineProperty(p, "default", { enumerable: !0, value: d });
    } : function(p, d) {
      p.default = d;
    }), a = ss && ss.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(d, p, m);
      return n(d, p), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.RetrieveFileOut$ = t.RetrieveFileOut$outboundSchema = t.RetrieveFileOut$inboundSchema = void 0, t.retrieveFileOutToJSON = c, t.retrieveFileOutFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Up(), l = /* @__PURE__ */ Bp(), f = /* @__PURE__ */ xp();
    t.RetrieveFileOut$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      bytes: r.number().int(),
      created_at: r.number().int(),
      filename: r.string(),
      purpose: o.FilePurpose$inboundSchema,
      sample_type: l.SampleType$inboundSchema,
      num_lines: r.nullable(r.number().int()).optional(),
      source: f.Source$inboundSchema,
      deleted: r.boolean()
    }).transform((p) => (0, i.remap)(p, {
      bytes: "sizeBytes",
      created_at: "createdAt",
      sample_type: "sampleType",
      num_lines: "numLines"
    })), t.RetrieveFileOut$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      sizeBytes: r.number().int(),
      createdAt: r.number().int(),
      filename: r.string(),
      purpose: o.FilePurpose$outboundSchema,
      sampleType: l.SampleType$outboundSchema,
      numLines: r.nullable(r.number().int()).optional(),
      source: f.Source$outboundSchema,
      deleted: r.boolean()
    }).transform((p) => (0, i.remap)(p, {
      sizeBytes: "bytes",
      createdAt: "created_at",
      sampleType: "sample_type",
      numLines: "num_lines"
    }));
    var u;
    (function(p) {
      p.inboundSchema = t.RetrieveFileOut$inboundSchema, p.outboundSchema = t.RetrieveFileOut$outboundSchema;
    })(u || (t.RetrieveFileOut$ = u = {}));
    function c(p) {
      return JSON.stringify(t.RetrieveFileOut$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (d) => t.RetrieveFileOut$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'RetrieveFileOut' from JSON");
    }
  }(ss)), ss;
}
var os = {}, FO;
function DJ() {
  return FO || (FO = 1, function(t) {
    var e = os && os.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = os && os.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = os && os.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Security$ = t.Security$outboundSchema = t.Security$inboundSchema = void 0, t.securityToJSON = l, t.securityFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.Security$inboundSchema = r.object({
      ApiKey: r.string().optional()
    }).transform((u) => (0, i.remap)(u, {
      ApiKey: "apiKey"
    })), t.Security$outboundSchema = r.object({
      apiKey: r.string().optional()
    }).transform((u) => (0, i.remap)(u, {
      apiKey: "ApiKey"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.Security$inboundSchema, u.outboundSchema = t.Security$outboundSchema;
    })(o || (t.Security$ = o = {}));
    function l(u) {
      return JSON.stringify(t.Security$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.Security$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'Security' from JSON");
    }
  }(os)), os;
}
var us = {}, DO;
function qJ() {
  return DO || (DO = 1, function(t) {
    var e = us && us.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = us && us.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = us && us.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.UnarchiveFTModelOut$ = t.UnarchiveFTModelOut$outboundSchema = t.UnarchiveFTModelOut$inboundSchema = t.UnarchiveFTModelOutObject$ = t.UnarchiveFTModelOutObject$outboundSchema = t.UnarchiveFTModelOutObject$inboundSchema = t.UnarchiveFTModelOutObject = void 0, t.unarchiveFTModelOutToJSON = l, t.unarchiveFTModelOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.UnarchiveFTModelOutObject = {
      Model: "model"
    }, t.UnarchiveFTModelOutObject$inboundSchema = r.nativeEnum(t.UnarchiveFTModelOutObject), t.UnarchiveFTModelOutObject$outboundSchema = t.UnarchiveFTModelOutObject$inboundSchema;
    var s;
    (function(u) {
      u.inboundSchema = t.UnarchiveFTModelOutObject$inboundSchema, u.outboundSchema = t.UnarchiveFTModelOutObject$outboundSchema;
    })(s || (t.UnarchiveFTModelOutObject$ = s = {})), t.UnarchiveFTModelOut$inboundSchema = r.object({
      id: r.string(),
      object: r.literal("model").default("model"),
      archived: r.boolean().default(!1)
    }), t.UnarchiveFTModelOut$outboundSchema = r.object({
      id: r.string(),
      object: r.literal("model").default("model"),
      archived: r.boolean().default(!1)
    });
    var o;
    (function(u) {
      u.inboundSchema = t.UnarchiveFTModelOut$inboundSchema, u.outboundSchema = t.UnarchiveFTModelOut$outboundSchema;
    })(o || (t.UnarchiveFTModelOut$ = o = {}));
    function l(u) {
      return JSON.stringify(t.UnarchiveFTModelOut$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, i.safeParse)(u, (c) => t.UnarchiveFTModelOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'UnarchiveFTModelOut' from JSON");
    }
  }(us)), us;
}
var cs = {}, qO;
function JJ() {
  return qO || (qO = 1, function(t) {
    var e = cs && cs.__createBinding || (Object.create ? function(f, u, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(u, c);
      (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return u[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, u, c, h) {
      h === void 0 && (h = c), f[h] = u[c];
    }), n = cs && cs.__setModuleDefault || (Object.create ? function(f, u) {
      Object.defineProperty(f, "default", { enumerable: !0, value: u });
    } : function(f, u) {
      f.default = u;
    }), a = cs && cs.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var u = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(u, f, c);
      return n(u, f), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.UpdateFTModelIn$ = t.UpdateFTModelIn$outboundSchema = t.UpdateFTModelIn$inboundSchema = void 0, t.updateFTModelInToJSON = o, t.updateFTModelInFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.UpdateFTModelIn$inboundSchema = r.object({
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional()
    }), t.UpdateFTModelIn$outboundSchema = r.object({
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.UpdateFTModelIn$inboundSchema, f.outboundSchema = t.UpdateFTModelIn$outboundSchema;
    })(s || (t.UpdateFTModelIn$ = s = {}));
    function o(f) {
      return JSON.stringify(t.UpdateFTModelIn$outboundSchema.parse(f));
    }
    function l(f) {
      return (0, i.safeParse)(f, (u) => t.UpdateFTModelIn$inboundSchema.parse(JSON.parse(u)), "Failed to parse 'UpdateFTModelIn' from JSON");
    }
  }(cs)), cs;
}
var ls = {}, JO;
function LJ() {
  return JO || (JO = 1, function(t) {
    var e = ls && ls.__createBinding || (Object.create ? function(p, d, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(d, m);
      (!g || ("get" in g ? !d.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return d[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, d, m, b) {
      b === void 0 && (b = m), p[b] = d[m];
    }), n = ls && ls.__setModuleDefault || (Object.create ? function(p, d) {
      Object.defineProperty(p, "default", { enumerable: !0, value: d });
    } : function(p, d) {
      p.default = d;
    }), a = ls && ls.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(d, p, m);
      return n(d, p), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.UploadFileOut$ = t.UploadFileOut$outboundSchema = t.UploadFileOut$inboundSchema = void 0, t.uploadFileOutToJSON = c, t.uploadFileOutFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Up(), l = /* @__PURE__ */ Bp(), f = /* @__PURE__ */ xp();
    t.UploadFileOut$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      bytes: r.number().int(),
      created_at: r.number().int(),
      filename: r.string(),
      purpose: o.FilePurpose$inboundSchema,
      sample_type: l.SampleType$inboundSchema,
      num_lines: r.nullable(r.number().int()).optional(),
      source: f.Source$inboundSchema
    }).transform((p) => (0, i.remap)(p, {
      bytes: "sizeBytes",
      created_at: "createdAt",
      sample_type: "sampleType",
      num_lines: "numLines"
    })), t.UploadFileOut$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      sizeBytes: r.number().int(),
      createdAt: r.number().int(),
      filename: r.string(),
      purpose: o.FilePurpose$outboundSchema,
      sampleType: l.SampleType$outboundSchema,
      numLines: r.nullable(r.number().int()).optional(),
      source: f.Source$outboundSchema
    }).transform((p) => (0, i.remap)(p, {
      sizeBytes: "bytes",
      createdAt: "created_at",
      sampleType: "sample_type",
      numLines: "num_lines"
    }));
    var u;
    (function(p) {
      p.inboundSchema = t.UploadFileOut$inboundSchema, p.outboundSchema = t.UploadFileOut$outboundSchema;
    })(u || (t.UploadFileOut$ = u = {}));
    function c(p) {
      return JSON.stringify(t.UploadFileOut$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (d) => t.UploadFileOut$inboundSchema.parse(JSON.parse(d)), "Failed to parse 'UploadFileOut' from JSON");
    }
  }(ls)), ls;
}
var ds = {}, LO;
function UJ() {
  return LO || (LO = 1, function(t) {
    var e = ds && ds.__createBinding || (Object.create ? function(h, p, d, m) {
      m === void 0 && (m = d);
      var b = Object.getOwnPropertyDescriptor(p, d);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[d];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, d, m) {
      m === void 0 && (m = d), h[m] = p[d];
    }), n = ds && ds.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = ds && ds.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var d in h) d !== "default" && Object.prototype.hasOwnProperty.call(h, d) && e(p, h, d);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ValidationError$ = t.ValidationError$outboundSchema = t.ValidationError$inboundSchema = t.Loc$ = t.Loc$outboundSchema = t.Loc$inboundSchema = void 0, t.locToJSON = o, t.locFromJSON = l, t.validationErrorToJSON = u, t.validationErrorFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.Loc$inboundSchema = r.union([r.string(), r.number().int()]), t.Loc$outboundSchema = r.union([r.string(), r.number().int()]);
    var s;
    (function(h) {
      h.inboundSchema = t.Loc$inboundSchema, h.outboundSchema = t.Loc$outboundSchema;
    })(s || (t.Loc$ = s = {}));
    function o(h) {
      return JSON.stringify(t.Loc$outboundSchema.parse(h));
    }
    function l(h) {
      return (0, i.safeParse)(h, (p) => t.Loc$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'Loc' from JSON");
    }
    t.ValidationError$inboundSchema = r.object({
      loc: r.array(r.union([r.string(), r.number().int()])),
      msg: r.string(),
      type: r.string()
    }), t.ValidationError$outboundSchema = r.object({
      loc: r.array(r.union([r.string(), r.number().int()])),
      msg: r.string(),
      type: r.string()
    });
    var f;
    (function(h) {
      h.inboundSchema = t.ValidationError$inboundSchema, h.outboundSchema = t.ValidationError$outboundSchema;
    })(f || (t.ValidationError$ = f = {}));
    function u(h) {
      return JSON.stringify(t.ValidationError$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, i.safeParse)(h, (p) => t.ValidationError$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'ValidationError' from JSON");
    }
  }(ds)), ds;
}
var UO;
function Oe() {
  return UO || (UO = 1, function(t) {
    var e = Ao && Ao.__createBinding || (Object.create ? function(a, r, i, s) {
      s === void 0 && (s = i);
      var o = Object.getOwnPropertyDescriptor(r, i);
      (!o || ("get" in o ? !r.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
        return r[i];
      } }), Object.defineProperty(a, s, o);
    } : function(a, r, i, s) {
      s === void 0 && (s = i), a[s] = r[i];
    }), n = Ao && Ao.__exportStar || function(a, r) {
      for (var i in a) i !== "default" && !Object.prototype.hasOwnProperty.call(r, i) && e(r, a, i);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(/* @__PURE__ */ oJ(), t), n(/* @__PURE__ */ uJ(), t), n(/* @__PURE__ */ LT(), t), n(/* @__PURE__ */ cJ(), t), n(/* @__PURE__ */ su(), t), n(/* @__PURE__ */ UT(), t), n(/* @__PURE__ */ BT(), t), n(/* @__PURE__ */ lJ(), t), n(/* @__PURE__ */ VT(), t), n(/* @__PURE__ */ dJ(), t), n(/* @__PURE__ */ xT(), t), n(/* @__PURE__ */ B_(), t), n(/* @__PURE__ */ fJ(), t), n(/* @__PURE__ */ hJ(), t), n(/* @__PURE__ */ pJ(), t), n(/* @__PURE__ */ mJ(), t), n(/* @__PURE__ */ ZT(), t), n(/* @__PURE__ */ KT(), t), n(/* @__PURE__ */ bJ(), t), n(/* @__PURE__ */ gJ(), t), n(/* @__PURE__ */ WT(), t), n(/* @__PURE__ */ _J(), t), n(/* @__PURE__ */ GT(), t), n(/* @__PURE__ */ Xd(), t), n(/* @__PURE__ */ yJ(), t), n(/* @__PURE__ */ wJ(), t), n(/* @__PURE__ */ HT(), t), n(/* @__PURE__ */ vJ(), t), n(/* @__PURE__ */ D_(), t), n(/* @__PURE__ */ SJ(), t), n(/* @__PURE__ */ OJ(), t), n(/* @__PURE__ */ QT(), t), n(/* @__PURE__ */ XT(), t), n(/* @__PURE__ */ Up(), t), n(/* @__PURE__ */ YT(), t), n(/* @__PURE__ */ jJ(), t), n(/* @__PURE__ */ PJ(), t), n(/* @__PURE__ */ RJ(), t), n(/* @__PURE__ */ CJ(), t), n(/* @__PURE__ */ e$(), t), n(/* @__PURE__ */ t$(), t), n(/* @__PURE__ */ TJ(), t), n(/* @__PURE__ */ qT(), t), n(/* @__PURE__ */ kT(), t), n(/* @__PURE__ */ JT(), t), n(/* @__PURE__ */ n$(), t), n(/* @__PURE__ */ x_(), t), n(/* @__PURE__ */ IT(), t), n(/* @__PURE__ */ q_(), t), n(/* @__PURE__ */ $J(), t), n(/* @__PURE__ */ V_(), t), n(/* @__PURE__ */ s$(), t), n(/* @__PURE__ */ MJ(), t), n(/* @__PURE__ */ FT(), t), n(/* @__PURE__ */ AJ(), t), n(/* @__PURE__ */ EJ(), t), n(/* @__PURE__ */ zT(), t), n(/* @__PURE__ */ U_(), t), n(/* @__PURE__ */ IJ(), t), n(/* @__PURE__ */ o$(), t), n(/* @__PURE__ */ u$(), t), n(/* @__PURE__ */ c$(), t), n(/* @__PURE__ */ NJ(), t), n(/* @__PURE__ */ kJ(), t), n(/* @__PURE__ */ l$(), t), n(/* @__PURE__ */ Qd(), t), n(/* @__PURE__ */ NT(), t), n(/* @__PURE__ */ Yd(), t), n(/* @__PURE__ */ DT(), t), n(/* @__PURE__ */ FJ(), t), n(/* @__PURE__ */ Bp(), t), n(/* @__PURE__ */ DJ(), t), n(/* @__PURE__ */ xp(), t), n(/* @__PURE__ */ hc(), t), n(/* @__PURE__ */ J_(), t), n(/* @__PURE__ */ ef(), t), n(/* @__PURE__ */ L_(), t), n(/* @__PURE__ */ tf(), t), n(/* @__PURE__ */ nf(), t), n(/* @__PURE__ */ pc(), t), n(/* @__PURE__ */ Lp(), t), n(/* @__PURE__ */ r$(), t), n(/* @__PURE__ */ z_(), t), n(/* @__PURE__ */ a$(), t), n(/* @__PURE__ */ qJ(), t), n(/* @__PURE__ */ JJ(), t), n(/* @__PURE__ */ LJ(), t), n(/* @__PURE__ */ rf(), t), n(/* @__PURE__ */ mc(), t), n(/* @__PURE__ */ UJ(), t), n(/* @__PURE__ */ i$(), t), n(/* @__PURE__ */ Z_(), t);
  }(Ao)), Ao;
}
var Eo = {}, fs = {}, BO;
function BJ() {
  return BO || (BO = 1, function(t) {
    var e = fs && fs.__createBinding || (Object.create ? function(l, f, u, c) {
      c === void 0 && (c = u);
      var h = Object.getOwnPropertyDescriptor(f, u);
      (!h || ("get" in h ? !f.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
        return f[u];
      } }), Object.defineProperty(l, c, h);
    } : function(l, f, u, c) {
      c === void 0 && (c = u), l[c] = f[u];
    }), n = fs && fs.__setModuleDefault || (Object.create ? function(l, f) {
      Object.defineProperty(l, "default", { enumerable: !0, value: f });
    } : function(l, f) {
      l.default = f;
    }), a = fs && fs.__importStar || function(l) {
      if (l && l.__esModule) return l;
      var f = {};
      if (l != null) for (var u in l) u !== "default" && Object.prototype.hasOwnProperty.call(l, u) && e(f, l, u);
      return n(f, l), f;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.HTTPValidationError$ = t.HTTPValidationError$outboundSchema = t.HTTPValidationError$inboundSchema = t.HTTPValidationError = void 0;
    const r = a(/* @__PURE__ */ H()), i = a(/* @__PURE__ */ Oe());
    class s extends Error {
      constructor(f) {
        const u = "message" in f && typeof f.message == "string" ? f.message : `API error occurred: ${JSON.stringify(f)}`;
        super(u), this.data$ = f, f.detail != null && (this.detail = f.detail), this.name = "HTTPValidationError";
      }
    }
    t.HTTPValidationError = s, t.HTTPValidationError$inboundSchema = r.object({
      detail: r.array(i.ValidationError$inboundSchema).optional()
    }).transform((l) => new s(l)), t.HTTPValidationError$outboundSchema = r.instanceof(s).transform((l) => l.data$).pipe(r.object({
      detail: r.array(i.ValidationError$outboundSchema).optional()
    }));
    var o;
    (function(l) {
      l.inboundSchema = t.HTTPValidationError$inboundSchema, l.outboundSchema = t.HTTPValidationError$outboundSchema;
    })(o || (t.HTTPValidationError$ = o = {}));
  }(fs)), fs;
}
var xO;
function An() {
  return xO || (xO = 1, function(t) {
    var e = Eo && Eo.__createBinding || (Object.create ? function(a, r, i, s) {
      s === void 0 && (s = i);
      var o = Object.getOwnPropertyDescriptor(r, i);
      (!o || ("get" in o ? !r.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
        return r[i];
      } }), Object.defineProperty(a, s, o);
    } : function(a, r, i, s) {
      s === void 0 && (s = i), a[s] = r[i];
    }), n = Eo && Eo.__exportStar || function(a, r) {
      for (var i in a) i !== "default" && !Object.prototype.hasOwnProperty.call(r, i) && e(r, a, i);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(/* @__PURE__ */ jT(), t), n(/* @__PURE__ */ BJ(), t), n(/* @__PURE__ */ AT(), t), n(/* @__PURE__ */ ET(), t);
  }(Eo)), Eo;
}
var hs = {}, VO;
function De() {
  if (VO) return hs;
  VO = 1;
  var t = hs && hs.__classPrivateFieldSet || function(s, o, l, f, u) {
    if (f === "m") throw new TypeError("Private method is not writable");
    if (f === "a" && !u) throw new TypeError("Private accessor was defined without a setter");
    if (typeof o == "function" ? s !== o || !u : !o.has(s)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return f === "a" ? u.call(s, l) : u ? u.value = l : o.set(s, l), l;
  }, e = hs && hs.__classPrivateFieldGet || function(s, o, l, f) {
    if (l === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof o == "function" ? s !== o || !f : !o.has(s)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return l === "m" ? f : l === "a" ? f.call(s) : f ? f.value : o.get(s);
  }, n, a, r;
  Object.defineProperty(hs, "__esModule", { value: !0 }), hs.APIPromise = void 0;
  class i {
    constructor(o) {
      n.set(this, void 0), a.set(this, void 0), this[r] = "APIPromise", t(this, n, o instanceof Promise ? o : Promise.resolve(o), "f"), t(this, a, o instanceof Promise ? e(this, n, "f").then(([l]) => l) : Promise.resolve(o[0]), "f");
    }
    then(o, l) {
      return e(this, n, "f").then(o ? ([f]) => o(f) : void 0, l);
    }
    catch(o) {
      return e(this, a, "f").catch(o);
    }
    finally(o) {
      return e(this, a, "f").finally(o);
    }
    $inspect() {
      return e(this, n, "f");
    }
  }
  return hs.APIPromise = i, n = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap(), r = Symbol.toStringTag, hs;
}
var zO;
function xJ() {
  if (zO) return Or;
  zO = 1;
  var t = Or && Or.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Or && Or.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Or && Or.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Or, "__esModule", { value: !0 }), Or.agentsComplete = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ An()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.AgentsCompletionRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), C = (0, l.pathToFunc)("/v1/agents/completions")(), R = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, o.extractSecurity)(d._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, o.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "agents_completion_v1_agents_completions_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = d._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: C,
      headers: R,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, w = await d._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!w.ok)
      return [w, { status: "request-error", request: N }];
    const k = w.value, L = {
      HttpMeta: { Response: k, Request: N }
    }, [B] = await r.match(r.json(200, f.ChatCompletionResponse$inboundSchema), r.jsonErr(422, u.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(k, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: k }] : [B, { status: "complete", request: N, response: k }];
  }
  return Or;
}
var Pr = {}, ZO;
function VJ() {
  if (ZO) return Pr;
  ZO = 1;
  var t = Pr && Pr.__createBinding || (Object.create ? function(b, g, _, P) {
    P === void 0 && (P = _);
    var C = Object.getOwnPropertyDescriptor(g, _);
    (!C || ("get" in C ? !g.__esModule : C.writable || C.configurable)) && (C = { enumerable: !0, get: function() {
      return g[_];
    } }), Object.defineProperty(b, P, C);
  } : function(b, g, _, P) {
    P === void 0 && (P = _), b[P] = g[_];
  }), e = Pr && Pr.__setModuleDefault || (Object.create ? function(b, g) {
    Object.defineProperty(b, "default", { enumerable: !0, value: g });
  } : function(b, g) {
    b.default = g;
  }), n = Pr && Pr.__importStar || function(b) {
    if (b && b.__esModule) return b;
    var g = {};
    if (b != null) for (var _ in b) _ !== "default" && Object.prototype.hasOwnProperty.call(b, _) && t(g, b, _);
    return e(g, b), g;
  };
  Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.agentsStream = d;
  const a = n(/* @__PURE__ */ H()), r = /* @__PURE__ */ Ne(), i = /* @__PURE__ */ Jp(), s = n(/* @__PURE__ */ ke()), o = /* @__PURE__ */ X(), l = /* @__PURE__ */ Z(), f = /* @__PURE__ */ Fe(), u = /* @__PURE__ */ Ee(), c = n(/* @__PURE__ */ Oe()), h = n(/* @__PURE__ */ An()), p = /* @__PURE__ */ De();
  function d(b, g, _) {
    return new p.APIPromise(m(b, g, _));
  }
  async function m(b, g, _) {
    const P = (0, l.safeParse)(g, (ie) => c.AgentsCompletionStreamRequest$outboundSchema.parse(ie), "Input validation failed");
    if (!P.ok)
      return [P, { status: "invalid" }];
    const C = P.value, R = (0, r.encodeJSON)("body", C, { explode: !0 }), T = (0, u.pathToFunc)("/v1/agents/completions#stream")(), O = new Headers((0, o.compactMap)({
      "Content-Type": "application/json",
      Accept: "text/event-stream"
    })), A = await (0, f.extractSecurity)(b._options.apiKey), M = A == null ? {} : { apiKey: A }, I = (0, f.resolveGlobalSecurity)(M), N = {
      baseURL: _?.serverURL ?? b._baseURL ?? "",
      operationID: "stream_agents",
      oAuth2Scopes: [],
      resolvedSecurity: I,
      securitySource: b._options.apiKey,
      retryConfig: _?.retries || b._options.retryConfig || { strategy: "none" },
      retryCodes: _?.retryCodes || ["429", "500", "502", "503", "504"]
    }, w = b._createRequest(N, {
      security: I,
      method: "POST",
      baseURL: _?.serverURL,
      path: T,
      headers: O,
      body: R,
      timeoutMs: _?.timeoutMs || b._options.timeoutMs || -1
    }, _);
    if (!w.ok)
      return [w, { status: "invalid" }];
    const k = w.value, L = await b._do(k, {
      context: N,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: N.retryConfig,
      retryCodes: N.retryCodes
    });
    if (!L.ok)
      return [L, { status: "request-error", request: k }];
    const B = L.value, V = {
      HttpMeta: { Response: B, Request: k }
    }, [ce] = await s.match(s.sse(200, a.instanceof(ReadableStream).transform((ie) => new i.EventStream({
      stream: ie,
      decoder(ut) {
        return c.CompletionEvent$inboundSchema.parse(ut);
      }
    })), { sseSentinel: "[DONE]" }), s.jsonErr(422, h.HTTPValidationError$inboundSchema), s.fail("4XX"), s.fail("5XX"))(B, { extraFields: V });
    return ce.ok ? [ce, { status: "complete", request: k, response: B }] : [ce, { status: "complete", request: k, response: B }];
  }
  return Pr;
}
var KO;
function zJ() {
  if (KO) return Uc;
  KO = 1, Object.defineProperty(Uc, "__esModule", { value: !0 }), Uc.Agents = void 0;
  const t = /* @__PURE__ */ xJ(), e = /* @__PURE__ */ VJ(), n = /* @__PURE__ */ Mn(), a = /* @__PURE__ */ Zn();
  class r extends n.ClientSDK {
    /**
     * Agents Completion
     */
    async complete(s, o) {
      return (0, a.unwrapAsync)((0, t.agentsComplete)(this, s, o));
    }
    /**
     * Stream Agents completion
     *
     * @remarks
     * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
     */
    async stream(s, o) {
      return (0, a.unwrapAsync)((0, e.agentsStream)(this, s, o));
    }
  }
  return Uc.Agents = r, Uc;
}
var xc = {}, Vc = {}, Rr = {}, Io = {}, ps = {}, HO;
function ZJ() {
  return HO || (HO = 1, function(t) {
    var e = ps && ps.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = ps && ps.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = ps && ps.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.DeleteModelV1ModelsModelIdDeleteRequest$ = t.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema = t.DeleteModelV1ModelsModelIdDeleteRequest$inboundSchema = void 0, t.deleteModelV1ModelsModelIdDeleteRequestToJSON = l, t.deleteModelV1ModelsModelIdDeleteRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.DeleteModelV1ModelsModelIdDeleteRequest$inboundSchema = r.object({
      model_id: r.string()
    }).transform((u) => (0, i.remap)(u, {
      model_id: "modelId"
    })), t.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema = r.object({
      modelId: r.string()
    }).transform((u) => (0, i.remap)(u, {
      modelId: "model_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.DeleteModelV1ModelsModelIdDeleteRequest$inboundSchema, u.outboundSchema = t.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema;
    })(o || (t.DeleteModelV1ModelsModelIdDeleteRequest$ = o = {}));
    function l(u) {
      return JSON.stringify(t.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.DeleteModelV1ModelsModelIdDeleteRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'DeleteModelV1ModelsModelIdDeleteRequest' from JSON");
    }
  }(ps)), ps;
}
var ms = {}, GO;
function KJ() {
  return GO || (GO = 1, function(t) {
    var e = ms && ms.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = ms && ms.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = ms && ms.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilesApiRoutesDeleteFileRequest$ = t.FilesApiRoutesDeleteFileRequest$outboundSchema = t.FilesApiRoutesDeleteFileRequest$inboundSchema = void 0, t.filesApiRoutesDeleteFileRequestToJSON = l, t.filesApiRoutesDeleteFileRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FilesApiRoutesDeleteFileRequest$inboundSchema = r.object({
      file_id: r.string()
    }).transform((u) => (0, i.remap)(u, {
      file_id: "fileId"
    })), t.FilesApiRoutesDeleteFileRequest$outboundSchema = r.object({
      fileId: r.string()
    }).transform((u) => (0, i.remap)(u, {
      fileId: "file_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.FilesApiRoutesDeleteFileRequest$inboundSchema, u.outboundSchema = t.FilesApiRoutesDeleteFileRequest$outboundSchema;
    })(o || (t.FilesApiRoutesDeleteFileRequest$ = o = {}));
    function l(u) {
      return JSON.stringify(t.FilesApiRoutesDeleteFileRequest$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.FilesApiRoutesDeleteFileRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'FilesApiRoutesDeleteFileRequest' from JSON");
    }
  }(ms)), ms;
}
var bs = {}, WO;
function HJ() {
  return WO || (WO = 1, function(t) {
    var e = bs && bs.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = bs && bs.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = bs && bs.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilesApiRoutesDownloadFileRequest$ = t.FilesApiRoutesDownloadFileRequest$outboundSchema = t.FilesApiRoutesDownloadFileRequest$inboundSchema = void 0, t.filesApiRoutesDownloadFileRequestToJSON = l, t.filesApiRoutesDownloadFileRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FilesApiRoutesDownloadFileRequest$inboundSchema = r.object({
      file_id: r.string()
    }).transform((u) => (0, i.remap)(u, {
      file_id: "fileId"
    })), t.FilesApiRoutesDownloadFileRequest$outboundSchema = r.object({
      fileId: r.string()
    }).transform((u) => (0, i.remap)(u, {
      fileId: "file_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.FilesApiRoutesDownloadFileRequest$inboundSchema, u.outboundSchema = t.FilesApiRoutesDownloadFileRequest$outboundSchema;
    })(o || (t.FilesApiRoutesDownloadFileRequest$ = o = {}));
    function l(u) {
      return JSON.stringify(t.FilesApiRoutesDownloadFileRequest$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.FilesApiRoutesDownloadFileRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'FilesApiRoutesDownloadFileRequest' from JSON");
    }
  }(bs)), bs;
}
var gs = {}, XO;
function GJ() {
  return XO || (XO = 1, function(t) {
    var e = gs && gs.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = gs && gs.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = gs && gs.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilesApiRoutesGetSignedUrlRequest$ = t.FilesApiRoutesGetSignedUrlRequest$outboundSchema = t.FilesApiRoutesGetSignedUrlRequest$inboundSchema = void 0, t.filesApiRoutesGetSignedUrlRequestToJSON = l, t.filesApiRoutesGetSignedUrlRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FilesApiRoutesGetSignedUrlRequest$inboundSchema = r.object({
      file_id: r.string(),
      expiry: r.number().int().default(24)
    }).transform((u) => (0, i.remap)(u, {
      file_id: "fileId"
    })), t.FilesApiRoutesGetSignedUrlRequest$outboundSchema = r.object({
      fileId: r.string(),
      expiry: r.number().int().default(24)
    }).transform((u) => (0, i.remap)(u, {
      fileId: "file_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.FilesApiRoutesGetSignedUrlRequest$inboundSchema, u.outboundSchema = t.FilesApiRoutesGetSignedUrlRequest$outboundSchema;
    })(o || (t.FilesApiRoutesGetSignedUrlRequest$ = o = {}));
    function l(u) {
      return JSON.stringify(t.FilesApiRoutesGetSignedUrlRequest$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.FilesApiRoutesGetSignedUrlRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'FilesApiRoutesGetSignedUrlRequest' from JSON");
    }
  }(gs)), gs;
}
var _s = {}, QO;
function WJ() {
  return QO || (QO = 1, function(t) {
    var e = _s && _s.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = _s && _s.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = _s && _s.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilesApiRoutesListFilesRequest$ = t.FilesApiRoutesListFilesRequest$outboundSchema = t.FilesApiRoutesListFilesRequest$inboundSchema = void 0, t.filesApiRoutesListFilesRequestToJSON = f, t.filesApiRoutesListFilesRequestFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = a(/* @__PURE__ */ Oe());
    t.FilesApiRoutesListFilesRequest$inboundSchema = r.object({
      page: r.number().int().default(0),
      page_size: r.number().int().default(100),
      sample_type: r.nullable(r.array(o.SampleType$inboundSchema)).optional(),
      source: r.nullable(r.array(o.Source$inboundSchema)).optional(),
      search: r.nullable(r.string()).optional(),
      purpose: r.nullable(o.FilePurpose$inboundSchema).optional()
    }).transform((c) => (0, i.remap)(c, {
      page_size: "pageSize",
      sample_type: "sampleType"
    })), t.FilesApiRoutesListFilesRequest$outboundSchema = r.object({
      page: r.number().int().default(0),
      pageSize: r.number().int().default(100),
      sampleType: r.nullable(r.array(o.SampleType$outboundSchema)).optional(),
      source: r.nullable(r.array(o.Source$outboundSchema)).optional(),
      search: r.nullable(r.string()).optional(),
      purpose: r.nullable(o.FilePurpose$outboundSchema).optional()
    }).transform((c) => (0, i.remap)(c, {
      pageSize: "page_size",
      sampleType: "sample_type"
    }));
    var l;
    (function(c) {
      c.inboundSchema = t.FilesApiRoutesListFilesRequest$inboundSchema, c.outboundSchema = t.FilesApiRoutesListFilesRequest$outboundSchema;
    })(l || (t.FilesApiRoutesListFilesRequest$ = l = {}));
    function f(c) {
      return JSON.stringify(t.FilesApiRoutesListFilesRequest$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, s.safeParse)(c, (h) => t.FilesApiRoutesListFilesRequest$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'FilesApiRoutesListFilesRequest' from JSON");
    }
  }(_s)), _s;
}
var ys = {}, YO;
function XJ() {
  return YO || (YO = 1, function(t) {
    var e = ys && ys.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = ys && ys.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = ys && ys.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilesApiRoutesRetrieveFileRequest$ = t.FilesApiRoutesRetrieveFileRequest$outboundSchema = t.FilesApiRoutesRetrieveFileRequest$inboundSchema = void 0, t.filesApiRoutesRetrieveFileRequestToJSON = l, t.filesApiRoutesRetrieveFileRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FilesApiRoutesRetrieveFileRequest$inboundSchema = r.object({
      file_id: r.string()
    }).transform((u) => (0, i.remap)(u, {
      file_id: "fileId"
    })), t.FilesApiRoutesRetrieveFileRequest$outboundSchema = r.object({
      fileId: r.string()
    }).transform((u) => (0, i.remap)(u, {
      fileId: "file_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.FilesApiRoutesRetrieveFileRequest$inboundSchema, u.outboundSchema = t.FilesApiRoutesRetrieveFileRequest$outboundSchema;
    })(o || (t.FilesApiRoutesRetrieveFileRequest$ = o = {}));
    function l(u) {
      return JSON.stringify(t.FilesApiRoutesRetrieveFileRequest$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.FilesApiRoutesRetrieveFileRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'FilesApiRoutesRetrieveFileRequest' from JSON");
    }
  }(ys)), ys;
}
var ws = {}, Dn = {}, e0;
function d$() {
  if (e0) return Dn;
  e0 = 1;
  var t = Dn && Dn.__createBinding || (Object.create ? function(i, s, o, l) {
    l === void 0 && (l = o);
    var f = Object.getOwnPropertyDescriptor(s, o);
    (!f || ("get" in f ? !s.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return s[o];
    } }), Object.defineProperty(i, l, f);
  } : function(i, s, o, l) {
    l === void 0 && (l = o), i[l] = s[o];
  }), e = Dn && Dn.__setModuleDefault || (Object.create ? function(i, s) {
    Object.defineProperty(i, "default", { enumerable: !0, value: s });
  } : function(i, s) {
    i.default = s;
  }), n = Dn && Dn.__importStar || function(i) {
    if (i && i.__esModule) return i;
    var s = {};
    if (i != null) for (var o in i) o !== "default" && Object.prototype.hasOwnProperty.call(i, o) && t(s, i, o);
    return e(s, i), s;
  };
  Object.defineProperty(Dn, "__esModule", { value: !0 }), Dn.blobLikeSchema = void 0, Dn.isBlobLike = r;
  const a = n(/* @__PURE__ */ H());
  Dn.blobLikeSchema = a.custom(r, {
    message: "expected a Blob, File or Blob-like object",
    fatal: !0
  });
  function r(i) {
    if (i instanceof Blob)
      return !0;
    if (typeof i != "object" || i == null || !(Symbol.toStringTag in i))
      return !1;
    const s = i[Symbol.toStringTag];
    return typeof s != "string" || s !== "Blob" && s !== "File" ? !1 : "stream" in i && typeof i.stream == "function";
  }
  return Dn;
}
var t0;
function QJ() {
  return t0 || (t0 = 1, function(t) {
    var e = ws && ws.__createBinding || (Object.create ? function(d, m, b, g) {
      g === void 0 && (g = b);
      var _ = Object.getOwnPropertyDescriptor(m, b);
      (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
        return m[b];
      } }), Object.defineProperty(d, g, _);
    } : function(d, m, b, g) {
      g === void 0 && (g = b), d[g] = m[b];
    }), n = ws && ws.__setModuleDefault || (Object.create ? function(d, m) {
      Object.defineProperty(d, "default", { enumerable: !0, value: m });
    } : function(d, m) {
      d.default = m;
    }), a = ws && ws.__importStar || function(d) {
      if (d && d.__esModule) return d;
      var m = {};
      if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && e(m, d, b);
      return n(m, d), m;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilesApiRoutesUploadFileMultiPartBodyParams$ = t.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema = t.FilesApiRoutesUploadFileMultiPartBodyParams$inboundSchema = t.FileT$ = t.FileT$outboundSchema = t.FileT$inboundSchema = void 0, t.fileToJSON = f, t.fileFromJSON = u, t.filesApiRoutesUploadFileMultiPartBodyParamsToJSON = h, t.filesApiRoutesUploadFileMultiPartBodyParamsFromJSON = p;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ d$(), o = a(/* @__PURE__ */ Oe());
    t.FileT$inboundSchema = r.object({
      fileName: r.string(),
      content: r.union([
        r.instanceof(ReadableStream),
        r.instanceof(Blob),
        r.instanceof(ArrayBuffer),
        r.instanceof(Uint8Array)
      ])
    }), t.FileT$outboundSchema = r.object({
      fileName: r.string(),
      content: r.union([
        r.instanceof(ReadableStream),
        r.instanceof(Blob),
        r.instanceof(ArrayBuffer),
        r.instanceof(Uint8Array)
      ])
    });
    var l;
    (function(d) {
      d.inboundSchema = t.FileT$inboundSchema, d.outboundSchema = t.FileT$outboundSchema;
    })(l || (t.FileT$ = l = {}));
    function f(d) {
      return JSON.stringify(t.FileT$outboundSchema.parse(d));
    }
    function u(d) {
      return (0, i.safeParse)(d, (m) => t.FileT$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'FileT' from JSON");
    }
    t.FilesApiRoutesUploadFileMultiPartBodyParams$inboundSchema = r.object({
      file: r.lazy(() => t.FileT$inboundSchema),
      purpose: o.FilePurpose$inboundSchema.optional()
    }), t.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema = r.object({
      file: r.lazy(() => t.FileT$outboundSchema).or(s.blobLikeSchema),
      purpose: o.FilePurpose$outboundSchema.optional()
    });
    var c;
    (function(d) {
      d.inboundSchema = t.FilesApiRoutesUploadFileMultiPartBodyParams$inboundSchema, d.outboundSchema = t.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema;
    })(c || (t.FilesApiRoutesUploadFileMultiPartBodyParams$ = c = {}));
    function h(d) {
      return JSON.stringify(t.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema.parse(d));
    }
    function p(d) {
      return (0, i.safeParse)(d, (m) => t.FilesApiRoutesUploadFileMultiPartBodyParams$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'FilesApiRoutesUploadFileMultiPartBodyParams' from JSON");
    }
  }(ws)), ws;
}
var vs = {}, n0;
function YJ() {
  return n0 || (n0 = 1, function(t) {
    var e = vs && vs.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = vs && vs.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = vs && vs.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesBatchCancelBatchJobRequest$ = t.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema = t.JobsApiRoutesBatchCancelBatchJobRequest$inboundSchema = void 0, t.jobsApiRoutesBatchCancelBatchJobRequestToJSON = l, t.jobsApiRoutesBatchCancelBatchJobRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesBatchCancelBatchJobRequest$inboundSchema = r.object({
      job_id: r.string()
    }).transform((u) => (0, i.remap)(u, {
      job_id: "jobId"
    })), t.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema = r.object({
      jobId: r.string()
    }).transform((u) => (0, i.remap)(u, {
      jobId: "job_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.JobsApiRoutesBatchCancelBatchJobRequest$inboundSchema, u.outboundSchema = t.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema;
    })(o || (t.JobsApiRoutesBatchCancelBatchJobRequest$ = o = {}));
    function l(u) {
      return JSON.stringify(t.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.JobsApiRoutesBatchCancelBatchJobRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesBatchCancelBatchJobRequest' from JSON");
    }
  }(vs)), vs;
}
var Ss = {}, r0;
function eL() {
  return r0 || (r0 = 1, function(t) {
    var e = Ss && Ss.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Ss && Ss.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Ss && Ss.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesBatchGetBatchJobRequest$ = t.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema = t.JobsApiRoutesBatchGetBatchJobRequest$inboundSchema = void 0, t.jobsApiRoutesBatchGetBatchJobRequestToJSON = l, t.jobsApiRoutesBatchGetBatchJobRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesBatchGetBatchJobRequest$inboundSchema = r.object({
      job_id: r.string()
    }).transform((u) => (0, i.remap)(u, {
      job_id: "jobId"
    })), t.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema = r.object({
      jobId: r.string()
    }).transform((u) => (0, i.remap)(u, {
      jobId: "job_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.JobsApiRoutesBatchGetBatchJobRequest$inboundSchema, u.outboundSchema = t.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema;
    })(o || (t.JobsApiRoutesBatchGetBatchJobRequest$ = o = {}));
    function l(u) {
      return JSON.stringify(t.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.JobsApiRoutesBatchGetBatchJobRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesBatchGetBatchJobRequest' from JSON");
    }
  }(Ss)), Ss;
}
var Os = {}, a0;
function tL() {
  return a0 || (a0 = 1, function(t) {
    var e = Os && Os.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Os && Os.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Os && Os.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesBatchGetBatchJobsRequest$ = t.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema = t.JobsApiRoutesBatchGetBatchJobsRequest$inboundSchema = void 0, t.jobsApiRoutesBatchGetBatchJobsRequestToJSON = f, t.jobsApiRoutesBatchGetBatchJobsRequestFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = a(/* @__PURE__ */ Oe());
    t.JobsApiRoutesBatchGetBatchJobsRequest$inboundSchema = r.object({
      page: r.number().int().default(0),
      page_size: r.number().int().default(100),
      model: r.nullable(r.string()).optional(),
      metadata: r.nullable(r.record(r.any())).optional(),
      created_after: r.nullable(r.string().datetime({ offset: !0 }).transform((c) => new Date(c))).optional(),
      created_by_me: r.boolean().default(!1),
      status: r.nullable(o.BatchJobStatus$inboundSchema).optional()
    }).transform((c) => (0, i.remap)(c, {
      page_size: "pageSize",
      created_after: "createdAfter",
      created_by_me: "createdByMe"
    })), t.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema = r.object({
      page: r.number().int().default(0),
      pageSize: r.number().int().default(100),
      model: r.nullable(r.string()).optional(),
      metadata: r.nullable(r.record(r.any())).optional(),
      createdAfter: r.nullable(r.date().transform((c) => c.toISOString())).optional(),
      createdByMe: r.boolean().default(!1),
      status: r.nullable(o.BatchJobStatus$outboundSchema).optional()
    }).transform((c) => (0, i.remap)(c, {
      pageSize: "page_size",
      createdAfter: "created_after",
      createdByMe: "created_by_me"
    }));
    var l;
    (function(c) {
      c.inboundSchema = t.JobsApiRoutesBatchGetBatchJobsRequest$inboundSchema, c.outboundSchema = t.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema;
    })(l || (t.JobsApiRoutesBatchGetBatchJobsRequest$ = l = {}));
    function f(c) {
      return JSON.stringify(t.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, s.safeParse)(c, (h) => t.JobsApiRoutesBatchGetBatchJobsRequest$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'JobsApiRoutesBatchGetBatchJobsRequest' from JSON");
    }
  }(Os)), Os;
}
var js = {}, i0;
function nL() {
  return i0 || (i0 = 1, function(t) {
    var e = js && js.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = js && js.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = js && js.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$ = t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema = t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$inboundSchema = void 0, t.jobsApiRoutesFineTuningArchiveFineTunedModelRequestToJSON = l, t.jobsApiRoutesFineTuningArchiveFineTunedModelRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$inboundSchema = r.object({
      model_id: r.string()
    }).transform((u) => (0, i.remap)(u, {
      model_id: "modelId"
    })), t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema = r.object({
      modelId: r.string()
    }).transform((u) => (0, i.remap)(u, {
      modelId: "model_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$inboundSchema, u.outboundSchema = t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema;
    })(o || (t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$ = o = {}));
    function l(u) {
      return JSON.stringify(t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesFineTuningArchiveFineTunedModelRequest' from JSON");
    }
  }(js)), js;
}
var Ps = {}, s0;
function rL() {
  return s0 || (s0 = 1, function(t) {
    var e = Ps && Ps.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Ps && Ps.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Ps && Ps.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$ = t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema = t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$inboundSchema = void 0, t.jobsApiRoutesFineTuningCancelFineTuningJobRequestToJSON = l, t.jobsApiRoutesFineTuningCancelFineTuningJobRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$inboundSchema = r.object({
      job_id: r.string()
    }).transform((u) => (0, i.remap)(u, {
      job_id: "jobId"
    })), t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema = r.object({
      jobId: r.string()
    }).transform((u) => (0, i.remap)(u, {
      jobId: "job_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$inboundSchema, u.outboundSchema = t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema;
    })(o || (t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$ = o = {}));
    function l(u) {
      return JSON.stringify(t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesFineTuningCancelFineTuningJobRequest' from JSON");
    }
  }(Ps)), Ps;
}
var Rs = {}, o0;
function aL() {
  return o0 || (o0 = 1, function(t) {
    var e = Rs && Rs.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Rs && Rs.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Rs && Rs.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$ = t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$outboundSchema = t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema = void 0, t.jobsApiRoutesFineTuningCreateFineTuningJobResponseToJSON = l, t.jobsApiRoutesFineTuningCreateFineTuningJobResponseFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = a(/* @__PURE__ */ Oe());
    t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema = r.union([
      s.LegacyJobMetadataOut$inboundSchema,
      s.JobOut$inboundSchema
    ]), t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$outboundSchema = r.union([
      s.LegacyJobMetadataOut$outboundSchema,
      s.JobOut$outboundSchema
    ]);
    var o;
    (function(u) {
      u.inboundSchema = t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema, u.outboundSchema = t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$outboundSchema;
    })(o || (t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$ = o = {}));
    function l(u) {
      return JSON.stringify(t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, i.safeParse)(u, (c) => t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesFineTuningCreateFineTuningJobResponse' from JSON");
    }
  }(Rs)), Rs;
}
var Cs = {}, u0;
function iL() {
  return u0 || (u0 = 1, function(t) {
    var e = Cs && Cs.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Cs && Cs.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Cs && Cs.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningGetFineTuningJobRequest$ = t.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema = t.JobsApiRoutesFineTuningGetFineTuningJobRequest$inboundSchema = void 0, t.jobsApiRoutesFineTuningGetFineTuningJobRequestToJSON = l, t.jobsApiRoutesFineTuningGetFineTuningJobRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesFineTuningGetFineTuningJobRequest$inboundSchema = r.object({
      job_id: r.string()
    }).transform((u) => (0, i.remap)(u, {
      job_id: "jobId"
    })), t.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema = r.object({
      jobId: r.string()
    }).transform((u) => (0, i.remap)(u, {
      jobId: "job_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.JobsApiRoutesFineTuningGetFineTuningJobRequest$inboundSchema, u.outboundSchema = t.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema;
    })(o || (t.JobsApiRoutesFineTuningGetFineTuningJobRequest$ = o = {}));
    function l(u) {
      return JSON.stringify(t.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.JobsApiRoutesFineTuningGetFineTuningJobRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesFineTuningGetFineTuningJobRequest' from JSON");
    }
  }(Cs)), Cs;
}
var Ts = {}, c0;
function sL() {
  return c0 || (c0 = 1, function(t) {
    var e = Ts && Ts.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = Ts && Ts.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Ts && Ts.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$ = t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema = t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$inboundSchema = t.Status$ = t.Status$outboundSchema = t.Status$inboundSchema = t.Status = void 0, t.jobsApiRoutesFineTuningGetFineTuningJobsRequestToJSON = f, t.jobsApiRoutesFineTuningGetFineTuningJobsRequestFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.Status = {
      Queued: "QUEUED",
      Started: "STARTED",
      Validating: "VALIDATING",
      Validated: "VALIDATED",
      Running: "RUNNING",
      FailedValidation: "FAILED_VALIDATION",
      Failed: "FAILED",
      Success: "SUCCESS",
      Cancelled: "CANCELLED",
      CancellationRequested: "CANCELLATION_REQUESTED"
    }, t.Status$inboundSchema = r.nativeEnum(t.Status), t.Status$outboundSchema = t.Status$inboundSchema;
    var o;
    (function(c) {
      c.inboundSchema = t.Status$inboundSchema, c.outboundSchema = t.Status$outboundSchema;
    })(o || (t.Status$ = o = {})), t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$inboundSchema = r.object({
      page: r.number().int().default(0),
      page_size: r.number().int().default(100),
      model: r.nullable(r.string()).optional(),
      created_after: r.nullable(r.string().datetime({ offset: !0 }).transform((c) => new Date(c))).optional(),
      created_by_me: r.boolean().default(!1),
      status: r.nullable(t.Status$inboundSchema).optional(),
      wandb_project: r.nullable(r.string()).optional(),
      wandb_name: r.nullable(r.string()).optional(),
      suffix: r.nullable(r.string()).optional()
    }).transform((c) => (0, i.remap)(c, {
      page_size: "pageSize",
      created_after: "createdAfter",
      created_by_me: "createdByMe",
      wandb_project: "wandbProject",
      wandb_name: "wandbName"
    })), t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema = r.object({
      page: r.number().int().default(0),
      pageSize: r.number().int().default(100),
      model: r.nullable(r.string()).optional(),
      createdAfter: r.nullable(r.date().transform((c) => c.toISOString())).optional(),
      createdByMe: r.boolean().default(!1),
      status: r.nullable(t.Status$outboundSchema).optional(),
      wandbProject: r.nullable(r.string()).optional(),
      wandbName: r.nullable(r.string()).optional(),
      suffix: r.nullable(r.string()).optional()
    }).transform((c) => (0, i.remap)(c, {
      pageSize: "page_size",
      createdAfter: "created_after",
      createdByMe: "created_by_me",
      wandbProject: "wandb_project",
      wandbName: "wandb_name"
    }));
    var l;
    (function(c) {
      c.inboundSchema = t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$inboundSchema, c.outboundSchema = t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema;
    })(l || (t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$ = l = {}));
    function f(c) {
      return JSON.stringify(t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, s.safeParse)(c, (h) => t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'JobsApiRoutesFineTuningGetFineTuningJobsRequest' from JSON");
    }
  }(Ts)), Ts;
}
var $s = {}, l0;
function oL() {
  return l0 || (l0 = 1, function(t) {
    var e = $s && $s.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = $s && $s.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = $s && $s.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningStartFineTuningJobRequest$ = t.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema = t.JobsApiRoutesFineTuningStartFineTuningJobRequest$inboundSchema = void 0, t.jobsApiRoutesFineTuningStartFineTuningJobRequestToJSON = l, t.jobsApiRoutesFineTuningStartFineTuningJobRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesFineTuningStartFineTuningJobRequest$inboundSchema = r.object({
      job_id: r.string()
    }).transform((u) => (0, i.remap)(u, {
      job_id: "jobId"
    })), t.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema = r.object({
      jobId: r.string()
    }).transform((u) => (0, i.remap)(u, {
      jobId: "job_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.JobsApiRoutesFineTuningStartFineTuningJobRequest$inboundSchema, u.outboundSchema = t.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema;
    })(o || (t.JobsApiRoutesFineTuningStartFineTuningJobRequest$ = o = {}));
    function l(u) {
      return JSON.stringify(t.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.JobsApiRoutesFineTuningStartFineTuningJobRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesFineTuningStartFineTuningJobRequest' from JSON");
    }
  }($s)), $s;
}
var Ms = {}, d0;
function uL() {
  return d0 || (d0 = 1, function(t) {
    var e = Ms && Ms.__createBinding || (Object.create ? function(u, c, h, p) {
      p === void 0 && (p = h);
      var d = Object.getOwnPropertyDescriptor(c, h);
      (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(u, p, d);
    } : function(u, c, h, p) {
      p === void 0 && (p = h), u[p] = c[h];
    }), n = Ms && Ms.__setModuleDefault || (Object.create ? function(u, c) {
      Object.defineProperty(u, "default", { enumerable: !0, value: c });
    } : function(u, c) {
      u.default = c;
    }), a = Ms && Ms.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var c = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(c, u, h);
      return n(c, u), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$ = t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema = t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$inboundSchema = void 0, t.jobsApiRoutesFineTuningUnarchiveFineTunedModelRequestToJSON = l, t.jobsApiRoutesFineTuningUnarchiveFineTunedModelRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$inboundSchema = r.object({
      model_id: r.string()
    }).transform((u) => (0, i.remap)(u, {
      model_id: "modelId"
    })), t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema = r.object({
      modelId: r.string()
    }).transform((u) => (0, i.remap)(u, {
      modelId: "model_id"
    }));
    var o;
    (function(u) {
      u.inboundSchema = t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$inboundSchema, u.outboundSchema = t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema;
    })(o || (t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$ = o = {}));
    function l(u) {
      return JSON.stringify(t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema.parse(u));
    }
    function f(u) {
      return (0, s.safeParse)(u, (c) => t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest' from JSON");
    }
  }(Ms)), Ms;
}
var As = {}, f0;
function cL() {
  return f0 || (f0 = 1, function(t) {
    var e = As && As.__createBinding || (Object.create ? function(c, h, p, d) {
      d === void 0 && (d = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, d, m);
    } : function(c, h, p, d) {
      d === void 0 && (d = p), c[d] = h[p];
    }), n = As && As.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = As && As.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$ = t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema = t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$inboundSchema = void 0, t.jobsApiRoutesFineTuningUpdateFineTunedModelRequestToJSON = f, t.jobsApiRoutesFineTuningUpdateFineTunedModelRequestFromJSON = u;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = a(/* @__PURE__ */ Oe());
    t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$inboundSchema = r.object({
      model_id: r.string(),
      UpdateFTModelIn: o.UpdateFTModelIn$inboundSchema
    }).transform((c) => (0, i.remap)(c, {
      model_id: "modelId",
      UpdateFTModelIn: "updateFTModelIn"
    })), t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema = r.object({
      modelId: r.string(),
      updateFTModelIn: o.UpdateFTModelIn$outboundSchema
    }).transform((c) => (0, i.remap)(c, {
      modelId: "model_id",
      updateFTModelIn: "UpdateFTModelIn"
    }));
    var l;
    (function(c) {
      c.inboundSchema = t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$inboundSchema, c.outboundSchema = t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema;
    })(l || (t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$ = l = {}));
    function f(c) {
      return JSON.stringify(t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema.parse(c));
    }
    function u(c) {
      return (0, s.safeParse)(c, (h) => t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'JobsApiRoutesFineTuningUpdateFineTunedModelRequest' from JSON");
    }
  }(As)), As;
}
var Es = {}, h0;
function lL() {
  return h0 || (h0 = 1, function(t) {
    var e = Es && Es.__createBinding || (Object.create ? function(d, m, b, g) {
      g === void 0 && (g = b);
      var _ = Object.getOwnPropertyDescriptor(m, b);
      (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
        return m[b];
      } }), Object.defineProperty(d, g, _);
    } : function(d, m, b, g) {
      g === void 0 && (g = b), d[g] = m[b];
    }), n = Es && Es.__setModuleDefault || (Object.create ? function(d, m) {
      Object.defineProperty(d, "default", { enumerable: !0, value: m });
    } : function(d, m) {
      d.default = m;
    }), a = Es && Es.__importStar || function(d) {
      if (d && d.__esModule) return d;
      var m = {};
      if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && e(m, d, b);
      return n(m, d), m;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$ = t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$outboundSchema = t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema = t.RetrieveModelV1ModelsModelIdGetRequest$ = t.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema = t.RetrieveModelV1ModelsModelIdGetRequest$inboundSchema = void 0, t.retrieveModelV1ModelsModelIdGetRequestToJSON = f, t.retrieveModelV1ModelsModelIdGetRequestFromJSON = u, t.retrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGetToJSON = h, t.retrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGetFromJSON = p;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = a(/* @__PURE__ */ Oe());
    t.RetrieveModelV1ModelsModelIdGetRequest$inboundSchema = r.object({
      model_id: r.string()
    }).transform((d) => (0, i.remap)(d, {
      model_id: "modelId"
    })), t.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema = r.object({
      modelId: r.string()
    }).transform((d) => (0, i.remap)(d, {
      modelId: "model_id"
    }));
    var l;
    (function(d) {
      d.inboundSchema = t.RetrieveModelV1ModelsModelIdGetRequest$inboundSchema, d.outboundSchema = t.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema;
    })(l || (t.RetrieveModelV1ModelsModelIdGetRequest$ = l = {}));
    function f(d) {
      return JSON.stringify(t.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema.parse(d));
    }
    function u(d) {
      return (0, s.safeParse)(d, (m) => t.RetrieveModelV1ModelsModelIdGetRequest$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'RetrieveModelV1ModelsModelIdGetRequest' from JSON");
    }
    t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema = r.union([
      o.BaseModelCard$inboundSchema.and(r.object({ type: r.literal("base") }).transform((d) => ({
        type: d.type
      }))),
      o.FTModelCard$inboundSchema.and(r.object({ type: r.literal("fine-tuned") }).transform((d) => ({
        type: d.type
      })))
    ]), t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$outboundSchema = r.union([
      o.BaseModelCard$outboundSchema.and(r.object({ type: r.literal("base") }).transform((d) => ({
        type: d.type
      }))),
      o.FTModelCard$outboundSchema.and(r.object({ type: r.literal("fine-tuned") }).transform((d) => ({
        type: d.type
      })))
    ]);
    var c;
    (function(d) {
      d.inboundSchema = t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema, d.outboundSchema = t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$outboundSchema;
    })(c || (t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$ = c = {}));
    function h(d) {
      return JSON.stringify(t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$outboundSchema.parse(d));
    }
    function p(d) {
      return (0, s.safeParse)(d, (m) => t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet' from JSON");
    }
  }(Es)), Es;
}
var p0;
function wt() {
  return p0 || (p0 = 1, function(t) {
    var e = Io && Io.__createBinding || (Object.create ? function(a, r, i, s) {
      s === void 0 && (s = i);
      var o = Object.getOwnPropertyDescriptor(r, i);
      (!o || ("get" in o ? !r.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
        return r[i];
      } }), Object.defineProperty(a, s, o);
    } : function(a, r, i, s) {
      s === void 0 && (s = i), a[s] = r[i];
    }), n = Io && Io.__exportStar || function(a, r) {
      for (var i in a) i !== "default" && !Object.prototype.hasOwnProperty.call(r, i) && e(r, a, i);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(/* @__PURE__ */ ZJ(), t), n(/* @__PURE__ */ KJ(), t), n(/* @__PURE__ */ HJ(), t), n(/* @__PURE__ */ GJ(), t), n(/* @__PURE__ */ WJ(), t), n(/* @__PURE__ */ XJ(), t), n(/* @__PURE__ */ QJ(), t), n(/* @__PURE__ */ YJ(), t), n(/* @__PURE__ */ eL(), t), n(/* @__PURE__ */ tL(), t), n(/* @__PURE__ */ nL(), t), n(/* @__PURE__ */ rL(), t), n(/* @__PURE__ */ aL(), t), n(/* @__PURE__ */ iL(), t), n(/* @__PURE__ */ sL(), t), n(/* @__PURE__ */ oL(), t), n(/* @__PURE__ */ uL(), t), n(/* @__PURE__ */ cL(), t), n(/* @__PURE__ */ lL(), t);
  }(Io)), Io;
}
var m0;
function dL() {
  if (m0) return Rr;
  m0 = 1;
  var t = Rr && Rr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Rr && Rr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Rr && Rr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.batchJobsCancel = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = {
      job_id: (0, a.encodeSimple)("job_id", _.job_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, l.pathToFunc)("/v1/batch/jobs/{job_id}/cancel")(C), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "jobs_api_routes_batch_cancel_batch_job",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "POST",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.BatchJobOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return Rr;
}
var Cr = {}, b0;
function fL() {
  if (b0) return Cr;
  b0 = 1;
  var t = Cr && Cr.__createBinding || (Object.create ? function(p, d, m, b) {
    b === void 0 && (b = m);
    var g = Object.getOwnPropertyDescriptor(d, m);
    (!g || ("get" in g ? !d.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
      return d[m];
    } }), Object.defineProperty(p, b, g);
  } : function(p, d, m, b) {
    b === void 0 && (b = m), p[b] = d[m];
  }), e = Cr && Cr.__setModuleDefault || (Object.create ? function(p, d) {
    Object.defineProperty(p, "default", { enumerable: !0, value: d });
  } : function(p, d) {
    p.default = d;
  }), n = Cr && Cr.__importStar || function(p) {
    if (p && p.__esModule) return p;
    var d = {};
    if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && t(d, p, m);
    return e(d, p), d;
  };
  Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.batchJobsCreate = c;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = /* @__PURE__ */ De();
  function c(p, d, m) {
    return new u.APIPromise(h(p, d, m));
  }
  async function h(p, d, m) {
    const b = (0, s.safeParse)(d, (L) => f.BatchJobIn$outboundSchema.parse(L), "Input validation failed");
    if (!b.ok)
      return [b, { status: "invalid" }];
    const g = b.value, _ = (0, a.encodeJSON)("body", g, { explode: !0 }), P = (0, l.pathToFunc)("/v1/batch/jobs")(), C = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), R = await (0, o.extractSecurity)(p._options.apiKey), T = R == null ? {} : { apiKey: R }, O = (0, o.resolveGlobalSecurity)(T), A = {
      baseURL: m?.serverURL ?? p._baseURL ?? "",
      operationID: "jobs_api_routes_batch_create_batch_job",
      oAuth2Scopes: [],
      resolvedSecurity: O,
      securitySource: p._options.apiKey,
      retryConfig: m?.retries || p._options.retryConfig || { strategy: "none" },
      retryCodes: m?.retryCodes || ["429", "500", "502", "503", "504"]
    }, M = p._createRequest(A, {
      security: O,
      method: "POST",
      baseURL: m?.serverURL,
      path: P,
      headers: C,
      body: _,
      timeoutMs: m?.timeoutMs || p._options.timeoutMs || -1
    }, m);
    if (!M.ok)
      return [M, { status: "invalid" }];
    const I = M.value, N = await p._do(I, {
      context: A,
      errorCodes: ["4XX", "5XX"],
      retryConfig: A.retryConfig,
      retryCodes: A.retryCodes
    });
    if (!N.ok)
      return [N, { status: "request-error", request: I }];
    const w = N.value, [k] = await r.match(r.json(200, f.BatchJobOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(w);
    return k.ok ? [k, { status: "complete", request: I, response: w }] : [k, { status: "complete", request: I, response: w }];
  }
  return Cr;
}
var Tr = {}, g0;
function hL() {
  if (g0) return Tr;
  g0 = 1;
  var t = Tr && Tr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Tr && Tr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Tr && Tr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Tr, "__esModule", { value: !0 }), Tr.batchJobsGet = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = {
      job_id: (0, a.encodeSimple)("job_id", _.job_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, l.pathToFunc)("/v1/batch/jobs/{job_id}")(C), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "jobs_api_routes_batch_get_batch_job",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.BatchJobOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return Tr;
}
var $r = {}, _0;
function pL() {
  if (_0) return $r;
  _0 = 1;
  var t = $r && $r.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = $r && $r.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = $r && $r.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty($r, "__esModule", { value: !0 }), $r.batchJobsList = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema.optional().parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = (0, l.pathToFunc)("/v1/batch/jobs")(), R = (0, a.encodeFormQuery)({
      created_after: _?.created_after,
      created_by_me: _?.created_by_me,
      metadata: _?.metadata,
      model: _?.model,
      page: _?.page,
      page_size: _?.page_size,
      status: _?.status
    }), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "jobs_api_routes_batch_get_batch_jobs",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      query: R,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.BatchJobsOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return $r;
}
var y0;
function mL() {
  if (y0) return Vc;
  y0 = 1, Object.defineProperty(Vc, "__esModule", { value: !0 }), Vc.MistralJobs = void 0;
  const t = /* @__PURE__ */ dL(), e = /* @__PURE__ */ fL(), n = /* @__PURE__ */ hL(), a = /* @__PURE__ */ pL(), r = /* @__PURE__ */ Mn(), i = /* @__PURE__ */ Zn();
  class s extends r.ClientSDK {
    /**
     * Get Batch Jobs
     *
     * @remarks
     * Get a list of batch jobs for your organization and user.
     */
    async list(l, f) {
      return (0, i.unwrapAsync)((0, a.batchJobsList)(this, l, f));
    }
    /**
     * Create Batch Job
     *
     * @remarks
     * Create a new batch job, it will be queued for processing.
     */
    async create(l, f) {
      return (0, i.unwrapAsync)((0, e.batchJobsCreate)(this, l, f));
    }
    /**
     * Get Batch Job
     *
     * @remarks
     * Get a batch job details by its UUID.
     */
    async get(l, f) {
      return (0, i.unwrapAsync)((0, n.batchJobsGet)(this, l, f));
    }
    /**
     * Cancel Batch Job
     *
     * @remarks
     * Request the cancellation of a batch job.
     */
    async cancel(l, f) {
      return (0, i.unwrapAsync)((0, t.batchJobsCancel)(this, l, f));
    }
  }
  return Vc.MistralJobs = s, Vc;
}
var w0;
function bL() {
  if (w0) return xc;
  w0 = 1, Object.defineProperty(xc, "__esModule", { value: !0 }), xc.Batch = void 0;
  const t = /* @__PURE__ */ Mn(), e = /* @__PURE__ */ mL();
  class n extends t.ClientSDK {
    get jobs() {
      return this._jobs ?? (this._jobs = new e.MistralJobs(this._options));
    }
  }
  return xc.Batch = n, xc;
}
var zc = {}, Mr = {}, v0;
function gL() {
  if (v0) return Mr;
  v0 = 1;
  var t = Mr && Mr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Mr && Mr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Mr && Mr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.chatComplete = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ An()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.ChatCompletionRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), C = (0, l.pathToFunc)("/v1/chat/completions")(), R = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, o.extractSecurity)(d._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, o.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "chat_completion_v1_chat_completions_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = d._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: C,
      headers: R,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, w = await d._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!w.ok)
      return [w, { status: "request-error", request: N }];
    const k = w.value, L = {
      HttpMeta: { Response: k, Request: N }
    }, [B] = await r.match(r.json(200, f.ChatCompletionResponse$inboundSchema), r.jsonErr(422, u.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(k, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: k }] : [B, { status: "complete", request: N, response: k }];
  }
  return Mr;
}
var Ar = {}, S0;
function _L() {
  if (S0) return Ar;
  S0 = 1;
  var t = Ar && Ar.__createBinding || (Object.create ? function(b, g, _, P) {
    P === void 0 && (P = _);
    var C = Object.getOwnPropertyDescriptor(g, _);
    (!C || ("get" in C ? !g.__esModule : C.writable || C.configurable)) && (C = { enumerable: !0, get: function() {
      return g[_];
    } }), Object.defineProperty(b, P, C);
  } : function(b, g, _, P) {
    P === void 0 && (P = _), b[P] = g[_];
  }), e = Ar && Ar.__setModuleDefault || (Object.create ? function(b, g) {
    Object.defineProperty(b, "default", { enumerable: !0, value: g });
  } : function(b, g) {
    b.default = g;
  }), n = Ar && Ar.__importStar || function(b) {
    if (b && b.__esModule) return b;
    var g = {};
    if (b != null) for (var _ in b) _ !== "default" && Object.prototype.hasOwnProperty.call(b, _) && t(g, b, _);
    return e(g, b), g;
  };
  Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.chatStream = d;
  const a = n(/* @__PURE__ */ H()), r = /* @__PURE__ */ Ne(), i = /* @__PURE__ */ Jp(), s = n(/* @__PURE__ */ ke()), o = /* @__PURE__ */ X(), l = /* @__PURE__ */ Z(), f = /* @__PURE__ */ Fe(), u = /* @__PURE__ */ Ee(), c = n(/* @__PURE__ */ Oe()), h = n(/* @__PURE__ */ An()), p = /* @__PURE__ */ De();
  function d(b, g, _) {
    return new p.APIPromise(m(b, g, _));
  }
  async function m(b, g, _) {
    const P = (0, l.safeParse)(g, (ie) => c.ChatCompletionStreamRequest$outboundSchema.parse(ie), "Input validation failed");
    if (!P.ok)
      return [P, { status: "invalid" }];
    const C = P.value, R = (0, r.encodeJSON)("body", C, { explode: !0 }), T = (0, u.pathToFunc)("/v1/chat/completions#stream")(), O = new Headers((0, o.compactMap)({
      "Content-Type": "application/json",
      Accept: "text/event-stream"
    })), A = await (0, f.extractSecurity)(b._options.apiKey), M = A == null ? {} : { apiKey: A }, I = (0, f.resolveGlobalSecurity)(M), N = {
      baseURL: _?.serverURL ?? b._baseURL ?? "",
      operationID: "stream_chat",
      oAuth2Scopes: [],
      resolvedSecurity: I,
      securitySource: b._options.apiKey,
      retryConfig: _?.retries || b._options.retryConfig || { strategy: "none" },
      retryCodes: _?.retryCodes || ["429", "500", "502", "503", "504"]
    }, w = b._createRequest(N, {
      security: I,
      method: "POST",
      baseURL: _?.serverURL,
      path: T,
      headers: O,
      body: R,
      timeoutMs: _?.timeoutMs || b._options.timeoutMs || -1
    }, _);
    if (!w.ok)
      return [w, { status: "invalid" }];
    const k = w.value, L = await b._do(k, {
      context: N,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: N.retryConfig,
      retryCodes: N.retryCodes
    });
    if (!L.ok)
      return [L, { status: "request-error", request: k }];
    const B = L.value, V = {
      HttpMeta: { Response: B, Request: k }
    }, [ce] = await s.match(s.sse(200, a.instanceof(ReadableStream).transform((ie) => new i.EventStream({
      stream: ie,
      decoder(ut) {
        return c.CompletionEvent$inboundSchema.parse(ut);
      }
    })), { sseSentinel: "[DONE]" }), s.jsonErr(422, h.HTTPValidationError$inboundSchema), s.fail("4XX"), s.fail("5XX"))(B, { extraFields: V });
    return ce.ok ? [ce, { status: "complete", request: k, response: B }] : [ce, { status: "complete", request: k, response: B }];
  }
  return Ar;
}
var vu = {}, No = {}, ob = {}, O0;
function K_() {
  return O0 || (O0 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.getDefaultOptions = t.defaultOptions = t.jsonDescription = t.ignoreOverride = void 0, t.ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
    const e = (a, r) => {
      if (r.description)
        try {
          return {
            ...a,
            ...JSON.parse(r.description)
          };
        } catch {
        }
      return a;
    };
    t.jsonDescription = e, t.defaultOptions = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      allowedAdditionalProperties: !0,
      rejectedAdditionalProperties: !1,
      definitionPath: "definitions",
      target: "jsonSchema7",
      strictUnions: !1,
      definitions: {},
      errorMessages: !1,
      markdownDescription: !1,
      patternStrategy: "escape",
      applyRegexFlags: !1,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref"
    };
    const n = (a) => typeof a == "string" ? {
      ...t.defaultOptions,
      name: a
    } : {
      ...t.defaultOptions,
      ...a
    };
    t.getDefaultOptions = n;
  }(ob)), ob;
}
var Zc = {}, j0;
function f$() {
  if (j0) return Zc;
  j0 = 1, Object.defineProperty(Zc, "__esModule", { value: !0 }), Zc.getRefs = void 0;
  const t = /* @__PURE__ */ K_(), e = (n) => {
    const a = (0, t.getDefaultOptions)(n), r = a.name !== void 0 ? [...a.basePath, a.definitionPath, a.name] : a.basePath;
    return {
      ...a,
      currentPath: r,
      propertyPath: void 0,
      seen: new Map(Object.entries(a.definitions).map(([i, s]) => [
        s._def,
        {
          def: s._def,
          path: [...a.basePath, a.definitionPath, i],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ]))
    };
  };
  return Zc.getRefs = e, Zc;
}
var ko = {}, P0;
function ou() {
  if (P0) return ko;
  P0 = 1, Object.defineProperty(ko, "__esModule", { value: !0 }), ko.setResponseValueAndErrors = ko.addErrorMessage = void 0;
  function t(n, a, r, i) {
    i?.errorMessages && r && (n.errorMessage = {
      ...n.errorMessage,
      [a]: r
    });
  }
  ko.addErrorMessage = t;
  function e(n, a, r, i, s) {
    n[a] = r, t(n, a, i, s);
  }
  return ko.setResponseValueAndErrors = e, ko;
}
var Kc = {}, Hc = {}, Gc = {}, R0;
function h$() {
  if (R0) return Gc;
  R0 = 1, Object.defineProperty(Gc, "__esModule", { value: !0 }), Gc.parseAnyDef = void 0;
  function t() {
    return {};
  }
  return Gc.parseAnyDef = t, Gc;
}
var Wc = {}, C0;
function p$() {
  if (C0) return Wc;
  C0 = 1, Object.defineProperty(Wc, "__esModule", { value: !0 }), Wc.parseArrayDef = void 0;
  const t = /* @__PURE__ */ H(), e = /* @__PURE__ */ ou(), n = /* @__PURE__ */ vt();
  function a(r, i) {
    const s = {
      type: "array"
    };
    return r.type?._def && r.type?._def?.typeName !== t.ZodFirstPartyTypeKind.ZodAny && (s.items = (0, n.parseDef)(r.type._def, {
      ...i,
      currentPath: [...i.currentPath, "items"]
    })), r.minLength && (0, e.setResponseValueAndErrors)(s, "minItems", r.minLength.value, r.minLength.message, i), r.maxLength && (0, e.setResponseValueAndErrors)(s, "maxItems", r.maxLength.value, r.maxLength.message, i), r.exactLength && ((0, e.setResponseValueAndErrors)(s, "minItems", r.exactLength.value, r.exactLength.message, i), (0, e.setResponseValueAndErrors)(s, "maxItems", r.exactLength.value, r.exactLength.message, i)), s;
  }
  return Wc.parseArrayDef = a, Wc;
}
var Xc = {}, T0;
function m$() {
  if (T0) return Xc;
  T0 = 1, Object.defineProperty(Xc, "__esModule", { value: !0 }), Xc.parseBigintDef = void 0;
  const t = /* @__PURE__ */ ou();
  function e(n, a) {
    const r = {
      type: "integer",
      format: "int64"
    };
    if (!n.checks)
      return r;
    for (const i of n.checks)
      switch (i.kind) {
        case "min":
          a.target === "jsonSchema7" ? i.inclusive ? (0, t.setResponseValueAndErrors)(r, "minimum", i.value, i.message, a) : (0, t.setResponseValueAndErrors)(r, "exclusiveMinimum", i.value, i.message, a) : (i.inclusive || (r.exclusiveMinimum = !0), (0, t.setResponseValueAndErrors)(r, "minimum", i.value, i.message, a));
          break;
        case "max":
          a.target === "jsonSchema7" ? i.inclusive ? (0, t.setResponseValueAndErrors)(r, "maximum", i.value, i.message, a) : (0, t.setResponseValueAndErrors)(r, "exclusiveMaximum", i.value, i.message, a) : (i.inclusive || (r.exclusiveMaximum = !0), (0, t.setResponseValueAndErrors)(r, "maximum", i.value, i.message, a));
          break;
        case "multipleOf":
          (0, t.setResponseValueAndErrors)(r, "multipleOf", i.value, i.message, a);
          break;
      }
    return r;
  }
  return Xc.parseBigintDef = e, Xc;
}
var Qc = {}, $0;
function b$() {
  if ($0) return Qc;
  $0 = 1, Object.defineProperty(Qc, "__esModule", { value: !0 }), Qc.parseBooleanDef = void 0;
  function t() {
    return {
      type: "boolean"
    };
  }
  return Qc.parseBooleanDef = t, Qc;
}
var Yc = {}, M0;
function H_() {
  if (M0) return Yc;
  M0 = 1, Object.defineProperty(Yc, "__esModule", { value: !0 }), Yc.parseBrandedDef = void 0;
  const t = /* @__PURE__ */ vt();
  function e(n, a) {
    return (0, t.parseDef)(n.type._def, a);
  }
  return Yc.parseBrandedDef = e, Yc;
}
var el = {}, A0;
function g$() {
  if (A0) return el;
  A0 = 1, Object.defineProperty(el, "__esModule", { value: !0 }), el.parseCatchDef = void 0;
  const t = /* @__PURE__ */ vt(), e = (n, a) => (0, t.parseDef)(n.innerType._def, a);
  return el.parseCatchDef = e, el;
}
var tl = {}, E0;
function _$() {
  if (E0) return tl;
  E0 = 1, Object.defineProperty(tl, "__esModule", { value: !0 }), tl.parseDateDef = void 0;
  const t = /* @__PURE__ */ ou();
  function e(a, r, i) {
    const s = i ?? r.dateStrategy;
    if (Array.isArray(s))
      return {
        anyOf: s.map((o, l) => e(a, r, o))
      };
    switch (s) {
      case "string":
      case "format:date-time":
        return {
          type: "string",
          format: "date-time"
        };
      case "format:date":
        return {
          type: "string",
          format: "date"
        };
      case "integer":
        return n(a, r);
    }
  }
  tl.parseDateDef = e;
  const n = (a, r) => {
    const i = {
      type: "integer",
      format: "unix-time"
    };
    if (r.target === "openApi3")
      return i;
    for (const s of a.checks)
      switch (s.kind) {
        case "min":
          (0, t.setResponseValueAndErrors)(
            i,
            "minimum",
            s.value,
            // This is in milliseconds
            s.message,
            r
          );
          break;
        case "max":
          (0, t.setResponseValueAndErrors)(
            i,
            "maximum",
            s.value,
            // This is in milliseconds
            s.message,
            r
          );
          break;
      }
    return i;
  };
  return tl;
}
var nl = {}, I0;
function y$() {
  if (I0) return nl;
  I0 = 1, Object.defineProperty(nl, "__esModule", { value: !0 }), nl.parseDefaultDef = void 0;
  const t = /* @__PURE__ */ vt();
  function e(n, a) {
    return {
      ...(0, t.parseDef)(n.innerType._def, a),
      default: n.defaultValue()
    };
  }
  return nl.parseDefaultDef = e, nl;
}
var rl = {}, N0;
function w$() {
  if (N0) return rl;
  N0 = 1, Object.defineProperty(rl, "__esModule", { value: !0 }), rl.parseEffectsDef = void 0;
  const t = /* @__PURE__ */ vt();
  function e(n, a) {
    return a.effectStrategy === "input" ? (0, t.parseDef)(n.schema._def, a) : {};
  }
  return rl.parseEffectsDef = e, rl;
}
var al = {}, k0;
function v$() {
  if (k0) return al;
  k0 = 1, Object.defineProperty(al, "__esModule", { value: !0 }), al.parseEnumDef = void 0;
  function t(e) {
    return {
      type: "string",
      enum: Array.from(e.values)
    };
  }
  return al.parseEnumDef = t, al;
}
var il = {}, F0;
function S$() {
  if (F0) return il;
  F0 = 1, Object.defineProperty(il, "__esModule", { value: !0 }), il.parseIntersectionDef = void 0;
  const t = /* @__PURE__ */ vt(), e = (a) => "type" in a && a.type === "string" ? !1 : "allOf" in a;
  function n(a, r) {
    const i = [
      (0, t.parseDef)(a.left._def, {
        ...r,
        currentPath: [...r.currentPath, "allOf", "0"]
      }),
      (0, t.parseDef)(a.right._def, {
        ...r,
        currentPath: [...r.currentPath, "allOf", "1"]
      })
    ].filter((l) => !!l);
    let s = r.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
    const o = [];
    return i.forEach((l) => {
      if (e(l))
        o.push(...l.allOf), l.unevaluatedProperties === void 0 && (s = void 0);
      else {
        let f = l;
        if ("additionalProperties" in l && l.additionalProperties === !1) {
          const { additionalProperties: u, ...c } = l;
          f = c;
        } else
          s = void 0;
        o.push(f);
      }
    }), o.length ? {
      allOf: o,
      ...s
    } : void 0;
  }
  return il.parseIntersectionDef = n, il;
}
var sl = {}, D0;
function O$() {
  if (D0) return sl;
  D0 = 1, Object.defineProperty(sl, "__esModule", { value: !0 }), sl.parseLiteralDef = void 0;
  function t(e, n) {
    const a = typeof e.value;
    return a !== "bigint" && a !== "number" && a !== "boolean" && a !== "string" ? {
      type: Array.isArray(e.value) ? "array" : "object"
    } : n.target === "openApi3" ? {
      type: a === "bigint" ? "integer" : a,
      enum: [e.value]
    } : {
      type: a === "bigint" ? "integer" : a,
      const: e.value
    };
  }
  return sl.parseLiteralDef = t, sl;
}
var ol = {}, ul = {}, ub = {}, q0;
function G_() {
  return q0 || (q0 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.parseStringDef = t.zodPatterns = void 0;
    const e = /* @__PURE__ */ ou();
    let n;
    t.zodPatterns = {
      /**
       * `c` was changed to `[cC]` to replicate /i flag
       */
      cuid: /^[cC][^\s-]{8,}$/,
      cuid2: /^[0-9a-z]+$/,
      ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
      /**
       * `a-z` was added to replicate /i flag
       */
      email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
      /**
       * Constructed a valid Unicode RegExp
       *
       * Lazily instantiate since this type of regex isn't supported
       * in all envs (e.g. React Native).
       *
       * See:
       * https://github.com/colinhacks/zod/issues/2433
       * Fix in Zod:
       * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
       */
      emoji: () => (n === void 0 && (n = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), n),
      /**
       * Unused
       */
      uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
      /**
       * Unused
       */
      ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
      /**
       * Unused
       */
      ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
      nanoid: /^[a-zA-Z0-9_-]{21}$/,
      jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };
    function a(u, c) {
      const h = {
        type: "string"
      };
      if (u.checks)
        for (const p of u.checks)
          switch (p.kind) {
            case "min":
              (0, e.setResponseValueAndErrors)(h, "minLength", typeof h.minLength == "number" ? Math.max(h.minLength, p.value) : p.value, p.message, c);
              break;
            case "max":
              (0, e.setResponseValueAndErrors)(h, "maxLength", typeof h.maxLength == "number" ? Math.min(h.maxLength, p.value) : p.value, p.message, c);
              break;
            case "email":
              switch (c.emailStrategy) {
                case "format:email":
                  o(h, "email", p.message, c);
                  break;
                case "format:idn-email":
                  o(h, "idn-email", p.message, c);
                  break;
                case "pattern:zod":
                  l(h, t.zodPatterns.email, p.message, c);
                  break;
              }
              break;
            case "url":
              o(h, "uri", p.message, c);
              break;
            case "uuid":
              o(h, "uuid", p.message, c);
              break;
            case "regex":
              l(h, p.regex, p.message, c);
              break;
            case "cuid":
              l(h, t.zodPatterns.cuid, p.message, c);
              break;
            case "cuid2":
              l(h, t.zodPatterns.cuid2, p.message, c);
              break;
            case "startsWith":
              l(h, RegExp(`^${r(p.value, c)}`), p.message, c);
              break;
            case "endsWith":
              l(h, RegExp(`${r(p.value, c)}$`), p.message, c);
              break;
            case "datetime":
              o(h, "date-time", p.message, c);
              break;
            case "date":
              o(h, "date", p.message, c);
              break;
            case "time":
              o(h, "time", p.message, c);
              break;
            case "duration":
              o(h, "duration", p.message, c);
              break;
            case "length":
              (0, e.setResponseValueAndErrors)(h, "minLength", typeof h.minLength == "number" ? Math.max(h.minLength, p.value) : p.value, p.message, c), (0, e.setResponseValueAndErrors)(h, "maxLength", typeof h.maxLength == "number" ? Math.min(h.maxLength, p.value) : p.value, p.message, c);
              break;
            case "includes": {
              l(h, RegExp(r(p.value, c)), p.message, c);
              break;
            }
            case "ip": {
              p.version !== "v6" && o(h, "ipv4", p.message, c), p.version !== "v4" && o(h, "ipv6", p.message, c);
              break;
            }
            case "base64url":
              l(h, t.zodPatterns.base64url, p.message, c);
              break;
            case "jwt":
              l(h, t.zodPatterns.jwt, p.message, c);
              break;
            case "cidr": {
              p.version !== "v6" && l(h, t.zodPatterns.ipv4Cidr, p.message, c), p.version !== "v4" && l(h, t.zodPatterns.ipv6Cidr, p.message, c);
              break;
            }
            case "emoji":
              l(h, t.zodPatterns.emoji(), p.message, c);
              break;
            case "ulid": {
              l(h, t.zodPatterns.ulid, p.message, c);
              break;
            }
            case "base64": {
              switch (c.base64Strategy) {
                case "format:binary": {
                  o(h, "binary", p.message, c);
                  break;
                }
                case "contentEncoding:base64": {
                  (0, e.setResponseValueAndErrors)(h, "contentEncoding", "base64", p.message, c);
                  break;
                }
                case "pattern:zod": {
                  l(h, t.zodPatterns.base64, p.message, c);
                  break;
                }
              }
              break;
            }
            case "nanoid":
              l(h, t.zodPatterns.nanoid, p.message, c);
          }
      return h;
    }
    t.parseStringDef = a;
    function r(u, c) {
      return c.patternStrategy === "escape" ? s(u) : u;
    }
    const i = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
    function s(u) {
      let c = "";
      for (let h = 0; h < u.length; h++)
        i.has(u[h]) || (c += "\\"), c += u[h];
      return c;
    }
    function o(u, c, h, p) {
      u.format || u.anyOf?.some((d) => d.format) ? (u.anyOf || (u.anyOf = []), u.format && (u.anyOf.push({
        format: u.format,
        ...u.errorMessage && p.errorMessages && {
          errorMessage: { format: u.errorMessage.format }
        }
      }), delete u.format, u.errorMessage && (delete u.errorMessage.format, Object.keys(u.errorMessage).length === 0 && delete u.errorMessage)), u.anyOf.push({
        format: c,
        ...h && p.errorMessages && { errorMessage: { format: h } }
      })) : (0, e.setResponseValueAndErrors)(u, "format", c, h, p);
    }
    function l(u, c, h, p) {
      u.pattern || u.allOf?.some((d) => d.pattern) ? (u.allOf || (u.allOf = []), u.pattern && (u.allOf.push({
        pattern: u.pattern,
        ...u.errorMessage && p.errorMessages && {
          errorMessage: { pattern: u.errorMessage.pattern }
        }
      }), delete u.pattern, u.errorMessage && (delete u.errorMessage.pattern, Object.keys(u.errorMessage).length === 0 && delete u.errorMessage)), u.allOf.push({
        pattern: f(c, p),
        ...h && p.errorMessages && { errorMessage: { pattern: h } }
      })) : (0, e.setResponseValueAndErrors)(u, "pattern", f(c, p), h, p);
    }
    function f(u, c) {
      if (!c.applyRegexFlags || !u.flags)
        return u.source;
      const h = {
        i: u.flags.includes("i"),
        m: u.flags.includes("m"),
        s: u.flags.includes("s")
        // `.` matches newlines
      }, p = h.i ? u.source.toLowerCase() : u.source;
      let d = "", m = !1, b = !1, g = !1;
      for (let _ = 0; _ < p.length; _++) {
        if (m) {
          d += p[_], m = !1;
          continue;
        }
        if (h.i) {
          if (b) {
            if (p[_].match(/[a-z]/)) {
              g ? (d += p[_], d += `${p[_ - 2]}-${p[_]}`.toUpperCase(), g = !1) : p[_ + 1] === "-" && p[_ + 2]?.match(/[a-z]/) ? (d += p[_], g = !0) : d += `${p[_]}${p[_].toUpperCase()}`;
              continue;
            }
          } else if (p[_].match(/[a-z]/)) {
            d += `[${p[_]}${p[_].toUpperCase()}]`;
            continue;
          }
        }
        if (h.m) {
          if (p[_] === "^") {
            d += `(^|(?<=[\r
]))`;
            continue;
          } else if (p[_] === "$") {
            d += `($|(?=[\r
]))`;
            continue;
          }
        }
        if (h.s && p[_] === ".") {
          d += b ? `${p[_]}\r
` : `[${p[_]}\r
]`;
          continue;
        }
        d += p[_], p[_] === "\\" ? m = !0 : b && p[_] === "]" ? b = !1 : !b && p[_] === "[" && (b = !0);
      }
      try {
        new RegExp(d);
      } catch {
        return console.warn(`Could not convert regex pattern at ${c.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), u.source;
      }
      return d;
    }
  }(ub)), ub;
}
var J0;
function W_() {
  if (J0) return ul;
  J0 = 1, Object.defineProperty(ul, "__esModule", { value: !0 }), ul.parseRecordDef = void 0;
  const t = /* @__PURE__ */ H(), e = /* @__PURE__ */ vt(), n = /* @__PURE__ */ G_(), a = /* @__PURE__ */ H_();
  function r(i, s) {
    if (s.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."), s.target === "openApi3" && i.keyType?._def.typeName === t.ZodFirstPartyTypeKind.ZodEnum)
      return {
        type: "object",
        required: i.keyType._def.values,
        properties: i.keyType._def.values.reduce((l, f) => ({
          ...l,
          [f]: (0, e.parseDef)(i.valueType._def, {
            ...s,
            currentPath: [...s.currentPath, "properties", f]
          }) ?? {}
        }), {}),
        additionalProperties: s.rejectedAdditionalProperties
      };
    const o = {
      type: "object",
      additionalProperties: (0, e.parseDef)(i.valueType._def, {
        ...s,
        currentPath: [...s.currentPath, "additionalProperties"]
      }) ?? s.allowedAdditionalProperties
    };
    if (s.target === "openApi3")
      return o;
    if (i.keyType?._def.typeName === t.ZodFirstPartyTypeKind.ZodString && i.keyType._def.checks?.length) {
      const { type: l, ...f } = (0, n.parseStringDef)(i.keyType._def, s);
      return {
        ...o,
        propertyNames: f
      };
    } else {
      if (i.keyType?._def.typeName === t.ZodFirstPartyTypeKind.ZodEnum)
        return {
          ...o,
          propertyNames: {
            enum: i.keyType._def.values
          }
        };
      if (i.keyType?._def.typeName === t.ZodFirstPartyTypeKind.ZodBranded && i.keyType._def.type._def.typeName === t.ZodFirstPartyTypeKind.ZodString && i.keyType._def.type._def.checks?.length) {
        const { type: l, ...f } = (0, a.parseBrandedDef)(i.keyType._def, s);
        return {
          ...o,
          propertyNames: f
        };
      }
    }
    return o;
  }
  return ul.parseRecordDef = r, ul;
}
var L0;
function j$() {
  if (L0) return ol;
  L0 = 1, Object.defineProperty(ol, "__esModule", { value: !0 }), ol.parseMapDef = void 0;
  const t = /* @__PURE__ */ vt(), e = /* @__PURE__ */ W_();
  function n(a, r) {
    if (r.mapStrategy === "record")
      return (0, e.parseRecordDef)(a, r);
    const i = (0, t.parseDef)(a.keyType._def, {
      ...r,
      currentPath: [...r.currentPath, "items", "items", "0"]
    }) || {}, s = (0, t.parseDef)(a.valueType._def, {
      ...r,
      currentPath: [...r.currentPath, "items", "items", "1"]
    }) || {};
    return {
      type: "array",
      maxItems: 125,
      items: {
        type: "array",
        items: [i, s],
        minItems: 2,
        maxItems: 2
      }
    };
  }
  return ol.parseMapDef = n, ol;
}
var cl = {}, U0;
function P$() {
  if (U0) return cl;
  U0 = 1, Object.defineProperty(cl, "__esModule", { value: !0 }), cl.parseNativeEnumDef = void 0;
  function t(e) {
    const n = e.values, r = Object.keys(e.values).filter((s) => typeof n[n[s]] != "number").map((s) => n[s]), i = Array.from(new Set(r.map((s) => typeof s)));
    return {
      type: i.length === 1 ? i[0] === "string" ? "string" : "number" : ["string", "number"],
      enum: r
    };
  }
  return cl.parseNativeEnumDef = t, cl;
}
var ll = {}, B0;
function R$() {
  if (B0) return ll;
  B0 = 1, Object.defineProperty(ll, "__esModule", { value: !0 }), ll.parseNeverDef = void 0;
  function t() {
    return {
      not: {}
    };
  }
  return ll.parseNeverDef = t, ll;
}
var dl = {}, x0;
function C$() {
  if (x0) return dl;
  x0 = 1, Object.defineProperty(dl, "__esModule", { value: !0 }), dl.parseNullDef = void 0;
  function t(e) {
    return e.target === "openApi3" ? {
      enum: ["null"],
      nullable: !0
    } : {
      type: "null"
    };
  }
  return dl.parseNullDef = t, dl;
}
var fl = {}, cb = {}, V0;
function X_() {
  return V0 || (V0 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.parseUnionDef = t.primitiveMappings = void 0;
    const e = /* @__PURE__ */ vt();
    t.primitiveMappings = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    function n(r, i) {
      if (i.target === "openApi3")
        return a(r, i);
      const s = r.options instanceof Map ? Array.from(r.options.values()) : r.options;
      if (s.every((o) => o._def.typeName in t.primitiveMappings && (!o._def.checks || !o._def.checks.length))) {
        const o = s.reduce((l, f) => {
          const u = t.primitiveMappings[f._def.typeName];
          return u && !l.includes(u) ? [...l, u] : l;
        }, []);
        return {
          type: o.length > 1 ? o : o[0]
        };
      } else if (s.every((o) => o._def.typeName === "ZodLiteral" && !o.description)) {
        const o = s.reduce((l, f) => {
          const u = typeof f._def.value;
          switch (u) {
            case "string":
            case "number":
            case "boolean":
              return [...l, u];
            case "bigint":
              return [...l, "integer"];
            case "object":
              if (f._def.value === null)
                return [...l, "null"];
            case "symbol":
            case "undefined":
            case "function":
            default:
              return l;
          }
        }, []);
        if (o.length === s.length) {
          const l = o.filter((f, u, c) => c.indexOf(f) === u);
          return {
            type: l.length > 1 ? l : l[0],
            enum: s.reduce((f, u) => f.includes(u._def.value) ? f : [...f, u._def.value], [])
          };
        }
      } else if (s.every((o) => o._def.typeName === "ZodEnum"))
        return {
          type: "string",
          enum: s.reduce((o, l) => [
            ...o,
            ...l._def.values.filter((f) => !o.includes(f))
          ], [])
        };
      return a(r, i);
    }
    t.parseUnionDef = n;
    const a = (r, i) => {
      const s = (r.options instanceof Map ? Array.from(r.options.values()) : r.options).map((o, l) => (0, e.parseDef)(o._def, {
        ...i,
        currentPath: [...i.currentPath, "anyOf", `${l}`]
      })).filter((o) => !!o && (!i.strictUnions || typeof o == "object" && Object.keys(o).length > 0));
      return s.length ? { anyOf: s } : void 0;
    };
  }(cb)), cb;
}
var z0;
function T$() {
  if (z0) return fl;
  z0 = 1, Object.defineProperty(fl, "__esModule", { value: !0 }), fl.parseNullableDef = void 0;
  const t = /* @__PURE__ */ vt(), e = /* @__PURE__ */ X_();
  function n(a, r) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(a.innerType._def.typeName) && (!a.innerType._def.checks || !a.innerType._def.checks.length))
      return r.target === "openApi3" ? {
        type: e.primitiveMappings[a.innerType._def.typeName],
        nullable: !0
      } : {
        type: [
          e.primitiveMappings[a.innerType._def.typeName],
          "null"
        ]
      };
    if (r.target === "openApi3") {
      const s = (0, t.parseDef)(a.innerType._def, {
        ...r,
        currentPath: [...r.currentPath]
      });
      return s && "$ref" in s ? { allOf: [s], nullable: !0 } : s && { ...s, nullable: !0 };
    }
    const i = (0, t.parseDef)(a.innerType._def, {
      ...r,
      currentPath: [...r.currentPath, "anyOf", "0"]
    });
    return i && { anyOf: [i, { type: "null" }] };
  }
  return fl.parseNullableDef = n, fl;
}
var hl = {}, Z0;
function $$() {
  if (Z0) return hl;
  Z0 = 1, Object.defineProperty(hl, "__esModule", { value: !0 }), hl.parseNumberDef = void 0;
  const t = /* @__PURE__ */ ou();
  function e(n, a) {
    const r = {
      type: "number"
    };
    if (!n.checks)
      return r;
    for (const i of n.checks)
      switch (i.kind) {
        case "int":
          r.type = "integer", (0, t.addErrorMessage)(r, "type", i.message, a);
          break;
        case "min":
          a.target === "jsonSchema7" ? i.inclusive ? (0, t.setResponseValueAndErrors)(r, "minimum", i.value, i.message, a) : (0, t.setResponseValueAndErrors)(r, "exclusiveMinimum", i.value, i.message, a) : (i.inclusive || (r.exclusiveMinimum = !0), (0, t.setResponseValueAndErrors)(r, "minimum", i.value, i.message, a));
          break;
        case "max":
          a.target === "jsonSchema7" ? i.inclusive ? (0, t.setResponseValueAndErrors)(r, "maximum", i.value, i.message, a) : (0, t.setResponseValueAndErrors)(r, "exclusiveMaximum", i.value, i.message, a) : (i.inclusive || (r.exclusiveMaximum = !0), (0, t.setResponseValueAndErrors)(r, "maximum", i.value, i.message, a));
          break;
        case "multipleOf":
          (0, t.setResponseValueAndErrors)(r, "multipleOf", i.value, i.message, a);
          break;
      }
    return r;
  }
  return hl.parseNumberDef = e, hl;
}
var pl = {}, K0;
function M$() {
  if (K0) return pl;
  K0 = 1, Object.defineProperty(pl, "__esModule", { value: !0 }), pl.parseObjectDef = void 0;
  const t = /* @__PURE__ */ H(), e = /* @__PURE__ */ vt();
  function n(i, s) {
    const o = s.target === "openAi", l = {
      type: "object",
      properties: {}
    }, f = [], u = i.shape();
    for (const h in u) {
      let p = u[h];
      if (p === void 0 || p._def === void 0)
        continue;
      let d = r(p);
      d && o && (p instanceof t.ZodOptional && (p = p._def.innerType), p.isNullable() || (p = p.nullable()), d = !1);
      const m = (0, e.parseDef)(p._def, {
        ...s,
        currentPath: [...s.currentPath, "properties", h],
        propertyPath: [...s.currentPath, "properties", h]
      });
      m !== void 0 && (l.properties[h] = m, d || f.push(h));
    }
    f.length && (l.required = f);
    const c = a(i, s);
    return c !== void 0 && (l.additionalProperties = c), l;
  }
  pl.parseObjectDef = n;
  function a(i, s) {
    if (i.catchall._def.typeName !== "ZodNever")
      return (0, e.parseDef)(i.catchall._def, {
        ...s,
        currentPath: [...s.currentPath, "additionalProperties"]
      });
    switch (i.unknownKeys) {
      case "passthrough":
        return s.allowedAdditionalProperties;
      case "strict":
        return s.rejectedAdditionalProperties;
      case "strip":
        return s.removeAdditionalStrategy === "strict" ? s.allowedAdditionalProperties : s.rejectedAdditionalProperties;
    }
  }
  function r(i) {
    try {
      return i.isOptional();
    } catch {
      return !0;
    }
  }
  return pl;
}
var ml = {}, H0;
function A$() {
  if (H0) return ml;
  H0 = 1, Object.defineProperty(ml, "__esModule", { value: !0 }), ml.parseOptionalDef = void 0;
  const t = /* @__PURE__ */ vt(), e = (n, a) => {
    if (a.currentPath.toString() === a.propertyPath?.toString())
      return (0, t.parseDef)(n.innerType._def, a);
    const r = (0, t.parseDef)(n.innerType._def, {
      ...a,
      currentPath: [...a.currentPath, "anyOf", "1"]
    });
    return r ? {
      anyOf: [
        {
          not: {}
        },
        r
      ]
    } : {};
  };
  return ml.parseOptionalDef = e, ml;
}
var bl = {}, G0;
function E$() {
  if (G0) return bl;
  G0 = 1, Object.defineProperty(bl, "__esModule", { value: !0 }), bl.parsePipelineDef = void 0;
  const t = /* @__PURE__ */ vt(), e = (n, a) => {
    if (a.pipeStrategy === "input")
      return (0, t.parseDef)(n.in._def, a);
    if (a.pipeStrategy === "output")
      return (0, t.parseDef)(n.out._def, a);
    const r = (0, t.parseDef)(n.in._def, {
      ...a,
      currentPath: [...a.currentPath, "allOf", "0"]
    }), i = (0, t.parseDef)(n.out._def, {
      ...a,
      currentPath: [...a.currentPath, "allOf", r ? "1" : "0"]
    });
    return {
      allOf: [r, i].filter((s) => s !== void 0)
    };
  };
  return bl.parsePipelineDef = e, bl;
}
var gl = {}, W0;
function I$() {
  if (W0) return gl;
  W0 = 1, Object.defineProperty(gl, "__esModule", { value: !0 }), gl.parsePromiseDef = void 0;
  const t = /* @__PURE__ */ vt();
  function e(n, a) {
    return (0, t.parseDef)(n.type._def, a);
  }
  return gl.parsePromiseDef = e, gl;
}
var _l = {}, X0;
function N$() {
  if (X0) return _l;
  X0 = 1, Object.defineProperty(_l, "__esModule", { value: !0 }), _l.parseSetDef = void 0;
  const t = /* @__PURE__ */ ou(), e = /* @__PURE__ */ vt();
  function n(a, r) {
    const s = {
      type: "array",
      uniqueItems: !0,
      items: (0, e.parseDef)(a.valueType._def, {
        ...r,
        currentPath: [...r.currentPath, "items"]
      })
    };
    return a.minSize && (0, t.setResponseValueAndErrors)(s, "minItems", a.minSize.value, a.minSize.message, r), a.maxSize && (0, t.setResponseValueAndErrors)(s, "maxItems", a.maxSize.value, a.maxSize.message, r), s;
  }
  return _l.parseSetDef = n, _l;
}
var yl = {}, Q0;
function k$() {
  if (Q0) return yl;
  Q0 = 1, Object.defineProperty(yl, "__esModule", { value: !0 }), yl.parseTupleDef = void 0;
  const t = /* @__PURE__ */ vt();
  function e(n, a) {
    return n.rest ? {
      type: "array",
      minItems: n.items.length,
      items: n.items.map((r, i) => (0, t.parseDef)(r._def, {
        ...a,
        currentPath: [...a.currentPath, "items", `${i}`]
      })).reduce((r, i) => i === void 0 ? r : [...r, i], []),
      additionalItems: (0, t.parseDef)(n.rest._def, {
        ...a,
        currentPath: [...a.currentPath, "additionalItems"]
      })
    } : {
      type: "array",
      minItems: n.items.length,
      maxItems: n.items.length,
      items: n.items.map((r, i) => (0, t.parseDef)(r._def, {
        ...a,
        currentPath: [...a.currentPath, "items", `${i}`]
      })).reduce((r, i) => i === void 0 ? r : [...r, i], [])
    };
  }
  return yl.parseTupleDef = e, yl;
}
var wl = {}, Y0;
function F$() {
  if (Y0) return wl;
  Y0 = 1, Object.defineProperty(wl, "__esModule", { value: !0 }), wl.parseUndefinedDef = void 0;
  function t() {
    return {
      not: {}
    };
  }
  return wl.parseUndefinedDef = t, wl;
}
var vl = {}, ej;
function D$() {
  if (ej) return vl;
  ej = 1, Object.defineProperty(vl, "__esModule", { value: !0 }), vl.parseUnknownDef = void 0;
  function t() {
    return {};
  }
  return vl.parseUnknownDef = t, vl;
}
var Sl = {}, tj;
function q$() {
  if (tj) return Sl;
  tj = 1, Object.defineProperty(Sl, "__esModule", { value: !0 }), Sl.parseReadonlyDef = void 0;
  const t = /* @__PURE__ */ vt(), e = (n, a) => (0, t.parseDef)(n.innerType._def, a);
  return Sl.parseReadonlyDef = e, Sl;
}
var nj;
function J$() {
  if (nj) return Hc;
  nj = 1, Object.defineProperty(Hc, "__esModule", { value: !0 }), Hc.selectParser = void 0;
  const t = /* @__PURE__ */ H(), e = /* @__PURE__ */ h$(), n = /* @__PURE__ */ p$(), a = /* @__PURE__ */ m$(), r = /* @__PURE__ */ b$(), i = /* @__PURE__ */ H_(), s = /* @__PURE__ */ g$(), o = /* @__PURE__ */ _$(), l = /* @__PURE__ */ y$(), f = /* @__PURE__ */ w$(), u = /* @__PURE__ */ v$(), c = /* @__PURE__ */ S$(), h = /* @__PURE__ */ O$(), p = /* @__PURE__ */ j$(), d = /* @__PURE__ */ P$(), m = /* @__PURE__ */ R$(), b = /* @__PURE__ */ C$(), g = /* @__PURE__ */ T$(), _ = /* @__PURE__ */ $$(), P = /* @__PURE__ */ M$(), C = /* @__PURE__ */ A$(), R = /* @__PURE__ */ E$(), T = /* @__PURE__ */ I$(), O = /* @__PURE__ */ W_(), A = /* @__PURE__ */ N$(), M = /* @__PURE__ */ G_(), I = /* @__PURE__ */ k$(), N = /* @__PURE__ */ F$(), w = /* @__PURE__ */ X_(), k = /* @__PURE__ */ D$(), L = /* @__PURE__ */ q$(), B = (V, ce, ie) => {
    switch (ce) {
      case t.ZodFirstPartyTypeKind.ZodString:
        return (0, M.parseStringDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodNumber:
        return (0, _.parseNumberDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodObject:
        return (0, P.parseObjectDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodBigInt:
        return (0, a.parseBigintDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodBoolean:
        return (0, r.parseBooleanDef)();
      case t.ZodFirstPartyTypeKind.ZodDate:
        return (0, o.parseDateDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodUndefined:
        return (0, N.parseUndefinedDef)();
      case t.ZodFirstPartyTypeKind.ZodNull:
        return (0, b.parseNullDef)(ie);
      case t.ZodFirstPartyTypeKind.ZodArray:
        return (0, n.parseArrayDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodUnion:
      case t.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
        return (0, w.parseUnionDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodIntersection:
        return (0, c.parseIntersectionDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodTuple:
        return (0, I.parseTupleDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodRecord:
        return (0, O.parseRecordDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodLiteral:
        return (0, h.parseLiteralDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodEnum:
        return (0, u.parseEnumDef)(V);
      case t.ZodFirstPartyTypeKind.ZodNativeEnum:
        return (0, d.parseNativeEnumDef)(V);
      case t.ZodFirstPartyTypeKind.ZodNullable:
        return (0, g.parseNullableDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodOptional:
        return (0, C.parseOptionalDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodMap:
        return (0, p.parseMapDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodSet:
        return (0, A.parseSetDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodLazy:
        return () => V.getter()._def;
      case t.ZodFirstPartyTypeKind.ZodPromise:
        return (0, T.parsePromiseDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodNaN:
      case t.ZodFirstPartyTypeKind.ZodNever:
        return (0, m.parseNeverDef)();
      case t.ZodFirstPartyTypeKind.ZodEffects:
        return (0, f.parseEffectsDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodAny:
        return (0, e.parseAnyDef)();
      case t.ZodFirstPartyTypeKind.ZodUnknown:
        return (0, k.parseUnknownDef)();
      case t.ZodFirstPartyTypeKind.ZodDefault:
        return (0, l.parseDefaultDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodBranded:
        return (0, i.parseBrandedDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodReadonly:
        return (0, L.parseReadonlyDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodCatch:
        return (0, s.parseCatchDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodPipeline:
        return (0, R.parsePipelineDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodFunction:
      case t.ZodFirstPartyTypeKind.ZodVoid:
      case t.ZodFirstPartyTypeKind.ZodSymbol:
        return;
      default:
        return /* @__PURE__ */ ((ut) => {
        })();
    }
  };
  return Hc.selectParser = B, Hc;
}
var rj;
function vt() {
  if (rj) return Kc;
  rj = 1, Object.defineProperty(Kc, "__esModule", { value: !0 }), Kc.parseDef = void 0;
  const t = /* @__PURE__ */ K_(), e = /* @__PURE__ */ J$();
  function n(s, o, l = !1) {
    const f = o.seen.get(s);
    if (o.override) {
      const p = o.override?.(s, o, f, l);
      if (p !== t.ignoreOverride)
        return p;
    }
    if (f && !l) {
      const p = a(f, o);
      if (p !== void 0)
        return p;
    }
    const u = { def: s, path: o.currentPath, jsonSchema: void 0 };
    o.seen.set(s, u);
    const c = (0, e.selectParser)(s, s.typeName, o), h = typeof c == "function" ? n(c(), o) : c;
    if (h && i(s, o, h), o.postProcess) {
      const p = o.postProcess(h, s, o);
      return u.jsonSchema = h, p;
    }
    return u.jsonSchema = h, h;
  }
  Kc.parseDef = n;
  const a = (s, o) => {
    switch (o.$refStrategy) {
      case "root":
        return { $ref: s.path.join("/") };
      case "relative":
        return { $ref: r(o.currentPath, s.path) };
      case "none":
      case "seen":
        return s.path.length < o.currentPath.length && s.path.every((l, f) => o.currentPath[f] === l) ? (console.warn(`Recursive reference detected at ${o.currentPath.join("/")}! Defaulting to any`), {}) : o.$refStrategy === "seen" ? {} : void 0;
    }
  }, r = (s, o) => {
    let l = 0;
    for (; l < s.length && l < o.length && s[l] === o[l]; l++)
      ;
    return [(s.length - l).toString(), ...o.slice(l)].join("/");
  }, i = (s, o, l) => (s.description && (l.description = s.description, o.markdownDescription && (l.markdownDescription = s.description)), l);
  return Kc;
}
var lb = {}, aj;
function yL() {
  return aj || (aj = 1, Object.defineProperty(lb, "__esModule", { value: !0 })), lb;
}
var Ol = {}, ij;
function sj() {
  if (ij) return Ol;
  ij = 1, Object.defineProperty(Ol, "__esModule", { value: !0 }), Ol.zodToJsonSchema = void 0;
  const t = /* @__PURE__ */ vt(), e = /* @__PURE__ */ f$(), n = (a, r) => {
    const i = (0, e.getRefs)(r), s = typeof r == "object" && r.definitions ? Object.entries(r.definitions).reduce((c, [h, p]) => ({
      ...c,
      [h]: (0, t.parseDef)(p._def, {
        ...i,
        currentPath: [...i.basePath, i.definitionPath, h]
      }, !0) ?? {}
    }), {}) : void 0, o = typeof r == "string" ? r : r?.nameStrategy === "title" ? void 0 : r?.name, l = (0, t.parseDef)(a._def, o === void 0 ? i : {
      ...i,
      currentPath: [...i.basePath, i.definitionPath, o]
    }, !1) ?? {}, f = typeof r == "object" && r.name !== void 0 && r.nameStrategy === "title" ? r.name : void 0;
    f !== void 0 && (l.title = f);
    const u = o === void 0 ? s ? {
      ...l,
      [i.definitionPath]: s
    } : l : {
      $ref: [
        ...i.$refStrategy === "relative" ? [] : i.basePath,
        i.definitionPath,
        o
      ].join("/"),
      [i.definitionPath]: {
        ...s,
        [o]: l
      }
    };
    return i.target === "jsonSchema7" ? u.$schema = "http://json-schema.org/draft-07/schema#" : (i.target === "jsonSchema2019-09" || i.target === "openAi") && (u.$schema = "https://json-schema.org/draft/2019-09/schema#"), i.target === "openAi" && ("anyOf" in u || "oneOf" in u || "allOf" in u || "type" in u && Array.isArray(u.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."), u;
  };
  return Ol.zodToJsonSchema = n, Ol;
}
var oj;
function wL() {
  return oj || (oj = 1, function(t) {
    var e = No && No.__createBinding || (Object.create ? function(r, i, s, o) {
      o === void 0 && (o = s);
      var l = Object.getOwnPropertyDescriptor(i, s);
      (!l || ("get" in l ? !i.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return i[s];
      } }), Object.defineProperty(r, o, l);
    } : function(r, i, s, o) {
      o === void 0 && (o = s), r[o] = i[s];
    }), n = No && No.__exportStar || function(r, i) {
      for (var s in r) s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && e(i, r, s);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(/* @__PURE__ */ K_(), t), n(/* @__PURE__ */ f$(), t), n(/* @__PURE__ */ ou(), t), n(/* @__PURE__ */ vt(), t), n(/* @__PURE__ */ yL(), t), n(/* @__PURE__ */ h$(), t), n(/* @__PURE__ */ p$(), t), n(/* @__PURE__ */ m$(), t), n(/* @__PURE__ */ b$(), t), n(/* @__PURE__ */ H_(), t), n(/* @__PURE__ */ g$(), t), n(/* @__PURE__ */ _$(), t), n(/* @__PURE__ */ y$(), t), n(/* @__PURE__ */ w$(), t), n(/* @__PURE__ */ v$(), t), n(/* @__PURE__ */ S$(), t), n(/* @__PURE__ */ O$(), t), n(/* @__PURE__ */ j$(), t), n(/* @__PURE__ */ P$(), t), n(/* @__PURE__ */ R$(), t), n(/* @__PURE__ */ C$(), t), n(/* @__PURE__ */ T$(), t), n(/* @__PURE__ */ $$(), t), n(/* @__PURE__ */ M$(), t), n(/* @__PURE__ */ A$(), t), n(/* @__PURE__ */ E$(), t), n(/* @__PURE__ */ I$(), t), n(/* @__PURE__ */ q$(), t), n(/* @__PURE__ */ W_(), t), n(/* @__PURE__ */ N$(), t), n(/* @__PURE__ */ G_(), t), n(/* @__PURE__ */ k$(), t), n(/* @__PURE__ */ F$(), t), n(/* @__PURE__ */ X_(), t), n(/* @__PURE__ */ D$(), t), n(/* @__PURE__ */ J$(), t), n(/* @__PURE__ */ sj(), t);
    const a = /* @__PURE__ */ sj();
    t.default = a.zodToJsonSchema;
  }(No)), No;
}
var uj;
function vL() {
  if (uj) return vu;
  uj = 1, Object.defineProperty(vu, "__esModule", { value: !0 }), vu.transformToChatCompletionRequest = e, vu.convertToParsedChatCompletionResponse = n, vu.responseFormatFromZodObject = a;
  const t = /* @__PURE__ */ wL();
  function e(r) {
    const { responseFormat: i, ...s } = r, o = a(i);
    return {
      ...s,
      responseFormat: o
    };
  }
  function n(r, i) {
    if (r.choices === void 0 || r.choices.length === 0)
      return {
        ...r,
        choices: r.choices === void 0 ? void 0 : []
      };
    const s = [];
    for (const o of r.choices)
      o.message === null || typeof o.message > "u" ? s.push({ ...o, message: void 0 }) : o.message.content !== null && typeof o.message.content < "u" && !Array.isArray(o.message.content) && s.push({
        ...o,
        message: {
          ...o.message,
          parsed: i.safeParse(JSON.parse(o.message.content)).data
        }
      });
    return {
      ...r,
      choices: s
    };
  }
  function a(r) {
    return {
      type: "json_schema",
      jsonSchema: {
        name: "placeholderName",
        schemaDefinition: (0, t.zodToJsonSchema)(r),
        strict: !0
      }
    };
  }
  return vu;
}
var cj;
function SL() {
  if (cj) return zc;
  cj = 1, Object.defineProperty(zc, "__esModule", { value: !0 }), zc.Chat = void 0;
  const t = /* @__PURE__ */ gL(), e = /* @__PURE__ */ _L(), n = /* @__PURE__ */ Mn(), a = /* @__PURE__ */ Zn(), r = /* @__PURE__ */ vL();
  class i extends n.ClientSDK {
    // #region sdk-class-body
    /**
     * Chat Completion with the response parsed in the same format as the input requestFormat.
     *
     * @remarks
     * The response will be parsed back to the initial Zod object passed in the requestFormat field.
     */
    async parse(o, l) {
      const f = (0, r.transformToChatCompletionRequest)(o), u = await (0, a.unwrapAsync)((0, t.chatComplete)(this, f, l));
      return (0, r.convertToParsedChatCompletionResponse)(u, o.responseFormat);
    }
    /**
     * Stream chat completion with a parsed request input.
     *
     * @remarks
     * Unlike the .parse method, this method will return a stream of events containing the JSON response. It will not be parsed back to the initial Zod object.
     * If you need to parse the stream, see the examples/src/async_structured_outputs.ts file.
     */
    async parseStream(o, l) {
      const f = (0, r.transformToChatCompletionRequest)(o);
      return (0, a.unwrapAsync)((0, e.chatStream)(this, f, l));
    }
    // #endregion sdk-class-body
    /**
     * Chat Completion
     */
    async complete(o, l) {
      return (0, a.unwrapAsync)((0, t.chatComplete)(this, o, l));
    }
    /**
     * Stream chat completion
     *
     * @remarks
     * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
     */
    async stream(o, l) {
      return (0, a.unwrapAsync)((0, e.chatStream)(this, o, l));
    }
  }
  return zc.Chat = i, zc;
}
var jl = {}, Er = {}, lj;
function OL() {
  if (lj) return Er;
  lj = 1;
  var t = Er && Er.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Er && Er.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Er && Er.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Er, "__esModule", { value: !0 }), Er.classifiersModerate = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ An()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.ClassificationRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), C = (0, l.pathToFunc)("/v1/moderations")(), R = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, o.extractSecurity)(d._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, o.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "moderations_v1_moderations_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = d._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: C,
      headers: R,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, w = await d._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!w.ok)
      return [w, { status: "request-error", request: N }];
    const k = w.value, L = {
      HttpMeta: { Response: k, Request: N }
    }, [B] = await r.match(r.json(200, f.ClassificationResponse$inboundSchema), r.jsonErr(422, u.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(k, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: k }] : [B, { status: "complete", request: N, response: k }];
  }
  return Er;
}
var Ir = {}, dj;
function jL() {
  if (dj) return Ir;
  dj = 1;
  var t = Ir && Ir.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Ir && Ir.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Ir && Ir.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Ir, "__esModule", { value: !0 }), Ir.classifiersModerateChat = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ An()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.ChatModerationRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), C = (0, l.pathToFunc)("/v1/chat/moderations")(), R = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, o.extractSecurity)(d._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, o.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "moderations_chat_v1_chat_moderations_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = d._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: C,
      headers: R,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, w = await d._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!w.ok)
      return [w, { status: "request-error", request: N }];
    const k = w.value, L = {
      HttpMeta: { Response: k, Request: N }
    }, [B] = await r.match(r.json(200, f.ClassificationResponse$inboundSchema), r.jsonErr(422, u.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(k, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: k }] : [B, { status: "complete", request: N, response: k }];
  }
  return Ir;
}
var fj;
function PL() {
  if (fj) return jl;
  fj = 1, Object.defineProperty(jl, "__esModule", { value: !0 }), jl.Classifiers = void 0;
  const t = /* @__PURE__ */ OL(), e = /* @__PURE__ */ jL(), n = /* @__PURE__ */ Mn(), a = /* @__PURE__ */ Zn();
  class r extends n.ClientSDK {
    /**
     * Moderations
     */
    async moderate(s, o) {
      return (0, a.unwrapAsync)((0, t.classifiersModerate)(this, s, o));
    }
    /**
     * Moderations Chat
     */
    async moderateChat(s, o) {
      return (0, a.unwrapAsync)((0, e.classifiersModerateChat)(this, s, o));
    }
  }
  return jl.Classifiers = r, jl;
}
var Pl = {}, Nr = {}, hj;
function RL() {
  if (hj) return Nr;
  hj = 1;
  var t = Nr && Nr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Nr && Nr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Nr && Nr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Nr, "__esModule", { value: !0 }), Nr.embeddingsCreate = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ An()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.EmbeddingRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), C = (0, l.pathToFunc)("/v1/embeddings")(), R = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, o.extractSecurity)(d._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, o.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "embeddings_v1_embeddings_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = d._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: C,
      headers: R,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, w = await d._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!w.ok)
      return [w, { status: "request-error", request: N }];
    const k = w.value, L = {
      HttpMeta: { Response: k, Request: N }
    }, [B] = await r.match(r.json(200, f.EmbeddingResponse$inboundSchema), r.jsonErr(422, u.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(k, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: k }] : [B, { status: "complete", request: N, response: k }];
  }
  return Nr;
}
var pj;
function CL() {
  if (pj) return Pl;
  pj = 1, Object.defineProperty(Pl, "__esModule", { value: !0 }), Pl.Embeddings = void 0;
  const t = /* @__PURE__ */ RL(), e = /* @__PURE__ */ Mn(), n = /* @__PURE__ */ Zn();
  class a extends e.ClientSDK {
    /**
     * Embeddings
     *
     * @remarks
     * Embeddings
     */
    async create(i, s) {
      return (0, n.unwrapAsync)((0, t.embeddingsCreate)(this, i, s));
    }
  }
  return Pl.Embeddings = a, Pl;
}
var Rl = {}, kr = {}, mj;
function TL() {
  if (mj) return kr;
  mj = 1;
  var t = kr && kr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = kr && kr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = kr && kr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(kr, "__esModule", { value: !0 }), kr.filesDelete = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.FilesApiRoutesDeleteFileRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = {
      file_id: (0, a.encodeSimple)("file_id", _.file_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, l.pathToFunc)("/v1/files/{file_id}")(C), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "files_api_routes_delete_file",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "DELETE",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.DeleteFileOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return kr;
}
var Fr = {}, bj;
function $L() {
  if (bj) return Fr;
  bj = 1;
  var t = Fr && Fr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Fr && Fr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Fr && Fr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Fr, "__esModule", { value: !0 }), Fr.filesDownload = h;
  const a = n(/* @__PURE__ */ H()), r = /* @__PURE__ */ Ne(), i = n(/* @__PURE__ */ ke()), s = /* @__PURE__ */ X(), o = /* @__PURE__ */ Z(), l = /* @__PURE__ */ Fe(), f = /* @__PURE__ */ Ee(), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, o.safeParse)(m, (V) => u.FilesApiRoutesDownloadFileRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = {
      file_id: (0, r.encodeSimple)("file_id", _.file_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, f.pathToFunc)("/v1/files/{file_id}/content")(C), T = new Headers((0, s.compactMap)({
      Accept: "application/octet-stream"
    })), O = await (0, l.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, l.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "files_api_routes_download_file",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await i.match(i.stream(200, a.instanceof(ReadableStream)), i.fail("4XX"), i.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return Fr;
}
var Dr = {}, gj;
function ML() {
  if (gj) return Dr;
  gj = 1;
  var t = Dr && Dr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Dr && Dr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Dr && Dr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.filesGetSignedUrl = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (ce) => u.FilesApiRoutesGetSignedUrlRequest$outboundSchema.parse(ce), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = {
      file_id: (0, a.encodeSimple)("file_id", _.file_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, l.pathToFunc)("/v1/files/{file_id}/url")(C), T = (0, a.encodeFormQuery)({
      expiry: _.expiry
    }), O = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), A = await (0, o.extractSecurity)(d._options.apiKey), M = A == null ? {} : { apiKey: A }, I = (0, o.resolveGlobalSecurity)(M), N = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "files_api_routes_get_signed_url",
      oAuth2Scopes: [],
      resolvedSecurity: I,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, w = d._createRequest(N, {
      security: I,
      method: "GET",
      baseURL: b?.serverURL,
      path: R,
      headers: O,
      query: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!w.ok)
      return [w, { status: "invalid" }];
    const k = w.value, L = await d._do(k, {
      context: N,
      errorCodes: ["4XX", "5XX"],
      retryConfig: N.retryConfig,
      retryCodes: N.retryCodes
    });
    if (!L.ok)
      return [L, { status: "request-error", request: k }];
    const B = L.value, [V] = await r.match(r.json(200, f.FileSignedURL$inboundSchema), r.fail("4XX"), r.fail("5XX"))(B);
    return V.ok ? [V, { status: "complete", request: k, response: B }] : [V, { status: "complete", request: k, response: B }];
  }
  return Dr;
}
var qr = {}, _j;
function AL() {
  if (_j) return qr;
  _j = 1;
  var t = qr && qr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = qr && qr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = qr && qr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(qr, "__esModule", { value: !0 }), qr.filesList = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.FilesApiRoutesListFilesRequest$outboundSchema.optional().parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = (0, l.pathToFunc)("/v1/files")(), R = (0, a.encodeFormQuery)({
      page: _?.page,
      page_size: _?.page_size,
      purpose: _?.purpose,
      sample_type: _?.sample_type,
      search: _?.search,
      source: _?.source
    }), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "files_api_routes_list_files",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      query: R,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.ListFilesOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return qr;
}
var Jr = {}, yj;
function EL() {
  if (yj) return Jr;
  yj = 1;
  var t = Jr && Jr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Jr && Jr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Jr && Jr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Jr, "__esModule", { value: !0 }), Jr.filesRetrieve = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.FilesApiRoutesRetrieveFileRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = {
      file_id: (0, a.encodeSimple)("file_id", _.file_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, l.pathToFunc)("/v1/files/{file_id}")(C), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "files_api_routes_retrieve_file",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.RetrieveFileOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return Jr;
}
var Lr = {}, Qf = {}, wj;
function IL() {
  if (wj) return Qf;
  wj = 1, Object.defineProperty(Qf, "__esModule", { value: !0 }), Qf.isReadableStream = t;
  function t(e) {
    if (typeof e != "object" || e === null)
      return !1;
    const n = e;
    return typeof n.getReader == "function" && typeof n.cancel == "function" && typeof n.tee == "function";
  }
  return Qf;
}
var vj;
function NL() {
  if (vj) return Lr;
  vj = 1;
  var t = Lr && Lr.__createBinding || (Object.create ? function(g, _, P, C) {
    C === void 0 && (C = P);
    var R = Object.getOwnPropertyDescriptor(_, P);
    (!R || ("get" in R ? !_.__esModule : R.writable || R.configurable)) && (R = { enumerable: !0, get: function() {
      return _[P];
    } }), Object.defineProperty(g, C, R);
  } : function(g, _, P, C) {
    C === void 0 && (C = P), g[C] = _[P];
  }), e = Lr && Lr.__setModuleDefault || (Object.create ? function(g, _) {
    Object.defineProperty(g, "default", { enumerable: !0, value: _ });
  } : function(g, _) {
    g.default = _;
  }), n = Lr && Lr.__importStar || function(g) {
    if (g && g.__esModule) return g;
    var _ = {};
    if (g != null) for (var P in g) P !== "default" && Object.prototype.hasOwnProperty.call(g, P) && t(_, g, P);
    return e(_, g), _;
  };
  Object.defineProperty(Lr, "__esModule", { value: !0 }), Lr.filesUpload = m;
  const a = /* @__PURE__ */ Ne(), r = /* @__PURE__ */ OT(), i = n(/* @__PURE__ */ ke()), s = /* @__PURE__ */ X(), o = /* @__PURE__ */ Z(), l = /* @__PURE__ */ Fe(), f = /* @__PURE__ */ Ee(), u = n(/* @__PURE__ */ Oe()), c = n(/* @__PURE__ */ wt()), h = /* @__PURE__ */ De(), p = /* @__PURE__ */ d$(), d = /* @__PURE__ */ IL();
  function m(g, _, P) {
    return new h.APIPromise(b(g, _, P));
  }
  async function b(g, _, P) {
    const C = (0, o.safeParse)(_, (ie) => c.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema.parse(ie), "Input validation failed");
    if (!C.ok)
      return [C, { status: "invalid" }];
    const R = C.value, T = new FormData();
    if ((0, p.isBlobLike)(R.file))
      (0, a.appendForm)(T, "file", R.file);
    else if ((0, d.isReadableStream)(R.file.content)) {
      const ie = await (0, r.readableStreamToArrayBuffer)(R.file.content), ut = new Blob([ie], { type: "application/octet-stream" });
      (0, a.appendForm)(T, "file", ut);
    } else
      (0, a.appendForm)(T, "file", new Blob([R.file.content], { type: "application/octet-stream" }), R.file.fileName);
    R.purpose !== void 0 && (0, a.appendForm)(T, "purpose", R.purpose);
    const O = (0, f.pathToFunc)("/v1/files")(), A = new Headers((0, s.compactMap)({
      Accept: "application/json"
    })), M = await (0, l.extractSecurity)(g._options.apiKey), I = M == null ? {} : { apiKey: M }, N = (0, l.resolveGlobalSecurity)(I), w = {
      baseURL: P?.serverURL ?? g._baseURL ?? "",
      operationID: "files_api_routes_upload_file",
      oAuth2Scopes: [],
      resolvedSecurity: N,
      securitySource: g._options.apiKey,
      retryConfig: P?.retries || g._options.retryConfig || { strategy: "none" },
      retryCodes: P?.retryCodes || ["429", "500", "502", "503", "504"]
    }, k = g._createRequest(w, {
      security: N,
      method: "POST",
      baseURL: P?.serverURL,
      path: O,
      headers: A,
      body: T,
      timeoutMs: P?.timeoutMs || g._options.timeoutMs || -1
    }, P);
    if (!k.ok)
      return [k, { status: "invalid" }];
    const L = k.value, B = await g._do(L, {
      context: w,
      errorCodes: ["4XX", "5XX"],
      retryConfig: w.retryConfig,
      retryCodes: w.retryCodes
    });
    if (!B.ok)
      return [B, { status: "request-error", request: L }];
    const V = B.value, [ce] = await i.match(i.json(200, u.UploadFileOut$inboundSchema), i.fail("4XX"), i.fail("5XX"))(V);
    return ce.ok ? [ce, { status: "complete", request: L, response: V }] : [ce, { status: "complete", request: L, response: V }];
  }
  return Lr;
}
var Sj;
function kL() {
  if (Sj) return Rl;
  Sj = 1, Object.defineProperty(Rl, "__esModule", { value: !0 }), Rl.Files = void 0;
  const t = /* @__PURE__ */ TL(), e = /* @__PURE__ */ $L(), n = /* @__PURE__ */ ML(), a = /* @__PURE__ */ AL(), r = /* @__PURE__ */ EL(), i = /* @__PURE__ */ NL(), s = /* @__PURE__ */ Mn(), o = /* @__PURE__ */ Zn();
  class l extends s.ClientSDK {
    /**
     * Upload File
     *
     * @remarks
     * Upload a file that can be used across various endpoints.
     *
     * The size of individual files can be a maximum of 512 MB. The Fine-tuning API only supports .jsonl files.
     *
     * Please contact us if you need to increase these storage limits.
     */
    async upload(u, c) {
      return (0, o.unwrapAsync)((0, i.filesUpload)(this, u, c));
    }
    /**
     * List Files
     *
     * @remarks
     * Returns a list of files that belong to the user's organization.
     */
    async list(u, c) {
      return (0, o.unwrapAsync)((0, a.filesList)(this, u, c));
    }
    /**
     * Retrieve File
     *
     * @remarks
     * Returns information about a specific file.
     */
    async retrieve(u, c) {
      return (0, o.unwrapAsync)((0, r.filesRetrieve)(this, u, c));
    }
    /**
     * Delete File
     *
     * @remarks
     * Delete a file.
     */
    async delete(u, c) {
      return (0, o.unwrapAsync)((0, t.filesDelete)(this, u, c));
    }
    /**
     * Download File
     *
     * @remarks
     * Download a file
     */
    async download(u, c) {
      return (0, o.unwrapAsync)((0, e.filesDownload)(this, u, c));
    }
    /**
     * Get Signed Url
     */
    async getSignedUrl(u, c) {
      return (0, o.unwrapAsync)((0, n.filesGetSignedUrl)(this, u, c));
    }
  }
  return Rl.Files = l, Rl;
}
var Cl = {}, Ur = {}, Oj;
function FL() {
  if (Oj) return Ur;
  Oj = 1;
  var t = Ur && Ur.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Ur && Ur.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Ur && Ur.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Ur, "__esModule", { value: !0 }), Ur.fimComplete = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ An()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.FIMCompletionRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), C = (0, l.pathToFunc)("/v1/fim/completions")(), R = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, o.extractSecurity)(d._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, o.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "fim_completion_v1_fim_completions_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = d._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: C,
      headers: R,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, w = await d._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!w.ok)
      return [w, { status: "request-error", request: N }];
    const k = w.value, L = {
      HttpMeta: { Response: k, Request: N }
    }, [B] = await r.match(r.json(200, f.FIMCompletionResponse$inboundSchema), r.jsonErr(422, u.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(k, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: k }] : [B, { status: "complete", request: N, response: k }];
  }
  return Ur;
}
var Br = {}, jj;
function DL() {
  if (jj) return Br;
  jj = 1;
  var t = Br && Br.__createBinding || (Object.create ? function(b, g, _, P) {
    P === void 0 && (P = _);
    var C = Object.getOwnPropertyDescriptor(g, _);
    (!C || ("get" in C ? !g.__esModule : C.writable || C.configurable)) && (C = { enumerable: !0, get: function() {
      return g[_];
    } }), Object.defineProperty(b, P, C);
  } : function(b, g, _, P) {
    P === void 0 && (P = _), b[P] = g[_];
  }), e = Br && Br.__setModuleDefault || (Object.create ? function(b, g) {
    Object.defineProperty(b, "default", { enumerable: !0, value: g });
  } : function(b, g) {
    b.default = g;
  }), n = Br && Br.__importStar || function(b) {
    if (b && b.__esModule) return b;
    var g = {};
    if (b != null) for (var _ in b) _ !== "default" && Object.prototype.hasOwnProperty.call(b, _) && t(g, b, _);
    return e(g, b), g;
  };
  Object.defineProperty(Br, "__esModule", { value: !0 }), Br.fimStream = d;
  const a = n(/* @__PURE__ */ H()), r = /* @__PURE__ */ Ne(), i = /* @__PURE__ */ Jp(), s = n(/* @__PURE__ */ ke()), o = /* @__PURE__ */ X(), l = /* @__PURE__ */ Z(), f = /* @__PURE__ */ Fe(), u = /* @__PURE__ */ Ee(), c = n(/* @__PURE__ */ Oe()), h = n(/* @__PURE__ */ An()), p = /* @__PURE__ */ De();
  function d(b, g, _) {
    return new p.APIPromise(m(b, g, _));
  }
  async function m(b, g, _) {
    const P = (0, l.safeParse)(g, (ie) => c.FIMCompletionStreamRequest$outboundSchema.parse(ie), "Input validation failed");
    if (!P.ok)
      return [P, { status: "invalid" }];
    const C = P.value, R = (0, r.encodeJSON)("body", C, { explode: !0 }), T = (0, u.pathToFunc)("/v1/fim/completions#stream")(), O = new Headers((0, o.compactMap)({
      "Content-Type": "application/json",
      Accept: "text/event-stream"
    })), A = await (0, f.extractSecurity)(b._options.apiKey), M = A == null ? {} : { apiKey: A }, I = (0, f.resolveGlobalSecurity)(M), N = {
      baseURL: _?.serverURL ?? b._baseURL ?? "",
      operationID: "stream_fim",
      oAuth2Scopes: [],
      resolvedSecurity: I,
      securitySource: b._options.apiKey,
      retryConfig: _?.retries || b._options.retryConfig || { strategy: "none" },
      retryCodes: _?.retryCodes || ["429", "500", "502", "503", "504"]
    }, w = b._createRequest(N, {
      security: I,
      method: "POST",
      baseURL: _?.serverURL,
      path: T,
      headers: O,
      body: R,
      timeoutMs: _?.timeoutMs || b._options.timeoutMs || -1
    }, _);
    if (!w.ok)
      return [w, { status: "invalid" }];
    const k = w.value, L = await b._do(k, {
      context: N,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: N.retryConfig,
      retryCodes: N.retryCodes
    });
    if (!L.ok)
      return [L, { status: "request-error", request: k }];
    const B = L.value, V = {
      HttpMeta: { Response: B, Request: k }
    }, [ce] = await s.match(s.sse(200, a.instanceof(ReadableStream).transform((ie) => new i.EventStream({
      stream: ie,
      decoder(ut) {
        return c.CompletionEvent$inboundSchema.parse(ut);
      }
    })), { sseSentinel: "[DONE]" }), s.jsonErr(422, h.HTTPValidationError$inboundSchema), s.fail("4XX"), s.fail("5XX"))(B, { extraFields: V });
    return ce.ok ? [ce, { status: "complete", request: k, response: B }] : [ce, { status: "complete", request: k, response: B }];
  }
  return Br;
}
var Pj;
function qL() {
  if (Pj) return Cl;
  Pj = 1, Object.defineProperty(Cl, "__esModule", { value: !0 }), Cl.Fim = void 0;
  const t = /* @__PURE__ */ FL(), e = /* @__PURE__ */ DL(), n = /* @__PURE__ */ Mn(), a = /* @__PURE__ */ Zn();
  class r extends n.ClientSDK {
    /**
     * Fim Completion
     *
     * @remarks
     * FIM completion.
     */
    async complete(s, o) {
      return (0, a.unwrapAsync)((0, t.fimComplete)(this, s, o));
    }
    /**
     * Stream fim completion
     *
     * @remarks
     * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
     */
    async stream(s, o) {
      return (0, a.unwrapAsync)((0, e.fimStream)(this, s, o));
    }
  }
  return Cl.Fim = r, Cl;
}
var Tl = {}, $l = {}, xr = {}, Rj;
function JL() {
  if (Rj) return xr;
  Rj = 1;
  var t = xr && xr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = xr && xr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = xr && xr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(xr, "__esModule", { value: !0 }), xr.fineTuningJobsCancel = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = {
      job_id: (0, a.encodeSimple)("job_id", _.job_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, l.pathToFunc)("/v1/fine_tuning/jobs/{job_id}/cancel")(C), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_cancel_fine_tuning_job",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "POST",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.DetailedJobOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return xr;
}
var Vr = {}, Cj;
function LL() {
  if (Cj) return Vr;
  Cj = 1;
  var t = Vr && Vr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Vr && Vr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Vr && Vr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Vr, "__esModule", { value: !0 }), Vr.fineTuningJobsCreate = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (B) => f.JobIn$outboundSchema.parse(B), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), C = (0, l.pathToFunc)("/v1/fine_tuning/jobs")(), R = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, o.extractSecurity)(d._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, o.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_create_fine_tuning_job",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = d._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: C,
      headers: R,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, w = await d._do(N, {
      context: M,
      errorCodes: ["4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!w.ok)
      return [w, { status: "request-error", request: N }];
    const k = w.value, [L] = await r.match(r.json(200, u.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema), r.fail("4XX"), r.fail("5XX"))(k);
    return L.ok ? [L, { status: "complete", request: N, response: k }] : [L, { status: "complete", request: N, response: k }];
  }
  return Vr;
}
var zr = {}, Tj;
function UL() {
  if (Tj) return zr;
  Tj = 1;
  var t = zr && zr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = zr && zr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = zr && zr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(zr, "__esModule", { value: !0 }), zr.fineTuningJobsGet = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = {
      job_id: (0, a.encodeSimple)("job_id", _.job_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, l.pathToFunc)("/v1/fine_tuning/jobs/{job_id}")(C), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_get_fine_tuning_job",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.DetailedJobOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return zr;
}
var Zr = {}, $j;
function BL() {
  if ($j) return Zr;
  $j = 1;
  var t = Zr && Zr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Zr && Zr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Zr && Zr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Zr, "__esModule", { value: !0 }), Zr.fineTuningJobsList = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema.optional().parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = (0, l.pathToFunc)("/v1/fine_tuning/jobs")(), R = (0, a.encodeFormQuery)({
      created_after: _?.created_after,
      created_by_me: _?.created_by_me,
      model: _?.model,
      page: _?.page,
      page_size: _?.page_size,
      status: _?.status,
      suffix: _?.suffix,
      wandb_name: _?.wandb_name,
      wandb_project: _?.wandb_project
    }), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_get_fine_tuning_jobs",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      query: R,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.JobsOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return Zr;
}
var Kr = {}, Mj;
function xL() {
  if (Mj) return Kr;
  Mj = 1;
  var t = Kr && Kr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Kr && Kr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Kr && Kr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Kr, "__esModule", { value: !0 }), Kr.fineTuningJobsStart = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = {
      job_id: (0, a.encodeSimple)("job_id", _.job_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, l.pathToFunc)("/v1/fine_tuning/jobs/{job_id}/start")(C), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_start_fine_tuning_job",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "POST",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.DetailedJobOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return Kr;
}
var Aj;
function VL() {
  if (Aj) return $l;
  Aj = 1, Object.defineProperty($l, "__esModule", { value: !0 }), $l.Jobs = void 0;
  const t = /* @__PURE__ */ JL(), e = /* @__PURE__ */ LL(), n = /* @__PURE__ */ UL(), a = /* @__PURE__ */ BL(), r = /* @__PURE__ */ xL(), i = /* @__PURE__ */ Mn(), s = /* @__PURE__ */ Zn();
  class o extends i.ClientSDK {
    /**
     * Get Fine Tuning Jobs
     *
     * @remarks
     * Get a list of fine-tuning jobs for your organization and user.
     */
    async list(f, u) {
      return (0, s.unwrapAsync)((0, a.fineTuningJobsList)(this, f, u));
    }
    /**
     * Create Fine Tuning Job
     *
     * @remarks
     * Create a new fine-tuning job, it will be queued for processing.
     */
    async create(f, u) {
      return (0, s.unwrapAsync)((0, e.fineTuningJobsCreate)(this, f, u));
    }
    /**
     * Get Fine Tuning Job
     *
     * @remarks
     * Get a fine-tuned job details by its UUID.
     */
    async get(f, u) {
      return (0, s.unwrapAsync)((0, n.fineTuningJobsGet)(this, f, u));
    }
    /**
     * Cancel Fine Tuning Job
     *
     * @remarks
     * Request the cancellation of a fine tuning job.
     */
    async cancel(f, u) {
      return (0, s.unwrapAsync)((0, t.fineTuningJobsCancel)(this, f, u));
    }
    /**
     * Start Fine Tuning Job
     *
     * @remarks
     * Request the start of a validated fine tuning job.
     */
    async start(f, u) {
      return (0, s.unwrapAsync)((0, r.fineTuningJobsStart)(this, f, u));
    }
  }
  return $l.Jobs = o, $l;
}
var Ej;
function zL() {
  if (Ej) return Tl;
  Ej = 1, Object.defineProperty(Tl, "__esModule", { value: !0 }), Tl.FineTuning = void 0;
  const t = /* @__PURE__ */ Mn(), e = /* @__PURE__ */ VL();
  class n extends t.ClientSDK {
    get jobs() {
      return this._jobs ?? (this._jobs = new e.Jobs(this._options));
    }
  }
  return Tl.FineTuning = n, Tl;
}
var Ml = {}, Hr = {}, Ij;
function ZL() {
  if (Ij) return Hr;
  Ij = 1;
  var t = Hr && Hr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Hr && Hr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Hr && Hr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Hr, "__esModule", { value: !0 }), Hr.modelsArchive = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = {
      model_id: (0, a.encodeSimple)("model_id", _.model_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, l.pathToFunc)("/v1/fine_tuning/models/{model_id}/archive")(C), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_archive_fine_tuned_model",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "POST",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.ArchiveFTModelOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return Hr;
}
var Gr = {}, Nj;
function KL() {
  if (Nj) return Gr;
  Nj = 1;
  var t = Gr && Gr.__createBinding || (Object.create ? function(m, b, g, _) {
    _ === void 0 && (_ = g);
    var P = Object.getOwnPropertyDescriptor(b, g);
    (!P || ("get" in P ? !b.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
      return b[g];
    } }), Object.defineProperty(m, _, P);
  } : function(m, b, g, _) {
    _ === void 0 && (_ = g), m[_] = b[g];
  }), e = Gr && Gr.__setModuleDefault || (Object.create ? function(m, b) {
    Object.defineProperty(m, "default", { enumerable: !0, value: b });
  } : function(m, b) {
    m.default = b;
  }), n = Gr && Gr.__importStar || function(m) {
    if (m && m.__esModule) return m;
    var b = {};
    if (m != null) for (var g in m) g !== "default" && Object.prototype.hasOwnProperty.call(m, g) && t(b, m, g);
    return e(b, m), b;
  };
  Object.defineProperty(Gr, "__esModule", { value: !0 }), Gr.modelsDelete = p;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ An()), c = n(/* @__PURE__ */ wt()), h = /* @__PURE__ */ De();
  function p(m, b, g) {
    return new h.APIPromise(d(m, b, g));
  }
  async function d(m, b, g) {
    const _ = (0, s.safeParse)(b, (ie) => c.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema.parse(ie), "Input validation failed");
    if (!_.ok)
      return [_, { status: "invalid" }];
    const P = _.value, C = null, R = {
      model_id: (0, a.encodeSimple)("model_id", P.model_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, T = (0, l.pathToFunc)("/v1/models/{model_id}")(R), O = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), A = await (0, o.extractSecurity)(m._options.apiKey), M = A == null ? {} : { apiKey: A }, I = (0, o.resolveGlobalSecurity)(M), N = {
      baseURL: g?.serverURL ?? m._baseURL ?? "",
      operationID: "delete_model_v1_models__model_id__delete",
      oAuth2Scopes: [],
      resolvedSecurity: I,
      securitySource: m._options.apiKey,
      retryConfig: g?.retries || m._options.retryConfig || { strategy: "none" },
      retryCodes: g?.retryCodes || ["429", "500", "502", "503", "504"]
    }, w = m._createRequest(N, {
      security: I,
      method: "DELETE",
      baseURL: g?.serverURL,
      path: T,
      headers: O,
      body: C,
      timeoutMs: g?.timeoutMs || m._options.timeoutMs || -1
    }, g);
    if (!w.ok)
      return [w, { status: "invalid" }];
    const k = w.value, L = await m._do(k, {
      context: N,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: N.retryConfig,
      retryCodes: N.retryCodes
    });
    if (!L.ok)
      return [L, { status: "request-error", request: k }];
    const B = L.value, V = {
      HttpMeta: { Response: B, Request: k }
    }, [ce] = await r.match(r.json(200, f.DeleteModelOut$inboundSchema), r.jsonErr(422, u.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(B, { extraFields: V });
    return ce.ok ? [ce, { status: "complete", request: k, response: B }] : [ce, { status: "complete", request: k, response: B }];
  }
  return Gr;
}
var Wr = {}, kj;
function HL() {
  if (kj) return Wr;
  kj = 1;
  var t = Wr && Wr.__createBinding || (Object.create ? function(h, p, d, m) {
    m === void 0 && (m = d);
    var b = Object.getOwnPropertyDescriptor(p, d);
    (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
      return p[d];
    } }), Object.defineProperty(h, m, b);
  } : function(h, p, d, m) {
    m === void 0 && (m = d), h[m] = p[d];
  }), e = Wr && Wr.__setModuleDefault || (Object.create ? function(h, p) {
    Object.defineProperty(h, "default", { enumerable: !0, value: p });
  } : function(h, p) {
    h.default = p;
  }), n = Wr && Wr.__importStar || function(h) {
    if (h && h.__esModule) return h;
    var p = {};
    if (h != null) for (var d in h) d !== "default" && Object.prototype.hasOwnProperty.call(h, d) && t(p, h, d);
    return e(p, h), p;
  };
  Object.defineProperty(Wr, "__esModule", { value: !0 }), Wr.modelsList = u;
  const a = n(/* @__PURE__ */ ke()), r = /* @__PURE__ */ X(), i = /* @__PURE__ */ Fe(), s = /* @__PURE__ */ Ee(), o = n(/* @__PURE__ */ Oe()), l = n(/* @__PURE__ */ An()), f = /* @__PURE__ */ De();
  function u(h, p) {
    return new f.APIPromise(c(h, p));
  }
  async function c(h, p) {
    const d = (0, s.pathToFunc)("/v1/models")(), m = new Headers((0, r.compactMap)({
      Accept: "application/json"
    })), b = await (0, i.extractSecurity)(h._options.apiKey), g = b == null ? {} : { apiKey: b }, _ = (0, i.resolveGlobalSecurity)(g), P = {
      baseURL: p?.serverURL ?? h._baseURL ?? "",
      operationID: "list_models_v1_models_get",
      oAuth2Scopes: [],
      resolvedSecurity: _,
      securitySource: h._options.apiKey,
      retryConfig: p?.retries || h._options.retryConfig || { strategy: "none" },
      retryCodes: p?.retryCodes || ["429", "500", "502", "503", "504"]
    }, C = h._createRequest(P, {
      security: _,
      method: "GET",
      baseURL: p?.serverURL,
      path: d,
      headers: m,
      timeoutMs: p?.timeoutMs || h._options.timeoutMs || -1
    }, p);
    if (!C.ok)
      return [C, { status: "invalid" }];
    const R = C.value, T = await h._do(R, {
      context: P,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: P.retryConfig,
      retryCodes: P.retryCodes
    });
    if (!T.ok)
      return [T, { status: "request-error", request: R }];
    const O = T.value, A = {
      HttpMeta: { Response: O, Request: R }
    }, [M] = await a.match(a.json(200, o.ModelList$inboundSchema), a.jsonErr(422, l.HTTPValidationError$inboundSchema), a.fail("4XX"), a.fail("5XX"))(O, { extraFields: A });
    return M.ok ? [M, { status: "complete", request: R, response: O }] : [M, { status: "complete", request: R, response: O }];
  }
  return Wr;
}
var Xr = {}, Fj;
function GL() {
  if (Fj) return Xr;
  Fj = 1;
  var t = Xr && Xr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Xr && Xr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Xr && Xr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Xr, "__esModule", { value: !0 }), Xr.modelsRetrieve = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ An()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (ce) => u.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema.parse(ce), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = {
      model_id: (0, a.encodeSimple)("model_id", _.model_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, l.pathToFunc)("/v1/models/{model_id}")(C), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "retrieve_model_v1_models__model_id__get",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, B = {
      HttpMeta: { Response: L, Request: w }
    }, [V] = await r.match(r.json(200, u.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema), r.jsonErr(422, f.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L, { extraFields: B });
    return V.ok ? [V, { status: "complete", request: w, response: L }] : [V, { status: "complete", request: w, response: L }];
  }
  return Xr;
}
var Qr = {}, Dj;
function WL() {
  if (Dj) return Qr;
  Dj = 1;
  var t = Qr && Qr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Qr && Qr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Qr && Qr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Qr, "__esModule", { value: !0 }), Qr.modelsUnarchive = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, C = {
      model_id: (0, a.encodeSimple)("model_id", _.model_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, l.pathToFunc)("/v1/fine_tuning/models/{model_id}/archive")(C), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_unarchive_fine_tuned_model",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "DELETE",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.UnarchiveFTModelOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return Qr;
}
var Yr = {}, qj;
function XL() {
  if (qj) return Yr;
  qj = 1;
  var t = Yr && Yr.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = Yr && Yr.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = Yr && Yr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.modelsUpdate = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ wt()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => u.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _.UpdateFTModelIn, { explode: !0 }), C = {
      model_id: (0, a.encodeSimple)("model_id", _.model_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, R = (0, l.pathToFunc)("/v1/fine_tuning/models/{model_id}")(C), T = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), O = await (0, o.extractSecurity)(d._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, o.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_update_fine_tuned_model",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = d._createRequest(I, {
      security: M,
      method: "PATCH",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const w = N.value, k = await d._do(w, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!k.ok)
      return [k, { status: "request-error", request: w }];
    const L = k.value, [B] = await r.match(r.json(200, f.FTModelOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: w, response: L }] : [B, { status: "complete", request: w, response: L }];
  }
  return Yr;
}
var Jj;
function QL() {
  if (Jj) return Ml;
  Jj = 1, Object.defineProperty(Ml, "__esModule", { value: !0 }), Ml.Models = void 0;
  const t = /* @__PURE__ */ ZL(), e = /* @__PURE__ */ KL(), n = /* @__PURE__ */ HL(), a = /* @__PURE__ */ GL(), r = /* @__PURE__ */ WL(), i = /* @__PURE__ */ XL(), s = /* @__PURE__ */ Mn(), o = /* @__PURE__ */ Zn();
  class l extends s.ClientSDK {
    /**
     * List Models
     *
     * @remarks
     * List all models available to the user.
     */
    async list(u) {
      return (0, o.unwrapAsync)((0, n.modelsList)(this, u));
    }
    /**
     * Retrieve Model
     *
     * @remarks
     * Retrieve a model information.
     */
    async retrieve(u, c) {
      return (0, o.unwrapAsync)((0, a.modelsRetrieve)(this, u, c));
    }
    /**
     * Delete Model
     *
     * @remarks
     * Delete a fine-tuned model.
     */
    async delete(u, c) {
      return (0, o.unwrapAsync)((0, e.modelsDelete)(this, u, c));
    }
    /**
     * Update Fine Tuned Model
     *
     * @remarks
     * Update a model name or description.
     */
    async update(u, c) {
      return (0, o.unwrapAsync)((0, i.modelsUpdate)(this, u, c));
    }
    /**
     * Archive Fine Tuned Model
     *
     * @remarks
     * Archive a fine-tuned model.
     */
    async archive(u, c) {
      return (0, o.unwrapAsync)((0, t.modelsArchive)(this, u, c));
    }
    /**
     * Unarchive Fine Tuned Model
     *
     * @remarks
     * Un-archive a fine-tuned model.
     */
    async unarchive(u, c) {
      return (0, o.unwrapAsync)((0, r.modelsUnarchive)(this, u, c));
    }
  }
  return Ml.Models = l, Ml;
}
var Al = {}, ea = {}, Lj;
function YL() {
  if (Lj) return ea;
  Lj = 1;
  var t = ea && ea.__createBinding || (Object.create ? function(d, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(d, g, _);
  } : function(d, m, b, g) {
    g === void 0 && (g = b), d[g] = m[b];
  }), e = ea && ea.__setModuleDefault || (Object.create ? function(d, m) {
    Object.defineProperty(d, "default", { enumerable: !0, value: m });
  } : function(d, m) {
    d.default = m;
  }), n = ea && ea.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var m = {};
    if (d != null) for (var b in d) b !== "default" && Object.prototype.hasOwnProperty.call(d, b) && t(m, d, b);
    return e(m, d), m;
  };
  Object.defineProperty(ea, "__esModule", { value: !0 }), ea.ocrProcess = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ ke()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), o = /* @__PURE__ */ Fe(), l = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), u = n(/* @__PURE__ */ An()), c = /* @__PURE__ */ De();
  function h(d, m, b) {
    return new c.APIPromise(p(d, m, b));
  }
  async function p(d, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.OCRRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), C = (0, l.pathToFunc)("/v1/ocr")(), R = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, o.extractSecurity)(d._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, o.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? d._baseURL ?? "",
      operationID: "ocr_v1_ocr_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: d._options.apiKey,
      retryConfig: b?.retries || d._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = d._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: C,
      headers: R,
      body: P,
      timeoutMs: b?.timeoutMs || d._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, w = await d._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!w.ok)
      return [w, { status: "request-error", request: N }];
    const k = w.value, L = {
      HttpMeta: { Response: k, Request: N }
    }, [B] = await r.match(r.json(200, f.OCRResponse$inboundSchema), r.jsonErr(422, u.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(k, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: k }] : [B, { status: "complete", request: N, response: k }];
  }
  return ea;
}
var Uj;
function eU() {
  if (Uj) return Al;
  Uj = 1, Object.defineProperty(Al, "__esModule", { value: !0 }), Al.Ocr = void 0;
  const t = /* @__PURE__ */ YL(), e = /* @__PURE__ */ Mn(), n = /* @__PURE__ */ Zn();
  class a extends e.ClientSDK {
    /**
     * OCR
     */
    async process(i, s) {
      return (0, n.unwrapAsync)((0, t.ocrProcess)(this, i, s));
    }
  }
  return Al.Ocr = a, Al;
}
var Bj;
function tU() {
  if (Bj) return kc;
  Bj = 1, Object.defineProperty(kc, "__esModule", { value: !0 }), kc.Mistral = void 0;
  const t = /* @__PURE__ */ Mn(), e = /* @__PURE__ */ zJ(), n = /* @__PURE__ */ bL(), a = /* @__PURE__ */ SL(), r = /* @__PURE__ */ PL(), i = /* @__PURE__ */ CL(), s = /* @__PURE__ */ kL(), o = /* @__PURE__ */ qL(), l = /* @__PURE__ */ zL(), f = /* @__PURE__ */ QL(), u = /* @__PURE__ */ eU();
  class c extends t.ClientSDK {
    get models() {
      return this._models ?? (this._models = new f.Models(this._options));
    }
    get files() {
      return this._files ?? (this._files = new s.Files(this._options));
    }
    get fineTuning() {
      return this._fineTuning ?? (this._fineTuning = new l.FineTuning(this._options));
    }
    get batch() {
      return this._batch ?? (this._batch = new n.Batch(this._options));
    }
    get chat() {
      return this._chat ?? (this._chat = new a.Chat(this._options));
    }
    get fim() {
      return this._fim ?? (this._fim = new o.Fim(this._options));
    }
    get agents() {
      return this._agents ?? (this._agents = new e.Agents(this._options));
    }
    get embeddings() {
      return this._embeddings ?? (this._embeddings = new i.Embeddings(this._options));
    }
    get classifiers() {
      return this._classifiers ?? (this._classifiers = new r.Classifiers(this._options));
    }
    get ocr() {
      return this._ocr ?? (this._ocr = new u.Ocr(this._options));
    }
  }
  return kc.Mistral = c, kc;
}
var xj;
function nU() {
  return xj || (xj = 1, function(t) {
    var e = tr && tr.__createBinding || (Object.create ? function(i, s, o, l) {
      l === void 0 && (l = o);
      var f = Object.getOwnPropertyDescriptor(s, o);
      (!f || ("get" in f ? !s.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
        return s[o];
      } }), Object.defineProperty(i, l, f);
    } : function(i, s, o, l) {
      l === void 0 && (l = o), i[l] = s[o];
    }), n = tr && tr.__setModuleDefault || (Object.create ? function(i, s) {
      Object.defineProperty(i, "default", { enumerable: !0, value: s });
    } : function(i, s) {
      i.default = s;
    }), a = tr && tr.__exportStar || function(i, s) {
      for (var o in i) o !== "default" && !Object.prototype.hasOwnProperty.call(s, o) && e(s, i, o);
    }, r = tr && tr.__importStar || function(i) {
      if (i && i.__esModule) return i;
      var s = {};
      if (i != null) for (var o in i) o !== "default" && Object.prototype.hasOwnProperty.call(i, o) && e(s, i, o);
      return n(s, i), s;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.files = void 0, a(/* @__PURE__ */ N_(), t), t.files = r(/* @__PURE__ */ OT()), a(/* @__PURE__ */ tU(), t);
  }(tr)), tr;
}
var L$ = /* @__PURE__ */ nU();
const rU = /* @__PURE__ */ HA({
  __proto__: null
}, [L$]);
var U$ = /* @__PURE__ */ qp();
const aU = /^[a-zA-Z0-9]{9}$/;
function iU(t) {
  return aU.test(t);
}
function sU(t) {
  let e = t;
  const n = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  if (e === 0)
    return n[0];
  const a = [], r = n.length;
  for (; e; )
    a.push(n[e % r]), e = Math.floor(e / r);
  return a.reverse().join("");
}
function oU(t) {
  let e = 0;
  for (let n = 0; n < t.length; n += 1) {
    const a = t.charCodeAt(n);
    e = (e << 5) - e + a, e &= e;
  }
  return Math.abs(e);
}
function Vj(t) {
  if (iU(t))
    return t;
  {
    const e = oU(t), n = sU(e);
    return n.length >= 9 ? n.slice(0, 9) : n.padStart(9, "0");
  }
}
function B$(t) {
  return t ? typeof t == "string" ? t : t.map((e) => {
    if (e.type === "image_url") {
      if (typeof e.imageUrl != "string" && e.imageUrl?.detail) {
        const { detail: n } = e.imageUrl;
        if (n !== "high" && n !== "auto" && n !== "low")
          return {
            type: e.type,
            image_url: {
              url: e.imageUrl.url
            }
          };
      }
      return {
        type: e.type,
        image_url: e.imageUrl
      };
    }
    return e;
  }) : "";
}
function zj(t) {
  const e = (r) => {
    switch (r) {
      case "human":
        return "user";
      case "ai":
        return "assistant";
      case "system":
        return "system";
      case "tool":
        return "tool";
      case "function":
        return "assistant";
      default:
        throw new Error(`Unknown message type: ${r}`);
    }
  }, n = (r, i) => {
    const s = (o, l) => {
      if (o.type === "image_url" && (l === "user" || l === "assistant"))
        return {
          type: o.type,
          imageUrl: o?.image_url
        };
      if (o.type === "text")
        return {
          type: o.type,
          text: o?.text
        };
      throw new Error(`ChatMistralAI only supports messages of "image_url" for roles "user" and "assistant", and "text" for all others.

Received: ${JSON.stringify(r, null, 2)}`);
    };
    if (typeof r == "string")
      return r;
    if (Array.isArray(r)) {
      const o = e(i), l = [];
      return r.forEach((f) => {
        if (f.type === "text" || f.type === "image_url")
          l.push(s(f, o));
        else
          throw new Error('Mistral only supports types "text" or "image_url" for complex message types.');
      }), l;
    }
    throw new Error(`Message content must be a string or an array.

Received: ${JSON.stringify(r, null, 2)}`);
  }, a = (r) => {
    if (Vs(r) && r.tool_calls?.length)
      return r.tool_calls.map((i) => ({
        ...i,
        id: Vj(i.id ?? "")
      })).map(__);
  };
  return t.map((r) => {
    const i = a(r), s = n(r.content, r.getType());
    return "tool_call_id" in r && typeof r.tool_call_id == "string" ? {
      role: e(r.getType()),
      content: s,
      name: r.name,
      toolCallId: Vj(r.tool_call_id)
    } : Vs(r) ? i === void 0 ? {
      role: e(r.getType()),
      content: s
    } : {
      role: e(r.getType()),
      toolCalls: i
    } : {
      role: e(r.getType()),
      content: s
    };
  });
}
function uU(t, e) {
  const { message: n } = t;
  if (n === void 0)
    throw new Error("No message found in response");
  let a = [];
  "toolCalls" in n && Array.isArray(n.toolCalls) && (a = n.toolCalls);
  const r = B$(n.content);
  switch (n.role) {
    case "assistant": {
      const i = [], s = [];
      for (const o of a)
        try {
          const l = Hd(o, { returnId: !0 });
          i.push({
            ...l,
            id: l.id ?? Pt().replace(/-/g, "")
          });
        } catch (l) {
          s.push($p(o, l.message));
        }
      return new $t({
        content: r,
        tool_calls: i,
        invalid_tool_calls: s,
        additional_kwargs: {},
        usage_metadata: e ? {
          input_tokens: e.promptTokens,
          output_tokens: e.completionTokens,
          total_tokens: e.totalTokens
        } : void 0
      });
    }
    default:
      return new _r({ content: r });
  }
}
function cU(t, e) {
  if (!t.content && !t.toolCalls)
    return e ? new Ze({
      content: "",
      usage_metadata: e ? {
        input_tokens: e.promptTokens,
        output_tokens: e.completionTokens,
        total_tokens: e.totalTokens
      } : void 0
    }) : null;
  const n = t.toolCalls?.length ? t.toolCalls?.map((o, l) => ({
    ...o,
    index: l,
    id: o.id ?? Pt().replace(/-/g, ""),
    type: "function"
  })) : void 0;
  let a = "assistant";
  t.role && (a = t.role);
  const r = B$(t.content);
  let i;
  const s = [];
  if (n !== void 0)
    for (const o of n) {
      const l = o.function?.arguments, f = l === void 0 || typeof l == "string" ? l : JSON.stringify(l);
      s.push({
        name: o.function?.name,
        args: f,
        id: o.id,
        index: o.index,
        type: "tool_call_chunk"
      });
    }
  else
    i = {};
  return a === "user" ? new uc({ content: r }) : a === "assistant" ? new Ze({
    content: r,
    tool_call_chunks: s,
    additional_kwargs: i,
    usage_metadata: e ? {
      input_tokens: e.promptTokens,
      output_tokens: e.completionTokens,
      total_tokens: e.totalTokens
    } : void 0
  }) : a === "tool" ? new jp({
    content: r,
    additional_kwargs: i,
    tool_call_id: n?.[0].id ?? ""
  }) : a === "function" ? new xd({
    content: r,
    additional_kwargs: i
  }) : new oc({ content: r, role: a });
}
function Zj(t) {
  return t.map((e) => {
    if ("function" in e)
      return e;
    const n = e.description ?? `Tool: ${e.name}`;
    return {
      type: "function",
      function: {
        name: e.name,
        description: n,
        parameters: Cn(e.schema)
      }
    };
  });
}
class jZ extends Sn {
  // Used for tracing, replace with the same name as your class
  static lc_name() {
    return "ChatMistralAI";
  }
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "chat_models", "mistralai"]
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mistral-small-latest"
    }), Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "endpoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serverURL", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0.7
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "maxTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "safeMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "safePrompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "randomSeed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "seed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxRetries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "streamUsage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "beforeRequestHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "requestErrorHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "responseHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "httpClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "presencePenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "frequencyPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numCompletions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const n = e?.apiKey ?? ft("MISTRAL_API_KEY");
    if (!n)
      throw new Error("API key MISTRAL_API_KEY is missing for MistralAI, but it is required.");
    this.apiKey = n, this.streaming = e?.streaming ?? this.streaming, this.serverURL = e?.serverURL ?? this.serverURL, this.temperature = e?.temperature ?? this.temperature, this.topP = e?.topP ?? this.topP, this.maxTokens = e?.maxTokens ?? this.maxTokens, this.safePrompt = e?.safePrompt ?? this.safePrompt, this.randomSeed = e?.seed ?? e?.randomSeed ?? this.seed, this.seed = this.randomSeed, this.maxRetries = e?.maxRetries, this.httpClient = e?.httpClient, this.model = e?.model ?? e?.modelName ?? this.model, this.streamUsage = e?.streamUsage ?? this.streamUsage, this.beforeRequestHooks = e?.beforeRequestHooks ?? this.beforeRequestHooks, this.requestErrorHooks = e?.requestErrorHooks ?? this.requestErrorHooks, this.responseHooks = e?.responseHooks ?? this.responseHooks, this.presencePenalty = e?.presencePenalty ?? this.presencePenalty, this.frequencyPenalty = e?.frequencyPenalty ?? this.frequencyPenalty, this.numCompletions = e?.numCompletions ?? this.numCompletions, this.addAllHooksToHttpClient();
  }
  get lc_secrets() {
    return {
      apiKey: "MISTRAL_API_KEY"
    };
  }
  get lc_aliases() {
    return {
      apiKey: "mistral_api_key"
    };
  }
  getLsParams(e) {
    const n = this.invocationParams(e);
    return {
      ls_provider: "mistral",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: n.temperature ?? void 0,
      ls_max_tokens: n.maxTokens ?? void 0
    };
  }
  _llmType() {
    return "mistral_ai";
  }
  /**
   * Get the parameters used to invoke the model
   */
  invocationParams(e) {
    const { response_format: n, tools: a, tool_choice: r } = e ?? {}, i = a?.length ? Zj(a) : void 0;
    return {
      model: this.model,
      tools: i,
      temperature: this.temperature,
      maxTokens: this.maxTokens,
      topP: this.topP,
      randomSeed: this.seed,
      safePrompt: this.safePrompt,
      toolChoice: r,
      responseFormat: n,
      presencePenalty: this.presencePenalty,
      frequencyPenalty: this.frequencyPenalty,
      n: this.numCompletions
    };
  }
  bindTools(e, n) {
    return this.bind({
      tools: Zj(e),
      ...n
    });
  }
  async completionWithRetry(e, n) {
    const a = new ru({
      maxRetries: this.maxRetries
    }), r = new L$.Mistral({
      apiKey: this.apiKey,
      serverURL: this.serverURL,
      // If httpClient exists, pass it into constructor
      ...this.httpClient ? { httpClient: this.httpClient } : {}
    });
    return a.call(async () => {
      try {
        let i;
        return n ? i = await r.chat.stream(e) : i = await r.chat.complete(e), i;
      } catch (i) {
        throw (i.message?.includes("status: 400") || i.message?.toLowerCase().includes("status 400") || i.message?.includes("validation failed")) && (i.status = 400), i;
      }
    });
  }
  /** @ignore */
  async _generate(e, n, a) {
    const r = {}, i = this.invocationParams(n), s = zj(e), o = {
      ...i,
      messages: s
    }, l = n.signal ?? !!n.timeout;
    if (this.streaming || l) {
      const d = this._streamResponseChunks(e, n, a), m = {};
      for await (const g of d) {
        const _ = g.generationInfo?.completion ?? 0;
        m[_] === void 0 ? m[_] = g : m[_] = m[_].concat(g);
      }
      return { generations: Object.entries(m).sort(([g], [_]) => parseInt(g, 10) - parseInt(_, 10)).map(([g, _]) => _), llmOutput: { estimatedTokenUsage: r } };
    }
    const f = await this.completionWithRetry(o, !1), { completionTokens: u, promptTokens: c, totalTokens: h } = f?.usage ?? {};
    u && (r.completionTokens = (r.completionTokens ?? 0) + u), c && (r.promptTokens = (r.promptTokens ?? 0) + c), h && (r.totalTokens = (r.totalTokens ?? 0) + h);
    const p = [];
    for (const d of f?.choices ?? []) {
      if ("delta" in d)
        throw new Error("Delta not supported in non-streaming mode.");
      if (!("message" in d))
        throw new Error("No message found in the choice.");
      let m = d.message?.content ?? "";
      Array.isArray(m) && (m = m[0].type === "text" ? m[0].text : "");
      const b = {
        text: m,
        message: uU(d, f?.usage)
      };
      d.finishReason && (b.generationInfo = { finishReason: d.finishReason }), p.push(b);
    }
    return {
      generations: p,
      llmOutput: { tokenUsage: r }
    };
  }
  async *_streamResponseChunks(e, n, a) {
    const r = zj(e), s = {
      ...this.invocationParams(n),
      messages: r
    }, o = await this.completionWithRetry(s, !0);
    for await (const { data: l } of o) {
      if (n.signal?.aborted)
        throw new Error("AbortError");
      const f = l?.choices[0];
      if (!f || !("delta" in f))
        continue;
      const { delta: u } = f;
      if (!u)
        continue;
      const c = {
        prompt: 0,
        completion: f.index ?? 0
      }, h = this.streamUsage || n.streamUsage, p = cU(u, h ? l.usage : null);
      if (p === null)
        continue;
      let d = u.content ?? "";
      Array.isArray(d) && (d = d[0].type === "text" ? d[0].text : "");
      const m = new Bt({
        message: p,
        text: d,
        generationInfo: c
      });
      yield m, a?.handleLLMNewToken(m.text ?? "", c, void 0, void 0, void 0, { chunk: m });
    }
  }
  addAllHooksToHttpClient() {
    try {
      if (this.removeAllHooksFromHttpClient(), [
        this.beforeRequestHooks,
        this.requestErrorHooks,
        this.responseHooks
      ].some((n) => n && n.length > 0) && !this.httpClient && (this.httpClient = new U$.HTTPClient()), this.beforeRequestHooks)
        for (const n of this.beforeRequestHooks)
          this.httpClient?.addHook("beforeRequest", n);
      if (this.requestErrorHooks)
        for (const n of this.requestErrorHooks)
          this.httpClient?.addHook("requestError", n);
      if (this.responseHooks)
        for (const n of this.responseHooks)
          this.httpClient?.addHook("response", n);
    } catch {
      throw new Error("Error in adding all hooks");
    }
  }
  removeAllHooksFromHttpClient() {
    try {
      if (this.beforeRequestHooks)
        for (const e of this.beforeRequestHooks)
          this.httpClient?.removeHook("beforeRequest", e);
      if (this.requestErrorHooks)
        for (const e of this.requestErrorHooks)
          this.httpClient?.removeHook("requestError", e);
      if (this.responseHooks)
        for (const e of this.responseHooks)
          this.httpClient?.removeHook("response", e);
    } catch {
      throw new Error("Error in removing hooks");
    }
  }
  removeHookFromHttpClient(e) {
    try {
      this.httpClient?.removeHook("beforeRequest", e), this.httpClient?.removeHook("requestError", e), this.httpClient?.removeHook("response", e);
    } catch {
      throw new Error("Error in removing hook");
    }
  }
  /** @ignore */
  _combineLLMOutput() {
    return [];
  }
  withStructuredOutput(e, n) {
    const a = e, r = n?.name, i = n?.method, s = n?.includeRaw;
    let o, l;
    if (i === "jsonMode")
      o = this.bind({
        response_format: { type: "json_object" }
      }), Kj(a) ? l = Cd.fromZodSchema(a) : l = new Td();
    else {
      let h = r ?? "extract";
      if (Kj(a)) {
        const p = Cn(a);
        o = this.bind({
          tools: [
            {
              type: "function",
              function: {
                name: h,
                description: p.description,
                parameters: p
              }
            }
          ],
          tool_choice: "any"
        }), l = new Yu({
          returnSingle: !0,
          keyName: h,
          zodSchema: a
        });
      } else {
        let p;
        typeof a.name == "string" && typeof a.parameters == "object" && a.parameters != null ? (p = a, h = a.name) : p = {
          name: h,
          description: a.description ?? "",
          parameters: a
        }, o = this.bind({
          tools: [
            {
              type: "function",
              function: p
            }
          ],
          tool_choice: "any"
        }), l = new Yu({
          returnSingle: !0,
          keyName: h
        });
      }
    }
    if (!s)
      return o.pipe(l);
    const f = Mt.assign({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parsed: (h, p) => l.invoke(h.raw, p)
    }), u = Mt.assign({
      parsed: () => null
    }), c = f.withFallbacks({
      fallbacks: [u]
    });
    return dt.from([
      {
        raw: o
      },
      c
    ]);
  }
}
function Kj(t) {
  return typeof t?.parse == "function";
}
class PZ extends j_ {
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "modelName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mistral-embed"
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mistral-embed"
    }), Object.defineProperty(this, "encodingFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "float"
    }), Object.defineProperty(this, "batchSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 512
    }), Object.defineProperty(this, "stripNewLines", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "endpoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serverURL", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "beforeRequestHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "requestErrorHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "responseHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "httpClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const n = e?.apiKey ?? ft("MISTRAL_API_KEY");
    if (!n)
      throw new Error("API key missing for MistralAI, but it is required.");
    this.apiKey = n, this.serverURL = e?.serverURL ?? this.serverURL, this.modelName = e?.model ?? e?.modelName ?? this.model, this.model = this.modelName, this.encodingFormat = e?.encodingFormat ?? this.encodingFormat, this.batchSize = e?.batchSize ?? this.batchSize, this.stripNewLines = e?.stripNewLines ?? this.stripNewLines, this.beforeRequestHooks = e?.beforeRequestHooks ?? this.beforeRequestHooks, this.requestErrorHooks = e?.requestErrorHooks ?? this.requestErrorHooks, this.responseHooks = e?.responseHooks ?? this.responseHooks, this.httpClient = e?.httpClient ?? this.httpClient, this.addAllHooksToHttpClient();
  }
  /**
   * Method to generate embeddings for an array of documents. Splits the
   * documents into batches and makes requests to the MistralAI API to generate
   * embeddings.
   * @param {Array<string>} texts Array of documents to generate embeddings for.
   * @returns {Promise<number[][]>} Promise that resolves to a 2D array of embeddings for each document.
   */
  async embedDocuments(e) {
    const n = zh(this.stripNewLines ? e.map((s) => s.replace(/\n/g, " ")) : e, this.batchSize), a = n.map((s) => this.embeddingWithRetry(s)), r = await Promise.all(a), i = [];
    for (let s = 0; s < r.length; s += 1) {
      const o = n[s], { data: l } = r[s];
      for (let f = 0; f < o.length; f += 1)
        i.push(l[f].embedding ?? []);
    }
    return i;
  }
  /**
   * Method to generate an embedding for a single document. Calls the
   * embeddingWithRetry method with the document as the input.
   * @param {string} text Document to generate an embedding for.
   * @returns {Promise<number[]>} Promise that resolves to an embedding for the document.
   */
  async embedQuery(e) {
    const { data: n } = await this.embeddingWithRetry(this.stripNewLines ? e.replace(/\n/g, " ") : e);
    return n[0].embedding ?? [];
  }
  /**
   * Private method to make a request to the MistralAI API to generate
   * embeddings. Handles the retry logic and returns the response from the
   * API.
   * @param {string | Array<string>} inputs Text to send to the MistralAI API.
   * @returns {Promise<MistralAIEmbeddingsResponse>} Promise that resolves to the response from the API.
   */
  async embeddingWithRetry(e) {
    const { Mistral: n } = await this.imports(), a = new n({
      apiKey: this.apiKey,
      serverURL: this.serverURL,
      // If httpClient exists, pass it into constructor
      ...this.httpClient ? { httpClient: this.httpClient } : {}
    }), r = {
      model: this.model,
      inputs: e,
      encodingFormat: this.encodingFormat
    };
    return this.caller.call(async () => await a.embeddings.create(r));
  }
  addAllHooksToHttpClient() {
    try {
      if (this.removeAllHooksFromHttpClient(), [
        this.beforeRequestHooks,
        this.requestErrorHooks,
        this.responseHooks
      ].some((n) => n && n.length > 0) && !this.httpClient && (this.httpClient = new U$.HTTPClient()), this.beforeRequestHooks)
        for (const n of this.beforeRequestHooks)
          this.httpClient?.addHook("beforeRequest", n);
      if (this.requestErrorHooks)
        for (const n of this.requestErrorHooks)
          this.httpClient?.addHook("requestError", n);
      if (this.responseHooks)
        for (const n of this.responseHooks)
          this.httpClient?.addHook("response", n);
    } catch {
      throw new Error("Error in adding all hooks");
    }
  }
  removeAllHooksFromHttpClient() {
    try {
      if (this.beforeRequestHooks)
        for (const e of this.beforeRequestHooks)
          this.httpClient?.removeHook("beforeRequest", e);
      if (this.requestErrorHooks)
        for (const e of this.requestErrorHooks)
          this.httpClient?.removeHook("requestError", e);
      if (this.responseHooks)
        for (const e of this.responseHooks)
          this.httpClient?.removeHook("response", e);
    } catch {
      throw new Error("Error in removing hooks");
    }
  }
  removeHookFromHttpClient(e) {
    try {
      this.httpClient?.removeHook("beforeRequest", e), this.httpClient?.removeHook("requestError", e), this.httpClient?.removeHook("response", e);
    } catch {
      throw new Error("Error in removing hook");
    }
  }
  /** @ignore */
  async imports() {
    const { Mistral: e } = await Promise.resolve().then(() => rU);
    return { Mistral: e };
  }
}
const Au = "0.5.0";
let Hj = !1, td, x$, V$, pg, z$, Z$, K$, H$, G$;
function lU(t, e = { auto: !1 }) {
  if (Hj)
    throw new Error(`you must \`import 'groq-sdk/shims/${t.kind}'\` before importing anything else from groq-sdk`);
  if (td)
    throw new Error(`can't \`import 'groq-sdk/shims/${t.kind}'\` after \`import 'groq-sdk/shims/${td}'\``);
  Hj = e.auto, td = t.kind, x$ = t.fetch, V$ = t.FormData, pg = t.File, z$ = t.ReadableStream, Z$ = t.getMultipartRequestOptions, K$ = t.getDefaultAgent, H$ = t.fileFromPath, G$ = t.isFsReadStream;
}
let dU = class {
  constructor(e) {
    this.body = e;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};
function fU({ manuallyImported: t } = {}) {
  const e = t ? "You may need to use polyfills" : "Add one of these imports before your first `import  from 'groq-sdk'`:\n- `import 'groq-sdk/shims/node'` (if you're running on Node)\n- `import 'groq-sdk/shims/web'` (otherwise)\n";
  let n, a, r, i;
  try {
    n = fetch, a = Request, r = Response, i = Headers;
  } catch (s) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${s.message}. ${e}`);
  }
  return {
    kind: "web",
    fetch: n,
    Request: a,
    Response: r,
    Headers: i,
    FormData: (
      // @ts-ignore
      typeof FormData < "u" ? FormData : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`);
        }
      }
    ),
    Blob: typeof Blob < "u" ? Blob : class {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File < "u" ? File : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream < "u" ? ReadableStream : class {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`);
        }
      }
    ),
    getMultipartRequestOptions: async (s, o) => ({
      ...o,
      body: new dU(s)
    }),
    getDefaultAgent: (s) => {
    },
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/groq/groq-typescript#file-uploads");
    },
    isFsReadStream: (s) => !1
  };
}
td || lU(fU(), { auto: !0 });
class br extends Error {
}
let En = class mg extends br {
  constructor(e, n, a, r) {
    super(`${mg.makeMessage(e, n, a)}`), this.status = e, this.headers = r, this.error = n;
  }
  static makeMessage(e, n, a) {
    const r = n?.message ? typeof n.message == "string" ? n.message : JSON.stringify(n.message) : n ? JSON.stringify(n) : a;
    return e && r ? `${e} ${r}` : e ? `${e} status code (no body)` : r || "(no status code or body)";
  }
  static generate(e, n, a, r) {
    if (!e)
      return new Vp({ cause: yg(n) });
    const i = n;
    return e === 400 ? new X$(e, i, a, r) : e === 401 ? new Q$(e, i, a, r) : e === 403 ? new Y$(e, i, a, r) : e === 404 ? new eM(e, i, a, r) : e === 409 ? new tM(e, i, a, r) : e === 422 ? new nM(e, i, a, r) : e === 429 ? new rM(e, i, a, r) : e >= 500 ? new aM(e, i, a, r) : new mg(e, i, a, r);
  }
}, bg = class extends En {
  constructor({ message: e } = {}) {
    super(void 0, void 0, e || "Request was aborted.", void 0), this.status = void 0;
  }
}, Vp = class extends En {
  constructor({ message: e, cause: n }) {
    super(void 0, void 0, e || "Connection error.", void 0), this.status = void 0, n && (this.cause = n);
  }
}, W$ = class extends Vp {
  constructor({ message: e } = {}) {
    super({ message: e ?? "Request timed out." });
  }
}, X$ = class extends En {
  constructor() {
    super(...arguments), this.status = 400;
  }
}, Q$ = class extends En {
  constructor() {
    super(...arguments), this.status = 401;
  }
}, Y$ = class extends En {
  constructor() {
    super(...arguments), this.status = 403;
  }
}, eM = class extends En {
  constructor() {
    super(...arguments), this.status = 404;
  }
}, tM = class extends En {
  constructor() {
    super(...arguments), this.status = 409;
  }
}, nM = class extends En {
  constructor() {
    super(...arguments), this.status = 422;
  }
}, rM = class extends En {
  constructor() {
    super(...arguments), this.status = 429;
  }
}, aM = class extends En {
}, hU = class zl {
  constructor(e, n) {
    this.iterator = e, this.controller = n;
  }
  static fromSSEResponse(e, n) {
    let a = !1;
    const r = new pU();
    async function* i() {
      if (!e.body)
        throw n.abort(), new br("Attempted to iterate over a response with no body");
      const o = new Gh(), l = Gj(e.body);
      for await (const f of l)
        for (const u of o.decode(f)) {
          const c = r.decode(u);
          c && (yield c);
        }
      for (const f of o.flush()) {
        const u = r.decode(f);
        u && (yield u);
      }
    }
    async function* s() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let o = !1;
      try {
        for await (const l of i())
          if (!o) {
            if (l.data.startsWith("[DONE]")) {
              o = !0;
              continue;
            }
            if (l.event === null) {
              let f;
              try {
                f = JSON.parse(l.data);
              } catch (u) {
                throw console.error("Could not parse message into JSON:", l.data), console.error("From chunk:", l.raw), u;
              }
              if (f && f.error)
                throw new En(void 0, f.error, void 0, void 0);
              yield f;
            }
          }
        o = !0;
      } catch (l) {
        if (l instanceof Error && l.name === "AbortError")
          return;
        throw l;
      } finally {
        o || n.abort();
      }
    }
    return new zl(s, n);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(e, n) {
    let a = !1;
    async function* r() {
      const s = new Gh(), o = Gj(e);
      for await (const l of o)
        for (const f of s.decode(l))
          yield f;
      for (const l of s.flush())
        yield l;
    }
    async function* i() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let s = !1;
      try {
        for await (const o of r())
          s || o && (yield JSON.parse(o));
        s = !0;
      } catch (o) {
        if (o instanceof Error && o.name === "AbortError")
          return;
        throw o;
      } finally {
        s || n.abort();
      }
    }
    return new zl(i, n);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const e = [], n = [], a = this.iterator(), r = (i) => ({
      next: () => {
        if (i.length === 0) {
          const s = a.next();
          e.push(s), n.push(s);
        }
        return i.shift();
      }
    });
    return [
      new zl(() => r(e), this.controller),
      new zl(() => r(n), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const e = this;
    let n;
    const a = new TextEncoder();
    return new z$({
      async start() {
        n = e[Symbol.asyncIterator]();
      },
      async pull(r) {
        try {
          const { value: i, done: s } = await n.next();
          if (s)
            return r.close();
          const o = a.encode(JSON.stringify(i) + `
`);
          r.enqueue(o);
        } catch (i) {
          r.error(i);
        }
      },
      async cancel() {
        await n.return?.();
      }
    });
  }
}, pU = class {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(e) {
    if (e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e) {
      if (!this.event && !this.data.length)
        return null;
      const i = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], i;
    }
    if (this.chunks.push(e), e.startsWith(":"))
      return null;
    let [n, a, r] = mU(e, ":");
    return r.startsWith(" ") && (r = r.substring(1)), n === "event" ? this.event = r : n === "data" && this.data.push(r), null;
  }
}, Gh = class gg {
  constructor() {
    this.buffer = [], this.trailingCR = !1;
  }
  decode(e) {
    let n = this.decodeText(e);
    if (this.trailingCR && (n = "\r" + n, this.trailingCR = !1), n.endsWith("\r") && (this.trailingCR = !0, n = n.slice(0, -1)), !n)
      return [];
    const a = gg.NEWLINE_CHARS.has(n[n.length - 1] || "");
    let r = n.split(gg.NEWLINE_REGEXP);
    return r.length === 1 && !a ? (this.buffer.push(r[0]), []) : (this.buffer.length > 0 && (r = [this.buffer.join("") + r[0], ...r.slice(1)], this.buffer = []), a || (this.buffer = [r.pop() || ""]), r);
  }
  decodeText(e) {
    if (e == null)
      return "";
    if (typeof e == "string")
      return e;
    if (typeof Ke < "u") {
      if (e instanceof Ke)
        return e.toString();
      if (e instanceof Uint8Array)
        return Ke.from(e).toString();
      throw new br(`Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder < "u") {
      if (e instanceof Uint8Array || e instanceof ArrayBuffer)
        return this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8")), this.textDecoder.decode(e);
      throw new br(`Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new br("Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.");
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR)
      return [];
    const e = [this.buffer.join("")];
    return this.buffer = [], this.trailingCR = !1, e;
  }
};
Gh.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r", "\v", "\f", "", "", "", "", "\u2028", "\u2029"]);
Gh.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function mU(t, e) {
  const n = t.indexOf(e);
  return n !== -1 ? [t.substring(0, n), e, t.substring(n + e.length)] : [t, "", ""];
}
function Gj(t) {
  if (t[Symbol.asyncIterator])
    return t;
  const e = t.getReader();
  return {
    async next() {
      try {
        const n = await e.read();
        return n?.done && e.releaseLock(), n;
      } catch (n) {
        throw e.releaseLock(), n;
      }
    },
    async return() {
      const n = e.cancel();
      return e.releaseLock(), await n, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
const iM = (t) => t != null && typeof t == "object" && typeof t.url == "string" && typeof t.blob == "function", sM = (t) => t != null && typeof t == "object" && typeof t.name == "string" && typeof t.lastModified == "number" && Q_(t), Q_ = (t) => t != null && typeof t == "object" && typeof t.size == "number" && typeof t.type == "string" && typeof t.text == "function" && typeof t.slice == "function" && typeof t.arrayBuffer == "function", bU = (t) => sM(t) || iM(t) || G$(t);
async function oM(t, e, n) {
  if (t = await t, n ?? (n = sM(t) ? { lastModified: t.lastModified, type: t.type } : {}), iM(t)) {
    const r = await t.blob();
    return e || (e = new URL(t.url).pathname.split(/[\\/]/).pop() ?? "unknown_file"), new pg([r], e, n);
  }
  const a = await gU(t);
  if (e || (e = yU(t) ?? "unknown_file"), !n.type) {
    const r = a[0]?.type;
    typeof r == "string" && (n = { ...n, type: r });
  }
  return new pg(a, e, n);
}
async function gU(t) {
  let e = [];
  if (typeof t == "string" || ArrayBuffer.isView(t) || // includes Uint8Array, Buffer, etc.
  t instanceof ArrayBuffer)
    e.push(t);
  else if (Q_(t))
    e.push(await t.arrayBuffer());
  else if (wU(t))
    for await (const n of t)
      e.push(n);
  else
    throw new Error(`Unexpected data type: ${typeof t}; constructor: ${t?.constructor?.name}; props: ${_U(t)}`);
  return e;
}
function _U(t) {
  return `[${Object.getOwnPropertyNames(t).map((n) => `"${n}"`).join(", ")}]`;
}
function yU(t) {
  return db(t.name) || db(t.filename) || // For fs.ReadStream
  db(t.path)?.split(/[\\/]/).pop();
}
const db = (t) => {
  if (typeof t == "string")
    return t;
  if (typeof Ke < "u" && t instanceof Ke)
    return String(t);
}, wU = (t) => t != null && typeof t == "object" && typeof t[Symbol.asyncIterator] == "function", Wj = (t) => t && typeof t == "object" && t.body && t[Symbol.toStringTag] === "MultipartBody", uM = async (t) => {
  const e = await vU(t.body);
  return Z$(e, t);
}, vU = async (t) => {
  const e = new V$();
  return await Promise.all(Object.entries(t || {}).map(([n, a]) => _g(e, n, a))), e;
}, _g = async (t, e, n) => {
  if (n !== void 0) {
    if (n == null)
      throw new TypeError(`Received null for "${e}"; to pass null in FormData, you must use the string 'null'`);
    if (typeof n == "string" || typeof n == "number" || typeof n == "boolean")
      t.append(e, String(n));
    else if (bU(n)) {
      const a = await oM(n);
      t.append(e, a);
    } else if (Array.isArray(n))
      await Promise.all(n.map((a) => _g(t, e + "[]", a)));
    else if (typeof n == "object")
      await Promise.all(Object.entries(n).map(([a, r]) => _g(t, `${e}[${a}]`, r)));
    else
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${n} instead`);
  }
};
async function cM(t) {
  const { response: e } = t;
  if (t.options.stream)
    return Zu("response", e.status, e.url, e.headers, e.body), t.options.__streamClass ? t.options.__streamClass.fromSSEResponse(e, t.controller) : hU.fromSSEResponse(e, t.controller);
  if (e.status === 204)
    return null;
  if (t.options.__binaryResponse)
    return e;
  const n = e.headers.get("content-type");
  if (n?.includes("application/json") || n?.includes("application/vnd.api+json")) {
    const i = await e.json();
    return Zu("response", e.status, e.url, e.headers, i), i;
  }
  const r = await e.text();
  return Zu("response", e.status, e.url, e.headers, r), r;
}
let lM = class dM extends Promise {
  constructor(e, n = cM) {
    super((a) => {
      a(null);
    }), this.responsePromise = e, this.parseResponse = n;
  }
  _thenUnwrap(e) {
    return new dM(this.responsePromise, async (n) => e(await this.parseResponse(n)));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'groq-sdk'`:
   * - `import 'groq-sdk/shims/node'` (if you're running on Node)
   * - `import 'groq-sdk/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((e) => e.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'groq-sdk'`:
   * - `import 'groq-sdk/shims/node'` (if you're running on Node)
   * - `import 'groq-sdk/shims/web'` (otherwise)
   */
  async withResponse() {
    const [e, n] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: e, response: n };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)), this.parsedPromise;
  }
  then(e, n) {
    return this.parse().then(e, n);
  }
  catch(e) {
    return this.parse().catch(e);
  }
  finally(e) {
    return this.parse().finally(e);
  }
}, SU = class {
  constructor({
    baseURL: e,
    maxRetries: n = 2,
    timeout: a = 6e4,
    // 1 minute
    httpAgent: r,
    fetch: i
  }) {
    this.baseURL = e, this.maxRetries = fb("maxRetries", n), this.timeout = fb("timeout", a), this.httpAgent = r, this.fetch = i ?? x$;
  }
  authHeaders(e) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(e) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...CU(),
      ...this.authHeaders(e)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(e, n) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${NU()}`;
  }
  get(e, n) {
    return this.methodRequest("get", e, n);
  }
  post(e, n) {
    return this.methodRequest("post", e, n);
  }
  patch(e, n) {
    return this.methodRequest("patch", e, n);
  }
  put(e, n) {
    return this.methodRequest("put", e, n);
  }
  delete(e, n) {
    return this.methodRequest("delete", e, n);
  }
  methodRequest(e, n, a) {
    return this.request(Promise.resolve(a).then(async (r) => {
      const i = r && Q_(r?.body) ? new DataView(await r.body.arrayBuffer()) : r?.body instanceof DataView ? r.body : r?.body instanceof ArrayBuffer ? new DataView(r.body) : r && ArrayBuffer.isView(r?.body) ? new DataView(r.body.buffer) : r?.body;
      return { method: e, path: n, ...r, body: i };
    }));
  }
  getAPIList(e, n, a) {
    return this.requestAPIList(n, { method: "get", path: e, ...a });
  }
  calculateContentLength(e) {
    if (typeof e == "string") {
      if (typeof Ke < "u")
        return Ke.byteLength(e, "utf8").toString();
      if (typeof TextEncoder < "u")
        return new TextEncoder().encode(e).length.toString();
    } else if (ArrayBuffer.isView(e))
      return e.byteLength.toString();
    return null;
  }
  buildRequest(e) {
    const { method: n, path: a, query: r, headers: i = {} } = e, s = ArrayBuffer.isView(e.body) || e.__binaryRequest && typeof e.body == "string" ? e.body : Wj(e.body) ? e.body.body : e.body ? JSON.stringify(e.body, null, 2) : null, o = this.calculateContentLength(s), l = this.buildURL(a, r);
    "timeout" in e && fb("timeout", e.timeout);
    const f = e.timeout ?? this.timeout, u = e.httpAgent ?? this.httpAgent ?? K$(l), c = f + 1e3;
    typeof u?.options?.timeout == "number" && c > (u.options.timeout ?? 0) && (u.options.timeout = c), this.idempotencyHeader && n !== "get" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()), i[this.idempotencyHeader] = e.idempotencyKey);
    const h = this.buildHeaders({ options: e, headers: i, contentLength: o });
    return { req: {
      method: n,
      ...s && { body: s },
      headers: h,
      ...u && { agent: u },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: e.signal ?? null
    }, url: l, timeout: f };
  }
  buildHeaders({ options: e, headers: n, contentLength: a }) {
    const r = {};
    a && (r["content-length"] = a);
    const i = this.defaultHeaders(e);
    return tP(r, i), tP(r, n), Wj(e.body) && td !== "node" && delete r["content-type"], this.validateHeaders(r, n), r;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(e) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(e, { url: n, options: a }) {
  }
  parseHeaders(e) {
    return e ? Symbol.iterator in e ? Object.fromEntries(Array.from(e).map((n) => [...n])) : { ...e } : {};
  }
  makeStatusError(e, n, a, r) {
    return En.generate(e, n, a, r);
  }
  request(e, n = null) {
    return new lM(this.makeRequest(e, n));
  }
  async makeRequest(e, n) {
    const a = await e;
    n == null && (n = a.maxRetries ?? this.maxRetries), await this.prepareOptions(a);
    const { req: r, url: i, timeout: s } = this.buildRequest(a);
    if (await this.prepareRequest(r, { url: i, options: a }), Zu("request", i, a, r.headers), a.signal?.aborted)
      throw new bg();
    const o = new AbortController(), l = await this.fetchWithTimeout(i, r, s, o).catch(yg);
    if (l instanceof Error) {
      if (a.signal?.aborted)
        throw new bg();
      if (n)
        return this.retryRequest(a, n);
      throw l.name === "AbortError" ? new W$() : new Vp({ cause: l });
    }
    const f = jU(l.headers);
    if (!l.ok) {
      if (n && this.shouldRetry(l)) {
        const m = `retrying, ${n} attempts remaining`;
        return Zu(`response (error; ${m})`, l.status, i, f), this.retryRequest(a, n, f);
      }
      const u = await l.text().catch((m) => yg(m).message), c = TU(u), h = c ? void 0 : u;
      throw Zu(`response (error; ${n ? "(error; no more retries left)" : "(error; not retryable)"})`, l.status, i, f, h), this.makeStatusError(l.status, c, h, f);
    }
    return { response: l, options: a, controller: o };
  }
  requestAPIList(e, n) {
    const a = this.makeRequest(n, null);
    return new OU(this, a, e);
  }
  buildURL(e, n) {
    const a = MU(e) ? new URL(e) : new URL(this.baseURL + (this.baseURL.endsWith("/") && e.startsWith("/") ? e.slice(1) : e)), r = this.defaultQuery();
    return EU(r) || (n = { ...r, ...n }), typeof n == "object" && n && !Array.isArray(n) && (a.search = this.stringifyQuery(n)), a.toString();
  }
  stringifyQuery(e) {
    return Object.entries(e).filter(([n, a]) => typeof a < "u").map(([n, a]) => {
      if (typeof a == "string" || typeof a == "number" || typeof a == "boolean")
        return `${encodeURIComponent(n)}=${encodeURIComponent(a)}`;
      if (a === null)
        return `${encodeURIComponent(n)}=`;
      throw new br(`Cannot stringify type ${typeof a}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(e, n, a, r) {
    const { signal: i, ...s } = n || {};
    i && i.addEventListener("abort", () => r.abort());
    const o = setTimeout(() => r.abort(), a);
    return this.getRequestClient().fetch.call(void 0, e, { signal: r.signal, ...s }).finally(() => {
      clearTimeout(o);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(e) {
    const n = e.headers.get("x-should-retry");
    return n === "true" ? !0 : n === "false" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500;
  }
  async retryRequest(e, n, a) {
    let r;
    const i = a?.["retry-after-ms"];
    if (i) {
      const o = parseFloat(i);
      Number.isNaN(o) || (r = o);
    }
    const s = a?.["retry-after"];
    if (s && !r) {
      const o = parseFloat(s);
      Number.isNaN(o) ? r = Date.parse(s) - Date.now() : r = o * 1e3;
    }
    if (!(r && 0 <= r && r < 60 * 1e3)) {
      const o = e.maxRetries ?? this.maxRetries;
      r = this.calculateDefaultRetryTimeoutMillis(n, o);
    }
    return await AU(r), this.makeRequest(e, n - 1);
  }
  calculateDefaultRetryTimeoutMillis(e, n) {
    const i = n - e, s = Math.min(0.5 * Math.pow(2, i), 8), o = 1 - Math.random() * 0.25;
    return s * o * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${Au}`;
  }
}, OU = class extends lM {
  constructor(e, n, a) {
    super(n, async (r) => new a(e, r.response, await cM(r), r.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const e = await this;
    for await (const n of e)
      yield n;
  }
};
const jU = (t) => new Proxy(Object.fromEntries(
  // @ts-ignore
  t.entries()
), {
  get(e, n) {
    const a = n.toString();
    return e[a.toLowerCase()] || e[a];
  }
}), PU = () => {
  if (typeof Deno < "u" && Deno.build != null)
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Au,
      "X-Stainless-OS": Qj(Deno.build.os),
      "X-Stainless-Arch": Xj(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Au,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": ue.version
    };
  if (Object.prototype.toString.call(typeof ue < "u" ? ue : 0) === "[object process]")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Au,
      "X-Stainless-OS": Qj(ue.platform),
      "X-Stainless-Arch": Xj(ue.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": ue.version
    };
  const t = RU();
  return t ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Au,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${t.browser}`,
    "X-Stainless-Runtime-Version": t.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Au,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function RU() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const t = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: e, pattern: n } of t) {
    const a = n.exec(navigator.userAgent);
    if (a) {
      const r = a[1] || 0, i = a[2] || 0, s = a[3] || 0;
      return { browser: e, version: `${r}.${i}.${s}` };
    }
  }
  return null;
}
const Xj = (t) => t === "x32" ? "x32" : t === "x86_64" || t === "x64" ? "x64" : t === "arm" ? "arm" : t === "aarch64" || t === "arm64" ? "arm64" : t ? `other:${t}` : "unknown", Qj = (t) => (t = t.toLowerCase(), t.includes("ios") ? "iOS" : t === "android" ? "Android" : t === "darwin" ? "MacOS" : t === "win32" ? "Windows" : t === "freebsd" ? "FreeBSD" : t === "openbsd" ? "OpenBSD" : t === "linux" ? "Linux" : t ? `Other:${t}` : "Unknown");
let Yj;
const CU = () => Yj ?? (Yj = PU()), TU = (t) => {
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}, $U = new RegExp("^(?:[a-z]+:)?//", "i"), MU = (t) => $U.test(t), AU = (t) => new Promise((e) => setTimeout(e, t)), fb = (t, e) => {
  if (typeof e != "number" || !Number.isInteger(e))
    throw new br(`${t} must be an integer`);
  if (e < 0)
    throw new br(`${t} must be a positive integer`);
  return e;
}, yg = (t) => t instanceof Error ? t : new Error(t), eP = (t) => {
  if (typeof ue < "u")
    return ue.env?.[t]?.trim() ?? void 0;
  if (typeof Deno < "u")
    return Deno.env?.get?.(t)?.trim();
};
function EU(t) {
  if (!t)
    return !0;
  for (const e in t)
    return !1;
  return !0;
}
function IU(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function tP(t, e) {
  for (const n in e) {
    if (!IU(e, n))
      continue;
    const a = n.toLowerCase();
    if (!a)
      continue;
    const r = e[n];
    r === null ? delete t[a] : r !== void 0 && (t[a] = r);
  }
}
function Zu(t, ...e) {
  typeof ue < "u" && ue?.env?.DEBUG === "true" && console.log(`Groq:DEBUG:${t}`, ...e);
}
const NU = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
  const e = Math.random() * 16 | 0;
  return (t === "x" ? e : e & 3 | 8).toString(16);
}), kU = () => (
  // @ts-ignore
  typeof window < "u" && // @ts-ignore
  typeof window.document < "u" && // @ts-ignore
  typeof navigator < "u"
);
let vo = class {
  constructor(e) {
    this._client = e;
  }
};
class Wh extends vo {
  /**
   * Transcribes audio into the input language.
   */
  create(e, n) {
    return this._client.post("/openai/v1/audio/transcriptions", uM({ body: e, ...n }));
  }
}
Wh || (Wh = {});
class Xh extends vo {
  /**
   * Translates audio into English.
   */
  create(e, n) {
    return this._client.post("/openai/v1/audio/translations", uM({ body: e, ...n }));
  }
}
Xh || (Xh = {});
class Qh extends vo {
  constructor() {
    super(...arguments), this.transcriptions = new Wh(this._client), this.translations = new Xh(this._client);
  }
}
(function(t) {
  t.Transcriptions = Wh, t.Translations = Xh;
})(Qh || (Qh = {}));
let Yh = class extends vo {
  create(e, n) {
    return this._client.post("/openai/v1/chat/completions", {
      body: e,
      ...n,
      stream: e.stream ?? !1
    });
  }
};
Yh || (Yh = {});
let ep = class extends vo {
  constructor() {
    super(...arguments), this.completions = new Yh(this._client);
  }
};
(function(t) {
  t.Completions = Yh;
})(ep || (ep = {}));
let tp = class extends vo {
};
tp || (tp = {});
class np extends vo {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(e, n) {
    return this._client.post("/openai/v1/embeddings", { body: e, ...n });
  }
}
np || (np = {});
let rp = class extends vo {
  /**
   * Get a specific model
   */
  retrieve(e, n) {
    return this._client.get(`/openai/v1/models/${e}`, n);
  }
  /**
   * get all available models
   */
  list(e) {
    return this._client.get("/openai/v1/models", e);
  }
  /**
   * Delete a model
   */
  delete(e, n) {
    return this._client.delete(`/openai/v1/models/${e}`, n);
  }
};
rp || (rp = {});
var fM;
class ht extends SU {
  /**
   * API Client for interfacing with the Groq API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['GROQ_API_KEY'] ?? undefined]
   * @param {string} [opts.baseURL=process.env['GROQ_BASE_URL'] ?? https://api.groq.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL: e = eP("GROQ_BASE_URL"), apiKey: n = eP("GROQ_API_KEY"), ...a } = {}) {
    if (n === void 0)
      throw new br("The GROQ_API_KEY environment variable is missing or empty; either provide it, or instantiate the Groq client with an apiKey option, like new Groq({ apiKey: 'My API Key' }).");
    const r = {
      apiKey: n,
      ...a,
      baseURL: e || "https://api.groq.com"
    };
    if (!r.dangerouslyAllowBrowser && kU())
      throw new br(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new Groq({ apiKey, dangerouslyAllowBrowser: true })`);
    super({
      baseURL: r.baseURL,
      timeout: r.timeout ?? 6e4,
      httpAgent: r.httpAgent,
      maxRetries: r.maxRetries,
      fetch: r.fetch
    }), this.completions = new tp(this), this.chat = new ep(this), this.embeddings = new np(this), this.audio = new Qh(this), this.models = new rp(this), this._options = r, this.apiKey = n;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(e) {
    return {
      ...super.defaultHeaders(e),
      ...this._options.defaultHeaders
    };
  }
  authHeaders(e) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
}
fM = ht;
ht.Groq = fM;
ht.GroqError = br;
ht.APIError = En;
ht.APIConnectionError = Vp;
ht.APIConnectionTimeoutError = W$;
ht.APIUserAbortError = bg;
ht.NotFoundError = eM;
ht.ConflictError = tM;
ht.RateLimitError = rM;
ht.BadRequestError = X$;
ht.AuthenticationError = Q$;
ht.InternalServerError = aM;
ht.PermissionDeniedError = Y$;
ht.UnprocessableEntityError = nM;
ht.toFile = oM;
ht.fileFromPath = H$;
(function(t) {
  t.Completions = tp, t.Chat = ep, t.Embeddings = np, t.Audio = Qh, t.Models = rp;
})(ht || (ht = {}));
function FU(t) {
  const e = t._getType();
  switch (e) {
    case "system":
      return "system";
    case "ai":
      return "assistant";
    case "human":
      return "user";
    case "function":
      return "function";
    case "tool":
      return "tool";
    default:
      throw new Error(`Unknown message type: ${e}`);
  }
}
function nP(t) {
  return t.map((e) => {
    if (typeof e.content != "string")
      throw new Error("Non string message content not supported");
    const n = {
      role: FU(e),
      content: e.content,
      name: e.name,
      function_call: e.additional_kwargs.function_call,
      tool_calls: e.additional_kwargs.tool_calls,
      tool_call_id: e.tool_call_id
    };
    return Vs(e) && e.tool_calls?.length ? n.tool_calls = e.tool_calls.map(__) : (e.additional_kwargs.tool_calls != null && (n.tool_calls = e.additional_kwargs.tool_calls), e.tool_call_id != null && (n.tool_call_id = e.tool_call_id)), n;
  });
}
function DU(t, e) {
  const n = t.tool_calls;
  switch (t.role) {
    case "assistant": {
      const a = [], r = [];
      for (const i of n ?? [])
        try {
          a.push(Hd(i, { returnId: !0 }));
        } catch (s) {
          r.push($p(i, s.message));
        }
      return new $t({
        content: t.content || "",
        additional_kwargs: { tool_calls: n },
        tool_calls: a,
        invalid_tool_calls: r,
        usage_metadata: e
      });
    }
    default:
      return new yo(t.content || "", t.role ?? "unknown");
  }
}
function qU(t, e) {
  if (t?.length)
    return t.map((n) => ({
      id: n.id,
      name: n.function?.name,
      args: n.function?.arguments,
      type: "tool_call_chunk",
      index: e
    }));
}
function JU(t, e, n) {
  const { role: a } = t, r = t.content ?? "";
  let i;
  t.function_call ? i = {
    function_call: t.function_call
  } : t.tool_calls ? i = {
    tool_calls: t.tool_calls
  } : i = {};
  let s, o;
  if (n?.usage && (s = {
    input_tokens: n.usage.prompt_tokens,
    output_tokens: n.usage.completion_tokens,
    total_tokens: n.usage.total_tokens
  }, o = n.id), a === "user")
    return {
      message: new uc({ content: r })
    };
  if (a === "assistant") {
    const l = qU(t.tool_calls, e);
    return {
      message: new Ze({
        content: r,
        additional_kwargs: i,
        tool_call_chunks: l ? l.map((f) => ({
          type: f.type,
          args: f.args,
          index: f.index
        })) : void 0,
        usage_metadata: s,
        id: o
      }),
      toolCallData: l ? l.map((f) => ({
        id: f.id ?? "",
        name: f.name ?? "",
        index: f.index ?? e,
        type: "tool_call_chunk"
      })) : void 0
    };
  } else return a === "system" ? {
    message: new Hu({ content: r })
  } : {
    message: new oc({ content: r, role: a })
  };
}
class WZ extends Sn {
  static lc_name() {
    return "ChatGroq";
  }
  _llmType() {
    return "groq";
  }
  get lc_secrets() {
    return {
      apiKey: "GROQ_API_KEY"
    };
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "chat_models", "groq"]
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0.7
    }), Object.defineProperty(this, "stop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stopSequences", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
    const n = e.apiKey || ft("GROQ_API_KEY");
    if (!n)
      throw new Error('Groq API key not found. Please set the GROQ_API_KEY environment variable or provide the key into "apiKey"');
    const a = {
      "User-Agent": "langchainjs",
      ...e.defaultHeaders ?? {}
    };
    this.client = new ht({
      apiKey: n,
      dangerouslyAllowBrowser: !0,
      baseURL: e.baseUrl,
      timeout: e.timeout,
      httpAgent: e.httpAgent,
      fetch: e.fetch,
      maxRetries: 0,
      defaultHeaders: a,
      defaultQuery: e.defaultQuery
    }), this.apiKey = n, this.temperature = e.temperature ?? this.temperature, this.model = e.model, this.streaming = e.streaming ?? this.streaming, this.stop = e.stopSequences ?? (typeof e.stop == "string" ? [e.stop] : e.stop) ?? [], this.stopSequences = this.stop, this.maxTokens = e.maxTokens;
  }
  getLsParams(e) {
    const n = this.invocationParams(e);
    return {
      ls_provider: "groq",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: n.temperature ?? this.temperature,
      ls_max_tokens: n.max_tokens ?? this.maxTokens,
      ls_stop: e.stop
    };
  }
  async completionWithRetry(e, n) {
    return this.caller.call(async () => this.client.chat.completions.create(e, n));
  }
  invocationParams(e) {
    const n = super.invocationParams(e);
    return e.tool_choice !== void 0 && (n.tool_choice = e.tool_choice), e.tools !== void 0 && (n.tools = e.tools), e.response_format !== void 0 && (n.response_format = e.response_format), {
      ...n,
      stop: e.stop ?? this.stopSequences,
      model: this.model,
      temperature: this.temperature,
      max_tokens: this.maxTokens
    };
  }
  bindTools(e, n) {
    return this.bind({
      tools: e.map((a) => $d(a)),
      ...n
    });
  }
  async *_streamResponseChunks(e, n, a) {
    const r = this.invocationParams(n), i = nP(e), s = await this.completionWithRetry({
      ...r,
      messages: i,
      stream: !0
    }, {
      signal: n?.signal,
      headers: n?.headers
    });
    let o = "";
    const l = [];
    let f;
    for await (const u of s) {
      f = u;
      const c = u?.choices[0];
      if (!c)
        continue;
      c.delta?.role && (o = c.delta.role);
      const { message: h, toolCallData: p } = JU({
        ...c.delta,
        role: o
      }, c.index, u.x_groq);
      if (p) {
        const m = p.filter((b) => l.every((g) => g.id !== b.id));
        l.push(...m), yield new Bt({
          message: new Ze({
            content: "",
            tool_call_chunks: m
          }),
          text: ""
        });
      }
      const d = new Bt({
        message: h,
        text: c.delta.content ?? "",
        generationInfo: {
          finishReason: c.finish_reason
        }
      });
      yield d, a?.handleLLMNewToken(d.text ?? "");
    }
    if (f && ("choices" in f && delete f.choices, yield new Bt({
      message: new Ze({
        content: "",
        response_metadata: f
      }),
      text: ""
    })), n.signal?.aborted)
      throw new Error("AbortError");
  }
  async _generate(e, n, a) {
    if (this.streaming) {
      const r = {}, i = this._streamResponseChunks(e, n, a), s = {};
      for await (const l of i) {
        const f = l.generationInfo?.completion ?? 0;
        s[f] === void 0 ? s[f] = l : s[f] = s[f].concat(l);
      }
      return { generations: Object.entries(s).sort(([l], [f]) => parseInt(l, 10) - parseInt(f, 10)).map(([l, f]) => f), llmOutput: { estimatedTokenUsage: r } };
    } else
      return this._generateNonStreaming(e, n, a);
  }
  async _generateNonStreaming(e, n, a) {
    const r = {}, i = this.invocationParams(n), s = nP(e), o = await this.completionWithRetry({
      ...i,
      stream: !1,
      messages: s
    }, {
      signal: n?.signal,
      headers: n?.headers
    });
    if ("usage" in o && o.usage) {
      const { completion_tokens: f, prompt_tokens: u, total_tokens: c } = o.usage;
      f && (r.completionTokens = (r.completionTokens ?? 0) + f), u && (r.promptTokens = (r.promptTokens ?? 0) + u), c && (r.totalTokens = (r.totalTokens ?? 0) + c);
    }
    const l = [];
    if ("choices" in o && o.choices)
      for (const f of o.choices) {
        const u = f.message?.content ?? "";
        let c;
        r.totalTokens !== void 0 && (c = {
          input_tokens: r.promptTokens ?? 0,
          output_tokens: r.completionTokens ?? 0,
          total_tokens: r.totalTokens
        });
        const h = {
          text: u,
          message: DU(f.message ?? { role: "assistant" }, c)
        };
        h.generationInfo = {
          ...f.finish_reason ? { finish_reason: f.finish_reason } : {},
          ...f.logprobs ? { logprobs: f.logprobs } : {}
        }, l.push(h);
      }
    return {
      generations: l,
      llmOutput: { tokenUsage: r }
    };
  }
  withStructuredOutput(e, n) {
    const a = e, r = n?.name, i = n?.method, s = n?.includeRaw;
    let o = r ?? "extract", l, f;
    if (i === "jsonMode")
      f = this.bind({
        response_format: { type: "json_object" }
      }), eu(a) ? l = Cd.fromZodSchema(a) : l = new Td();
    else if (eu(a)) {
      const p = Cn(a);
      f = this.bind({
        tools: [
          {
            type: "function",
            function: {
              name: o,
              description: p.description,
              parameters: p
            }
          }
        ],
        tool_choice: {
          type: "function",
          function: {
            name: o
          }
        }
      }), l = new Yu({
        returnSingle: !0,
        keyName: o,
        zodSchema: a
      });
    } else {
      let p;
      typeof a.name == "string" && typeof a.parameters == "object" && a.parameters != null ? (p = a, o = a.name) : (o = a.title ?? o, p = {
        name: o,
        description: a.description ?? "",
        parameters: a
      }), f = this.bind({
        tools: [
          {
            type: "function",
            function: p
          }
        ],
        tool_choice: {
          type: "function",
          function: {
            name: o
          }
        }
      }), l = new Yu({
        returnSingle: !0,
        keyName: o
      });
    }
    if (!s)
      return f.pipe(l).withConfig({
        runName: "ChatGroqStructuredOutput"
      });
    const u = Mt.assign({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parsed: (p, d) => l.invoke(p.raw, d)
    }), c = Mt.assign({
      parsed: () => null
    }), h = u.withFallbacks({
      fallbacks: [c]
    });
    return dt.from([
      {
        raw: f
      },
      h
    ]).withConfig({
      runName: "ChatGroqStructuredOutput"
    });
  }
}
const Eu = "1.26.0";
let rP = !1, nd, hM, wg, pM, mM, bM;
function LU(t, e = { auto: !1 }) {
  if (rP)
    throw new Error(`you must \`import '@cerebras/cerebras_cloud_sdk/shims/${t.kind}'\` before importing anything else from @cerebras/cerebras_cloud_sdk`);
  if (nd)
    throw new Error(`can't \`import '@cerebras/cerebras_cloud_sdk/shims/${t.kind}'\` after \`import '@cerebras/cerebras_cloud_sdk/shims/${nd}'\``);
  rP = e.auto, nd = t.kind, hM = t.fetch, wg = t.File, pM = t.ReadableStream, mM = t.getDefaultAgent, bM = t.fileFromPath;
}
class UU {
  constructor(e) {
    this.body = e;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
}
function BU({ manuallyImported: t } = {}) {
  const e = t ? "You may need to use polyfills" : "Add one of these imports before your first `import  from '@cerebras/cerebras_cloud_sdk'`:\n- `import '@cerebras/cerebras_cloud_sdk/shims/node'` (if you're running on Node)\n- `import '@cerebras/cerebras_cloud_sdk/shims/web'` (otherwise)\n";
  let n, a, r, i;
  try {
    n = fetch, a = Request, r = Response, i = Headers;
  } catch (s) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${s.message}. ${e}`);
  }
  return {
    kind: "web",
    fetch: n,
    Request: a,
    Response: r,
    Headers: i,
    FormData: (
      // @ts-ignore
      typeof FormData < "u" ? FormData : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`);
        }
      }
    ),
    Blob: typeof Blob < "u" ? Blob : class {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File < "u" ? File : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream < "u" ? ReadableStream : class {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`);
        }
      }
    ),
    getMultipartRequestOptions: async (s, o) => ({
      ...o,
      body: new UU(s)
    }),
    getDefaultAgent: (s) => {
    },
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/Cerebras/cerebras-cloud-sdk-node#file-uploads");
    },
    isFsReadStream: (s) => !1
  };
}
nd || LU(BU(), { auto: !0 });
class la extends Error {
}
class Nt extends la {
  constructor(e, n, a, r) {
    super(`${Nt.makeMessage(e, n, a)}`), this.status = e, this.headers = r, this.error = n;
  }
  static makeMessage(e, n, a) {
    const r = n?.message ? typeof n.message == "string" ? n.message : JSON.stringify(n.message) : n ? JSON.stringify(n) : a;
    return e && r ? `${e} ${r}` : e ? `${e} status code (no body)` : r || "(no status code or body)";
  }
  static generate(e, n, a, r) {
    if (e === void 0 || r === void 0)
      return new zp({ message: a, cause: Sg(n) });
    const i = n;
    return e === 400 ? new _M(e, i, a, r) : e === 401 ? new yM(e, i, a, r) : e === 403 ? new wM(e, i, a, r) : e === 404 ? new vM(e, i, a, r) : e === 409 ? new SM(e, i, a, r) : e === 422 ? new OM(e, i, a, r) : e === 429 ? new jM(e, i, a, r) : e >= 500 ? new PM(e, i, a, r) : new Nt(e, i, a, r);
  }
}
class vg extends Nt {
  constructor({ message: e } = {}) {
    super(void 0, void 0, e || "Request was aborted.", void 0);
  }
}
class zp extends Nt {
  constructor({ message: e, cause: n }) {
    super(void 0, void 0, e || "Connection error.", void 0), n && (this.cause = n);
  }
}
class gM extends zp {
  constructor({ message: e } = {}) {
    super({ message: e ?? "Request timed out." });
  }
}
class _M extends Nt {
}
class yM extends Nt {
}
class wM extends Nt {
}
class vM extends Nt {
}
class SM extends Nt {
}
class OM extends Nt {
}
class jM extends Nt {
}
class PM extends Nt {
}
class qu {
  constructor(e, n) {
    this.iterator = e, this.controller = n;
  }
  static fromSSEResponse(e, n) {
    let a = !1;
    async function* r() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let i = !1;
      try {
        for await (const s of xU(e, n))
          if (!i) {
            if (s.data.startsWith("[DONE]")) {
              i = !0;
              continue;
            }
            if (s.event === null) {
              let o;
              try {
                o = JSON.parse(s.data);
              } catch (l) {
                throw console.error("Could not parse message into JSON:", s.data), console.error("From chunk:", s.raw), l;
              }
              if (o && o.error) {
                const l = o.status_code || 0;
                throw Nt.generate(l, o.error, void 0, void 0);
              }
              yield o;
            } else {
              let o;
              try {
                o = JSON.parse(s.data);
              } catch (l) {
                throw console.error("Could not parse message into JSON:", s.data), console.error("From chunk:", s.raw), l;
              }
              if (s.event == "error") {
                const l = o.status_code || 0;
                throw Nt.generate(l, o.error, void 0, void 0);
              }
              yield { event: s.event, data: o };
            }
          }
        i = !0;
      } catch (s) {
        if (s instanceof Error && s.name === "AbortError")
          return;
        throw s;
      } finally {
        i || n.abort();
      }
    }
    return new qu(r, n);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(e, n) {
    let a = !1;
    async function* r() {
      const s = new tu(), o = RM(e);
      for await (const l of o)
        for (const f of s.decode(l))
          yield f;
      for (const l of s.flush())
        yield l;
    }
    async function* i() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let s = !1;
      try {
        for await (const o of r())
          s || o && (yield JSON.parse(o));
        s = !0;
      } catch (o) {
        if (o instanceof Error && o.name === "AbortError")
          return;
        throw o;
      } finally {
        s || n.abort();
      }
    }
    return new qu(i, n);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const e = [], n = [], a = this.iterator(), r = (i) => ({
      next: () => {
        if (i.length === 0) {
          const s = a.next();
          e.push(s), n.push(s);
        }
        return i.shift();
      }
    });
    return [
      new qu(() => r(e), this.controller),
      new qu(() => r(n), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const e = this;
    let n;
    const a = new TextEncoder();
    return new pM({
      async start() {
        n = e[Symbol.asyncIterator]();
      },
      async pull(r) {
        try {
          const { value: i, done: s } = await n.next();
          if (s)
            return r.close();
          const o = a.encode(JSON.stringify(i) + `
`);
          r.enqueue(o);
        } catch (i) {
          r.error(i);
        }
      },
      async cancel() {
        await n.return?.();
      }
    });
  }
}
async function* xU(t, e) {
  if (!t.body)
    throw e.abort(), new la("Attempted to iterate over a response with no body");
  const n = new ZU(), a = new tu(), r = RM(t.body);
  for await (const i of VU(r))
    for (const s of a.decode(i)) {
      const o = n.decode(s);
      o && (yield o);
    }
  for (const i of a.flush()) {
    const s = n.decode(i);
    s && (yield s);
  }
}
async function* VU(t) {
  let e = new Uint8Array();
  for await (const n of t) {
    if (n == null)
      continue;
    const a = n instanceof ArrayBuffer ? new Uint8Array(n) : typeof n == "string" ? new TextEncoder().encode(n) : n;
    let r = new Uint8Array(e.length + a.length);
    r.set(e), r.set(a, e.length), e = r;
    let i;
    for (; (i = zU(e)) !== -1; )
      yield e.slice(0, i), e = e.slice(i);
  }
  e.length > 0 && (yield e);
}
function zU(t) {
  for (let a = 0; a < t.length - 2; a++) {
    if (t[a] === 10 && t[a + 1] === 10 || t[a] === 13 && t[a + 1] === 13)
      return a + 2;
    if (t[a] === 13 && t[a + 1] === 10 && a + 3 < t.length && t[a + 2] === 13 && t[a + 3] === 10)
      return a + 4;
  }
  return -1;
}
class ZU {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(e) {
    if (e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e) {
      if (!this.event && !this.data.length)
        return null;
      const i = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], i;
    }
    if (this.chunks.push(e), e.startsWith(":"))
      return null;
    let [n, a, r] = KU(e, ":");
    return r.startsWith(" ") && (r = r.substring(1)), n === "event" ? this.event = r : n === "data" && this.data.push(r), null;
  }
}
class tu {
  constructor() {
    this.buffer = [], this.trailingCR = !1;
  }
  decode(e) {
    let n = this.decodeText(e);
    if (this.trailingCR && (n = "\r" + n, this.trailingCR = !1), n.endsWith("\r") && (this.trailingCR = !0, n = n.slice(0, -1)), !n)
      return [];
    const a = tu.NEWLINE_CHARS.has(n[n.length - 1] || "");
    let r = n.split(tu.NEWLINE_REGEXP);
    return a && r.pop(), r.length === 1 && !a ? (this.buffer.push(r[0]), []) : (this.buffer.length > 0 && (r = [this.buffer.join("") + r[0], ...r.slice(1)], this.buffer = []), a || (this.buffer = [r.pop() || ""]), r);
  }
  decodeText(e) {
    if (e == null)
      return "";
    if (typeof e == "string")
      return e;
    if (typeof Ke < "u") {
      if (e instanceof Ke)
        return e.toString();
      if (e instanceof Uint8Array)
        return Ke.from(e).toString();
      throw new la(`Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder < "u") {
      if (e instanceof Uint8Array || e instanceof ArrayBuffer)
        return this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8")), this.textDecoder.decode(e);
      throw new la(`Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new la("Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.");
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR)
      return [];
    const e = [this.buffer.join("")];
    return this.buffer = [], this.trailingCR = !1, e;
  }
}
tu.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r"]);
tu.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function KU(t, e) {
  const n = t.indexOf(e);
  return n !== -1 ? [t.substring(0, n), e, t.substring(n + e.length)] : [t, "", ""];
}
function RM(t) {
  if (t[Symbol.asyncIterator])
    return t;
  const e = t.getReader();
  return {
    async next() {
      try {
        const n = await e.read();
        return n?.done && e.releaseLock(), n;
      } catch (n) {
        throw e.releaseLock(), n;
      }
    },
    async return() {
      const n = e.cancel();
      return e.releaseLock(), await n, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
const HU = (t) => t != null && typeof t == "object" && typeof t.url == "string" && typeof t.blob == "function", GU = (t) => t != null && typeof t == "object" && typeof t.name == "string" && typeof t.lastModified == "number" && Zp(t), Zp = (t) => t != null && typeof t == "object" && typeof t.size == "number" && typeof t.type == "string" && typeof t.text == "function" && typeof t.slice == "function" && typeof t.arrayBuffer == "function";
async function WU(t, e, n) {
  if (t = await t, GU(t))
    return t;
  if (HU(t)) {
    const r = await t.blob();
    e || (e = new URL(t.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const i = Zp(r) ? [await r.arrayBuffer()] : [r];
    return new wg(i, e, n);
  }
  const a = await XU(t);
  if (e || (e = YU(t) ?? "unknown_file"), !n?.type) {
    const r = a[0]?.type;
    typeof r == "string" && (n = { ...n, type: r });
  }
  return new wg(a, e, n);
}
async function XU(t) {
  let e = [];
  if (typeof t == "string" || ArrayBuffer.isView(t) || // includes Uint8Array, Buffer, etc.
  t instanceof ArrayBuffer)
    e.push(t);
  else if (Zp(t))
    e.push(await t.arrayBuffer());
  else if (eB(t))
    for await (const n of t)
      e.push(n);
  else
    throw new Error(`Unexpected data type: ${typeof t}; constructor: ${t?.constructor?.name}; props: ${QU(t)}`);
  return e;
}
function QU(t) {
  return `[${Object.getOwnPropertyNames(t).map((n) => `"${n}"`).join(", ")}]`;
}
function YU(t) {
  return hb(t.name) || hb(t.filename) || // For fs.ReadStream
  hb(t.path)?.split(/[\\/]/).pop();
}
const hb = (t) => {
  if (typeof t == "string")
    return t;
  if (typeof Ke < "u" && t instanceof Ke)
    return String(t);
}, eB = (t) => t != null && typeof t == "object" && typeof t[Symbol.asyncIterator] == "function", aP = (t) => t && typeof t == "object" && t.body && t[Symbol.toStringTag] === "MultipartBody";
async function CM(t) {
  const { response: e } = t;
  if (t.options.stream)
    return Vo("response", e.status, e.url, e.headers, e.body), t.options.__streamClass ? t.options.__streamClass.fromSSEResponse(e, t.controller) : qu.fromSSEResponse(e, t.controller);
  if (e.status === 204)
    return null;
  if (t.options.__binaryResponse)
    return e;
  const a = e.headers.get("content-type")?.split(";")[0]?.trim();
  if (a?.includes("application/json") || a?.endsWith("+json")) {
    const s = await e.json();
    return Vo("response", e.status, e.url, e.headers, s), s;
  }
  const i = await e.text();
  return Vo("response", e.status, e.url, e.headers, i), i;
}
class Kp extends Promise {
  constructor(e, n = CM) {
    super((a) => {
      a(null);
    }), this.responsePromise = e, this.parseResponse = n;
  }
  _thenUnwrap(e) {
    return new Kp(this.responsePromise, async (n) => e(await this.parseResponse(n), n));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from '@cerebras/cerebras_cloud_sdk'`:
   * - `import '@cerebras/cerebras_cloud_sdk/shims/node'` (if you're running on Node)
   * - `import '@cerebras/cerebras_cloud_sdk/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((e) => e.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from '@cerebras/cerebras_cloud_sdk'`:
   * - `import '@cerebras/cerebras_cloud_sdk/shims/node'` (if you're running on Node)
   * - `import '@cerebras/cerebras_cloud_sdk/shims/web'` (otherwise)
   */
  async withResponse() {
    const [e, n] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: e, response: n };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)), this.parsedPromise;
  }
  then(e, n) {
    return this.parse().then(e, n);
  }
  catch(e) {
    return this.parse().catch(e);
  }
  finally(e) {
    return this.parse().finally(e);
  }
}
class tB {
  constructor({
    baseURL: e,
    maxRetries: n = 2,
    timeout: a = 6e4,
    // 1 minute
    httpAgent: r,
    fetch: i
  }) {
    this.baseURL = e, this.maxRetries = pb("maxRetries", n), this.timeout = pb("timeout", a), this.httpAgent = r, this.fetch = i ?? hM;
  }
  authHeaders(e) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(e) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...oB(),
      ...this.authHeaders(e)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(e, n) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${fB()}`;
  }
  get(e, n) {
    return this.methodRequest("get", e, n);
  }
  post(e, n) {
    return this.methodRequest("post", e, n);
  }
  patch(e, n) {
    return this.methodRequest("patch", e, n);
  }
  put(e, n) {
    return this.methodRequest("put", e, n);
  }
  delete(e, n) {
    return this.methodRequest("delete", e, n);
  }
  methodRequest(e, n, a) {
    return this.request(Promise.resolve(a).then(async (r) => {
      const i = r && Zp(r?.body) ? new DataView(await r.body.arrayBuffer()) : r?.body instanceof DataView ? r.body : r?.body instanceof ArrayBuffer ? new DataView(r.body) : r && ArrayBuffer.isView(r?.body) ? new DataView(r.body.buffer) : r?.body;
      return { method: e, path: n, ...r, body: i };
    }));
  }
  getAPIList(e, n, a) {
    return this.requestAPIList(n, { method: "get", path: e, ...a });
  }
  calculateContentLength(e) {
    if (typeof e == "string") {
      if (typeof Ke < "u")
        return Ke.byteLength(e, "utf8").toString();
      if (typeof TextEncoder < "u")
        return new TextEncoder().encode(e).length.toString();
    } else if (ArrayBuffer.isView(e))
      return e.byteLength.toString();
    return null;
  }
  buildRequest(e, { retryCount: n = 0 } = {}) {
    e = { ...e };
    const { method: a, path: r, query: i, headers: s = {} } = e, o = ArrayBuffer.isView(e.body) || e.__binaryRequest && typeof e.body == "string" ? e.body : aP(e.body) ? e.body.body : e.body ? JSON.stringify(e.body, null, 2) : null, l = this.calculateContentLength(o), f = this.buildURL(r, i);
    "timeout" in e && pb("timeout", e.timeout), e.timeout = e.timeout ?? this.timeout;
    const u = e.httpAgent ?? this.httpAgent ?? mM(f), c = e.timeout + 1e3;
    typeof u?.options?.timeout == "number" && c > (u.options.timeout ?? 0) && (u.options.timeout = c), this.idempotencyHeader && a !== "get" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()), s[this.idempotencyHeader] = e.idempotencyKey);
    const h = this.buildHeaders({ options: e, headers: s, contentLength: l, retryCount: n });
    return { req: {
      method: a,
      ...o && { body: o },
      headers: h,
      ...u && { agent: u },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: e.signal ?? null
    }, url: f, timeout: e.timeout };
  }
  buildHeaders({ options: e, headers: n, contentLength: a, retryCount: r }) {
    const i = {};
    a && (i["content-length"] = a);
    const s = this.defaultHeaders(e);
    return lP(i, s), lP(i, n), aP(e.body) && nd !== "node" && delete i["content-type"], Yf(s, "x-stainless-retry-count") === void 0 && Yf(n, "x-stainless-retry-count") === void 0 && (i["x-stainless-retry-count"] = String(r)), Yf(s, "x-stainless-timeout") === void 0 && Yf(n, "x-stainless-timeout") === void 0 && e.timeout && (i["x-stainless-timeout"] = String(e.timeout)), this.validateHeaders(i, n), i;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(e) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(e, { url: n, options: a }) {
  }
  parseHeaders(e) {
    return e ? Symbol.iterator in e ? Object.fromEntries(Array.from(e).map((n) => [...n])) : { ...e } : {};
  }
  makeStatusError(e, n, a, r) {
    return Nt.generate(e, n, a, r);
  }
  request(e, n = null) {
    return new Kp(this.makeRequest(e, n));
  }
  async makeRequest(e, n) {
    const a = await e, r = a.maxRetries ?? this.maxRetries;
    n == null && (n = r), await this.prepareOptions(a);
    const { req: i, url: s, timeout: o } = this.buildRequest(a, { retryCount: r - n });
    if (await this.prepareRequest(i, { url: s, options: a }), Vo("request", s, a, i.headers), a.signal?.aborted)
      throw new vg();
    const l = new AbortController(), f = await this.fetchWithTimeout(s, i, o, l).catch(Sg);
    if (f instanceof Error) {
      if (a.signal?.aborted)
        throw new vg();
      if (n)
        return this.retryRequest(a, n);
      throw f.name === "AbortError" ? new gM() : new zp({ cause: f });
    }
    const u = rB(f.headers);
    if (!f.ok) {
      if (n && this.shouldRetry(f)) {
        const b = `retrying, ${n} attempts remaining`;
        return Vo(`response (error; ${b})`, f.status, s, u), this.retryRequest(a, n, u);
      }
      const c = await f.text().catch((b) => Sg(b).message), h = uB(c), p = h ? void 0 : c;
      throw Vo(`response (error; ${n ? "(error; no more retries left)" : "(error; not retryable)"})`, f.status, s, u, p), this.makeStatusError(f.status, h, p, u);
    }
    return { response: f, options: a, controller: l };
  }
  requestAPIList(e, n) {
    const a = this.makeRequest(n, null);
    return new nB(this, a, e);
  }
  buildURL(e, n) {
    const a = lB(e) ? new URL(e) : new URL(this.baseURL + (this.baseURL.endsWith("/") && e.startsWith("/") ? e.slice(1) : e)), r = this.defaultQuery();
    return TM(r) || (n = { ...r, ...n }), typeof n == "object" && n && !Array.isArray(n) && (a.search = this.stringifyQuery(n)), a.toString();
  }
  stringifyQuery(e) {
    return Object.entries(e).filter(([n, a]) => typeof a < "u").map(([n, a]) => {
      if (typeof a == "string" || typeof a == "number" || typeof a == "boolean")
        return `${encodeURIComponent(n)}=${encodeURIComponent(a)}`;
      if (a === null)
        return `${encodeURIComponent(n)}=`;
      throw new la(`Cannot stringify type ${typeof a}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(e, n, a, r) {
    const { signal: i, ...s } = n || {};
    i && i.addEventListener("abort", () => r.abort());
    const o = setTimeout(() => r.abort(), a), l = {
      signal: r.signal,
      ...s
    };
    return l.method && (l.method = l.method.toUpperCase()), // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
    this.fetch.call(void 0, e, l).finally(() => {
      clearTimeout(o);
    });
  }
  shouldRetry(e) {
    const n = e.headers.get("x-should-retry");
    return n === "true" ? !0 : n === "false" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500;
  }
  async retryRequest(e, n, a) {
    let r;
    const i = a?.["retry-after-ms"];
    if (i) {
      const o = parseFloat(i);
      Number.isNaN(o) || (r = o);
    }
    const s = a?.["retry-after"];
    if (s && !r) {
      const o = parseFloat(s);
      Number.isNaN(o) ? r = Date.parse(s) - Date.now() : r = o * 1e3;
    }
    if (!(r && 0 <= r && r < 60 * 1e3)) {
      const o = e.maxRetries ?? this.maxRetries;
      r = this.calculateDefaultRetryTimeoutMillis(n, o);
    }
    return await dB(r), this.makeRequest(e, n - 1);
  }
  calculateDefaultRetryTimeoutMillis(e, n) {
    const i = n - e, s = Math.min(0.5 * Math.pow(2, i), 8), o = 1 - Math.random() * 0.25;
    return s * o * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${Eu}`;
  }
}
class nB extends Kp {
  constructor(e, n, a) {
    super(n, async (r) => new a(e, r.response, await CM(r), r.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const e = await this;
    for await (const n of e)
      yield n;
  }
}
const rB = (t) => new Proxy(Object.fromEntries(
  // @ts-ignore
  t.entries()
), {
  get(e, n) {
    const a = n.toString();
    return e[a.toLowerCase()] || e[a];
  }
}), aB = {
  method: !0,
  path: !0,
  query: !0,
  body: !0,
  headers: !0,
  maxRetries: !0,
  stream: !0,
  timeout: !0,
  httpAgent: !0,
  signal: !0,
  idempotencyKey: !0,
  __binaryRequest: !0,
  __binaryResponse: !0,
  __streamClass: !0
}, iP = (t) => typeof t == "object" && t !== null && !TM(t) && Object.keys(t).every((e) => $M(aB, e)), iB = () => {
  if (typeof Deno < "u" && Deno.build != null)
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Eu,
      "X-Stainless-OS": oP(Deno.build.os),
      "X-Stainless-Arch": sP(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Eu,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": ue.version
    };
  if (Object.prototype.toString.call(typeof ue < "u" ? ue : 0) === "[object process]")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Eu,
      "X-Stainless-OS": oP(ue.platform),
      "X-Stainless-Arch": sP(ue.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": ue.version
    };
  const t = sB();
  return t ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Eu,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${t.browser}`,
    "X-Stainless-Runtime-Version": t.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Eu,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function sB() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const t = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: e, pattern: n } of t) {
    const a = n.exec(navigator.userAgent);
    if (a) {
      const r = a[1] || 0, i = a[2] || 0, s = a[3] || 0;
      return { browser: e, version: `${r}.${i}.${s}` };
    }
  }
  return null;
}
const sP = (t) => t === "x32" ? "x32" : t === "x86_64" || t === "x64" ? "x64" : t === "arm" ? "arm" : t === "aarch64" || t === "arm64" ? "arm64" : t ? `other:${t}` : "unknown", oP = (t) => (t = t.toLowerCase(), t.includes("ios") ? "iOS" : t === "android" ? "Android" : t === "darwin" ? "MacOS" : t === "win32" ? "Windows" : t === "freebsd" ? "FreeBSD" : t === "openbsd" ? "OpenBSD" : t === "linux" ? "Linux" : t ? `Other:${t}` : "Unknown");
let uP;
const oB = () => uP ?? (uP = iB()), uB = (t) => {
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}, cB = /^[a-z][a-z0-9+.-]*:/i, lB = (t) => cB.test(t), dB = (t) => new Promise((e) => setTimeout(e, t)), pb = (t, e) => {
  if (typeof e != "number" || !Number.isInteger(e))
    throw new la(`${t} must be an integer`);
  if (e < 0)
    throw new la(`${t} must be a positive integer`);
  return e;
}, Sg = (t) => {
  if (t instanceof Error)
    return t;
  if (typeof t == "object" && t !== null)
    try {
      return new Error(JSON.stringify(t));
    } catch {
    }
  return new Error(t);
}, cP = (t) => {
  if (typeof ue < "u")
    return ue.env?.[t]?.trim() ?? void 0;
  if (typeof Deno < "u")
    return Deno.env?.get?.(t)?.trim();
};
function TM(t) {
  if (!t)
    return !0;
  for (const e in t)
    return !1;
  return !0;
}
function $M(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function lP(t, e) {
  for (const n in e) {
    if (!$M(e, n))
      continue;
    const a = n.toLowerCase();
    if (!a)
      continue;
    const r = e[n];
    r === null ? delete t[a] : r !== void 0 && (t[a] = r);
  }
}
function Vo(t, ...e) {
  typeof ue < "u" && ue?.env?.DEBUG === "true" && console.log(`Cerebras:DEBUG:${t}`, ...e);
}
const fB = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
  const e = Math.random() * 16 | 0;
  return (t === "x" ? e : e & 3 | 8).toString(16);
}), hB = (t) => typeof t?.get == "function", Yf = (t, e) => {
  const n = e.toLowerCase();
  if (hB(t)) {
    const a = e[0]?.toUpperCase() + e.substring(1).replace(/([^\w])(\w)/g, (r, i, s) => i + s.toUpperCase());
    for (const r of [e, n, e.toUpperCase(), a]) {
      const i = t.get(r);
      if (i)
        return i;
    }
  }
  for (const [a, r] of Object.entries(t))
    if (a.toLowerCase() === n)
      return Array.isArray(r) ? (r.length <= 1 || console.warn(`Received ${r.length} entries for the ${e} header, using the first entry.`), r[0]) : r;
};
class Hp {
  constructor(e) {
    this._client = e;
  }
}
let MM = class extends Hp {
  create(e, n) {
    const { "CF-RAY": a, "X-Amz-Cf-Id": r, "X-delay-time": i, ...s } = e;
    return this._client.post("/v1/chat/completions", {
      body: s,
      ...n,
      stream: s.stream ?? !1,
      headers: {
        ...a != null ? { "CF-RAY": a } : void 0,
        ...r != null ? { "X-Amz-Cf-Id": r } : void 0,
        ...i?.toString() != null ? { "X-delay-time": i?.toString() } : void 0,
        ...n?.headers
      }
    });
  }
};
class Y_ extends Hp {
  constructor() {
    super(...arguments), this.completions = new MM(this._client);
  }
}
Y_.Completions = MM;
class AM extends Hp {
  create(e, n) {
    const { "CF-RAY": a, "X-Amz-Cf-Id": r, "X-delay-time": i, ...s } = e;
    return this._client.post("/v1/completions", {
      body: s,
      ...n,
      stream: s.stream ?? !1,
      headers: {
        ...a != null ? { "CF-RAY": a } : void 0,
        ...r != null ? { "X-Amz-Cf-Id": r } : void 0,
        ...i?.toString() != null ? { "X-delay-time": i?.toString() } : void 0,
        ...n?.headers
      }
    });
  }
}
class EM extends Hp {
  retrieve(e, n = {}, a) {
    if (iP(n))
      return this.retrieve(e, {}, n);
    const { "CF-RAY": r, "X-Amz-Cf-Id": i } = n;
    return this._client.get(`/v1/models/${e}`, {
      ...a,
      headers: {
        ...r != null ? { "CF-RAY": r } : void 0,
        ...i != null ? { "X-Amz-Cf-Id": i } : void 0,
        ...a?.headers
      }
    });
  }
  list(e = {}, n) {
    if (iP(e))
      return this.list({}, e);
    const { "CF-RAY": a, "X-Amz-Cf-Id": r } = e;
    return this._client.get("/v1/models", {
      ...n,
      headers: {
        ...a != null ? { "CF-RAY": a } : void 0,
        ...r != null ? { "X-Amz-Cf-Id": r } : void 0,
        ...n?.headers
      }
    });
  }
}
var IM;
class at extends tB {
  /**
   * API Client for interfacing with the Cerebras API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['CEREBRAS_API_KEY'] ?? undefined]
   * @param {string} [opts.baseURL=process.env['CEREBRAS_BASE_URL'] ?? https://api.cerebras.ai] - Override the default base URL for the API.
   * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean | undefined} opts.warmTCPConnection - Whether to warm TCP connection in the constructor.
   */
  constructor({ baseURL: e = cP("CEREBRAS_BASE_URL"), apiKey: n = cP("CEREBRAS_API_KEY"), warmTCPConnection: a = !0, ...r } = {}) {
    if (n === void 0)
      throw new la("The CEREBRAS_API_KEY environment variable is missing or empty; either provide it, or instantiate the Cerebras client with an apiKey option, like new Cerebras({ apiKey: 'My API Key' }).");
    const i = {
      apiKey: n,
      ...r,
      baseURL: e || "https://api.cerebras.ai"
    };
    super({
      baseURL: i.baseURL,
      timeout: i.timeout ?? 6e4,
      httpAgent: i.httpAgent,
      maxRetries: i.maxRetries,
      fetch: i.fetch
    }), this.chat = new Y_(this), this.completions = new AM(this), this.models = new EM(this), this._options = i, this.apiKey = n, a && (async () => {
      try {
        await this.get("/v1/tcp_warming", {
          timeout: 1e3,
          maxRetries: 0
        });
      } catch (s) {
        Vo(`TCP Warming had exception: ${s}`);
      }
    })();
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(e) {
    return {
      ...super.defaultHeaders(e),
      ...this._options.defaultHeaders
    };
  }
  authHeaders(e) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
}
IM = at;
at.Cerebras = IM;
at.DEFAULT_TIMEOUT = 6e4;
at.CerebrasError = la;
at.APIError = Nt;
at.APIConnectionError = zp;
at.APIConnectionTimeoutError = gM;
at.APIUserAbortError = vg;
at.NotFoundError = vM;
at.ConflictError = SM;
at.RateLimitError = jM;
at.BadRequestError = _M;
at.AuthenticationError = yM;
at.InternalServerError = PM;
at.PermissionDeniedError = wM;
at.UnprocessableEntityError = OM;
at.toFile = WU;
at.fileFromPath = bM;
at.Chat = Y_;
at.Completions = AM;
at.Models = EM;
function dP(t) {
  const e = t.match(/^data:.*?;base64,(.*)$/);
  return e ? e[1] : "";
}
function pB(t) {
  if (typeof t.content == "string")
    return [
      {
        role: "assistant",
        content: t.content
      }
    ];
  const n = t.content.filter((r) => r.type === "text" && typeof r.text == "string").map((r) => ({
    role: "assistant",
    content: r.text
  }));
  let a;
  if (t.content.find((r) => r.type === "tool_use") && t.tool_calls?.length) {
    const r = t.tool_calls?.map((i) => ({
      id: i.id,
      type: "function",
      function: {
        name: i.name,
        arguments: JSON.stringify(i.args)
      }
    }));
    r && (a = {
      role: "assistant",
      tool_calls: r,
      content: ""
    });
  } else if (t.content.find((r) => r.type === "tool_use") && !t.tool_calls?.length)
    throw new Error("'tool_use' content type is not supported without tool calls.");
  return [...n, ...a ? [a] : []];
}
function mB(t) {
  return typeof t.content == "string" ? [
    {
      role: "user",
      content: t.content
    }
  ] : t.content.map((e) => {
    if (e.type === "text")
      return {
        role: "user",
        content: e.text
      };
    if (e.type === "image_url") {
      if (typeof e.image_url == "string")
        return {
          role: "user",
          content: "",
          images: [dP(e.image_url)]
        };
      if (e.image_url.url && typeof e.image_url.url == "string")
        return {
          role: "user",
          content: "",
          images: [dP(e.image_url.url)]
        };
    }
    throw new Error(`Unsupported content type: ${e.type}`);
  });
}
function bB(t) {
  if (typeof t.content == "string")
    return [
      {
        role: "system",
        content: t.content
      }
    ];
  if (t.content.every((e) => e.type === "text" && typeof e.text == "string"))
    return t.content.map((e) => ({
      role: "system",
      content: e.text
    }));
  throw new Error(`Unsupported content type(s): ${t.content.map((e) => e.type).join(", ")}`);
}
function gB(t) {
  if (typeof t.content != "string")
    throw new Error("Non string tool message content is not supported");
  return [
    {
      role: "tool",
      content: t.content,
      tool_call_id: t.tool_call_id
    }
  ];
}
function fP(t) {
  return t.flatMap((e) => {
    if (["human", "generic"].includes(e._getType()))
      return mB(e);
    if (e._getType() === "ai")
      return pB(e);
    if (e._getType() === "system")
      return bB(e);
    if (e._getType() === "tool")
      return gB(e);
    throw new Error(`Unsupported message type: ${e._getType()}`);
  });
}
function _B(t) {
  if (t)
    return t === "any" || t === "required" ? "required" : t === "auto" ? "auto" : t === "none" ? "none" : typeof t == "string" ? {
      type: "function",
      function: {
        name: t
      }
    } : t;
}
class nK extends Sn {
  static lc_name() {
    return "ChatCerebras";
  }
  get lc_secrets() {
    return {
      apiKey: "CEREBRAS_API_KEY"
    };
  }
  get lc_aliases() {
    return {
      apiKey: "CEREBRAS_API_KEY"
    };
  }
  getLsParams(e) {
    const n = this.invocationParams(e);
    return {
      ls_provider: "cerebras",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: n.temperature ?? void 0,
      ls_max_tokens: n.max_completion_tokens ?? void 0,
      ls_stop: e.stop
    };
  }
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxCompletionTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "seed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.model = e.model, this.maxCompletionTokens = e.maxCompletionTokens, this.temperature = e.temperature, this.topP = e.topP, this.seed = e.seed, this.streaming = e.streaming, this.client = new at({
      apiKey: e.apiKey ?? ft("CEREBRAS_API_KEY"),
      timeout: e.timeout,
      // Rely on built-in async caller
      maxRetries: 0,
      fetch: e.fetch
    });
  }
  // Replace
  _llmType() {
    return "cerebras";
  }
  bindTools(e, n) {
    return this.bind({
      tools: e.map((a) => $d(a)),
      ...n
    });
  }
  /**
   * A method that returns the parameters for an Ollama API call. It
   * includes model and options parameters.
   * @param options Optional parsed call options.
   * @returns An object containing the parameters for an Ollama API call.
   */
  invocationParams(e) {
    return {
      model: this.model,
      max_completion_tokens: this.maxCompletionTokens,
      temperature: this.temperature,
      top_p: this.topP,
      seed: this.seed,
      stop: e?.stop,
      response_format: e?.response_format,
      user: e?.user,
      tools: e?.tools?.length ? e.tools.map((n) => $d(n)) : void 0,
      tool_choice: _B(e?.tool_choice)
    };
  }
  async _generate(e, n, a) {
    if (this.streaming) {
      let c;
      for await (const p of this._streamResponseChunks(e, n, a))
        c ? c = on(c, p.message) : c = p.message;
      const h = new $t({
        id: c?.id,
        content: c?.content ?? "",
        tool_calls: c?.tool_calls,
        response_metadata: c?.response_metadata,
        usage_metadata: c?.usage_metadata
      });
      return {
        generations: [
          {
            text: typeof h.content == "string" ? h.content : "",
            message: h
          }
        ]
      };
    }
    const r = await this.caller.call(async () => await this.client.chat.completions.create({
      ...this.invocationParams(n),
      messages: fP(e),
      stream: !1
    }, {
      headers: n.headers,
      httpAgent: n.httpAgent
    })), { choices: i, usage: s, ...o } = r, l = i[0], f = l?.message?.content ?? "", u = {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      input_tokens: s?.prompt_tokens,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      output_tokens: s?.completion_tokens,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      total_tokens: s?.total_tokens
    };
    return {
      generations: [
        {
          text: f,
          message: new $t({
            content: f,
            tool_calls: l?.message?.tool_calls?.map(
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              (c) => ({
                id: c.id,
                name: c.function?.name,
                args: JSON.parse(c.function?.arguments),
                index: c.index,
                type: "tool_call"
              })
            ),
            usage_metadata: u,
            response_metadata: o
          })
        }
      ]
    };
  }
  /**
   * Implement to support streaming.
   * Should yield chunks iteratively.
   */
  async *_streamResponseChunks(e, n, a) {
    const r = await this.caller.call(async () => await this.client.chat.completions.create({
      ...this.invocationParams(n),
      messages: fP(e),
      stream: !0
    }, {
      headers: n.headers,
      httpAgent: n.httpAgent
    }));
    for await (const i of r) {
      const { choices: s, system_fingerprint: o, model: l, id: f, object: u, usage: c, ...h } = i, p = s[0], d = p?.delta?.content ?? "";
      let m;
      c !== void 0 && (m = {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        input_tokens: c.prompt_tokens,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        output_tokens: c.completion_tokens,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        total_tokens: c.total_tokens
      });
      const b = {};
      p.finish_reason != null && (b.finish_reason = p.finish_reason, b.id = f, b.system_fingerprint = o, b.model = l, b.object = u);
      const g = new Bt({
        text: d,
        message: new Ze({
          content: d,
          tool_call_chunks: p?.delta.tool_calls?.map(
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (_) => ({
              id: _.id,
              name: _.function?.name,
              args: _.function?.arguments,
              index: _.index,
              type: "tool_call_chunk"
            })
          ),
          usage_metadata: m,
          response_metadata: h
        }),
        generationInfo: b
      });
      yield g, await a?.handleLLMNewToken(d, void 0, void 0, void 0, void 0, { chunk: g });
    }
  }
  withStructuredOutput(e, n) {
    if (n?.strict)
      throw new Error('"strict" mode is not supported for this model by default.');
    const a = e, r = n?.name, i = a.description ?? "A function available to call.", s = n?.method, o = n?.includeRaw;
    if (s === "jsonMode")
      throw new Error('Cerebras withStructuredOutput implementation only supports "functionCalling" as a method.');
    let l = r ?? "extract", f;
    eu(a) ? f = [
      {
        type: "function",
        function: {
          name: l,
          description: i,
          parameters: Cn(a)
        }
      }
    ] : ("name" in a && (l = a.name), f = [
      {
        type: "function",
        function: {
          name: l,
          description: i,
          parameters: a
        }
      }
    ]);
    const u = this.bindTools(f, {
      tool_choice: f[0].function.name
    }), c = au.from((m) => {
      if (!m.tool_calls || m.tool_calls.length === 0)
        throw new Error("No tool calls found in the response.");
      const b = m.tool_calls.find((g) => g.name === l);
      if (!b)
        throw new Error(`No tool call found with name ${l}.`);
      return b.args;
    });
    if (!o)
      return u.pipe(c).withConfig({
        runName: "ChatCerebrasStructuredOutput"
      });
    const h = Mt.assign({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parsed: (m, b) => c.invoke(m.raw, b)
    }), p = Mt.assign({
      parsed: () => null
    }), d = h.withFallbacks({
      fallbacks: [p]
    });
    return dt.from([
      {
        raw: u
      },
      d
    ]).withConfig({
      runName: "ChatCerebrasStructuredOutput"
    });
  }
}
const yB = "0.5.14", NM = "11434", kM = `http://127.0.0.1:${NM}`;
var wB = Object.defineProperty, vB = (t, e, n) => e in t ? wB(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, mb = (t, e, n) => (vB(t, typeof e != "symbol" ? e + "" : e, n), n);
class ey extends Error {
  constructor(e, n) {
    super(e), this.error = e, this.status_code = n, this.name = "ResponseError", Error.captureStackTrace && Error.captureStackTrace(this, ey);
  }
}
class SB {
  constructor(e, n, a) {
    mb(this, "abortController"), mb(this, "itr"), mb(this, "doneCallback"), this.abortController = e, this.itr = n, this.doneCallback = a;
  }
  abort() {
    this.abortController.abort();
  }
  async *[Symbol.asyncIterator]() {
    for await (const e of this.itr) {
      if ("error" in e)
        throw new Error(e.error);
      if (yield e, e.done || e.status === "success") {
        this.doneCallback();
        return;
      }
    }
    throw new Error("Did not receive done or success response in stream.");
  }
}
const ty = async (t) => {
  if (t.ok)
    return;
  let e = `Error ${t.status}: ${t.statusText}`, n = null;
  if (t.headers.get("content-type")?.includes("application/json"))
    try {
      n = await t.json(), e = n.error || e;
    } catch {
      console.log("Failed to parse error response as JSON");
    }
  else
    try {
      console.log("Getting text from response"), e = await t.text() || e;
    } catch {
      console.log("Failed to get text from error response");
    }
  throw new ey(e, t.status);
};
function OB() {
  if (typeof window < "u" && window.navigator) {
    const t = navigator;
    return "userAgentData" in t && t.userAgentData?.platform ? `${t.userAgentData.platform.toLowerCase()} Browser/${navigator.userAgent};` : navigator.platform ? `${navigator.platform.toLowerCase()} Browser/${navigator.userAgent};` : `unknown Browser/${navigator.userAgent};`;
  } else if (typeof ue < "u")
    return `${ue.arch} ${ue.platform} Node.js/${ue.version}`;
  return "";
}
function jB(t) {
  if (t instanceof Headers) {
    const e = {};
    return t.forEach((n, a) => {
      e[a] = n;
    }), e;
  } else return Array.isArray(t) ? Object.fromEntries(t) : t || {};
}
const ny = async (t, e, n = {}) => {
  const a = {
    "Content-Type": "application/json",
    Accept: "application/json",
    "User-Agent": `ollama-js/${yB} (${OB()})`
  };
  n.headers = jB(n.headers);
  const r = Object.fromEntries(
    Object.entries(n.headers).filter(([i]) => !Object.keys(a).some((s) => s.toLowerCase() === i.toLowerCase()))
  );
  return n.headers = {
    ...a,
    ...r
  }, t(e, n);
}, hP = async (t, e, n) => {
  const a = await ny(t, e, {
    headers: n?.headers
  });
  return await ty(a), a;
}, Su = async (t, e, n, a) => {
  const i = ((o) => o !== null && typeof o == "object" && !Array.isArray(o))(n) ? JSON.stringify(n) : n, s = await ny(t, e, {
    method: "POST",
    body: i,
    signal: a?.signal,
    headers: a?.headers
  });
  return await ty(s), s;
}, PB = async (t, e, n, a) => {
  const r = await ny(t, e, {
    method: "DELETE",
    body: JSON.stringify(n),
    headers: a?.headers
  });
  return await ty(r), r;
}, RB = async function* (t) {
  const e = new TextDecoder("utf-8");
  let n = "";
  const a = t.getReader();
  for (; ; ) {
    const { done: r, value: i } = await a.read();
    if (r)
      break;
    n += e.decode(i);
    const s = n.split(`
`);
    n = s.pop() ?? "";
    for (const o of s)
      try {
        yield JSON.parse(o);
      } catch {
        console.warn("invalid json: ", o);
      }
  }
  for (const r of n.split(`
`).filter((i) => i !== ""))
    try {
      yield JSON.parse(r);
    } catch {
      console.warn("invalid json: ", r);
    }
}, CB = (t) => {
  if (!t)
    return kM;
  let e = t.includes("://");
  t.startsWith(":") && (t = `http://127.0.0.1${t}`, e = !0), e || (t = `http://${t}`);
  const n = new URL(t);
  let a = n.port;
  a || (e ? a = n.protocol === "https:" ? "443" : "80" : a = NM);
  let r = `${n.protocol}//${n.hostname}:${a}${n.pathname}`;
  return r.endsWith("/") && (r = r.slice(0, -1)), r;
};
var TB = Object.defineProperty, $B = (t, e, n) => e in t ? TB(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, bb = (t, e, n) => ($B(t, typeof e != "symbol" ? e + "" : e, n), n);
let Gp = class {
  constructor(e) {
    bb(this, "config"), bb(this, "fetch"), bb(this, "ongoingStreamedRequests", []), this.config = {
      host: "",
      headers: e?.headers
    }, e?.proxy || (this.config.host = CB(e?.host ?? kM)), this.fetch = e?.fetch ?? fetch;
  }
  // Abort any ongoing streamed requests to Ollama
  abort() {
    for (const e of this.ongoingStreamedRequests)
      e.abort();
    this.ongoingStreamedRequests.length = 0;
  }
  /**
   * Processes a request to the Ollama server. If the request is streamable, it will return a
   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response
   * object.
   * @param endpoint {string} - The endpoint to send the request to.
   * @param request {object} - The request object to send to the endpoint.
   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields
   * response messages.
   * @throws {Error} - If the response body is missing or if the response is an error.
   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.
   */
  async processStreamableRequest(e, n) {
    n.stream = n.stream ?? !1;
    const a = `${this.config.host}/api/${e}`;
    if (n.stream) {
      const i = new AbortController(), s = await Su(this.fetch, a, n, {
        signal: i.signal,
        headers: this.config.headers
      });
      if (!s.body)
        throw new Error("Missing body");
      const o = RB(s.body), l = new SB(
        i,
        o,
        () => {
          const f = this.ongoingStreamedRequests.indexOf(l);
          f > -1 && this.ongoingStreamedRequests.splice(f, 1);
        }
      );
      return this.ongoingStreamedRequests.push(l), l;
    }
    return await (await Su(this.fetch, a, n, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Encodes an image to base64 if it is a Uint8Array.
   * @param image {Uint8Array | string} - The image to encode.
   * @returns {Promise<string>} - The base64 encoded image.
   */
  async encodeImage(e) {
    if (typeof e != "string") {
      const n = new Uint8Array(e);
      let a = "";
      const r = n.byteLength;
      for (let i = 0; i < r; i++)
        a += String.fromCharCode(n[i]);
      return btoa(a);
    }
    return e;
  }
  /**
   * Generates a response from a text prompt.
   * @param request {GenerateRequest} - The request object.
   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async generate(e) {
    return e.images && (e.images = await Promise.all(e.images.map(this.encodeImage.bind(this)))), this.processStreamableRequest("generate", e);
  }
  /**
   * Chats with the model. The request object can contain messages with images that are either
   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the
   * request.
   * @param request {ChatRequest} - The request object.
   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an
   * AbortableAsyncIterator that yields response messages.
   */
  async chat(e) {
    if (e.messages)
      for (const n of e.messages)
        n.images && (n.images = await Promise.all(
          n.images.map(this.encodeImage.bind(this))
        ));
    return this.processStreamableRequest("chat", e);
  }
  /**
   * Creates a new model from a stream of data.
   * @param request {CreateRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.
   */
  async create(e) {
    return this.processStreamableRequest("create", {
      ...e
    });
  }
  /**
   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PullRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async pull(e) {
    return this.processStreamableRequest("pull", {
      name: e.model,
      stream: e.stream,
      insecure: e.insecure
    });
  }
  /**
   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PushRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async push(e) {
    return this.processStreamableRequest("push", {
      name: e.model,
      stream: e.stream,
      insecure: e.insecure
    });
  }
  /**
   * Deletes a model from the server. The request object should contain the name of the model to
   * delete.
   * @param request {DeleteRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async delete(e) {
    return await PB(
      this.fetch,
      `${this.config.host}/api/delete`,
      { name: e.model },
      { headers: this.config.headers }
    ), { status: "success" };
  }
  /**
   * Copies a model from one name to another. The request object should contain the name of the
   * model to copy and the new name.
   * @param request {CopyRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async copy(e) {
    return await Su(this.fetch, `${this.config.host}/api/copy`, { ...e }, {
      headers: this.config.headers
    }), { status: "success" };
  }
  /**
   * Lists the models on the server.
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async list() {
    return await (await hP(this.fetch, `${this.config.host}/api/tags`, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Shows the metadata of a model. The request object should contain the name of the model.
   * @param request {ShowRequest} - The request object.
   * @returns {Promise<ShowResponse>} - The response object.
   */
  async show(e) {
    return await (await Su(this.fetch, `${this.config.host}/api/show`, {
      ...e
    }, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Embeds text input into vectors.
   * @param request {EmbedRequest} - The request object.
   * @returns {Promise<EmbedResponse>} - The response object.
   */
  async embed(e) {
    return await (await Su(this.fetch, `${this.config.host}/api/embed`, {
      ...e
    }, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Embeds a text prompt into a vector.
   * @param request {EmbeddingsRequest} - The request object.
   * @returns {Promise<EmbeddingsResponse>} - The response object.
   */
  async embeddings(e) {
    return await (await Su(this.fetch, `${this.config.host}/api/embeddings`, {
      ...e
    }, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Lists the running models on the server
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async ps() {
    return await (await hP(this.fetch, `${this.config.host}/api/ps`, {
      headers: this.config.headers
    })).json();
  }
};
new Gp();
function pP(t, e) {
  return new Ze({
    content: t.content ?? "",
    tool_call_chunks: t.tool_calls?.map((n) => ({
      name: n.function.name,
      args: JSON.stringify(n.function.arguments),
      type: "tool_call_chunk",
      index: 0,
      id: Pt()
    })),
    response_metadata: e?.responseMetadata,
    usage_metadata: e?.usageMetadata
  });
}
function mP(t) {
  const e = t.match(/^data:.*?;base64,(.*)$/);
  return e ? e[1] : "";
}
function MB(t) {
  if (typeof t.content == "string")
    return [
      {
        role: "assistant",
        content: t.content
      }
    ];
  const n = t.content.filter((r) => r.type === "text" && typeof r.text == "string").map((r) => ({
    role: "assistant",
    content: r.text
  }));
  let a;
  if (t.content.find((r) => r.type === "tool_use") && t.tool_calls?.length) {
    const r = t.tool_calls?.map((i) => ({
      id: i.id,
      type: "function",
      function: {
        name: i.name,
        arguments: i.args
      }
    }));
    r && (a = {
      role: "assistant",
      tool_calls: r,
      content: ""
    });
  } else if (t.content.find((r) => r.type === "tool_use") && !t.tool_calls?.length)
    throw new Error("'tool_use' content type is not supported without tool calls.");
  return [...n, ...a ? [a] : []];
}
function AB(t) {
  return typeof t.content == "string" ? [
    {
      role: "user",
      content: t.content
    }
  ] : t.content.map((e) => {
    if (e.type === "text")
      return {
        role: "user",
        content: e.text
      };
    if (e.type === "image_url") {
      if (typeof e.image_url == "string")
        return {
          role: "user",
          content: "",
          images: [mP(e.image_url)]
        };
      if (e.image_url.url && typeof e.image_url.url == "string")
        return {
          role: "user",
          content: "",
          images: [mP(e.image_url.url)]
        };
    }
    throw new Error(`Unsupported content type: ${e.type}`);
  });
}
function EB(t) {
  if (typeof t.content == "string")
    return [
      {
        role: "system",
        content: t.content
      }
    ];
  if (t.content.every((e) => e.type === "text" && typeof e.text == "string"))
    return t.content.map((e) => ({
      role: "system",
      content: e.text
    }));
  throw new Error(`Unsupported content type(s): ${t.content.map((e) => e.type).join(", ")}`);
}
function IB(t) {
  if (typeof t.content != "string")
    throw new Error("Non string tool message content is not supported");
  return [
    {
      role: "tool",
      content: t.content
    }
  ];
}
function NB(t) {
  return t.flatMap((e) => {
    if (["human", "generic"].includes(e._getType()))
      return AB(e);
    if (e._getType() === "ai")
      return MB(e);
    if (e._getType() === "system")
      return EB(e);
    if (e._getType() === "tool")
      return IB(e);
    throw new Error(`Unsupported message type: ${e._getType()}`);
  });
}
class aK extends Sn {
  // Used for tracing, replace with the same name as your class
  static lc_name() {
    return "ChatOllama";
  }
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "llama3"
    }), Object.defineProperty(this, "numa", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numCtx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numBatch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numGpu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainGpu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lowVram", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "f16Kv", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logitsAll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "vocabOnly", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useMmap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useMlock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "embeddingOnly", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numThread", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numKeep", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "seed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numPredict", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topK", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tfsZ", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "typicalP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repeatLastN", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repeatPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "presencePenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "frequencyPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mirostat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mirostatTau", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mirostatEta", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "penalizeNewline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "format", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "keepAlive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkOrPullModel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "baseUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "http://127.0.0.1:11434"
    }), this.client = new Gp({
      host: e?.baseUrl,
      headers: e?.headers
    }), this.baseUrl = e?.baseUrl ?? this.baseUrl, this.model = e?.model ?? this.model, this.numa = e?.numa, this.numCtx = e?.numCtx, this.numBatch = e?.numBatch, this.numGpu = e?.numGpu, this.mainGpu = e?.mainGpu, this.lowVram = e?.lowVram, this.f16Kv = e?.f16Kv, this.logitsAll = e?.logitsAll, this.vocabOnly = e?.vocabOnly, this.useMmap = e?.useMmap, this.useMlock = e?.useMlock, this.embeddingOnly = e?.embeddingOnly, this.numThread = e?.numThread, this.numKeep = e?.numKeep, this.seed = e?.seed, this.numPredict = e?.numPredict, this.topK = e?.topK, this.topP = e?.topP, this.tfsZ = e?.tfsZ, this.typicalP = e?.typicalP, this.repeatLastN = e?.repeatLastN, this.temperature = e?.temperature, this.repeatPenalty = e?.repeatPenalty, this.presencePenalty = e?.presencePenalty, this.frequencyPenalty = e?.frequencyPenalty, this.mirostat = e?.mirostat, this.mirostatTau = e?.mirostatTau, this.mirostatEta = e?.mirostatEta, this.penalizeNewline = e?.penalizeNewline, this.streaming = e?.streaming, this.format = e?.format, this.keepAlive = e?.keepAlive, this.checkOrPullModel = e?.checkOrPullModel ?? this.checkOrPullModel;
  }
  // Replace
  _llmType() {
    return "ollama";
  }
  /**
   * Download a model onto the local machine.
   *
   * @param {string} model The name of the model to download.
   * @param {PullModelOptions | undefined} options Options for pulling the model.
   * @returns {Promise<void>}
   */
  async pull(e, n) {
    const { stream: a, insecure: r, logProgress: i } = {
      stream: !0,
      ...n
    };
    if (a)
      for await (const s of await this.client.pull({
        model: e,
        insecure: r,
        stream: a
      }))
        i && console.log(s);
    else {
      const s = await this.client.pull({ model: e, insecure: r });
      i && console.log(s);
    }
  }
  bindTools(e, n) {
    return this.bind({
      tools: e.map((a) => $d(a)),
      ...n
    });
  }
  getLsParams(e) {
    const n = this.invocationParams(e);
    return {
      ls_provider: "ollama",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: n.options?.temperature ?? void 0,
      ls_max_tokens: n.options?.num_predict ?? void 0,
      ls_stop: e.stop
    };
  }
  invocationParams(e) {
    if (e?.tool_choice)
      throw new Error("Tool choice is not supported for ChatOllama.");
    return {
      model: this.model,
      format: e?.format ?? this.format,
      keep_alive: this.keepAlive,
      options: {
        numa: this.numa,
        num_ctx: this.numCtx,
        num_batch: this.numBatch,
        num_gpu: this.numGpu,
        main_gpu: this.mainGpu,
        low_vram: this.lowVram,
        f16_kv: this.f16Kv,
        logits_all: this.logitsAll,
        vocab_only: this.vocabOnly,
        use_mmap: this.useMmap,
        use_mlock: this.useMlock,
        embedding_only: this.embeddingOnly,
        num_thread: this.numThread,
        num_keep: this.numKeep,
        seed: this.seed,
        num_predict: this.numPredict,
        top_k: this.topK,
        top_p: this.topP,
        tfs_z: this.tfsZ,
        typical_p: this.typicalP,
        repeat_last_n: this.repeatLastN,
        temperature: this.temperature,
        repeat_penalty: this.repeatPenalty,
        presence_penalty: this.presencePenalty,
        frequency_penalty: this.frequencyPenalty,
        mirostat: this.mirostat,
        mirostat_tau: this.mirostatTau,
        mirostat_eta: this.mirostatEta,
        penalize_newline: this.penalizeNewline,
        stop: e?.stop
      },
      tools: e?.tools?.length ? e.tools.map((n) => $d(n)) : void 0
    };
  }
  /**
   * Check if a model exists on the local machine.
   *
   * @param {string} model The name of the model to check.
   * @returns {Promise<boolean>} Whether or not the model exists.
   */
  async checkModelExistsOnMachine(e) {
    const { models: n } = await this.client.list();
    return !!n.find((a) => a.name === e || a.name === `${e}:latest`);
  }
  async _generate(e, n, a) {
    this.checkOrPullModel && (await this.checkModelExistsOnMachine(this.model) || await this.pull(this.model, {
      logProgress: !0
    }));
    let r;
    for await (const s of this._streamResponseChunks(e, n, a))
      r ? r = on(r, s.message) : r = s.message;
    const i = new $t({
      id: r?.id,
      content: r?.content ?? "",
      tool_calls: r?.tool_calls,
      response_metadata: r?.response_metadata,
      usage_metadata: r?.usage_metadata
    });
    return {
      generations: [
        {
          text: typeof i.content == "string" ? i.content : "",
          message: i
        }
      ]
    };
  }
  /**
   * Implement to support streaming.
   * Should yield chunks iteratively.
   */
  async *_streamResponseChunks(e, n, a) {
    this.checkOrPullModel && (await this.checkModelExistsOnMachine(this.model) || await this.pull(this.model, {
      logProgress: !0
    }));
    const r = this.invocationParams(n), i = NB(e), s = {
      input_tokens: 0,
      output_tokens: 0,
      total_tokens: 0
    };
    if (r.tools && r.tools.length > 0) {
      const f = await this.client.chat({
        ...r,
        messages: i,
        stream: !1
        // Ollama currently does not support streaming with tools
      }), { message: u, ...c } = f;
      return s.input_tokens += c.prompt_eval_count ?? 0, s.output_tokens += c.eval_count ?? 0, s.total_tokens = s.input_tokens + s.output_tokens, yield new Bt({
        text: u.content,
        message: pP(u, {
          responseMetadata: c,
          usageMetadata: s
        })
      }), a?.handleLLMNewToken(u.content);
    }
    const o = await this.client.chat({
      ...r,
      messages: i,
      stream: !0
    });
    let l;
    for await (const f of o) {
      n.signal?.aborted && this.client.abort();
      const { message: u, ...c } = f;
      s.input_tokens += c.prompt_eval_count ?? 0, s.output_tokens += c.eval_count ?? 0, s.total_tokens = s.input_tokens + s.output_tokens, l = c, yield new Bt({
        text: u.content ?? "",
        message: pP(u)
      }), await a?.handleLLMNewToken(u.content ?? "");
    }
    yield new Bt({
      text: "",
      message: new Ze({
        content: "",
        response_metadata: l,
        usage_metadata: s
      })
    });
  }
  withStructuredOutput(e, n) {
    if (n?.method === void 0 || n?.method === "jsonSchema") {
      const a = eu(e), r = a ? Cn(e) : e, i = this.bind({
        format: r
      }), s = a ? Cd.fromZodSchema(e) : new Td();
      if (!n?.includeRaw)
        return i.pipe(s);
      const o = Mt.assign({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parsed: (u, c) => s.invoke(u.raw, c)
      }), l = Mt.assign({
        parsed: () => null
      }), f = o.withFallbacks({
        fallbacks: [l]
      });
      return dt.from([
        {
          raw: i
        },
        f
      ]);
    } else
      return super.withStructuredOutput(e, n);
  }
}
class iK extends j_ {
  constructor(e) {
    super({ maxConcurrency: 1, ...e }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mxbai-embed-large"
    }), Object.defineProperty(this, "baseUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "http://localhost:11434"
    }), Object.defineProperty(this, "keepAlive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "requestOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "truncate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.client = new Gp({
      host: e?.baseUrl,
      headers: e?.headers ? new Headers(e.headers) : void 0
    }), this.baseUrl = e?.baseUrl ?? this.baseUrl, this.model = e?.model ?? this.model, this.keepAlive = e?.keepAlive, this.truncate = e?.truncate ?? this.truncate, this.requestOptions = e?.requestOptions ? this._convertOptions(e?.requestOptions) : void 0;
  }
  /** convert camelCased Ollama request options like "useMMap" to
   * the snake_cased equivalent which the ollama API actually uses.
   * Used only for consistency with the llms/Ollama and chatModels/Ollama classes
   */
  _convertOptions(e) {
    const n = {}, a = {
      embeddingOnly: "embedding_only",
      frequencyPenalty: "frequency_penalty",
      keepAlive: "keep_alive",
      logitsAll: "logits_all",
      lowVram: "low_vram",
      mainGpu: "main_gpu",
      mirostat: "mirostat",
      mirostatEta: "mirostat_eta",
      mirostatTau: "mirostat_tau",
      numBatch: "num_batch",
      numCtx: "num_ctx",
      numGpu: "num_gpu",
      numKeep: "num_keep",
      numPredict: "num_predict",
      numThread: "num_thread",
      penalizeNewline: "penalize_newline",
      presencePenalty: "presence_penalty",
      repeatLastN: "repeat_last_n",
      repeatPenalty: "repeat_penalty",
      temperature: "temperature",
      stop: "stop",
      tfsZ: "tfs_z",
      topK: "top_k",
      topP: "top_p",
      typicalP: "typical_p",
      useMlock: "use_mlock",
      useMmap: "use_mmap",
      vocabOnly: "vocab_only",
      f16Kv: "f16_kv",
      numa: "numa",
      seed: "seed"
    };
    for (const [r, i] of Object.entries(e)) {
      const s = a[r];
      s ? n[s] = i : n[r] = i;
    }
    return n;
  }
  async embedDocuments(e) {
    return this.embeddingWithRetry(e);
  }
  async embedQuery(e) {
    return (await this.embeddingWithRetry([e]))[0];
  }
  async embeddingWithRetry(e) {
    return (await this.caller.call(() => this.client.embed({
      model: this.model,
      input: e,
      keep_alive: this.keepAlive,
      options: this.requestOptions,
      truncate: this.truncate
    }))).embeddings;
  }
}
class sK extends nq {
  static lc_name() {
    return "Ollama";
  }
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "llama3"
    }), Object.defineProperty(this, "baseUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "http://localhost:11434"
    }), Object.defineProperty(this, "keepAlive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "embeddingOnly", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "f16KV", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "frequencyPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logitsAll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lowVram", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainGpu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mirostat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mirostatEta", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mirostatTau", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numBatch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numCtx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numGpu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numKeep", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numPredict", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numThread", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "penalizeNewline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "presencePenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repeatLastN", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repeatPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tfsZ", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topK", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "typicalP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useMLock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useMMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "vocabOnly", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "format", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.model = e?.model ?? this.model, this.baseUrl = e?.baseUrl?.endsWith("/") ? e?.baseUrl.slice(0, -1) : e?.baseUrl ?? this.baseUrl, this.client = new Gp({
      host: this.baseUrl,
      headers: e?.headers
    }), this.keepAlive = e?.keepAlive, this.embeddingOnly = e?.embeddingOnly, this.f16KV = e?.f16Kv, this.frequencyPenalty = e?.frequencyPenalty, this.logitsAll = e?.logitsAll, this.lowVram = e?.lowVram, this.mainGpu = e?.mainGpu, this.mirostat = e?.mirostat, this.mirostatEta = e?.mirostatEta, this.mirostatTau = e?.mirostatTau, this.numBatch = e?.numBatch, this.numCtx = e?.numCtx, this.numGpu = e?.numGpu, this.numKeep = e?.numKeep, this.numPredict = e?.numPredict, this.numThread = e?.numThread, this.penalizeNewline = e?.penalizeNewline, this.presencePenalty = e?.presencePenalty, this.repeatLastN = e?.repeatLastN, this.repeatPenalty = e?.repeatPenalty, this.temperature = e?.temperature, this.stop = e?.stop, this.tfsZ = e?.tfsZ, this.topK = e?.topK, this.topP = e?.topP, this.typicalP = e?.typicalP, this.useMLock = e?.useMlock, this.useMMap = e?.useMmap, this.vocabOnly = e?.vocabOnly, this.format = e?.format;
  }
  _llmType() {
    return "ollama";
  }
  invocationParams(e) {
    return {
      model: this.model,
      format: this.format,
      keep_alive: this.keepAlive,
      images: e?.images,
      options: {
        embedding_only: this.embeddingOnly,
        f16_kv: this.f16KV,
        frequency_penalty: this.frequencyPenalty,
        logits_all: this.logitsAll,
        low_vram: this.lowVram,
        main_gpu: this.mainGpu,
        mirostat: this.mirostat,
        mirostat_eta: this.mirostatEta,
        mirostat_tau: this.mirostatTau,
        num_batch: this.numBatch,
        num_ctx: this.numCtx,
        num_gpu: this.numGpu,
        num_keep: this.numKeep,
        num_predict: this.numPredict,
        num_thread: this.numThread,
        penalize_newline: this.penalizeNewline,
        presence_penalty: this.presencePenalty,
        repeat_last_n: this.repeatLastN,
        repeat_penalty: this.repeatPenalty,
        temperature: this.temperature,
        stop: e?.stop ?? this.stop,
        tfs_z: this.tfsZ,
        top_k: this.topK,
        top_p: this.topP,
        typical_p: this.typicalP,
        use_mlock: this.useMLock,
        use_mmap: this.useMMap,
        vocab_only: this.vocabOnly
      }
    };
  }
  async *_streamResponseChunks(e, n, a) {
    const r = await this.caller.call(async () => this.client.generate({
      ...this.invocationParams(n),
      prompt: e,
      stream: !0
    }));
    for await (const i of r) {
      if (n.signal?.aborted)
        throw new Error("This operation was aborted");
      i.done ? yield new ma({
        text: "",
        generationInfo: {
          model: i.model,
          total_duration: i.total_duration,
          load_duration: i.load_duration,
          prompt_eval_count: i.prompt_eval_count,
          prompt_eval_duration: i.prompt_eval_duration,
          eval_count: i.eval_count,
          eval_duration: i.eval_duration
        }
      }) : (yield new ma({
        text: i.response,
        generationInfo: {
          ...i,
          response: void 0
        }
      }), await a?.handleLLMNewToken(i.response ?? ""));
    }
  }
  /** @ignore */
  async _call(e, n, a) {
    const r = [];
    for await (const i of this._streamResponseChunks(e, n, a))
      r.push(i.text);
    return r.join("");
  }
}
class lr {
  constructor(e) {
    Object.defineProperty(this, "pageContent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.pageContent = e.pageContent !== void 0 ? e.pageContent.toString() : "", this.metadata = e.metadata ?? {}, this.id = e.id;
  }
}
class kB extends Te {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "documents", "transformers"]
    });
  }
  /**
   * Method to invoke the document transformation. This method calls the
   * transformDocuments method with the provided input.
   * @param input The input documents to be transformed.
   * @param _options Optional configuration object to customize the behavior of callbacks.
   * @returns A Promise that resolves to the transformed documents.
   */
  invoke(e, n) {
    return this.transformDocuments(e);
  }
}
class Wp extends Te {
  get lc_attributes() {
    return {
      partialVariables: void 0
      // python doesn't support this yet
    };
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompts", this._getPromptType()]
    }), Object.defineProperty(this, "inputVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputParser", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "partialVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { inputVariables: n } = e;
    if (n.includes("stop"))
      throw new Error("Cannot have an input variable named 'stop', as it is used internally, please rename.");
    Object.assign(this, e);
  }
  /**
   * Merges partial variables and user variables.
   * @param userVariables The user variables to merge with the partial variables.
   * @returns A Promise that resolves to an object containing the merged variables.
   */
  async mergePartialAndUserVariables(e) {
    const n = this.partialVariables ?? {}, a = {};
    for (const [i, s] of Object.entries(n))
      typeof s == "string" ? a[i] = s : a[i] = await s();
    return {
      ...a,
      ...e
    };
  }
  /**
   * Invokes the prompt template with the given input and options.
   * @param input The input to invoke the prompt template with.
   * @param options Optional configuration for the callback.
   * @returns A Promise that resolves to the output of the prompt template.
   */
  async invoke(e, n) {
    const a = {
      ...this.metadata,
      ...n?.metadata
    }, r = [...this.tags ?? [], ...n?.tags ?? []];
    return this._callWithConfig((i) => this.formatPromptValue(i), e, { ...n, tags: r, metadata: a, runType: "prompt" });
  }
  /**
   * Return a json-like object representing this prompt template.
   * @deprecated
   */
  serialize() {
    throw new Error("Use .toJSON() instead");
  }
  /**
   * @deprecated
   * Load a prompt template from a json-like object describing it.
   *
   * @remarks
   * Deserializing needs to be async because templates (e.g. {@link FewShotPromptTemplate}) can
   * reference remote resources that we read asynchronously with a web
   * request.
   */
  static async deserialize(e) {
    switch (e._type) {
      case "prompt": {
        const { PromptTemplate: n } = await Promise.resolve().then(() => _P);
        return n.deserialize(e);
      }
      case void 0: {
        const { PromptTemplate: n } = await Promise.resolve().then(() => _P);
        return n.deserialize({ ...e, _type: "prompt" });
      }
      case "few_shot": {
        const { FewShotPromptTemplate: n } = await Promise.resolve().then(() => cx);
        return n.deserialize(e);
      }
      default:
        throw new Error(`Invalid prompt type in config: ${e._type}`);
    }
  }
}
class ap extends Wp {
  /**
   * Formats the prompt given the input values and returns a formatted
   * prompt value.
   * @param values The input values to format the prompt.
   * @returns A Promise that resolves to a formatted prompt value.
   */
  async formatPromptValue(e) {
    const n = await this.format(e);
    return new JC(n);
  }
}
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
var FB = Object.prototype.toString, bc = Array.isArray || function(e) {
  return FB.call(e) === "[object Array]";
};
function ry(t) {
  return typeof t == "function";
}
function DB(t) {
  return bc(t) ? "array" : typeof t;
}
function gb(t) {
  return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function bP(t, e) {
  return t != null && typeof t == "object" && e in t;
}
function qB(t, e) {
  return t != null && typeof t != "object" && t.hasOwnProperty && t.hasOwnProperty(e);
}
var JB = RegExp.prototype.test;
function LB(t, e) {
  return JB.call(t, e);
}
var UB = /\S/;
function BB(t) {
  return !LB(UB, t);
}
var xB = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function VB(t) {
  return String(t).replace(/[&<>"'`=\/]/g, function(n) {
    return xB[n];
  });
}
var zB = /\s*/, ZB = /\s+/, gP = /\s*=/, KB = /\s*\}/, HB = /#|\^|\/|>|\{|&|=|!/;
function GB(t, e) {
  if (!t)
    return [];
  var n = !1, a = [], r = [], i = [], s = !1, o = !1, l = "", f = 0;
  function u() {
    if (s && !o)
      for (; i.length; )
        delete r[i.pop()];
    else
      i = [];
    s = !1, o = !1;
  }
  var c, h, p;
  function d(A) {
    if (typeof A == "string" && (A = A.split(ZB, 2)), !bc(A) || A.length !== 2)
      throw new Error("Invalid tags: " + A);
    c = new RegExp(gb(A[0]) + "\\s*"), h = new RegExp("\\s*" + gb(A[1])), p = new RegExp("\\s*" + gb("}" + A[1]));
  }
  d(e || dn.tags);
  for (var m = new af(t), b, g, _, P, C, R; !m.eos(); ) {
    if (b = m.pos, _ = m.scanUntil(c), _)
      for (var T = 0, O = _.length; T < O; ++T)
        P = _.charAt(T), BB(P) ? (i.push(r.length), l += P) : (o = !0, n = !0, l += " "), r.push(["text", P, b, b + 1]), b += 1, P === `
` && (u(), l = "", f = 0, n = !1);
    if (!m.scan(c))
      break;
    if (s = !0, g = m.scan(HB) || "name", m.scan(zB), g === "=" ? (_ = m.scanUntil(gP), m.scan(gP), m.scanUntil(h)) : g === "{" ? (_ = m.scanUntil(p), m.scan(KB), m.scanUntil(h), g = "&") : _ = m.scanUntil(h), !m.scan(h))
      throw new Error("Unclosed tag at " + m.pos);
    if (g == ">" ? C = [g, _, b, m.pos, l, f, n] : C = [g, _, b, m.pos], f++, r.push(C), g === "#" || g === "^")
      a.push(C);
    else if (g === "/") {
      if (R = a.pop(), !R)
        throw new Error('Unopened section "' + _ + '" at ' + b);
      if (R[1] !== _)
        throw new Error('Unclosed section "' + R[1] + '" at ' + b);
    } else g === "name" || g === "{" || g === "&" ? o = !0 : g === "=" && d(_);
  }
  if (u(), R = a.pop(), R)
    throw new Error('Unclosed section "' + R[1] + '" at ' + m.pos);
  return XB(WB(r));
}
function WB(t) {
  for (var e = [], n, a, r = 0, i = t.length; r < i; ++r)
    n = t[r], n && (n[0] === "text" && a && a[0] === "text" ? (a[1] += n[1], a[3] = n[3]) : (e.push(n), a = n));
  return e;
}
function XB(t) {
  for (var e = [], n = e, a = [], r, i, s = 0, o = t.length; s < o; ++s)
    switch (r = t[s], r[0]) {
      case "#":
      case "^":
        n.push(r), a.push(r), n = r[4] = [];
        break;
      case "/":
        i = a.pop(), i[5] = r[2], n = a.length > 0 ? a[a.length - 1][4] : e;
        break;
      default:
        n.push(r);
    }
  return e;
}
function af(t) {
  this.string = t, this.tail = t, this.pos = 0;
}
af.prototype.eos = function() {
  return this.tail === "";
};
af.prototype.scan = function(e) {
  var n = this.tail.match(e);
  if (!n || n.index !== 0)
    return "";
  var a = n[0];
  return this.tail = this.tail.substring(a.length), this.pos += a.length, a;
};
af.prototype.scanUntil = function(e) {
  var n = this.tail.search(e), a;
  switch (n) {
    case -1:
      a = this.tail, this.tail = "";
      break;
    case 0:
      a = "";
      break;
    default:
      a = this.tail.substring(0, n), this.tail = this.tail.substring(n);
  }
  return this.pos += a.length, a;
};
function ec(t, e) {
  this.view = t, this.cache = { ".": this.view }, this.parent = e;
}
ec.prototype.push = function(e) {
  return new ec(e, this);
};
ec.prototype.lookup = function(e) {
  var n = this.cache, a;
  if (n.hasOwnProperty(e))
    a = n[e];
  else {
    for (var r = this, i, s, o, l = !1; r; ) {
      if (e.indexOf(".") > 0)
        for (i = r.view, s = e.split("."), o = 0; i != null && o < s.length; )
          o === s.length - 1 && (l = bP(i, s[o]) || qB(i, s[o])), i = i[s[o++]];
      else
        i = r.view[e], l = bP(r.view, e);
      if (l) {
        a = i;
        break;
      }
      r = r.parent;
    }
    n[e] = a;
  }
  return ry(a) && (a = a.call(this.view)), a;
};
function Qt() {
  this.templateCache = {
    _cache: {},
    set: function(e, n) {
      this._cache[e] = n;
    },
    get: function(e) {
      return this._cache[e];
    },
    clear: function() {
      this._cache = {};
    }
  };
}
Qt.prototype.clearCache = function() {
  typeof this.templateCache < "u" && this.templateCache.clear();
};
Qt.prototype.parse = function(e, n) {
  var a = this.templateCache, r = e + ":" + (n || dn.tags).join(":"), i = typeof a < "u", s = i ? a.get(r) : void 0;
  return s == null && (s = GB(e, n), i && a.set(r, s)), s;
};
Qt.prototype.render = function(e, n, a, r) {
  var i = this.getConfigTags(r), s = this.parse(e, i), o = n instanceof ec ? n : new ec(n, void 0);
  return this.renderTokens(s, o, a, e, r);
};
Qt.prototype.renderTokens = function(e, n, a, r, i) {
  for (var s = "", o, l, f, u = 0, c = e.length; u < c; ++u)
    f = void 0, o = e[u], l = o[0], l === "#" ? f = this.renderSection(o, n, a, r, i) : l === "^" ? f = this.renderInverted(o, n, a, r, i) : l === ">" ? f = this.renderPartial(o, n, a, i) : l === "&" ? f = this.unescapedValue(o, n) : l === "name" ? f = this.escapedValue(o, n, i) : l === "text" && (f = this.rawValue(o)), f !== void 0 && (s += f);
  return s;
};
Qt.prototype.renderSection = function(e, n, a, r, i) {
  var s = this, o = "", l = n.lookup(e[1]);
  function f(h) {
    return s.render(h, n, a, i);
  }
  if (l) {
    if (bc(l))
      for (var u = 0, c = l.length; u < c; ++u)
        o += this.renderTokens(e[4], n.push(l[u]), a, r, i);
    else if (typeof l == "object" || typeof l == "string" || typeof l == "number")
      o += this.renderTokens(e[4], n.push(l), a, r, i);
    else if (ry(l)) {
      if (typeof r != "string")
        throw new Error("Cannot use higher-order sections without the original template");
      l = l.call(n.view, r.slice(e[3], e[5]), f), l != null && (o += l);
    } else
      o += this.renderTokens(e[4], n, a, r, i);
    return o;
  }
};
Qt.prototype.renderInverted = function(e, n, a, r, i) {
  var s = n.lookup(e[1]);
  if (!s || bc(s) && s.length === 0)
    return this.renderTokens(e[4], n, a, r, i);
};
Qt.prototype.indentPartial = function(e, n, a) {
  for (var r = n.replace(/[^ \t]/g, ""), i = e.split(`
`), s = 0; s < i.length; s++)
    i[s].length && (s > 0 || !a) && (i[s] = r + i[s]);
  return i.join(`
`);
};
Qt.prototype.renderPartial = function(e, n, a, r) {
  if (a) {
    var i = this.getConfigTags(r), s = ry(a) ? a(e[1]) : a[e[1]];
    if (s != null) {
      var o = e[6], l = e[5], f = e[4], u = s;
      l == 0 && f && (u = this.indentPartial(s, f, o));
      var c = this.parse(u, i);
      return this.renderTokens(c, n, a, u, r);
    }
  }
};
Qt.prototype.unescapedValue = function(e, n) {
  var a = n.lookup(e[1]);
  if (a != null)
    return a;
};
Qt.prototype.escapedValue = function(e, n, a) {
  var r = this.getConfigEscape(a) || dn.escape, i = n.lookup(e[1]);
  if (i != null)
    return typeof i == "number" && r === dn.escape ? String(i) : r(i);
};
Qt.prototype.rawValue = function(e) {
  return e[1];
};
Qt.prototype.getConfigTags = function(e) {
  return bc(e) ? e : e && typeof e == "object" ? e.tags : void 0;
};
Qt.prototype.getConfigEscape = function(e) {
  if (e && typeof e == "object" && !bc(e))
    return e.escape;
};
var dn = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: void 0,
  escape: void 0,
  parse: void 0,
  render: void 0,
  Scanner: void 0,
  Context: void 0,
  Writer: void 0,
  /**
   * Allows a user to override the default caching strategy, by providing an
   * object with set, get and clear methods. This can also be used to disable
   * the cache by setting it to the literal `undefined`.
   */
  set templateCache(t) {
    Ad.templateCache = t;
  },
  /**
   * Gets the default or overridden caching object from the default writer.
   */
  get templateCache() {
    return Ad.templateCache;
  }
}, Ad = new Qt();
dn.clearCache = function() {
  return Ad.clearCache();
};
dn.parse = function(e, n) {
  return Ad.parse(e, n);
};
dn.render = function(e, n, a, r) {
  if (typeof e != "string")
    throw new TypeError('Invalid template! Template should be a "string" but "' + DB(e) + '" was given as the first argument for mustache#render(template, view, partials)');
  return Ad.render(e, n, a, r);
};
dn.escape = VB;
dn.Scanner = af;
dn.Context = ec;
dn.Writer = Qt;
function FM() {
  dn.escape = (t) => t;
}
const ip = (t) => {
  const e = t.split(""), n = [], a = (i, s) => {
    for (let o = s; o < e.length; o += 1)
      if (i.includes(e[o]))
        return o;
    return -1;
  };
  let r = 0;
  for (; r < e.length; )
    if (e[r] === "{" && r + 1 < e.length && e[r + 1] === "{")
      n.push({ type: "literal", text: "{" }), r += 2;
    else if (e[r] === "}" && r + 1 < e.length && e[r + 1] === "}")
      n.push({ type: "literal", text: "}" }), r += 2;
    else if (e[r] === "{") {
      const i = a("}", r);
      if (i < 0)
        throw new Error("Unclosed '{' in template.");
      n.push({
        type: "variable",
        name: e.slice(r + 1, i).join("")
      }), r = i + 1;
    } else {
      if (e[r] === "}")
        throw new Error("Single '}' in template.");
      {
        const i = a("{}", r), s = (i < 0 ? e.slice(r) : e.slice(r, i)).join("");
        n.push({ type: "literal", text: s }), r = i < 0 ? e.length : i;
      }
    }
  return n;
}, QB = (t) => t.map((e) => e[0] === "name" ? { type: "variable", name: e[1].includes(".") ? e[1].split(".")[0] : e[1] } : ["#", "&", "^", ">"].includes(e[0]) ? { type: "variable", name: e[1] } : { type: "literal", text: e[1] }), Og = (t) => {
  FM();
  const e = dn.parse(t);
  return QB(e);
}, YB = (t, e) => ip(t).reduce((n, a) => {
  if (a.type === "variable") {
    if (a.name in e) {
      const r = typeof e[a.name] == "string" ? e[a.name] : JSON.stringify(e[a.name]);
      return n + r;
    }
    throw new Error(`(f-string) Missing value for input ${a.name}`);
  }
  return n + a.text;
}, ""), ex = (t, e) => (FM(), dn.render(t, e)), jg = {
  "f-string": YB,
  mustache: ex
}, tx = {
  "f-string": ip,
  mustache: Og
}, dr = (t, e, n) => {
  try {
    return jg[e](t, n);
  } catch (a) {
    throw Pp(a, "INVALID_PROMPT_INPUT");
  }
}, nx = (t, e) => tx[e](t), ay = (t, e, n) => {
  if (!(e in jg)) {
    const a = Object.keys(jg);
    throw new Error(`Invalid template format. Got \`${e}\`;
                         should be one of ${a}`);
  }
  try {
    const a = n.reduce((r, i) => (r[i] = "foo", r), {});
    Array.isArray(t) ? t.forEach((r) => {
      if (r.type === "text")
        dr(r.text, e, a);
      else if (r.type === "image_url")
        if (typeof r.image_url == "string")
          dr(r.image_url, e, a);
        else {
          const i = r.image_url.url;
          dr(i, e, a);
        }
      else
        throw new Error(`Invalid message template received. ${JSON.stringify(r, null, 2)}`);
    }) : dr(t, e, a);
  } catch (a) {
    throw new Error(`Invalid prompt schema: ${a.message}`);
  }
};
class We extends ap {
  static lc_name() {
    return "PromptTemplate";
  }
  constructor(e) {
    if (super(e), Object.defineProperty(this, "template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "templateFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "f-string"
    }), Object.defineProperty(this, "validateTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "additionalContentFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), e.templateFormat === "mustache" && e.validateTemplate === void 0 && (this.validateTemplate = !1), Object.assign(this, e), this.validateTemplate) {
      if (this.templateFormat === "mustache")
        throw new Error("Mustache templates cannot be validated.");
      let n = this.inputVariables;
      this.partialVariables && (n = n.concat(Object.keys(this.partialVariables))), ay(this.template, this.templateFormat, n);
    }
  }
  _getPromptType() {
    return "prompt";
  }
  /**
   * Formats the prompt template with the provided values.
   * @param values The values to be used to format the prompt template.
   * @returns A promise that resolves to a string which is the formatted prompt.
   */
  async format(e) {
    const n = await this.mergePartialAndUserVariables(e);
    return dr(this.template, this.templateFormat, n);
  }
  /**
   * Take examples in list format with prefix and suffix to create a prompt.
   *
   * Intended to be used a a way to dynamically create a prompt from examples.
   *
   * @param examples - List of examples to use in the prompt.
   * @param suffix - String to go after the list of examples. Should generally set up the user's input.
   * @param inputVariables - A list of variable names the final prompt template will expect
   * @param exampleSeparator - The separator to use in between examples
   * @param prefix - String that should go before any examples. Generally includes examples.
   *
   * @returns The final prompt template generated.
   */
  static fromExamples(e, n, a, r = `

`, i = "") {
    const s = [i, ...e, n].join(r);
    return new We({
      inputVariables: a,
      template: s
    });
  }
  static fromTemplate(e, n) {
    const { templateFormat: a = "f-string", ...r } = n ?? {}, i = /* @__PURE__ */ new Set();
    return nx(e, a).forEach((s) => {
      s.type === "variable" && i.add(s.name);
    }), new We({
      // Rely on extracted types
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      inputVariables: [...i],
      templateFormat: a,
      template: e,
      ...r
    });
  }
  /**
   * Partially applies values to the prompt template.
   * @param values The values to be partially applied to the prompt template.
   * @returns A new instance of PromptTemplate with the partially applied values.
   */
  async partial(e) {
    const n = this.inputVariables.filter((i) => !(i in e)), a = {
      ...this.partialVariables ?? {},
      ...e
    }, r = {
      ...this,
      inputVariables: n,
      partialVariables: a
    };
    return new We(r);
  }
  serialize() {
    if (this.outputParser !== void 0)
      throw new Error("Cannot serialize a prompt template with an output parser");
    return {
      _type: this._getPromptType(),
      input_variables: this.inputVariables,
      template: this.template,
      template_format: this.templateFormat
    };
  }
  static async deserialize(e) {
    if (!e.template)
      throw new Error("Prompt template must have a template");
    return new We({
      inputVariables: e.input_variables,
      template: e.template,
      templateFormat: e.template_format
    });
  }
}
const _P = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PromptTemplate: We
}, Symbol.toStringTag, { value: "Module" }));
class rd extends Wp {
  static lc_name() {
    return "ImagePromptTemplate";
  }
  constructor(e) {
    if (super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompts", "image"]
    }), Object.defineProperty(this, "template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "templateFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "f-string"
    }), Object.defineProperty(this, "validateTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "additionalContentFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.template = e.template, this.templateFormat = e.templateFormat ?? this.templateFormat, this.validateTemplate = e.validateTemplate ?? this.validateTemplate, this.additionalContentFields = e.additionalContentFields, this.validateTemplate) {
      let n = this.inputVariables;
      this.partialVariables && (n = n.concat(Object.keys(this.partialVariables))), ay([
        { type: "image_url", image_url: this.template }
      ], this.templateFormat, n);
    }
  }
  _getPromptType() {
    return "prompt";
  }
  /**
   * Partially applies values to the prompt template.
   * @param values The values to be partially applied to the prompt template.
   * @returns A new instance of ImagePromptTemplate with the partially applied values.
   */
  async partial(e) {
    const n = this.inputVariables.filter((i) => !(i in e)), a = {
      ...this.partialVariables ?? {},
      ...e
    }, r = {
      ...this,
      inputVariables: n,
      partialVariables: a
    };
    return new rd(r);
  }
  /**
   * Formats the prompt template with the provided values.
   * @param values The values to be used to format the prompt template.
   * @returns A promise that resolves to a string which is the formatted prompt.
   */
  async format(e) {
    const n = {};
    for (const [s, o] of Object.entries(this.template))
      typeof o == "string" ? n[s] = dr(o, this.templateFormat, e) : n[s] = o;
    const a = e.url || n.url, r = e.detail || n.detail;
    if (!a)
      throw new Error("Must provide either an image URL.");
    if (typeof a != "string")
      throw new Error("url must be a string.");
    const i = { url: a };
    return r && (i.detail = r), i;
  }
  /**
   * Formats the prompt given the input values and returns a formatted
   * prompt value.
   * @param values The input values to format the prompt.
   * @returns A Promise that resolves to a formatted prompt value.
   */
  async formatPromptValue(e) {
    const n = await this.format(e);
    return new BF(n);
  }
}
class iy extends Te {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompts", "chat"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
  }
  /**
   * Calls the formatMessages method with the provided input and options.
   * @param input Input for the formatMessages method
   * @param options Optional BaseCallbackConfig
   * @returns Formatted output messages
   */
  async invoke(e, n) {
    return this._callWithConfig((a) => this.formatMessages(a), e, { ...n, runType: "prompt" });
  }
}
class yP extends iy {
  static lc_name() {
    return "MessagesPlaceholder";
  }
  constructor(e) {
    typeof e == "string" && (e = { variableName: e }), super(e), Object.defineProperty(this, "variableName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "optional", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.variableName = e.variableName, this.optional = e.optional ?? !1;
  }
  get inputVariables() {
    return [this.variableName];
  }
  async formatMessages(e) {
    const n = e[this.variableName];
    if (this.optional && !n)
      return [];
    if (!n) {
      const r = new Error(`Field "${this.variableName}" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages as an input value. Received: undefined`);
      throw r.name = "InputFormatError", r;
    }
    let a;
    try {
      Array.isArray(n) ? a = n.map(co) : a = [co(n)];
    } catch (r) {
      const i = typeof n == "string" ? n : JSON.stringify(n, null, 2), s = new Error([
        `Field "${this.variableName}" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages or coerceable values as input.`,
        `Received value: ${i}`,
        `Additional message: ${r.message}`
      ].join(`

`));
      throw s.name = "InputFormatError", s.lc_error_code = r.lc_error_code, s;
    }
    return a;
  }
}
class rx extends iy {
  constructor(e) {
    "prompt" in e || (e = { prompt: e }), super(e), Object.defineProperty(this, "prompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.prompt = e.prompt;
  }
  get inputVariables() {
    return this.prompt.inputVariables;
  }
  async formatMessages(e) {
    return [await this.format(e)];
  }
}
class ax extends Wp {
  constructor(e) {
    super(e);
  }
  async format(e) {
    return (await this.formatPromptValue(e)).toString();
  }
  async formatPromptValue(e) {
    const n = await this.formatMessages(e);
    return new LC(n);
  }
}
class ix extends rx {
  static lc_name() {
    return "ChatMessagePromptTemplate";
  }
  constructor(e, n) {
    "prompt" in e || (e = { prompt: e, role: n }), super(e), Object.defineProperty(this, "role", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.role = e.role;
  }
  async format(e) {
    return new yo(await this.prompt.format(e), this.role);
  }
  static fromTemplate(e, n, a) {
    return new this(We.fromTemplate(e, {
      templateFormat: a?.templateFormat
    }), n);
  }
}
class sy extends iy {
  static _messageClass() {
    throw new Error("Can not invoke _messageClass from inside _StringImageMessagePromptTemplate");
  }
  constructor(e, n) {
    if ("prompt" in e || (e = { prompt: e }), super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompts", "chat"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "inputVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "additionalOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "prompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "messageClass", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chatMessageClass", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.prompt = e.prompt, Array.isArray(this.prompt)) {
      let a = [];
      this.prompt.forEach((r) => {
        "inputVariables" in r && (a = a.concat(r.inputVariables));
      }), this.inputVariables = a;
    } else
      this.inputVariables = this.prompt.inputVariables;
    this.additionalOptions = n ?? this.additionalOptions;
  }
  createMessage(e) {
    const n = this.constructor;
    if (n._messageClass()) {
      const a = n._messageClass();
      return new a({ content: e });
    } else if (n.chatMessageClass) {
      const a = n.chatMessageClass();
      return new a({
        content: e,
        role: this.getRoleFromMessageClass(a.lc_name())
      });
    } else
      throw new Error("No message class defined");
  }
  getRoleFromMessageClass(e) {
    switch (e) {
      case "HumanMessage":
        return "human";
      case "AIMessage":
        return "ai";
      case "SystemMessage":
        return "system";
      case "ChatMessage":
        return "chat";
      default:
        throw new Error("Invalid message class name");
    }
  }
  static fromTemplate(e, n) {
    if (typeof e == "string")
      return new this(We.fromTemplate(e, n));
    const a = [];
    for (const r of e)
      if (typeof r == "string" || typeof r == "object" && "text" in r) {
        let i = "";
        typeof r == "string" ? i = r : typeof r.text == "string" && (i = r.text ?? "");
        const s = {
          ...n,
          ...typeof r != "string" ? { additionalContentFields: r } : {}
        };
        a.push(We.fromTemplate(i, s));
      } else if (typeof r == "object" && "image_url" in r) {
        let i = r.image_url ?? "", s, o = [];
        if (typeof i == "string") {
          let l;
          n?.templateFormat === "mustache" ? l = Og(i) : l = ip(i);
          const f = l.flatMap((u) => u.type === "variable" ? [u.name] : []);
          if ((f?.length ?? 0) > 0) {
            if (f.length > 1)
              throw new Error(`Only one format variable allowed per image template.
Got: ${f}
From: ${i}`);
            o = [f[0]];
          } else
            o = [];
          i = { url: i }, s = new rd({
            template: i,
            inputVariables: o,
            templateFormat: n?.templateFormat,
            additionalContentFields: r
          });
        } else if (typeof i == "object") {
          if ("url" in i) {
            let l;
            n?.templateFormat === "mustache" ? l = Og(i.url) : l = ip(i.url), o = l.flatMap((f) => f.type === "variable" ? [f.name] : []);
          } else
            o = [];
          s = new rd({
            template: i,
            inputVariables: o,
            templateFormat: n?.templateFormat,
            additionalContentFields: r
          });
        } else
          throw new Error("Invalid image template");
        a.push(s);
      }
    return new this({ prompt: a, additionalOptions: n });
  }
  async format(e) {
    if (this.prompt instanceof ap) {
      const n = await this.prompt.format(e);
      return this.createMessage(n);
    } else {
      const n = [];
      for (const a of this.prompt) {
        let r = {};
        if (!("inputVariables" in a))
          throw new Error(`Prompt ${a} does not have inputVariables defined.`);
        for (const i of a.inputVariables)
          r || (r = { [i]: e[i] }), r = { ...r, [i]: e[i] };
        if (a instanceof ap) {
          const i = await a.format(r);
          let s;
          "additionalContentFields" in a && (s = a.additionalContentFields), n.push({
            ...s,
            type: "text",
            text: i
          });
        } else if (a instanceof rd) {
          const i = await a.format(r);
          let s;
          "additionalContentFields" in a && (s = a.additionalContentFields), n.push({
            ...s,
            type: "image_url",
            image_url: i
          });
        }
      }
      return this.createMessage(n);
    }
  }
  async formatMessages(e) {
    return [await this.format(e)];
  }
}
class Zs extends sy {
  static _messageClass() {
    return _r;
  }
  static lc_name() {
    return "HumanMessagePromptTemplate";
  }
}
class DM extends sy {
  static _messageClass() {
    return $t;
  }
  static lc_name() {
    return "AIMessagePromptTemplate";
  }
}
class gc extends sy {
  static _messageClass() {
    return jh;
  }
  static lc_name() {
    return "SystemMessagePromptTemplate";
  }
}
function sx(t) {
  return typeof t.formatMessages == "function";
}
function ox(t, e) {
  if (sx(t) || an(t))
    return t;
  if (Array.isArray(t) && t[0] === "placeholder") {
    const r = t[1];
    if (e?.templateFormat === "mustache" && typeof r == "string" && r.slice(0, 2) === "{{" && r.slice(-2) === "}}") {
      const i = r.slice(2, -2);
      return new yP({ variableName: i, optional: !0 });
    } else if (typeof r == "string" && r[0] === "{" && r[r.length - 1] === "}") {
      const i = r.slice(1, -1);
      return new yP({ variableName: i, optional: !0 });
    }
    throw new Error(`Invalid placeholder template for format ${e?.templateFormat ?? '"f-string"'}: "${t[1]}". Expected a variable name surrounded by ${e?.templateFormat === "mustache" ? "double" : "single"} curly braces.`);
  }
  const n = co(t);
  let a;
  if (typeof n.content == "string" ? a = n.content : a = n.content.map((r) => "text" in r ? { ...r, text: r.text } : "image_url" in r ? { ...r, image_url: r.image_url } : r), n._getType() === "human")
    return Zs.fromTemplate(a, e);
  if (n._getType() === "ai")
    return DM.fromTemplate(a, e);
  if (n._getType() === "system")
    return gc.fromTemplate(a, e);
  if (yo.isInstance(n))
    return ix.fromTemplate(n.content, n.role, e);
  throw new Error(`Could not coerce message prompt template from input. Received message type: "${n._getType()}".`);
}
function ux(t) {
  return t.constructor.lc_name() === "MessagesPlaceholder";
}
class da extends ax {
  static lc_name() {
    return "ChatPromptTemplate";
  }
  get lc_aliases() {
    return {
      promptMessages: "messages"
    };
  }
  constructor(e) {
    if (super(e), Object.defineProperty(this, "promptMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "validateTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "templateFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "f-string"
    }), e.templateFormat === "mustache" && e.validateTemplate === void 0 && (this.validateTemplate = !1), Object.assign(this, e), this.validateTemplate) {
      const n = /* @__PURE__ */ new Set();
      for (const o of this.promptMessages)
        if (!(o instanceof ca))
          for (const l of o.inputVariables)
            n.add(l);
      const a = this.inputVariables, r = new Set(this.partialVariables ? a.concat(Object.keys(this.partialVariables)) : a), i = new Set([...r].filter((o) => !n.has(o)));
      if (i.size > 0)
        throw new Error(`Input variables \`${[
          ...i
        ]}\` are not used in any of the prompt messages.`);
      const s = new Set([...n].filter((o) => !r.has(o)));
      if (s.size > 0)
        throw new Error(`Input variables \`${[
          ...s
        ]}\` are used in prompt messages but not in the prompt template.`);
    }
  }
  _getPromptType() {
    return "chat";
  }
  async _parseImagePrompts(e, n) {
    if (typeof e.content == "string")
      return e;
    const a = await Promise.all(e.content.map(async (r) => {
      if (r.type !== "image_url")
        return r;
      let i = "";
      typeof r.image_url == "string" ? i = r.image_url : i = r.image_url.url;
      const o = await We.fromTemplate(i, {
        templateFormat: this.templateFormat
      }).format(n);
      return typeof r.image_url != "string" && "url" in r.image_url ? r.image_url.url = o : r.image_url = o, r;
    }));
    return e.content = a, e;
  }
  async formatMessages(e) {
    const n = await this.mergePartialAndUserVariables(e);
    let a = [];
    for (const r of this.promptMessages)
      if (r instanceof ca)
        a.push(await this._parseImagePrompts(r, n));
      else {
        const i = r.inputVariables.reduce((o, l) => {
          if (!(l in n) && !(ux(r) && r.optional))
            throw Pp(new Error(`Missing value for input variable \`${l.toString()}\``), "INVALID_PROMPT_INPUT");
          return o[l] = n[l], o;
        }, {}), s = await r.formatMessages(i);
        a = a.concat(s);
      }
    return a;
  }
  async partial(e) {
    const n = this.inputVariables.filter((i) => !(i in e)), a = {
      ...this.partialVariables ?? {},
      ...e
    }, r = {
      ...this,
      inputVariables: n,
      partialVariables: a
    };
    return new da(r);
  }
  static fromTemplate(e, n) {
    const a = We.fromTemplate(e, n), r = new Zs({ prompt: a });
    return this.fromMessages([r]);
  }
  /**
   * Create a chat model-specific prompt from individual chat messages
   * or message-like tuples.
   * @param promptMessages Messages to be passed to the chat model
   * @returns A new ChatPromptTemplate
   */
  static fromMessages(e, n) {
    const a = e.reduce((s, o) => s.concat(
      // eslint-disable-next-line no-instanceof/no-instanceof
      o instanceof da ? o.promptMessages : [
        ox(o, n)
      ]
    ), []), r = e.reduce((s, o) => (
      // eslint-disable-next-line no-instanceof/no-instanceof
      o instanceof da ? Object.assign(s, o.partialVariables) : s
    ), /* @__PURE__ */ Object.create(null)), i = /* @__PURE__ */ new Set();
    for (const s of a)
      if (!(s instanceof ca))
        for (const o of s.inputVariables)
          o in r || i.add(o);
    return new this({
      ...n,
      inputVariables: [...i],
      promptMessages: a,
      partialVariables: r,
      templateFormat: n?.templateFormat
    });
  }
  /** @deprecated Renamed to .fromMessages */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static fromPromptMessages(e) {
    return this.fromMessages(e);
  }
}
class sp extends ap {
  constructor(e) {
    if (super(e), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "examples", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "exampleSelector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "examplePrompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "suffix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "exampleSeparator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: `

`
    }), Object.defineProperty(this, "prefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "templateFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "f-string"
    }), Object.defineProperty(this, "validateTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.assign(this, e), this.examples !== void 0 && this.exampleSelector !== void 0)
      throw new Error("Only one of 'examples' and 'example_selector' should be provided");
    if (this.examples === void 0 && this.exampleSelector === void 0)
      throw new Error("One of 'examples' and 'example_selector' should be provided");
    if (this.validateTemplate) {
      let n = this.inputVariables;
      this.partialVariables && (n = n.concat(Object.keys(this.partialVariables))), ay(this.prefix + this.suffix, this.templateFormat, n);
    }
  }
  _getPromptType() {
    return "few_shot";
  }
  static lc_name() {
    return "FewShotPromptTemplate";
  }
  async getExamples(e) {
    if (this.examples !== void 0)
      return this.examples;
    if (this.exampleSelector !== void 0)
      return this.exampleSelector.selectExamples(e);
    throw new Error("One of 'examples' and 'example_selector' should be provided");
  }
  async partial(e) {
    const n = this.inputVariables.filter((i) => !(i in e)), a = {
      ...this.partialVariables ?? {},
      ...e
    }, r = {
      ...this,
      inputVariables: n,
      partialVariables: a
    };
    return new sp(r);
  }
  /**
   * Formats the prompt with the given values.
   * @param values The values to format the prompt with.
   * @returns A promise that resolves to a string representing the formatted prompt.
   */
  async format(e) {
    const n = await this.mergePartialAndUserVariables(e), a = await this.getExamples(n), r = await Promise.all(a.map((s) => this.examplePrompt.format(s))), i = [this.prefix, ...r, this.suffix].join(this.exampleSeparator);
    return dr(i, this.templateFormat, n);
  }
  serialize() {
    if (this.exampleSelector || !this.examples)
      throw new Error("Serializing an example selector is not currently supported");
    if (this.outputParser !== void 0)
      throw new Error("Serializing an output parser is not currently supported");
    return {
      _type: this._getPromptType(),
      input_variables: this.inputVariables,
      example_prompt: this.examplePrompt.serialize(),
      example_separator: this.exampleSeparator,
      suffix: this.suffix,
      prefix: this.prefix,
      template_format: this.templateFormat,
      examples: this.examples
    };
  }
  static async deserialize(e) {
    const { example_prompt: n } = e;
    if (!n)
      throw new Error("Missing example prompt");
    const a = await We.deserialize(n);
    let r;
    if (Array.isArray(e.examples))
      r = e.examples;
    else
      throw new Error("Invalid examples format. Only list or string are supported.");
    return new sp({
      inputVariables: e.input_variables,
      examplePrompt: a,
      examples: r,
      exampleSeparator: e.example_separator,
      prefix: e.prefix,
      suffix: e.suffix,
      templateFormat: e.template_format
    });
  }
}
const cx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FewShotPromptTemplate: sp
}, Symbol.toStringTag, { value: "Module" }));
class oy extends kB {
  constructor(e) {
    if (super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "document_transformers", "text_splitters"]
    }), Object.defineProperty(this, "chunkSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "chunkOverlap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 200
    }), Object.defineProperty(this, "keepSeparator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "lengthFunction", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.chunkSize = e?.chunkSize ?? this.chunkSize, this.chunkOverlap = e?.chunkOverlap ?? this.chunkOverlap, this.keepSeparator = e?.keepSeparator ?? this.keepSeparator, this.lengthFunction = e?.lengthFunction ?? ((n) => n.length), this.chunkOverlap >= this.chunkSize)
      throw new Error("Cannot have chunkOverlap >= chunkSize");
  }
  async transformDocuments(e, n = {}) {
    return this.splitDocuments(e, n);
  }
  splitOnSeparator(e, n) {
    let a;
    if (n)
      if (this.keepSeparator) {
        const r = n.replace(/[/\-\\^$*+?.()|[\]{}]/g, "\\$&");
        a = e.split(new RegExp(`(?=${r})`));
      } else
        a = e.split(n);
    else
      a = e.split("");
    return a.filter((r) => r !== "");
  }
  async createDocuments(e, n = [], a = {}) {
    const r = n.length > 0 ? n : [...Array(e.length)].map(() => ({})), { chunkHeader: i = "", chunkOverlapHeader: s = "(cont'd) ", appendChunkOverlapHeader: o = !1 } = a, l = new Array();
    for (let f = 0; f < e.length; f += 1) {
      const u = e[f];
      let c = 1, h = null, p = -1;
      for (const d of await this.splitText(u)) {
        let m = i;
        const b = u.indexOf(d, p + 1);
        if (h === null) {
          const C = this.numberOfNewLines(u, 0, b);
          c += C;
        } else {
          const C = p + await this.lengthFunction(h);
          if (C < b) {
            const R = this.numberOfNewLines(u, C, b);
            c += R;
          } else if (C > b) {
            const R = this.numberOfNewLines(u, b, C);
            c -= R;
          }
          o && (m += s);
        }
        const g = this.numberOfNewLines(d), _ = r[f].loc && typeof r[f].loc == "object" ? { ...r[f].loc } : {};
        _.lines = {
          from: c,
          to: c + g
        };
        const P = {
          ...r[f],
          loc: _
        };
        m += d, l.push(new lr({
          pageContent: m,
          metadata: P
        })), c += g, h = d, p = b;
      }
    }
    return l;
  }
  numberOfNewLines(e, n, a) {
    return (e.slice(n, a).match(/\n/g) || []).length;
  }
  async splitDocuments(e, n = {}) {
    const a = e.filter((s) => s.pageContent !== void 0), r = a.map((s) => s.pageContent), i = a.map((s) => s.metadata);
    return this.createDocuments(r, i, n);
  }
  joinDocs(e, n) {
    const a = e.join(n).trim();
    return a === "" ? null : a;
  }
  async mergeSplits(e, n) {
    const a = [], r = [];
    let i = 0;
    for (const o of e) {
      const l = await this.lengthFunction(o);
      if (i + l + r.length * n.length > this.chunkSize && (i > this.chunkSize && console.warn(`Created a chunk of size ${i}, +
which is longer than the specified ${this.chunkSize}`), r.length > 0)) {
        const f = this.joinDocs(r, n);
        for (f !== null && a.push(f); i > this.chunkOverlap || i + l + r.length * n.length > this.chunkSize && i > 0; )
          i -= await this.lengthFunction(r[0]), r.shift();
      }
      r.push(o), i += l;
    }
    const s = this.joinDocs(r, n);
    return s !== null && a.push(s), a;
  }
}
class oK extends oy {
  static lc_name() {
    return "CharacterTextSplitter";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "separator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: `

`
    }), this.separator = e?.separator ?? this.separator;
  }
  async splitText(e) {
    const n = this.splitOnSeparator(e, this.separator);
    return this.mergeSplits(n, this.keepSeparator ? "" : this.separator);
  }
}
class op extends oy {
  static lc_name() {
    return "RecursiveCharacterTextSplitter";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "separators", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [`

`, `
`, " ", ""]
    }), this.separators = e?.separators ?? this.separators, this.keepSeparator = e?.keepSeparator ?? !0;
  }
  async _splitText(e, n) {
    const a = [];
    let r = n[n.length - 1], i;
    for (let f = 0; f < n.length; f += 1) {
      const u = n[f];
      if (u === "") {
        r = u;
        break;
      }
      if (e.includes(u)) {
        r = u, i = n.slice(f + 1);
        break;
      }
    }
    const s = this.splitOnSeparator(e, r);
    let o = [];
    const l = this.keepSeparator ? "" : r;
    for (const f of s)
      if (await this.lengthFunction(f) < this.chunkSize)
        o.push(f);
      else {
        if (o.length) {
          const u = await this.mergeSplits(o, l);
          a.push(...u), o = [];
        }
        if (!i)
          a.push(f);
        else {
          const u = await this._splitText(f, i);
          a.push(...u);
        }
      }
    if (o.length) {
      const f = await this.mergeSplits(o, l);
      a.push(...f);
    }
    return a;
  }
  async splitText(e) {
    return this._splitText(e, this.separators);
  }
  static fromLanguage(e, n) {
    return new op({
      ...n,
      separators: op.getSeparatorsForLanguage(e)
    });
  }
  static getSeparatorsForLanguage(e) {
    if (e === "cpp")
      return [
        // Split along class definitions
        `
class `,
        // Split along function definitions
        `
void `,
        `
int `,
        `
float `,
        `
double `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
while `,
        `
switch `,
        `
case `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "go")
      return [
        // Split along function definitions
        `
func `,
        `
var `,
        `
const `,
        `
type `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
switch `,
        `
case `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "java")
      return [
        // Split along class definitions
        `
class `,
        // Split along method definitions
        `
public `,
        `
protected `,
        `
private `,
        `
static `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
while `,
        `
switch `,
        `
case `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "js")
      return [
        // Split along function definitions
        `
function `,
        `
const `,
        `
let `,
        `
var `,
        `
class `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
while `,
        `
switch `,
        `
case `,
        `
default `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "php")
      return [
        // Split along function definitions
        `
function `,
        // Split along class definitions
        `
class `,
        // Split along control flow statements
        `
if `,
        `
foreach `,
        `
while `,
        `
do `,
        `
switch `,
        `
case `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "proto")
      return [
        // Split along message definitions
        `
message `,
        // Split along service definitions
        `
service `,
        // Split along enum definitions
        `
enum `,
        // Split along option definitions
        `
option `,
        // Split along import statements
        `
import `,
        // Split along syntax declarations
        `
syntax `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "python")
      return [
        // First, try to split along class definitions
        `
class `,
        `
def `,
        `
	def `,
        // Now split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "rst")
      return [
        // Split along section titles
        `
===
`,
        `
---
`,
        `
***
`,
        // Split along directive markers
        `
.. `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "ruby")
      return [
        // Split along method definitions
        `
def `,
        `
class `,
        // Split along control flow statements
        `
if `,
        `
unless `,
        `
while `,
        `
for `,
        `
do `,
        `
begin `,
        `
rescue `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "rust")
      return [
        // Split along function definitions
        `
fn `,
        `
const `,
        `
let `,
        // Split along control flow statements
        `
if `,
        `
while `,
        `
for `,
        `
loop `,
        `
match `,
        `
const `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "scala")
      return [
        // Split along class definitions
        `
class `,
        `
object `,
        // Split along method definitions
        `
def `,
        `
val `,
        `
var `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
while `,
        `
match `,
        `
case `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "swift")
      return [
        // Split along function definitions
        `
func `,
        // Split along class definitions
        `
class `,
        `
struct `,
        `
enum `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
while `,
        `
do `,
        `
switch `,
        `
case `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "markdown")
      return [
        // First, try to split along Markdown headings (starting with level 2)
        `
## `,
        `
### `,
        `
#### `,
        `
##### `,
        `
###### `,
        // Note the alternative syntax for headings (below) is not handled here
        // Heading level 2
        // ---------------
        // End of code block
        "```\n\n",
        // Horizontal lines
        `

***

`,
        `

---

`,
        `

___

`,
        // Note that this splitter doesn't handle horizontal lines defined
        // by *three or more* of ***, ---, or ___, but this is not handled
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "latex")
      return [
        // First, try to split along Latex sections
        `
\\chapter{`,
        `
\\section{`,
        `
\\subsection{`,
        `
\\subsubsection{`,
        // Now split by environments
        `
\\begin{enumerate}`,
        `
\\begin{itemize}`,
        `
\\begin{description}`,
        `
\\begin{list}`,
        `
\\begin{quote}`,
        `
\\begin{quotation}`,
        `
\\begin{verse}`,
        `
\\begin{verbatim}`,
        // Now split by math environments
        `
\\begin{align}`,
        "$$",
        "$",
        // Now split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "html")
      return [
        // First, try to split along HTML tags
        "<body>",
        "<div>",
        "<p>",
        "<br>",
        "<li>",
        "<h1>",
        "<h2>",
        "<h3>",
        "<h4>",
        "<h5>",
        "<h6>",
        "<span>",
        "<table>",
        "<tr>",
        "<td>",
        "<th>",
        "<ul>",
        "<ol>",
        "<header>",
        "<footer>",
        "<nav>",
        // Head
        "<head>",
        "<style>",
        "<script>",
        "<meta>",
        "<title>",
        // Normal type of lines
        " ",
        ""
      ];
    if (e === "sol")
      return [
        // Split along compiler informations definitions
        `
pragma `,
        `
using `,
        // Split along contract definitions
        `
contract `,
        `
interface `,
        `
library `,
        // Split along method definitions
        `
constructor `,
        `
type `,
        `
function `,
        `
event `,
        `
modifier `,
        `
error `,
        `
struct `,
        `
enum `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
while `,
        `
do while `,
        `
assembly `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    throw new Error(`Language ${e} is not supported.`);
  }
}
class uK extends oy {
  static lc_name() {
    return "TokenTextSplitter";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "encodingName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "allowedSpecial", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "disallowedSpecial", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tokenizer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.encodingName = e?.encodingName ?? "gpt2", this.allowedSpecial = e?.allowedSpecial ?? [], this.disallowedSpecial = e?.disallowedSpecial ?? "all";
  }
  async splitText(e) {
    this.tokenizer || (this.tokenizer = await BC(this.encodingName));
    const n = [], a = this.tokenizer.encode(e, this.allowedSpecial, this.disallowedSpecial);
    let r = 0;
    for (; r < a.length; ) {
      r > 0 && (r -= this.chunkOverlap);
      const i = Math.min(r + this.chunkSize, a.length), s = a.slice(r, i);
      n.push(this.tokenizer.decode(s)), r = i;
    }
    return n;
  }
}
class qM {
}
const JM = (t, e) => {
  if (e !== void 0)
    return t[e];
  const n = Object.keys(t);
  if (n.length === 1)
    return t[n[0]];
}, LM = (t, e) => {
  const n = JM(t, e);
  if (!n) {
    const a = Object.keys(t);
    throw new Error(`input values have ${a.length} keys, you must specify an input key or pass only 1 key as input`);
  }
  return n;
}, lx = (t, e) => {
  const n = JM(t, e);
  if (!n && n !== "") {
    const a = Object.keys(t);
    throw new Error(`output values have ${a.length} keys, you must specify an output key or pass only 1 key as output`);
  }
  return n;
};
class dx extends gr {
  /**
   * This is a convenience method for adding a human message string to the store.
   * Please note that this is a convenience method. Code should favor the
   * bulk addMessages interface instead to save on round-trips to the underlying
   * persistence layer.
   * This method may be deprecated in a future release.
   */
  addUserMessage(e) {
    return this.addMessage(new _r(e));
  }
  /** @deprecated Use addAIMessage instead */
  addAIChatMessage(e) {
    return this.addMessage(new $t(e));
  }
  /**
   * This is a convenience method for adding an AI message string to the store.
   * Please note that this is a convenience method. Code should favor the bulk
   * addMessages interface instead to save on round-trips to the underlying
   * persistence layer.
   * This method may be deprecated in a future release.
   */
  addAIMessage(e) {
    return this.addMessage(new $t(e));
  }
  /**
   * Add a list of messages.
   *
   * Implementations should override this method to handle bulk addition of messages
   * in an efficient manner to avoid unnecessary round-trips to the underlying store.
   *
   * @param messages - A list of BaseMessage objects to store.
   */
  async addMessages(e) {
    for (const n of e)
      await this.addMessage(n);
  }
  /**
   * Remove all messages from the store.
   */
  clear() {
    throw new Error("Not implemented.");
  }
}
class fx extends dx {
  constructor(e) {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "stores", "message", "in_memory"]
    }), Object.defineProperty(this, "messages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this.messages = e ?? [];
  }
  /**
   * Method to get all the messages stored in the ChatMessageHistory
   * instance.
   * @returns Array of stored BaseMessage instances.
   */
  async getMessages() {
    return this.messages;
  }
  /**
   * Method to add a new message to the ChatMessageHistory instance.
   * @param message The BaseMessage instance to add.
   * @returns A promise that resolves when the message has been added.
   */
  async addMessage(e) {
    this.messages.push(e);
  }
  /**
   * Method to clear all the messages from the ChatMessageHistory instance.
   * @returns A promise that resolves when all messages have been cleared.
   */
  async clear() {
    this.messages = [];
  }
}
class uy extends qM {
  constructor(e) {
    super(), Object.defineProperty(this, "chatHistory", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.chatHistory = e?.chatHistory ?? new fx(), this.returnMessages = e?.returnMessages ?? this.returnMessages, this.inputKey = e?.inputKey ?? this.inputKey, this.outputKey = e?.outputKey ?? this.outputKey;
  }
  /**
   * Method to add user and AI messages to the chat history in sequence.
   * @param inputValues The input values from the user.
   * @param outputValues The output values from the AI.
   * @returns Promise that resolves when the context has been saved.
   */
  async saveContext(e, n) {
    await this.chatHistory.addUserMessage(LM(e, this.inputKey)), await this.chatHistory.addAIChatMessage(lx(n, this.outputKey));
  }
  /**
   * Method to clear the chat history.
   * @returns Promise that resolves when the chat history has been cleared.
   */
  async clear() {
    await this.chatHistory.clear();
  }
}
class hx extends uy {
  constructor(e) {
    super({
      chatHistory: e?.chatHistory,
      returnMessages: e?.returnMessages ?? !1,
      inputKey: e?.inputKey,
      outputKey: e?.outputKey
    }), Object.defineProperty(this, "humanPrefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Human"
    }), Object.defineProperty(this, "aiPrefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AI"
    }), Object.defineProperty(this, "memoryKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "history"
    }), this.humanPrefix = e?.humanPrefix ?? this.humanPrefix, this.aiPrefix = e?.aiPrefix ?? this.aiPrefix, this.memoryKey = e?.memoryKey ?? this.memoryKey;
  }
  get memoryKeys() {
    return [this.memoryKey];
  }
  /**
   * Loads the memory variables. It takes an `InputValues` object as a
   * parameter and returns a `Promise` that resolves with a
   * `MemoryVariables` object.
   * @param _values `InputValues` object.
   * @returns A `Promise` that resolves with a `MemoryVariables` object.
   */
  async loadMemoryVariables(e) {
    const n = await this.chatHistory.getMessages();
    return this.returnMessages ? {
      [this.memoryKey]: n
    } : {
      [this.memoryKey]: lo(n, this.humanPrefix, this.aiPrefix)
    };
  }
}
class kt extends m_ {
  get lc_namespace() {
    return ["langchain", "chains", this._chainType()];
  }
  constructor(e, n, a) {
    if (arguments.length === 1 && typeof e == "object" && !("saveContext" in e)) {
      const { memory: r, callbackManager: i, ...s } = e;
      super({ ...s, callbacks: i ?? s.callbacks }), this.memory = r;
    } else
      super({ verbose: n, callbacks: a }), this.memory = e;
  }
  /** @ignore */
  _selectMemoryInputs(e) {
    const n = { ...e };
    return "signal" in n && delete n.signal, "timeout" in n && delete n.timeout, n;
  }
  /**
   * Invoke the chain with the provided input and returns the output.
   * @param input Input values for the chain run.
   * @param config Optional configuration for the Runnable.
   * @returns Promise that resolves with the output of the chain run.
   */
  async invoke(e, n) {
    const a = Re(n), r = await this._formatValues(e), s = await (await st.configure(a?.callbacks, this.callbacks, a?.tags, this.tags, a?.metadata, this.metadata, { verbose: this.verbose }))?.handleChainStart(this.toJSON(), r, void 0, void 0, void 0, void 0, a?.runName);
    let o;
    try {
      o = await (r.signal ? Promise.race([
        this._call(r, s, a),
        new Promise((l, f) => {
          r.signal?.addEventListener("abort", () => {
            f(new Error("AbortError"));
          });
        })
      ]) : this._call(r, s, a));
    } catch (l) {
      throw await s?.handleChainError(l), l;
    }
    return this.memory != null && await this.memory.saveContext(this._selectMemoryInputs(e), o), await s?.handleChainEnd(o), Object.defineProperty(o, Rd, {
      value: s ? { runId: s?.runId } : void 0,
      configurable: !0
    }), o;
  }
  _validateOutputs(e) {
    const n = this.outputKeys.filter((a) => !(a in e));
    if (n.length)
      throw new Error(`Missing output keys: ${n.join(", ")} from chain ${this._chainType()}`);
  }
  async prepOutputs(e, n, a = !1) {
    return this._validateOutputs(n), this.memory && await this.memory.saveContext(e, n), a ? n : { ...e, ...n };
  }
  /**
   * Return a json-like object representing this chain.
   */
  serialize() {
    throw new Error("Method not implemented.");
  }
  /** @deprecated Use .invoke() instead. Will be removed in 0.2.0. */
  async run(e, n) {
    const a = this.inputKeys.filter((l) => !this.memory?.memoryKeys.includes(l));
    if (!(a.length <= 1))
      throw new Error(`Chain ${this._chainType()} expects multiple inputs, cannot use 'run' `);
    const i = a.length ? { [a[0]]: e } : {}, s = await this.call(i, n), o = Object.keys(s);
    if (o.length === 1)
      return s[o[0]];
    throw new Error("return values have multiple keys, `run` only supported when one key currently");
  }
  async _formatValues(e) {
    const n = { ...e };
    if (n.timeout && !n.signal && (n.signal = AbortSignal.timeout(n.timeout), delete n.timeout), this.memory != null) {
      const a = await this.memory.loadMemoryVariables(this._selectMemoryInputs(e));
      for (const [r, i] of Object.entries(a))
        n[r] = i;
    }
    return n;
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Run the core logic of this chain and add to output if desired.
   *
   * Wraps _call and handles memory.
   */
  async call(e, n, a) {
    const r = { tags: a, ...Cp(n) };
    return this.invoke(e, r);
  }
  /**
   * @deprecated Use .batch() instead. Will be removed in 0.2.0.
   *
   * Call the chain on all inputs in the list
   */
  async apply(e, n) {
    return Promise.all(e.map(async (a, r) => this.call(a, n?.[r])));
  }
  /**
   * Load a chain from a json-like object describing it.
   */
  static async deserialize(e, n = {}) {
    switch (e._type) {
      case "llm_chain": {
        const { LLMChain: a } = await Promise.resolve().then(() => bx);
        return a.deserialize(e);
      }
      case "sequential_chain": {
        const { SequentialChain: a } = await Promise.resolve().then(() => RP);
        return a.deserialize(e);
      }
      case "simple_sequential_chain": {
        const { SimpleSequentialChain: a } = await Promise.resolve().then(() => RP);
        return a.deserialize(e);
      }
      case "stuff_documents_chain": {
        const { StuffDocumentsChain: a } = await Promise.resolve().then(() => wb);
        return a.deserialize(e);
      }
      case "map_reduce_documents_chain": {
        const { MapReduceDocumentsChain: a } = await Promise.resolve().then(() => wb);
        return a.deserialize(e);
      }
      case "refine_documents_chain": {
        const { RefineDocumentsChain: a } = await Promise.resolve().then(() => wb);
        return a.deserialize(e);
      }
      case "vector_db_qa": {
        const { VectorDBQAChain: a } = await Promise.resolve().then(() => w4);
        return a.deserialize(e, n);
      }
      case "api_chain": {
        const { APIChain: a } = await Promise.resolve().then(() => J4);
        return a.deserialize(e);
      }
      default:
        throw new Error(`Invalid prompt type in config: ${e._type}`);
    }
  }
}
class px extends Kd {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "output_parsers", "default"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
  }
  static lc_name() {
    return "NoOpOutputParser";
  }
  /**
   * This method takes a string as input and returns the same string as
   * output. It does not perform any operations on the input string.
   * @param text The input string to be parsed.
   * @returns The same input string without any operations performed on it.
   */
  parse(e) {
    return Promise.resolve(e);
  }
  /**
   * This method returns an empty string. It does not provide any formatting
   * instructions.
   * @returns An empty string, indicating no formatting instructions.
   */
  getFormatInstructions() {
    return "";
  }
}
function mx(t) {
  return typeof t._llmType == "function";
}
function fh(t) {
  if (mx(t))
    return t;
  if ("bound" in t && Te.isRunnable(t.bound))
    return fh(t.bound);
  if ("runnable" in t && "fallbacks" in t && Te.isRunnable(t.runnable))
    return fh(t.runnable);
  if ("default" in t && Te.isRunnable(t.default))
    return fh(t.default);
  throw new Error("Unable to extract BaseLanguageModel from llmLike object.");
}
class nt extends kt {
  static lc_name() {
    return "LLMChain";
  }
  get inputKeys() {
    return this.prompt.inputVariables;
  }
  get outputKeys() {
    return [this.outputKey];
  }
  constructor(e) {
    if (super(e), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "prompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "llm", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "llmKwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "text"
    }), Object.defineProperty(this, "outputParser", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.prompt = e.prompt, this.llm = e.llm, this.llmKwargs = e.llmKwargs, this.outputKey = e.outputKey ?? this.outputKey, this.outputParser = e.outputParser ?? new px(), this.prompt.outputParser) {
      if (e.outputParser)
        throw new Error("Cannot set both outputParser and prompt.outputParser");
      this.outputParser = this.prompt.outputParser;
    }
  }
  getCallKeys() {
    return "callKeys" in this.llm ? this.llm.callKeys : [];
  }
  /** @ignore */
  _selectMemoryInputs(e) {
    const n = super._selectMemoryInputs(e), a = this.getCallKeys();
    for (const r of a)
      r in e && delete n[r];
    return n;
  }
  /** @ignore */
  async _getFinalOutput(e, n, a) {
    let r;
    return this.outputParser ? r = await this.outputParser.parseResultWithPrompt(e, n, a?.getChild()) : r = e[0].text, r;
  }
  /**
   * Run the core logic of this chain and add to output if desired.
   *
   * Wraps _call and handles memory.
   */
  call(e, n) {
    return super.call(e, n);
  }
  /** @ignore */
  async _call(e, n) {
    const a = { ...e }, r = {
      ...this.llmKwargs
    }, i = this.getCallKeys();
    for (const f of i)
      f in e && r && (r[f] = e[f], delete a[f]);
    const s = await this.prompt.formatPromptValue(a);
    if ("generatePrompt" in this.llm) {
      const { generations: f } = await this.llm.generatePrompt([s], r, n?.getChild());
      return {
        [this.outputKey]: await this._getFinalOutput(f[0], s, n)
      };
    }
    const l = await (this.outputParser ? this.llm.pipe(this.outputParser) : this.llm).invoke(s, n?.getChild());
    return {
      [this.outputKey]: l
    };
  }
  /**
   * Format prompt with values and pass to LLM
   *
   * @param values - keys to pass to prompt template
   * @param callbackManager - CallbackManager to use
   * @returns Completion from LLM.
   *
   * @example
   * ```ts
   * llm.predict({ adjective: "funny" })
   * ```
   */
  async predict(e, n) {
    return (await this.call(e, n))[this.outputKey];
  }
  _chainType() {
    return "llm";
  }
  static async deserialize(e) {
    const { llm: n, prompt: a } = e;
    if (!n)
      throw new Error("LLMChain must have llm");
    if (!a)
      throw new Error("LLMChain must have prompt");
    return new nt({
      llm: await b_.deserialize(n),
      prompt: await Wp.deserialize(a)
    });
  }
  /** @deprecated */
  serialize() {
    const e = "serialize" in this.llm ? this.llm.serialize() : void 0;
    return {
      _type: `${this._chainType()}_chain`,
      llm: e,
      prompt: this.prompt.serialize()
    };
  }
  _getNumTokens(e) {
    return fh(this.llm).getNumTokens(e);
  }
}
const bx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LLMChain: nt
}, Symbol.toStringTag, { value: "Module" })), gx = `Progressively summarize the lines of conversation provided, adding onto the previous summary returning a new summary.

EXAMPLE
Current summary:
The human asks what the AI thinks of artificial intelligence. The AI thinks artificial intelligence is a force for good.

New lines of conversation:
Human: Why do you think artificial intelligence is a force for good?
AI: Because artificial intelligence will help humans reach their full potential.

New summary:
The human asks what the AI thinks of artificial intelligence. The AI thinks artificial intelligence is a force for good because it will help humans reach their full potential.
END OF EXAMPLE

Current summary:
{summary}

New lines of conversation:
{new_lines}

New summary:`, _x = /* @__PURE__ */ new We({
  inputVariables: ["summary", "new_lines"],
  template: gx
});
class yx extends uy {
  constructor(e) {
    const { returnMessages: n, inputKey: a, outputKey: r, chatHistory: i, humanPrefix: s, aiPrefix: o, llm: l, prompt: f, summaryChatMessageClass: u } = e;
    super({ returnMessages: n, inputKey: a, outputKey: r, chatHistory: i }), Object.defineProperty(this, "memoryKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "history"
    }), Object.defineProperty(this, "humanPrefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Human"
    }), Object.defineProperty(this, "aiPrefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AI"
    }), Object.defineProperty(this, "llm", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "prompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: _x
    }), Object.defineProperty(this, "summaryChatMessageClass", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: jh
    }), this.memoryKey = e?.memoryKey ?? this.memoryKey, this.humanPrefix = s ?? this.humanPrefix, this.aiPrefix = o ?? this.aiPrefix, this.llm = l, this.prompt = f ?? this.prompt, this.summaryChatMessageClass = u ?? this.summaryChatMessageClass;
  }
  /**
   * Predicts a new summary for the conversation given the existing messages
   * and summary.
   * @param messages Existing messages in the conversation.
   * @param existingSummary Current summary of the conversation.
   * @returns A promise that resolves to a new summary string.
   */
  async predictNewSummary(e, n) {
    const a = lo(e, this.humanPrefix, this.aiPrefix);
    return await new nt({ llm: this.llm, prompt: this.prompt }).predict({
      summary: n,
      new_lines: a
    });
  }
}
class cK extends yx {
  constructor(e) {
    super(e), Object.defineProperty(this, "buffer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    });
  }
  get memoryKeys() {
    return [this.memoryKey];
  }
  /**
   * Loads the memory variables for the conversation memory.
   * @returns A promise that resolves to an object containing the memory variables.
   */
  async loadMemoryVariables(e) {
    return this.returnMessages ? {
      [this.memoryKey]: [new this.summaryChatMessageClass(this.buffer)]
    } : { [this.memoryKey]: this.buffer };
  }
  /**
   * Saves the context of the conversation memory.
   * @param inputValues Input values for the conversation.
   * @param outputValues Output values from the conversation.
   * @returns A promise that resolves when the context has been saved.
   */
  async saveContext(e, n) {
    await super.saveContext(e, n);
    const a = await this.chatHistory.getMessages();
    this.buffer = await this.predictNewSummary(a.slice(-2), this.buffer);
  }
  /**
   * Clears the conversation memory.
   * @returns A promise that resolves when the memory has been cleared.
   */
  async clear() {
    await super.clear(), this.buffer = "";
  }
}
const wx = (t) => t.map((e) => e.pageContent).join(`

`);
class lK extends qM {
  constructor(e) {
    super(), Object.defineProperty(this, "vectorStoreRetriever", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "memoryKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnDocs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.vectorStoreRetriever = e.vectorStoreRetriever, this.inputKey = e.inputKey, this.memoryKey = e.memoryKey ?? "memory", this.returnDocs = e.returnDocs ?? !1, this.metadata = e.metadata;
  }
  get memoryKeys() {
    return [this.memoryKey];
  }
  /**
   * Method to load memory variables. It uses the vectorStoreRetriever to
   * get relevant documents based on the query obtained from the input
   * values.
   * @param values An InputValues object.
   * @returns A Promise that resolves to a MemoryVariables object.
   */
  async loadMemoryVariables(e) {
    const n = LM(e, this.inputKey), a = await this.vectorStoreRetriever.getRelevantDocuments(n);
    return {
      [this.memoryKey]: this.returnDocs ? a : wx(a)
    };
  }
  /**
   * Method to save context. It constructs a document from the input and
   * output values (excluding the memory key) and adds it to the vector
   * store database using the vectorStoreRetriever.
   * @param inputValues An InputValues object.
   * @param outputValues An OutputValues object.
   * @returns A Promise that resolves to void.
   */
  async saveContext(e, n) {
    const a = typeof this.metadata == "function" ? this.metadata(e, n) : this.metadata, r = Object.entries(e).filter(([i]) => i !== this.memoryKey).concat(Object.entries(n)).map(([i, s]) => `${i}: ${s}`).join(`
`);
    await this.vectorStoreRetriever.addDocuments([
      new lr({ pageContent: r, metadata: a })
    ]);
  }
}
class dK extends uy {
  constructor(e) {
    super(e), Object.defineProperty(this, "humanPrefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Human"
    }), Object.defineProperty(this, "aiPrefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AI"
    }), Object.defineProperty(this, "memoryKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "history"
    }), Object.defineProperty(this, "maxTokenLimit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 2e3
    }), Object.defineProperty(this, "llm", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.llm = e.llm, this.humanPrefix = e?.humanPrefix ?? this.humanPrefix, this.aiPrefix = e?.aiPrefix ?? this.aiPrefix, this.memoryKey = e?.memoryKey ?? this.memoryKey, this.maxTokenLimit = e?.maxTokenLimit ?? this.maxTokenLimit;
  }
  get memoryKeys() {
    return [this.memoryKey];
  }
  /**
   * Loads the memory variables. It takes an `InputValues` object as a
   * parameter and returns a `Promise` that resolves with a
   * `MemoryVariables` object.
   * @param _values `InputValues` object.
   * @returns A `Promise` that resolves with a `MemoryVariables` object.
   */
  async loadMemoryVariables(e) {
    const n = await this.chatHistory.getMessages();
    return this.returnMessages ? {
      [this.memoryKey]: n
    } : {
      [this.memoryKey]: lo(n, this.humanPrefix, this.aiPrefix)
    };
  }
  /**
   * Saves the context from this conversation to buffer. If the amount
   * of tokens required to save the buffer exceeds MAX_TOKEN_LIMIT,
   * prune it.
   */
  async saveContext(e, n) {
    await super.saveContext(e, n);
    const a = await this.chatHistory.getMessages();
    let r = await this.llm.getNumTokens(lo(a, this.humanPrefix, this.aiPrefix));
    if (r > this.maxTokenLimit) {
      const i = [];
      for (; r > this.maxTokenLimit; )
        i.push(a.shift()), r = await this.llm.getNumTokens(lo(a, this.humanPrefix, this.aiPrefix));
    }
  }
}
class cy {
  /**
   * @deprecated Use `this.load()` and `splitter.splitDocuments()` individually.
   * Loads the documents and splits them using a specified text splitter.
   * @param textSplitter The TextSplitter instance to use for splitting the loaded documents. Defaults to a RecursiveCharacterTextSplitter instance.
   * @returns A Promise that resolves with an array of Document instances, each split according to the provided TextSplitter.
   */
  async loadAndSplit(e) {
    if (e === void 0)
      throw new Error("You must pass a text splitter to use this method.");
    const n = await this.load();
    return e.invoke(n);
  }
}
class hh extends cy {
  constructor(e, n) {
    super(), Object.defineProperty(this, "webPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "selector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textDecoder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { timeout: a, selector: r, textDecoder: i, headers: s, ...o } = n ?? {};
    this.timeout = a ?? 1e4, this.caller = new ru(o), this.selector = r ?? "body", this.textDecoder = i, this.headers = s;
  }
  /**
   * Fetches web documents from the given array of URLs and loads them using Cheerio.
   * It returns an array of CheerioAPI instances.
   * @param urls An array of URLs to fetch and load.
   * @returns A Promise that resolves to an array of CheerioAPI instances.
   */
  static async scrapeAll(e, n, a, r, i) {
    return Promise.all(e.map((s) => hh._scrape(s, n, a, r, i)));
  }
  static async _scrape(e, n, a, r, i) {
    const { headers: s, ...o } = i ?? {}, { load: l } = await hh.imports(), f = await n.call(fetch, e, {
      signal: a ? AbortSignal.timeout(a) : void 0,
      headers: s
    }), u = r?.decode(await f.arrayBuffer()) ?? await f.text();
    return l(u, o);
  }
  /**
   * Fetches the web document from the webPath and loads it using Cheerio.
   * It returns a CheerioAPI instance.
   * @returns A Promise that resolves to a CheerioAPI instance.
   */
  async scrape() {
    const e = { headers: this.headers };
    return hh._scrape(this.webPath, this.caller, this.timeout, this.textDecoder, e);
  }
  /**
   * Extracts the text content from the loaded document using the selector
   * and creates a Document instance with the extracted text and metadata.
   * It returns an array of Document instances.
   * @returns A Promise that resolves to an array of Document instances.
   */
  async load() {
    const e = await this.scrape(), n = e("title").text(), a = e(this.selector).text(), r = { source: this.webPath, title: n };
    return [new lr({ pageContent: a, metadata: r })];
  }
  /**
   * A static method that dynamically imports the Cheerio library and
   * returns the load function. If the import fails, it throws an error.
   * @returns A Promise that resolves to an object containing the load function from the Cheerio library.
   */
  static async imports() {
    try {
      const { load: e } = await Promise.resolve().then(() => QV);
      return { load: e };
    } catch (e) {
      throw console.error(e), new Error("Please install cheerio as a dependency with, e.g. `yarn add cheerio`");
    }
  }
}
class fK extends cy {
  constructor(e, n) {
    super(), Object.defineProperty(this, "webPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textDecoder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { timeout: a, textDecoder: r, headers: i, ...s } = n ?? {};
    this.timeout = a ?? 1e4, this.caller = new ru(s), this.textDecoder = r, this.headers = i;
  }
  async load() {
    const e = await this.caller.call(fetch, this.webPath, {
      signal: this.timeout ? AbortSignal.timeout(this.timeout) : void 0,
      headers: this.headers
    }), n = this.textDecoder?.decode(await e.arrayBuffer()) ?? await e.text();
    return [new lr({ pageContent: n })];
  }
}
class hK extends cy {
  constructor(e, { splitPages: n = !0, pdfjs: a = vx, parsedItemSeparator: r = "" } = {}) {
    super(), Object.defineProperty(this, "blob", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "splitPages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "pdfjs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "parsedItemSeparator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.blob = e, this.splitPages = n ?? this.splitPages, this.pdfjs = a, this.parsedItemSeparator = r;
  }
  /**
   * Loads the contents of the PDF as documents.
   * @returns An array of Documents representing the retrieved data.
   */
  async load() {
    const { getDocument: e, version: n } = await this.pdfjs(), a = await e({
      data: new Uint8Array(await this.blob.arrayBuffer()),
      useWorkerFetch: !1,
      isEvalSupported: !1,
      useSystemFonts: !0
    }).promise, r = await a.getMetadata().catch(() => null), i = [];
    for (let s = 1; s <= a.numPages; s += 1) {
      const l = await (await a.getPage(s)).getTextContent();
      if (l.items.length === 0)
        continue;
      let f;
      const u = [];
      for (const h of l.items)
        "str" in h && (f === h.transform[5] || !f ? u.push(h.str) : u.push(`
${h.str}`), f = h.transform[5]);
      const c = u.join(this.parsedItemSeparator);
      i.push(new lr({
        pageContent: c,
        metadata: {
          pdf: {
            version: n,
            info: r?.info,
            metadata: r?.metadata,
            totalPages: a.numPages
          },
          loc: {
            pageNumber: s
          }
        }
      }));
    }
    return this.splitPages ? i : i.length === 0 ? [] : [
      new lr({
        pageContent: i.map((s) => s.pageContent).join(`

`),
        metadata: {
          pdf: {
            version: n,
            info: r?.info,
            metadata: r?.metadata,
            totalPages: a.numPages
          }
        }
      })
    ];
  }
}
async function vx() {
  try {
    const { default: t } = await Promise.resolve().then(() => ez), { getDocument: e, version: n } = t;
    return { getDocument: e, version: n };
  } catch (t) {
    throw console.error(t), new Error("Failed to load pdf-parse. Please install it with eg. `npm install pdf-parse`.");
  }
}
class Sx extends Te {
  /**
   * Constructs a new `BaseRetriever` instance with optional configuration fields.
   *
   * @param fields - Optional input configuration that can include `callbacks`,
   *                 `tags`, `metadata`, and `verbose` settings for custom retriever behavior.
   */
  constructor(e) {
    super(e), Object.defineProperty(this, "callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "verbose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.callbacks = e?.callbacks, this.tags = e?.tags ?? [], this.metadata = e?.metadata ?? {}, this.verbose = e?.verbose ?? !1;
  }
  /**
   * TODO: This should be an abstract method, but we'd like to avoid breaking
   * changes to people currently using subclassed custom retrievers.
   * Change it on next major release.
   */
  /**
   * Placeholder method for retrieving relevant documents based on a query.
   *
   * This method is intended to be implemented by subclasses and will be
   * converted to an abstract method in the next major release. Currently, it
   * throws an error if not implemented, ensuring that custom retrievers define
   * the specific retrieval logic.
   *
   * @param _query - The query string used to search for relevant documents.
   * @param _callbacks - (optional) Callback manager for managing callbacks
   *                     during retrieval.
   * @returns A promise resolving to an array of `DocumentInterface` instances relevant to the query.
   * @throws {Error} Throws an error indicating the method is not implemented.
   */
  _getRelevantDocuments(e, n) {
    throw new Error("Not implemented!");
  }
  /**
   * Executes a retrieval operation.
   *
   * @param input - The query string used to search for relevant documents.
   * @param options - (optional) Configuration options for the retrieval run,
   *                  which may include callbacks, tags, and metadata.
   * @returns A promise that resolves to an array of `DocumentInterface` instances
   *          representing the most relevant documents to the query.
   */
  async invoke(e, n) {
    return this.getRelevantDocuments(e, Re(n));
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
   *
   * Main method used to retrieve relevant documents. It takes a query
   * string and an optional configuration object, and returns a promise that
   * resolves to an array of `Document` objects. This method handles the
   * retrieval process, including starting and ending callbacks, and error
   * handling.
   * @param query The query string to retrieve relevant documents for.
   * @param config Optional configuration object for the retrieval process.
   * @returns A promise that resolves to an array of `Document` objects.
   */
  async getRelevantDocuments(e, n) {
    const a = Re(Cp(n)), i = await (await st.configure(a.callbacks, this.callbacks, a.tags, this.tags, a.metadata, this.metadata, { verbose: this.verbose }))?.handleRetrieverStart(this.toJSON(), e, a.runId, void 0, void 0, void 0, a.runName);
    try {
      const s = await this._getRelevantDocuments(e, i);
      return await i?.handleRetrieverEnd(s), s;
    } catch (s) {
      throw await i?.handleRetrieverError(s), s;
    }
  }
}
class _b extends Sx {
  static lc_name() {
    return "VectorStoreRetriever";
  }
  get lc_namespace() {
    return ["langchain_core", "vectorstores"];
  }
  /**
   * Returns the type of vector store, as defined by the `vectorStore` instance.
   *
   * @returns {string} The vector store type.
   */
  _vectorstoreType() {
    return this.vectorStore._vectorstoreType();
  }
  /**
   * Initializes a new instance of `VectorStoreRetriever` with the specified configuration.
   *
   * This constructor configures the retriever to interact with a given `VectorStore`
   * and supports different retrieval strategies, including similarity search and maximal
   * marginal relevance (MMR) search. Various options allow customization of the number
   * of documents retrieved per query, filtering based on conditions, and fine-tuning
   * MMR-specific parameters.
   *
   * @param fields - Configuration options for setting up the retriever:
   *
   *   - `vectorStore` (required): The `VectorStore` instance implementing `VectorStoreInterface`
   *     that will be used to store and retrieve document embeddings. This is the core component
   *     of the retriever, enabling vector-based similarity and MMR searches.
   *
   *   - `k` (optional): Specifies the number of documents to retrieve per search query. If not
   *     provided, defaults to 4. This count determines the number of most relevant documents returned
   *     for each search operation, balancing performance with comprehensiveness.
   *
   *   - `searchType` (optional): Defines the search approach used by the retriever, allowing for
   *     flexibility between two methods:
   *       - `"similarity"` (default): A similarity-based search, retrieving documents with high vector
   *         similarity to the query. This type prioritizes relevance and is often used when diversity
   *         among results is less critical.
   *       - `"mmr"`: Maximal Marginal Relevance search, which combines relevance with diversity. MMR
   *         is useful for scenarios where varied content is essential, as it selects results that
   *         both match the query and introduce content diversity.
   *
   *   - `filter` (optional): A filter of type `FilterType`, defined by the vector store, that allows
   *     for refined and targeted search results. This filter applies specified conditions to limit
   *     which documents are eligible for retrieval, offering control over the scope of results.
   *
   *   - `searchKwargs` (optional, applicable only if `searchType` is `"mmr"`): Additional settings
   *     for configuring MMR-specific behavior. These parameters allow further tuning of the MMR
   *     search process:
   *       - `fetchK`: The initial number of documents fetched from the vector store before the MMR
   *         algorithm is applied. Fetching a larger set enables the algorithm to select a more
   *         diverse subset of documents.
   *       - `lambda`: A parameter controlling the relevance-diversity balance, where 0 emphasizes
   *         diversity and 1 prioritizes relevance. Intermediate values provide a blend of the two,
   *         allowing customization based on the importance of content variety relative to query relevance.
   */
  constructor(e) {
    super(e), Object.defineProperty(this, "vectorStore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "k", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4
    }), Object.defineProperty(this, "searchType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "similarity"
    }), Object.defineProperty(this, "searchKwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "filter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.vectorStore = e.vectorStore, this.k = e.k ?? this.k, this.searchType = e.searchType ?? this.searchType, this.filter = e.filter, e.searchType === "mmr" && (this.searchKwargs = e.searchKwargs);
  }
  /**
   * Retrieves relevant documents based on the specified query, using either
   * similarity or maximal marginal relevance (MMR) search.
   *
   * If `searchType` is set to `"mmr"`, performs an MMR search to balance
   * similarity and diversity among results. If `searchType` is `"similarity"`,
   * retrieves results purely based on similarity to the query.
   *
   * @param query - The query string used to find relevant documents.
   * @param runManager - Optional callback manager for tracking retrieval progress.
   * @returns A promise that resolves to an array of `DocumentInterface` instances
   *          representing the most relevant documents to the query.
   * @throws {Error} Throws an error if MMR search is requested but not supported
   *                 by the vector store.
   * @protected
   */
  async _getRelevantDocuments(e, n) {
    if (this.searchType === "mmr") {
      if (typeof this.vectorStore.maxMarginalRelevanceSearch != "function")
        throw new Error(`The vector store backing this retriever, ${this._vectorstoreType()} does not support max marginal relevance search.`);
      return this.vectorStore.maxMarginalRelevanceSearch(e, {
        k: this.k,
        filter: this.filter,
        ...this.searchKwargs
      }, n?.getChild("vectorstore"));
    }
    return this.vectorStore.similaritySearch(e, this.k, this.filter, n?.getChild("vectorstore"));
  }
  /**
   * Adds an array of documents to the vector store, embedding them as part of
   * the storage process.
   *
   * This method delegates document embedding and storage to the `addDocuments`
   * method of the underlying vector store.
   *
   * @param documents - An array of documents to embed and add to the vector store.
   * @param options - Optional settings to customize document addition.
   * @returns A promise that resolves to an array of document IDs or `void`,
   *          depending on the vector store's implementation.
   */
  async addDocuments(e, n) {
    return this.vectorStore.addDocuments(e, n);
  }
}
class Ox extends gr {
  /**
   * Initializes a new vector store with embeddings and database configuration.
   *
   * @param embeddings - Instance of `EmbeddingsInterface` used to embed queries.
   * @param dbConfig - Configuration settings for the database or storage system.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e, n) {
    super(n), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "vectorstores", this._vectorstoreType()]
    }), Object.defineProperty(this, "embeddings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.embeddings = e;
  }
  /**
   * Deletes documents from the vector store based on the specified parameters.
   *
   * @param _params - Flexible key-value pairs defining conditions for document deletion.
   * @returns A promise that resolves once the deletion is complete.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async delete(e) {
    throw new Error("Not implemented.");
  }
  /**
   * Searches for documents similar to a text query by embedding the query and
   * performing a similarity search on the resulting vector.
   *
   * @param query - Text query for finding similar documents.
   * @param k - Number of similar results to return. Defaults to 4.
   * @param filter - Optional filter based on `FilterType`.
   * @param _callbacks - Optional callbacks for monitoring search progress
   * @returns A promise resolving to an array of `DocumentInterface` instances representing similar documents.
   */
  async similaritySearch(e, n = 4, a = void 0, r = void 0) {
    return (await this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(e), n, a)).map((s) => s[0]);
  }
  /**
   * Searches for documents similar to a text query by embedding the query,
   * and returns results with similarity scores.
   *
   * @param query - Text query for finding similar documents.
   * @param k - Number of similar results to return. Defaults to 4.
   * @param filter - Optional filter based on `FilterType`.
   * @param _callbacks - Optional callbacks for monitoring search progress
   * @returns A promise resolving to an array of tuples, each containing a
   *          document and its similarity score.
   */
  async similaritySearchWithScore(e, n = 4, a = void 0, r = void 0) {
    return this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(e), n, a);
  }
  /**
   * Creates a `VectorStore` instance from an array of text strings and optional
   * metadata, using the specified embeddings and database configuration.
   *
   * Subclasses must implement this method to define how text and metadata
   * are embedded and stored in the vector store. Throws an error if not overridden.
   *
   * @param _texts - Array of strings representing the text documents to be stored.
   * @param _metadatas - Metadata for the texts, either as an array (one for each text)
   *                     or a single object (applied to all texts).
   * @param _embeddings - Instance of `EmbeddingsInterface` to embed the texts.
   * @param _dbConfig - Database configuration settings.
   * @returns A promise that resolves to a new `VectorStore` instance.
   * @throws {Error} Throws an error if this method is not overridden by a subclass.
   */
  static fromTexts(e, n, a, r) {
    throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
  }
  /**
   * Creates a `VectorStore` instance from an array of documents, using the specified
   * embeddings and database configuration.
   *
   * Subclasses must implement this method to define how documents are embedded
   * and stored. Throws an error if not overridden.
   *
   * @param _docs - Array of `DocumentInterface` instances representing the documents to be stored.
   * @param _embeddings - Instance of `EmbeddingsInterface` to embed the documents.
   * @param _dbConfig - Database configuration settings.
   * @returns A promise that resolves to a new `VectorStore` instance.
   * @throws {Error} Throws an error if this method is not overridden by a subclass.
   */
  static fromDocuments(e, n, a) {
    throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
  }
  /**
   * Creates a `VectorStoreRetriever` instance with flexible configuration options.
   *
   * @param kOrFields
   *    - If a number is provided, it sets the `k` parameter (number of items to retrieve).
   *    - If an object is provided, it should contain various configuration options.
   * @param filter
   *    - Optional filter criteria to limit the items retrieved based on the specified filter type.
   * @param callbacks
   *    - Optional callbacks that may be triggered at specific stages of the retrieval process.
   * @param tags
   *    - Tags to categorize or label the `VectorStoreRetriever`. Defaults to an empty array if not provided.
   * @param metadata
   *    - Additional metadata as key-value pairs to add contextual information for the retrieval process.
   * @param verbose
   *    - If `true`, enables detailed logging for the retrieval process. Defaults to `false`.
   *
   * @returns
   *    - A configured `VectorStoreRetriever` instance based on the provided parameters.
   *
   * @example
   * Basic usage with a `k` value:
   * ```typescript
   * const retriever = myVectorStore.asRetriever(5);
   * ```
   *
   * Usage with a configuration object:
   * ```typescript
   * const retriever = myVectorStore.asRetriever({
   *   k: 10,
   *   filter: myFilter,
   *   tags: ['example', 'test'],
   *   verbose: true,
   *   searchType: 'mmr',
   *   searchKwargs: { alpha: 0.5 },
   * });
   * ```
   */
  asRetriever(e, n, a, r, i, s) {
    if (typeof e == "number")
      return new _b({
        vectorStore: this,
        k: e,
        filter: n,
        tags: [...r ?? [], this._vectorstoreType()],
        metadata: i,
        verbose: s,
        callbacks: a
      });
    {
      const o = {
        vectorStore: this,
        k: e?.k,
        filter: e?.filter,
        tags: [...e?.tags ?? [], this._vectorstoreType()],
        metadata: e?.metadata,
        verbose: e?.verbose,
        callbacks: e?.callbacks,
        searchType: e?.searchType
      };
      return e?.searchType === "mmr" ? new _b({
        ...o,
        searchKwargs: e.searchKwargs
      }) : new _b({ ...o });
    }
  }
}
function jx(t, e) {
  let n = 0, a = 0, r = 0;
  for (let i = 0; i < t.length; i++)
    n += t[i] * e[i], a += t[i] * t[i], r += e[i] * e[i];
  return n / (Math.sqrt(a) * Math.sqrt(r));
}
function Px(t, e) {
  let n = 0, a = 0, r = 0;
  for (let i = 0; i < t.length; i++)
    n += t[i] * e[i], a += t[i] * t[i], r += e[i] * e[i];
  return n / (Math.sqrt(a) * Math.sqrt(r));
}
function Rx(t, e, n) {
  if (t.length === 0 || t[0].length === 0 || e.length === 0 || e[0].length === 0)
    return [[]];
  if (t[0].length !== e[0].length)
    throw new Error(`Number of columns in X and Y must be the same. X has shape ${[
      t.length,
      t[0].length
    ]} and Y has shape ${[e.length, e[0].length]}.`);
  return t.map((a) => e.map((r) => n(a, r)).map((r) => Number.isNaN(r) ? 0 : r));
}
function wP(t, e) {
  return Rx(t, e, Px);
}
function Cx(t, e, n = 0.5, a = 4) {
  if (Math.min(a, e.length) <= 0)
    return [];
  const r = Array.isArray(t[0]) ? t : [t], i = wP(r, e)[0], s = Tx(i).maxIndex, o = [e[s]], l = [s];
  for (; l.length < Math.min(a, e.length); ) {
    let f = -1 / 0, u = -1;
    const c = wP(e, o);
    i.forEach((h, p) => {
      if (l.includes(p))
        return;
      const d = Math.max(...c[p]), m = n * h - (1 - n) * d;
      m > f && (f = m, u = p);
    }), o.push(e[u]), l.push(u);
  }
  return l;
}
function Tx(t) {
  if (t.length === 0)
    return {
      maxIndex: -1,
      maxValue: NaN
    };
  let e = t[0], n = 0;
  for (let a = 1; a < t.length; a += 1)
    t[a] > e && (n = a, e = t[a]);
  return { maxIndex: n, maxValue: e };
}
class ly extends Ox {
  _vectorstoreType() {
    return "memory";
  }
  constructor(e, { similarity: n, ...a } = {}) {
    super(e, a), Object.defineProperty(this, "memoryVectors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "similarity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.similarity = n ?? jx;
  }
  /**
   * Method to add documents to the memory vector store. It extracts the
   * text from each document, generates embeddings for them, and adds the
   * resulting vectors to the store.
   * @param documents Array of `Document` instances to be added to the store.
   * @returns Promise that resolves when all documents have been added.
   */
  async addDocuments(e) {
    const n = e.map(({ pageContent: a }) => a);
    return this.addVectors(await this.embeddings.embedDocuments(n), e);
  }
  /**
   * Method to add vectors to the memory vector store. It creates
   * `MemoryVector` instances for each vector and document pair and adds
   * them to the store.
   * @param vectors Array of vectors to be added to the store.
   * @param documents Array of `Document` instances corresponding to the vectors.
   * @returns Promise that resolves when all vectors have been added.
   */
  async addVectors(e, n) {
    const a = e.map((r, i) => ({
      content: n[i].pageContent,
      embedding: r,
      metadata: n[i].metadata,
      id: n[i].id
    }));
    this.memoryVectors = this.memoryVectors.concat(a);
  }
  async _queryVectors(e, n, a) {
    const r = (s) => {
      if (!a)
        return !0;
      const o = new lr({
        metadata: s.metadata,
        pageContent: s.content,
        id: s.id
      });
      return a(o);
    };
    return this.memoryVectors.filter(r).map((s, o) => ({
      similarity: this.similarity(e, s.embedding),
      index: o,
      metadata: s.metadata,
      content: s.content,
      embedding: s.embedding,
      id: s.id
    })).sort((s, o) => s.similarity > o.similarity ? -1 : 0).slice(0, n);
  }
  /**
   * Method to perform a similarity search in the memory vector store. It
   * calculates the similarity between the query vector and each vector in
   * the store, sorts the results by similarity, and returns the top `k`
   * results along with their scores.
   * @param query Query vector to compare against the vectors in the store.
   * @param k Number of top results to return.
   * @param filter Optional filter function to apply to the vectors before performing the search.
   * @returns Promise that resolves with an array of tuples, each containing a `Document` and its similarity score.
   */
  async similaritySearchVectorWithScore(e, n, a) {
    return (await this._queryVectors(e, n, a)).map((s) => [
      new lr({
        metadata: s.metadata,
        pageContent: s.content,
        id: s.id
      }),
      s.similarity
    ]);
  }
  async maxMarginalRelevanceSearch(e, n) {
    const a = await this.embeddings.embedQuery(e), r = await this._queryVectors(a, n.fetchK ?? 20, n.filter), i = r.map((o) => o.embedding);
    return Cx(a, i, n.lambda, n.k).map((o) => new lr({
      metadata: r[o].metadata,
      pageContent: r[o].content,
      id: r[o].id
    }));
  }
  /**
   * Static method to create a `MemoryVectorStore` instance from an array of
   * texts. It creates a `Document` for each text and metadata pair, and
   * adds them to the store.
   * @param texts Array of texts to be added to the store.
   * @param metadatas Array or single object of metadata corresponding to the texts.
   * @param embeddings `Embeddings` instance used to generate embeddings for the texts.
   * @param dbConfig Optional `MemoryVectorStoreArgs` to configure the `MemoryVectorStore` instance.
   * @returns Promise that resolves with a new `MemoryVectorStore` instance.
   */
  static async fromTexts(e, n, a, r) {
    const i = [];
    for (let s = 0; s < e.length; s += 1) {
      const o = Array.isArray(n) ? n[s] : n, l = new lr({
        pageContent: e[s],
        metadata: o
      });
      i.push(l);
    }
    return ly.fromDocuments(i, a, r);
  }
  /**
   * Static method to create a `MemoryVectorStore` instance from an array of
   * `Document` instances. It adds the documents to the store.
   * @param docs Array of `Document` instances to be added to the store.
   * @param embeddings `Embeddings` instance used to generate embeddings for the documents.
   * @param dbConfig Optional `MemoryVectorStoreArgs` to configure the `MemoryVectorStore` instance.
   * @returns Promise that resolves with a new `MemoryVectorStore` instance.
   */
  static async fromDocuments(e, n, a) {
    const r = new this(n, a);
    return await r.addDocuments(e), r;
  }
  /**
   * Static method to create a `MemoryVectorStore` instance from an existing
   * index. It creates a new `MemoryVectorStore` instance without adding any
   * documents or vectors.
   * @param embeddings `Embeddings` instance used to generate embeddings for the documents.
   * @param dbConfig Optional `MemoryVectorStoreArgs` to configure the `MemoryVectorStore` instance.
   * @returns Promise that resolves with a new `MemoryVectorStore` instance.
   */
  static async fromExistingIndex(e, n) {
    return new this(e, n);
  }
}
class UM extends ly {
  static async fromJSON(e, n) {
    const a = JSON.parse(e);
    if (a.lc == null || a.type !== "constructor" || !Array.isArray(a.id))
      throw new Error("invalid serialization format");
    const r = new UM(n);
    if (a.kwargs?.docs == null)
      throw new Error("no documents in serialization");
    {
      const i = [], s = [];
      for (const o of a.kwargs.docs)
        o.pageContent && o.vector && (i.push(new lr({
          pageContent: o.pageContent,
          metadata: o.metadata || {}
        })), s.push(o.vector));
      r.addVectors(s, i);
    }
    return r;
  }
}
class $x extends Error {
  constructor(e, n) {
    super(e), Object.defineProperty(this, "output", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.output = n;
  }
}
class BM extends gr {
  get returnValues() {
    return ["output"];
  }
  get allowedTools() {
  }
  /**
   * Return the string type key uniquely identifying this class of agent.
   */
  _agentType() {
    throw new Error("Not implemented");
  }
  /**
   * Return response when agent has been stopped due to max iterations
   */
  returnStoppedResponse(e, n, a, r) {
    if (e === "force")
      return Promise.resolve({
        returnValues: { output: "Agent stopped due to max iterations." },
        log: ""
      });
    throw new Error(`Invalid stopping method: ${e}`);
  }
  /**
   * Prepare the agent for output, if needed
   */
  async prepareForOutput(e, n) {
    return {};
  }
}
class xM extends BM {
  _agentActionType() {
    return "single";
  }
}
class Mx extends BM {
  _agentActionType() {
    return "multi";
  }
}
function Ax(t) {
  return !Array.isArray(t) && t?.tool !== void 0;
}
function Ex(t) {
  return t.runnable !== void 0;
}
class Xp extends dt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "streamRunnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "singleAction", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static fromRunnables([e, ...n], a) {
    const r = dt.from([e, ...n], a.name);
    return r.singleAction = a.singleAction, r.streamRunnable = a.streamRunnable, r;
  }
  static isAgentRunnableSequence(e) {
    return typeof e.singleAction == "boolean";
  }
}
class Ix extends xM {
  get inputKeys() {
    return [];
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "runnable"]
    }), Object.defineProperty(this, "runnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streamRunnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "defaultRunName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RunnableAgent"
    }), this.runnable = e.runnable, this.defaultRunName = e.defaultRunName ?? this.runnable.name ?? this.defaultRunName, this.streamRunnable = e.streamRunnable ?? this.streamRunnable;
  }
  async plan(e, n, a, r) {
    const i = { ...n, steps: e }, s = Ye(r, {
      callbacks: a,
      runName: this.defaultRunName
    });
    if (this.streamRunnable) {
      const o = await this.runnable.stream(i, s);
      let l;
      for await (const f of o)
        if (l === void 0)
          l = f;
        else
          throw new Error([
            "Multiple agent actions/finishes received in streamed agent output.",
            'Set "streamRunnable: false" when initializing the agent to invoke this agent in non-streaming mode.'
          ].join(`
`));
      if (l === void 0)
        throw new Error([
          "No streaming output received from underlying runnable.",
          'Set "streamRunnable: false" when initializing the agent to invoke this agent in non-streaming mode.'
        ].join(`
`));
      return l;
    } else
      return this.runnable.invoke(i, s);
  }
}
class vP extends Mx {
  get inputKeys() {
    return [];
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "runnable"]
    }), Object.defineProperty(this, "runnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "defaultRunName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RunnableAgent"
    }), Object.defineProperty(this, "stop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streamRunnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.runnable = e.runnable, this.stop = e.stop, this.defaultRunName = e.defaultRunName ?? this.runnable.name ?? this.defaultRunName, this.streamRunnable = e.streamRunnable ?? this.streamRunnable;
  }
  async plan(e, n, a, r) {
    const i = { ...n, steps: e }, s = Ye(r, {
      callbacks: a,
      runName: this.defaultRunName
    });
    let o;
    if (this.streamRunnable) {
      const l = await this.runnable.stream(i, s);
      let f;
      for await (const u of l)
        if (f === void 0)
          f = u;
        else
          throw new Error([
            "Multiple agent actions/finishes received in streamed agent output.",
            'Set "streamRunnable: false" when initializing the agent to invoke this agent in non-streaming mode.'
          ].join(`
`));
      if (f === void 0)
        throw new Error([
          "No streaming output received from underlying runnable.",
          'Set "streamRunnable: false" when initializing the agent to invoke this agent in non-streaming mode.'
        ].join(`
`));
      o = f;
    } else
      o = await this.runnable.invoke(i, s);
    return Ax(o) ? [o] : o;
  }
}
class VM extends xM {
  get allowedTools() {
    return this._allowedTools;
  }
  get inputKeys() {
    return this.llmChain.inputKeys.filter((e) => e !== "agent_scratchpad");
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "llmChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputParser", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_allowedTools", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.llmChain = e.llmChain, this._allowedTools = e.allowedTools, this.outputParser = e.outputParser;
  }
  /**
   * Get the default output parser for this agent.
   */
  static getDefaultOutputParser(e) {
    throw new Error("Not implemented");
  }
  /**
   * Create a prompt for this class
   *
   * @param _tools - List of tools the agent will have access to, used to format the prompt.
   * @param _fields - Additional fields used to format the prompt.
   *
   * @returns A PromptTemplate assembled from the given tools and fields.
   * */
  static createPrompt(e, n) {
    throw new Error("Not implemented");
  }
  /** Construct an agent from an LLM and a list of tools */
  static fromLLMAndTools(e, n, a) {
    throw new Error("Not implemented");
  }
  /**
   * Validate that appropriate tools are passed in
   */
  static validateTools(e) {
  }
  _stop() {
    return [`
${this.observationPrefix()}`];
  }
  /**
   * Name of tool to use to terminate the chain.
   */
  finishToolName() {
    return "Final Answer";
  }
  /**
   * Construct a scratchpad to let the agent continue its thought process
   */
  async constructScratchPad(e) {
    return e.reduce((n, { action: a, observation: r }) => n + [
      a.log,
      `${this.observationPrefix()}${r}`,
      this.llmPrefix()
    ].join(`
`), "");
  }
  async _plan(e, n, a, r) {
    const i = await this.constructScratchPad(e), s = {
      ...n,
      agent_scratchpad: a ? `${i}${a}` : i
    };
    this._stop().length !== 0 && (s.stop = this._stop());
    const o = await this.llmChain.predict(s, r);
    if (!this.outputParser)
      throw new Error("Output parser not set");
    return this.outputParser.parse(o, r);
  }
  /**
   * Decide what to do given some input.
   *
   * @param steps - Steps the LLM has taken so far, along with observations from each.
   * @param inputs - User inputs.
   * @param callbackManager - Callback manager to use for this call.
   *
   * @returns Action specifying what tool to use.
   */
  plan(e, n, a) {
    return this._plan(e, n, void 0, a);
  }
  /**
   * Return response when agent has been stopped due to max iterations
   */
  async returnStoppedResponse(e, n, a, r) {
    if (e === "force")
      return {
        returnValues: { output: "Agent stopped due to max iterations." },
        log: ""
      };
    if (e === "generate")
      try {
        const i = await this._plan(n, a, `

I now need to return a final answer based on the previous steps:`, r);
        return "returnValues" in i ? i : { returnValues: { output: i.log }, log: i.log };
      } catch (i) {
        if (!(i instanceof $x))
          throw i;
        return { returnValues: { output: i.output }, log: i.output };
      }
    throw new Error(`Invalid stopping method: ${e}`);
  }
  /**
   * Load an agent from a json-like object describing it.
   */
  static async deserialize(e) {
    switch (e._type) {
      case "zero-shot-react-description": {
        const { ZeroShotAgent: n } = await Promise.resolve().then(() => Jx);
        return n.deserialize(e);
      }
      default:
        throw new Error("Unknown agent type");
    }
  }
}
const Nx = async (t, e, n, a, r) => {
  if (n.load_from_llm_and_tools) {
    if (!t)
      throw new Error("Loading from llm and tools, llm must be provided.");
    if (!e)
      throw new Error("Loading from llm and tools, tools must be provided.");
    return a(t, e, n);
  }
  if (!n.llm_chain)
    throw new Error("Loading from constructor, llm_chain must be provided.");
  const i = await nt.deserialize(n.llm_chain);
  return r({ ...n, llmChain: i });
};
class _c extends Kd {
}
const kx = "Answer the following questions as best you can. You have access to the following tools:", zM = `Use the following format in your response:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question`, Fx = `Begin!

Question: {input}
Thought:{agent_scratchpad}`, Dx = "Final Answer:";
class qx extends _c {
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "mrkl"]
    }), Object.defineProperty(this, "finishToolName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.finishToolName = e?.finishToolName || Dx;
  }
  /**
   * Parses the text output of an agent action, extracting the tool, tool
   * input, and output.
   * @param text The text output of an agent action.
   * @returns An object containing the tool, tool input, and output extracted from the text, along with the original text as a log.
   */
  async parse(e) {
    if (e.includes(this.finishToolName)) {
      const a = e.split(this.finishToolName);
      return {
        returnValues: { output: a[a.length - 1].trim() },
        log: e
      };
    }
    const n = /Action:([\s\S]*?)(?:\nAction Input:([\s\S]*?))?$/.exec(e);
    if (!n)
      throw new Vt(`Could not parse LLM output: ${e}`);
    return {
      tool: n[1].trim(),
      toolInput: n[2] ? n[2].trim().replace(/^("+)(.*?)(\1)$/, "$2") : "",
      log: e
    };
  }
  /**
   * Returns the format instructions for parsing the output of an agent
   * action in the style of the ZeroShotAgent.
   * @returns The format instructions for parsing the output.
   */
  getFormatInstructions() {
    return zM;
  }
}
class Fs extends VM {
  static lc_name() {
    return "ZeroShotAgent";
  }
  constructor(e) {
    const n = e?.outputParser ?? Fs.getDefaultOutputParser();
    super({ ...e, outputParser: n }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "mrkl"]
    });
  }
  _agentType() {
    return "zero-shot-react-description";
  }
  observationPrefix() {
    return "Observation: ";
  }
  llmPrefix() {
    return "Thought:";
  }
  /**
   * Returns the default output parser for the ZeroShotAgent.
   * @param fields Optional arguments for the output parser.
   * @returns An instance of ZeroShotAgentOutputParser.
   */
  static getDefaultOutputParser(e) {
    return new qx(e);
  }
  /**
   * Validates the tools for the ZeroShotAgent. Throws an error if any tool
   * does not have a description.
   * @param tools List of tools to validate.
   */
  static validateTools(e) {
    const n = e.find((a) => !a.description);
    if (n) {
      const a = `Got a tool ${n.name} without a description. This agent requires descriptions for all tools.`;
      throw new Error(a);
    }
  }
  /**
   * Create prompt in the style of the zero shot agent.
   *
   * @param tools - List of tools the agent will have access to, used to format the prompt.
   * @param args - Arguments to create the prompt with.
   * @param args.suffix - String to put after the list of tools.
   * @param args.prefix - String to put before the list of tools.
   * @param args.inputVariables - List of input variables the final prompt will expect.
   */
  static createPrompt(e, n) {
    const { prefix: a = kx, suffix: r = Fx, inputVariables: i = ["input", "agent_scratchpad"] } = n ?? {}, s = e.map((u) => `${u.name}: ${u.description}`).join(`
`), o = e.map((u) => `"${u.name}"`).join(", "), l = dr(zM, "f-string", {
      tool_names: o
    }), f = [a, s, l, r].join(`

`);
    return new We({
      template: f,
      inputVariables: i
    });
  }
  /**
   * Creates a ZeroShotAgent from a Large Language Model and a set of tools.
   * @param llm The Large Language Model to use.
   * @param tools The tools for the agent to use.
   * @param args Optional arguments for creating the agent.
   * @returns A new instance of ZeroShotAgent.
   */
  static fromLLMAndTools(e, n, a) {
    Fs.validateTools(n);
    const r = Fs.createPrompt(n, a), i = a?.outputParser ?? Fs.getDefaultOutputParser(), s = new nt({
      prompt: r,
      llm: e,
      callbacks: a?.callbacks ?? a?.callbackManager
    });
    return new Fs({
      llmChain: s,
      allowedTools: n.map((o) => o.name),
      outputParser: i
    });
  }
  static async deserialize(e) {
    const { llm: n, tools: a, ...r } = e;
    return Nx(n, a, r, (i, s, o) => Fs.fromLLMAndTools(i, s, {
      prefix: o.prefix,
      suffix: o.suffix,
      inputVariables: o.input_variables
    }), (i) => new Fs(i));
  }
}
const Jx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ZeroShotAgent: Fs
}, Symbol.toStringTag, { value: "Module" }));
class Lx extends gr {
  get finalOutputs() {
    return this._finalOutputs;
  }
  /** Intended to be used as a setter method, needs to be async. */
  async setFinalOutputs(e) {
    if (this._finalOutputs = void 0, e) {
      const n = await this.agentExecutor.prepOutputs(this.inputs, e, !0);
      this._finalOutputs = n;
    }
  }
  get nameToToolMap() {
    const e = this.agentExecutor.tools.map((n) => ({
      [n.name]: n
    }));
    return Object.assign({}, ...e);
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "executor_iterator"]
    }), Object.defineProperty(this, "agentExecutor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "runName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_finalOutputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "runManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "intermediateSteps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "iterations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.agentExecutor = e.agentExecutor, this.inputs = e.inputs, this.callbacks = e.callbacks, this.tags = e.tags, this.metadata = e.metadata, this.runName = e.runName, this.runManager = e.runManager, this.config = e.config;
  }
  /**
   * Reset the iterator to its initial state, clearing intermediate steps,
   * iterations, and the final output.
   */
  reset() {
    this.intermediateSteps = [], this.iterations = 0, this._finalOutputs = void 0;
  }
  updateIterations() {
    this.iterations += 1;
  }
  async *streamIterator() {
    for (this.reset(); ; )
      try {
        this.iterations === 0 && await this.onFirstStep(), yield await this._callNext();
      } catch (e) {
        if ("message" in e && e.message.startsWith("Final outputs already reached: ")) {
          if (!this.finalOutputs)
            throw e;
          return this.finalOutputs;
        }
        throw this.runManager && await this.runManager.handleChainError(e), e;
      }
  }
  /**
   * Perform any necessary setup for the first step
   * of the asynchronous iterator.
   */
  async onFirstStep() {
    if (this.iterations === 0) {
      const e = await st.configure(this.callbacks ?? this.config?.callbacks, this.agentExecutor.callbacks, this.tags ?? this.config?.tags, this.agentExecutor.tags, this.metadata ?? this.config?.metadata, this.agentExecutor.metadata, {
        verbose: this.agentExecutor.verbose
      });
      this.runManager = await e?.handleChainStart(this.agentExecutor.toJSON(), this.inputs, this.config?.runId, void 0, this.tags ?? this.config?.tags, this.metadata ?? this.config?.metadata, this.runName ?? this.config?.runName), this.config !== void 0 && delete this.config.runId;
    }
  }
  /**
   * Execute the next step in the chain using the
   * AgentExecutor's _takeNextStep method.
   */
  async _executeNextStep(e) {
    return this.agentExecutor._takeNextStep(this.nameToToolMap, this.inputs, this.intermediateSteps, e, this.config);
  }
  /**
   * Process the output of the next step,
   * handling AgentFinish and tool return cases.
   */
  async _processNextStepOutput(e, n) {
    if ("returnValues" in e) {
      const r = await this.agentExecutor._return(e, this.intermediateSteps, n);
      return this.runManager && await this.runManager.handleChainEnd(r), await this.setFinalOutputs(r), r;
    }
    this.intermediateSteps = this.intermediateSteps.concat(e);
    let a = {};
    if (Array.isArray(e) && e.length === 1) {
      const r = e[0], i = await this.agentExecutor._getToolReturn(r);
      i && (a = await this.agentExecutor._return(i, this.intermediateSteps, n), await this.runManager?.handleChainEnd(a), await this.setFinalOutputs(a));
    }
    return a = { intermediateSteps: e }, a;
  }
  async _stop() {
    const e = await this.agentExecutor.agent.returnStoppedResponse(this.agentExecutor.earlyStoppingMethod, this.intermediateSteps, this.inputs), n = await this.agentExecutor._return(e, this.intermediateSteps, this.runManager);
    return await this.setFinalOutputs(n), await this.runManager?.handleChainEnd(n), n;
  }
  async _callNext() {
    if (this.finalOutputs)
      throw new Error(`Final outputs already reached: ${JSON.stringify(this.finalOutputs, null, 2)}`);
    if (!this.agentExecutor.shouldContinueGetter(this.iterations))
      return this._stop();
    const e = await this._executeNextStep(this.runManager), n = await this._processNextStepOutput(e, this.runManager);
    return this.updateIterations(), n;
  }
}
class yb extends Mp {
  constructor() {
    super(...arguments), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "_Exception"
    }), Object.defineProperty(this, "description", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Exception tool"
    });
  }
  async _call(e) {
    return e;
  }
}
class ZM extends kt {
  static lc_name() {
    return "AgentExecutor";
  }
  get lc_namespace() {
    return ["langchain", "agents", "executor"];
  }
  get inputKeys() {
    return this.agent.inputKeys;
  }
  get outputKeys() {
    return this.agent.returnValues;
  }
  constructor(e) {
    let n, a = !0;
    if (Te.isRunnable(e.agent) ? (Xp.isAgentRunnableSequence(e.agent) ? e.agent.singleAction ? n = new Ix({
      runnable: e.agent,
      streamRunnable: e.agent.streamRunnable
    }) : n = new vP({
      runnable: e.agent,
      streamRunnable: e.agent.streamRunnable
    }) : n = new vP({ runnable: e.agent }), a = !1) : (Ex(e.agent) && (a = !1), n = e.agent), super(e), Object.defineProperty(this, "agent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tools", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnIntermediateSteps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "maxIterations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 15
    }), Object.defineProperty(this, "earlyStoppingMethod", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "force"
    }), Object.defineProperty(this, "returnOnlyOutputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "handleParsingErrors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "handleToolRuntimeErrors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.agent = n, this.tools = e.tools, this.handleParsingErrors = e.handleParsingErrors ?? this.handleParsingErrors, this.handleToolRuntimeErrors = e.handleToolRuntimeErrors, this.returnOnlyOutputs = a, this.agent._agentActionType() === "multi") {
      for (const r of this.tools)
        if (r.returnDirect)
          throw new Error(`Tool with return direct ${r.name} not supported for multi-action agent.`);
    }
    this.returnIntermediateSteps = e.returnIntermediateSteps ?? this.returnIntermediateSteps, this.maxIterations = e.maxIterations ?? this.maxIterations, this.earlyStoppingMethod = e.earlyStoppingMethod ?? this.earlyStoppingMethod;
  }
  /** Create from agent and a list of tools. */
  static fromAgentAndTools(e) {
    return new ZM(e);
  }
  get shouldContinueGetter() {
    return this.shouldContinue.bind(this);
  }
  /**
   * Method that checks if the agent execution should continue based on the
   * number of iterations.
   * @param iterations The current number of iterations.
   * @returns A boolean indicating whether the agent execution should continue.
   */
  shouldContinue(e) {
    return this.maxIterations === void 0 || e < this.maxIterations;
  }
  /** @ignore */
  async _call(e, n, a) {
    const r = Object.fromEntries(this.tools.map((f) => [f.name.toLowerCase(), f])), i = [];
    let s = 0;
    const o = async (f) => {
      const { returnValues: u } = f, c = await this.agent.prepareForOutput(u, i);
      await n?.handleAgentEnd(f);
      let h;
      return this.returnIntermediateSteps ? h = { ...u, intermediateSteps: i, ...c } : h = { ...u, ...c }, this.returnOnlyOutputs || (h = { ...e, ...h }), h;
    };
    for (; this.shouldContinue(s); ) {
      let f;
      try {
        f = await this.agent.plan(i, e, n?.getChild(), a);
      } catch (d) {
        if (d instanceof Vt) {
          let m, b = d.message;
          if (this.handleParsingErrors === !0)
            d.sendToLLM ? (m = d.observation, b = d.llmOutput ?? "") : m = "Invalid or incomplete response";
          else if (typeof this.handleParsingErrors == "string")
            m = this.handleParsingErrors;
          else if (typeof this.handleParsingErrors == "function")
            m = this.handleParsingErrors(d);
          else
            throw d;
          f = {
            tool: "_Exception",
            toolInput: m,
            log: b
          };
        } else
          throw d;
      }
      if ("returnValues" in f)
        return o(f);
      let u;
      Array.isArray(f) ? u = f : u = [f];
      const c = await Promise.all(u.map(async (d) => {
        await n?.handleAgentAction(d);
        const m = d.tool === "_Exception" ? new yb() : r[d.tool?.toLowerCase()];
        let b;
        try {
          if (b = m ? await m.invoke(d.toolInput, Ye(a, { callbacks: n?.getChild() })) : `${d.tool} is not a valid tool, try another one.`, typeof b != "string")
            throw new Error("Received unsupported non-string response from tool call.");
        } catch (g) {
          if (g instanceof Ph) {
            if (this.handleParsingErrors === !0)
              b = "Invalid or incomplete tool input. Please try again.";
            else if (typeof this.handleParsingErrors == "string")
              b = this.handleParsingErrors;
            else if (typeof this.handleParsingErrors == "function")
              b = this.handleParsingErrors(g);
            else
              throw g;
            return b = await new yb().call(b, n?.getChild()), { action: d, observation: b ?? "" };
          } else this.handleToolRuntimeErrors !== void 0 && (b = this.handleToolRuntimeErrors(g));
        }
        return { action: d, observation: b ?? "" };
      }));
      i.push(...c);
      const h = i[i.length - 1];
      if (r[h.action.tool?.toLowerCase()]?.returnDirect)
        return o({
          returnValues: { [this.agent.returnValues[0]]: h.observation },
          log: ""
        });
      s += 1;
    }
    const l = await this.agent.returnStoppedResponse(this.earlyStoppingMethod, i, e);
    return o(l);
  }
  async _takeNextStep(e, n, a, r, i) {
    let s;
    try {
      s = await this.agent.plan(a, n, r?.getChild(), i);
    } catch (f) {
      if (f instanceof Vt) {
        let u, c = f.message;
        if (this.handleParsingErrors === !0)
          f.sendToLLM ? (u = f.observation, c = f.llmOutput ?? "") : u = "Invalid or incomplete response";
        else if (typeof this.handleParsingErrors == "string")
          u = this.handleParsingErrors;
        else if (typeof this.handleParsingErrors == "function")
          u = this.handleParsingErrors(f);
        else
          throw f;
        s = {
          tool: "_Exception",
          toolInput: u,
          log: c
        };
      } else
        throw f;
    }
    if ("returnValues" in s)
      return s;
    let o;
    Array.isArray(s) ? o = s : o = [s];
    const l = [];
    for (const f of o) {
      let u = "";
      if (r && await r?.handleAgentAction(f), f.tool in e) {
        const c = e[f.tool];
        try {
          if (u = await c.call(f.toolInput, r?.getChild()), typeof u != "string")
            throw new Error("Received unsupported non-string response from tool call.");
        } catch (h) {
          if (h instanceof Ph) {
            if (this.handleParsingErrors === !0)
              u = "Invalid or incomplete tool input. Please try again.";
            else if (typeof this.handleParsingErrors == "string")
              u = this.handleParsingErrors;
            else if (typeof this.handleParsingErrors == "function")
              u = this.handleParsingErrors(h);
            else
              throw h;
            u = await new yb().call(u, r?.getChild());
          }
        }
      } else
        u = `${f.tool} is not a valid tool, try another available tool: ${Object.keys(e).join(", ")}`;
      l.push({
        action: f,
        observation: u
      });
    }
    return l;
  }
  async _return(e, n, a) {
    a && await a.handleAgentEnd(e);
    const r = e.returnValues;
    return this.returnIntermediateSteps && (r.intermediateSteps = n), r;
  }
  async _getToolReturn(e) {
    const { action: n, observation: a } = e, r = Object.fromEntries(this.tools.map((s) => [s.name.toLowerCase(), s])), [i = "output"] = this.agent.returnValues;
    return n.tool in r && r[n.tool].returnDirect ? {
      returnValues: { [i]: a },
      log: ""
    } : null;
  }
  _returnStoppedResponse(e) {
    if (e === "force")
      return {
        returnValues: {
          output: "Agent stopped due to iteration limit or time limit."
        },
        log: ""
      };
    throw new Error(`Got unsupported early_stopping_method: ${e}`);
  }
  async *_streamIterator(e, n) {
    const r = new Lx({
      inputs: e,
      agentExecutor: this,
      config: n,
      // TODO: Deprecate these other parameters
      metadata: n?.metadata,
      tags: n?.tags,
      callbacks: n?.callbacks
    }).streamIterator();
    for await (const i of r)
      i && (yield i);
  }
  _chainType() {
    return "agent_executor";
  }
  serialize() {
    throw new Error("Cannot serialize an AgentExecutor");
  }
}
class yc extends kt {
  static lc_name() {
    return "StuffDocumentsChain";
  }
  get inputKeys() {
    return [this.inputKey, ...this.llmChain.inputKeys].filter((e) => e !== this.documentVariableName);
  }
  get outputKeys() {
    return this.llmChain.outputKeys;
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "llmChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "input_documents"
    }), Object.defineProperty(this, "documentVariableName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "context"
    }), this.llmChain = e.llmChain, this.documentVariableName = e.documentVariableName ?? this.documentVariableName, this.inputKey = e.inputKey ?? this.inputKey;
  }
  /** @ignore */
  _prepInputs(e) {
    if (!(this.inputKey in e))
      throw new Error(`Document key ${this.inputKey} not found.`);
    const { [this.inputKey]: n, ...a } = e, i = n.map(({ pageContent: s }) => s).join(`

`);
    return {
      ...a,
      [this.documentVariableName]: i
    };
  }
  /** @ignore */
  async _call(e, n) {
    return await this.llmChain.call(this._prepInputs(e), n?.getChild("combine_documents"));
  }
  _chainType() {
    return "stuff_documents_chain";
  }
  static async deserialize(e) {
    if (!e.llm_chain)
      throw new Error("Missing llm_chain");
    return new yc({
      llmChain: await nt.deserialize(e.llm_chain)
    });
  }
  serialize() {
    return {
      _type: this._chainType(),
      llm_chain: this.llmChain.serialize()
    };
  }
}
class Qp extends kt {
  static lc_name() {
    return "MapReduceDocumentsChain";
  }
  get inputKeys() {
    return [this.inputKey, ...this.combineDocumentChain.inputKeys];
  }
  get outputKeys() {
    return this.combineDocumentChain.outputKeys;
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "llmChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "input_documents"
    }), Object.defineProperty(this, "documentVariableName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "context"
    }), Object.defineProperty(this, "returnIntermediateSteps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "maxTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3e3
    }), Object.defineProperty(this, "maxIterations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 10
    }), Object.defineProperty(this, "ensureMapStep", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "combineDocumentChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.llmChain = e.llmChain, this.combineDocumentChain = e.combineDocumentChain, this.documentVariableName = e.documentVariableName ?? this.documentVariableName, this.ensureMapStep = e.ensureMapStep ?? this.ensureMapStep, this.inputKey = e.inputKey ?? this.inputKey, this.maxTokens = e.maxTokens ?? this.maxTokens, this.maxIterations = e.maxIterations ?? this.maxIterations, this.returnIntermediateSteps = e.returnIntermediateSteps ?? !1;
  }
  /** @ignore */
  async _call(e, n) {
    if (!(this.inputKey in e))
      throw new Error(`Document key ${this.inputKey} not found.`);
    const { [this.inputKey]: a, ...r } = e;
    let i = a, s = [];
    for (let f = 0; f < this.maxIterations; f += 1) {
      const u = i.map((d) => ({
        [this.documentVariableName]: d.pageContent,
        ...r
      }));
      if (f !== 0 || !this.ensureMapStep) {
        const d = await this.combineDocumentChain.llmChain.prompt.format(this.combineDocumentChain._prepInputs({
          [this.combineDocumentChain.inputKey]: i,
          ...r
        }));
        if (await this.combineDocumentChain.llmChain._getNumTokens(d) < this.maxTokens)
          break;
      }
      const h = await this.llmChain.apply(
        u,
        // If we have a runManager, then we need to create a child for each input
        // so that we can track the progress of each input.
        n ? Array.from({ length: u.length }, (d, m) => n.getChild(`map_${m + 1}`)) : void 0
      ), { outputKey: p } = this.llmChain;
      this.returnIntermediateSteps && (s = s.concat(h.map((d) => d[p]))), i = h.map((d) => ({
        pageContent: d[p],
        metadata: {}
      }));
    }
    const o = {
      [this.combineDocumentChain.inputKey]: i,
      ...r
    }, l = await this.combineDocumentChain.call(o, n?.getChild("combine_documents"));
    return this.returnIntermediateSteps ? { ...l, intermediateSteps: s } : l;
  }
  _chainType() {
    return "map_reduce_documents_chain";
  }
  static async deserialize(e) {
    if (!e.llm_chain)
      throw new Error("Missing llm_chain");
    if (!e.combine_document_chain)
      throw new Error("Missing combine_document_chain");
    return new Qp({
      llmChain: await nt.deserialize(e.llm_chain),
      combineDocumentChain: await yc.deserialize(e.combine_document_chain)
    });
  }
  serialize() {
    return {
      _type: this._chainType(),
      llm_chain: this.llmChain.serialize(),
      combine_document_chain: this.combineDocumentChain.serialize()
    };
  }
}
class Yp extends kt {
  static lc_name() {
    return "RefineDocumentsChain";
  }
  get defaultDocumentPrompt() {
    return new We({
      inputVariables: ["page_content"],
      template: "{page_content}"
    });
  }
  get inputKeys() {
    return [
      .../* @__PURE__ */ new Set([
        this.inputKey,
        ...this.llmChain.inputKeys,
        ...this.refineLLMChain.inputKeys
      ])
    ].filter((e) => e !== this.documentVariableName && e !== this.initialResponseName);
  }
  get outputKeys() {
    return [this.outputKey];
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "llmChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "input_documents"
    }), Object.defineProperty(this, "outputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "output_text"
    }), Object.defineProperty(this, "documentVariableName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "context"
    }), Object.defineProperty(this, "initialResponseName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "existing_answer"
    }), Object.defineProperty(this, "refineLLMChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "documentPrompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.defaultDocumentPrompt
    }), this.llmChain = e.llmChain, this.refineLLMChain = e.refineLLMChain, this.documentVariableName = e.documentVariableName ?? this.documentVariableName, this.inputKey = e.inputKey ?? this.inputKey, this.outputKey = e.outputKey ?? this.outputKey, this.documentPrompt = e.documentPrompt ?? this.documentPrompt, this.initialResponseName = e.initialResponseName ?? this.initialResponseName;
  }
  /** @ignore */
  async _constructInitialInputs(e, n) {
    const a = {
      page_content: e.pageContent,
      ...e.metadata
    }, r = {};
    return this.documentPrompt.inputVariables.forEach((o) => {
      r[o] = a[o];
    }), { ...{
      [this.documentVariableName]: await this.documentPrompt.format({
        ...r
      })
    }, ...n };
  }
  /** @ignore */
  async _constructRefineInputs(e, n) {
    const a = {
      page_content: e.pageContent,
      ...e.metadata
    }, r = {};
    this.documentPrompt.inputVariables.forEach((o) => {
      r[o] = a[o];
    });
    const i = {
      [this.documentVariableName]: await this.documentPrompt.format({
        ...r
      })
    };
    return { [this.initialResponseName]: n, ...i };
  }
  /** @ignore */
  async _call(e, n) {
    if (!(this.inputKey in e))
      throw new Error(`Document key ${this.inputKey} not found.`);
    const { [this.inputKey]: a, ...r } = e, i = a, s = await this._constructInitialInputs(i[0], r);
    let o = await this.llmChain.predict({ ...s }, n?.getChild("answer"));
    for (let l = 1; l < i.length; l += 1) {
      const u = { ...await this._constructRefineInputs(i[l], o), ...r };
      o = await this.refineLLMChain.predict({ ...u }, n?.getChild("refine"));
    }
    return { [this.outputKey]: o };
  }
  _chainType() {
    return "refine_documents_chain";
  }
  static async deserialize(e) {
    const n = e.llm_chain;
    if (!n)
      throw new Error("Missing llm_chain");
    const a = e.refine_llm_chain;
    if (!a)
      throw new Error("Missing refine_llm_chain");
    return new Yp({
      llmChain: await nt.deserialize(n),
      refineLLMChain: await nt.deserialize(a)
    });
  }
  serialize() {
    return {
      _type: this._chainType(),
      llm_chain: this.llmChain.serialize(),
      refine_llm_chain: this.refineLLMChain.serialize()
    };
  }
}
const wb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MapReduceDocumentsChain: Qp,
  RefineDocumentsChain: Yp,
  StuffDocumentsChain: yc
}, Symbol.toStringTag, { value: "Module" }));
class Ux {
  /**
   * Asynchronous version of `getPrompt` that also accepts an options object
   * for partial variables.
   * @param llm The language model for which to get a prompt.
   * @param options Optional object for partial variables.
   * @returns A Promise that resolves to a prompt template.
   */
  async getPromptAsync(e, n) {
    return this.getPrompt(e).partial(n?.partialVariables ?? {});
  }
}
class sf extends Ux {
  constructor(e, n = []) {
    super(), Object.defineProperty(this, "defaultPrompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "conditionals", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.defaultPrompt = e, this.conditionals = n;
  }
  /**
   * Method that selects a prompt based on a set of conditions. If none of
   * the conditions are met, it returns the default prompt.
   * @param llm The language model for which to get a prompt.
   * @returns A prompt template.
   */
  getPrompt(e) {
    for (const [n, a] of this.conditionals)
      if (n(e))
        return a;
    return this.defaultPrompt;
  }
}
function of(t) {
  return t._modelType() === "base_chat_model";
}
const Bx = /* @__PURE__ */ new We({
  template: `Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.

{context}

Question: {question}
Helpful Answer:`,
  inputVariables: ["context", "question"]
}), xx = `Use the following pieces of context to answer the users question. 
If you don't know the answer, just say that you don't know, don't try to make up an answer.
----------------
{context}`, Vx = [
  /* @__PURE__ */ gc.fromTemplate(xx),
  /* @__PURE__ */ Zs.fromTemplate("{question}")
], zx = /* @__PURE__ */ da.fromMessages(Vx), Zx = /* @__PURE__ */ new sf(Bx, [[of, zx]]), Kx = `Use the following portion of a long document to see if any of the text is relevant to answer the question. 
Return any relevant text verbatim.
{context}
Question: {question}
Relevant text, if any:`, Hx = /* @__PURE__ */ We.fromTemplate(Kx), Gx = `Use the following portion of a long document to see if any of the text is relevant to answer the question. 
Return any relevant text verbatim.
----------------
{context}`, Wx = [
  /* @__PURE__ */ gc.fromTemplate(Gx),
  /* @__PURE__ */ Zs.fromTemplate("{question}")
], Xx = /* @__PURE__ */ da.fromMessages(Wx), Qx = /* @__PURE__ */ new sf(Hx, [
  [of, Xx]
]), Yx = `Given the following extracted parts of a long document and a question, create a final answer. 
If you don't know the answer, just say that you don't know. Don't try to make up an answer.

QUESTION: Which state/country's law governs the interpretation of the contract?
=========
Content: This Agreement is governed by English law and the parties submit to the exclusive jurisdiction of the English courts in  relation to any dispute (contractual or non-contractual) concerning this Agreement save that either party may apply to any court for an  injunction or other relief to protect its Intellectual Property Rights.

Content: No Waiver. Failure or delay in exercising any right or remedy under this Agreement shall not constitute a waiver of such (or any other)  right or remedy.

11.7 Severability. The invalidity, illegality or unenforceability of any term (or part of a term) of this Agreement shall not affect the continuation  in force of the remainder of the term (if any) and this Agreement.

11.8 No Agency. Except as expressly stated otherwise, nothing in this Agreement shall create an agency, partnership or joint venture of any  kind between the parties.

11.9 No Third-Party Beneficiaries.

Content: (b) if Google believes, in good faith, that the Distributor has violated or caused Google to violate any Anti-Bribery Laws (as  defined in Clause 8.5) or that such a violation is reasonably likely to occur,
=========
FINAL ANSWER: This Agreement is governed by English law.

QUESTION: What did the president say about Michael Jackson?
=========
Content: Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.  

Last year COVID-19 kept us apart. This year we are finally together again. 

Tonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. 

With a duty to one another to the American people to the Constitution. 

And with an unwavering resolve that freedom will always triumph over tyranny. 

Six days ago, Russias Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. 

He thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. 

He met the Ukrainian people. 

From President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world. 

Groups of citizens blocking tanks with their bodies. Everyone from students to retirees teachers turned soldiers defending their homeland.

Content: And we wont stop. 

We have lost so much to COVID-19. Time with one another. And worst of all, so much loss of life. 

Lets use this moment to reset. Lets stop looking at COVID-19 as a partisan dividing line and see it for what it is: A God-awful disease.  

Lets stop seeing each other as enemies, and start seeing each other for who we really are: Fellow Americans.  

We cant change how divided weve been. But we can change how we move forwardon COVID-19 and other issues we must face together. 

I recently visited the New York City Police Department days after the funerals of Officer Wilbert Mora and his partner, Officer Jason Rivera. 

They were responding to a 9-1-1 call when a man shot and killed them with a stolen gun. 

Officer Mora was 27 years old. 

Officer Rivera was 22. 

Both Dominican Americans whod grown up on the same streets they later chose to patrol as police officers. 

I spoke with their families and told them that we are forever in debt for their sacrifice, and we will carry on their mission to restore the trust and safety every community deserves.

Content: And a proud Ukrainian people, who have known 30 years  of independence, have repeatedly shown that they will not tolerate anyone who tries to take their country backwards.  

To all Americans, I will be honest with you, as Ive always promised. A Russian dictator, invading a foreign country, has costs around the world. 

And Im taking robust action to make sure the pain of our sanctions  is targeted at Russias economy. And I will use every tool at our disposal to protect American businesses and consumers. 

Tonight, I can announce that the United States has worked with 30 other countries to release 60 Million barrels of oil from reserves around the world.  

America will lead that effort, releasing 30 Million barrels from our own Strategic Petroleum Reserve. And we stand ready to do more if necessary, unified with our allies.  

These steps will help blunt gas prices here at home. And I know the news about whats happening can seem alarming. 

But I want you to know that we are going to be okay.

Content: More support for patients and families. 

To get there, I call on Congress to fund ARPA-H, the Advanced Research Projects Agency for Health. 

Its based on DARPAthe Defense Department project that led to the Internet, GPS, and so much more.  

ARPA-H will have a singular purposeto drive breakthroughs in cancer, Alzheimers, diabetes, and more. 

A unity agenda for the nation. 

We can do this. 

My fellow Americanstonight , we have gathered in a sacred spacethe citadel of our democracy. 

In this Capitol, generation after generation, Americans have debated great questions amid great strife, and have done great things. 

We have fought for freedom, expanded liberty, defeated totalitarianism and terror. 

And built the strongest, freest, and most prosperous nation the world has ever known. 

Now is the hour. 

Our moment of responsibility. 

Our test of resolve and conscience, of history itself. 

It is in this moment that our character is formed. Our purpose is found. Our future is forged. 

Well I know this nation.
=========
FINAL ANSWER: The president did not mention Michael Jackson.

QUESTION: {question}
=========
{summaries}
=========
FINAL ANSWER:`, e4 = /* @__PURE__ */ We.fromTemplate(Yx), t4 = `Given the following extracted parts of a long document and a question, create a final answer. 
If you don't know the answer, just say that you don't know. Don't try to make up an answer.
----------------
{summaries}`, n4 = [
  /* @__PURE__ */ gc.fromTemplate(t4),
  /* @__PURE__ */ Zs.fromTemplate("{question}")
], r4 = /* @__PURE__ */ da.fromMessages(n4), a4 = /* @__PURE__ */ new sf(e4, [
  [of, r4]
]), i4 = `The original question is as follows: {question}
We have provided an existing answer: {existing_answer}
We have the opportunity to refine the existing answer
(only if needed) with some more context below.
------------
{context}
------------
Given the new context, refine the original answer to better answer the question. 
If the context isn't useful, return the original answer.`, s4 = /* @__PURE__ */ new We({
  inputVariables: ["question", "existing_answer", "context"],
  template: i4
}), o4 = `The original question is as follows: {question}
We have provided an existing answer: {existing_answer}
We have the opportunity to refine the existing answer
(only if needed) with some more context below.
------------
{context}
------------
Given the new context, refine the original answer to better answer the question. 
If the context isn't useful, return the original answer.`, u4 = [
  /* @__PURE__ */ Zs.fromTemplate("{question}"),
  /* @__PURE__ */ DM.fromTemplate("{existing_answer}"),
  /* @__PURE__ */ Zs.fromTemplate(o4)
], c4 = /* @__PURE__ */ da.fromMessages(u4), l4 = /* @__PURE__ */ new sf(s4, [
  [of, c4]
]), d4 = `Context information is below. 
---------------------
{context}
---------------------
Given the context information and no prior knowledge, answer the question: {question}`, f4 = /* @__PURE__ */ new We({
  inputVariables: ["context", "question"],
  template: d4
}), h4 = `Context information is below. 
---------------------
{context}
---------------------
Given the context information and no prior knowledge, answer any questions`, p4 = [
  /* @__PURE__ */ gc.fromTemplate(h4),
  /* @__PURE__ */ Zs.fromTemplate("{question}")
], m4 = /* @__PURE__ */ da.fromMessages(p4), b4 = /* @__PURE__ */ new sf(f4, [
  [of, m4]
]), g4 = (t, e = { type: "stuff" }) => {
  const { type: n } = e;
  if (n === "stuff")
    return dy(t, e);
  if (n === "map_reduce")
    return _4(t, e);
  if (n === "refine")
    return y4(t, e);
  throw new Error(`Invalid _type: ${n}`);
};
function dy(t, e = {}) {
  const { prompt: n = Zx.getPrompt(t), verbose: a } = e, r = new nt({ prompt: n, llm: t, verbose: a });
  return new yc({ llmChain: r, verbose: a });
}
function _4(t, e = {}) {
  const { combineMapPrompt: n = Qx.getPrompt(t), combinePrompt: a = a4.getPrompt(t), verbose: r, combineLLM: i, returnIntermediateSteps: s } = e, o = new nt({ prompt: n, llm: t, verbose: r }), l = new nt({
    prompt: a,
    llm: i ?? t,
    verbose: r
  }), f = new yc({
    llmChain: l,
    documentVariableName: "summaries",
    verbose: r
  });
  return new Qp({
    llmChain: o,
    combineDocumentChain: f,
    returnIntermediateSteps: s,
    verbose: r
  });
}
function y4(t, e = {}) {
  const { questionPrompt: n = b4.getPrompt(t), refinePrompt: a = l4.getPrompt(t), refineLLM: r, verbose: i } = e, s = new nt({ prompt: n, llm: t, verbose: i }), o = new nt({
    prompt: a,
    llm: r ?? t,
    verbose: i
  });
  return new Yp({
    llmChain: s,
    refineLLMChain: o,
    verbose: i
  });
}
class fy extends kt {
  static lc_name() {
    return "VectorDBQAChain";
  }
  get inputKeys() {
    return [this.inputKey];
  }
  get outputKeys() {
    return this.combineDocumentsChain.outputKeys.concat(this.returnSourceDocuments ? ["sourceDocuments"] : []);
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "k", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "query"
    }), Object.defineProperty(this, "vectorstore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "combineDocumentsChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnSourceDocuments", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.vectorstore = e.vectorstore, this.combineDocumentsChain = e.combineDocumentsChain, this.inputKey = e.inputKey ?? this.inputKey, this.k = e.k ?? this.k, this.returnSourceDocuments = e.returnSourceDocuments ?? this.returnSourceDocuments;
  }
  /** @ignore */
  async _call(e, n) {
    if (!(this.inputKey in e))
      throw new Error(`Question key ${this.inputKey} not found.`);
    const a = e[this.inputKey], r = await this.vectorstore.similaritySearch(a, this.k, e.filter, n?.getChild("vectorstore")), i = { question: a, input_documents: r }, s = await this.combineDocumentsChain.call(i, n?.getChild("combine_documents"));
    return this.returnSourceDocuments ? {
      ...s,
      sourceDocuments: r
    } : s;
  }
  _chainType() {
    return "vector_db_qa";
  }
  static async deserialize(e, n) {
    if (!("vectorstore" in n))
      throw new Error("Need to pass in a vectorstore to deserialize VectorDBQAChain");
    const { vectorstore: a } = n;
    if (!e.combine_documents_chain)
      throw new Error("VectorDBQAChain must have combine_documents_chain in serialized data");
    return new fy({
      combineDocumentsChain: await kt.deserialize(e.combine_documents_chain),
      k: e.k,
      vectorstore: a
    });
  }
  serialize() {
    return {
      _type: this._chainType(),
      combine_documents_chain: this.combineDocumentsChain.serialize(),
      k: this.k
    };
  }
  /**
   * Static method that creates a VectorDBQAChain instance from a
   * BaseLanguageModel and a vector store. It also accepts optional options
   * to customize the chain.
   * @param llm The BaseLanguageModel instance.
   * @param vectorstore The vector store used for similarity search.
   * @param options Optional options to customize the chain.
   * @returns A new instance of VectorDBQAChain.
   */
  static fromLLM(e, n, a) {
    const r = dy(e);
    return new this({
      vectorstore: n,
      combineDocumentsChain: r,
      ...a
    });
  }
}
const w4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VectorDBQAChain: fy
}, Symbol.toStringTag, { value: "Module" })), v4 = "Answer the following questions as best you can. You have access to the following tools:", KM = `The way you use the tools is by specifying a json blob, denoted below by $JSON_BLOB
Specifically, this $JSON_BLOB should have a "action" key (with the name of the tool to use) and a "action_input" key (with the input to the tool going here). 
The $JSON_BLOB should only contain a SINGLE action, do NOT return a list of multiple actions. Here is an example of a valid $JSON_BLOB:

\`\`\`
{{
  "action": "calculator",
  "action_input": "1 + 2"
}}
\`\`\`

ALWAYS use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: 
\`\`\`
$JSON_BLOB
\`\`\`
Observation: the result of the action
... (this Thought/Action/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question`, S4 = "Begin! Reminder to always use the exact characters `Final Answer` when responding.", SP = "Final Answer:";
class O4 extends _c {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "chat"]
    });
  }
  /**
   * Parses the output text from the MRKL chain into an agent action or
   * agent finish. If the text contains the final answer action or does not
   * contain an action, it returns an AgentFinish with the output and log.
   * If the text contains a JSON response, it returns the tool, toolInput,
   * and log.
   * @param text The output text from the MRKL chain.
   * @returns An object that satisfies the AgentFinish interface or an object with the tool, toolInput, and log.
   */
  async parse(e) {
    if (e.includes(SP) || !e.includes('"action":')) {
      const a = e.split(SP);
      return { returnValues: { output: a[a.length - 1].trim() }, log: e };
    }
    const n = e.includes("```") ? e.trim().split(/```(?:json)?/)[1] : e.trim();
    try {
      const a = JSON.parse(n.trim());
      return {
        tool: a.action,
        toolInput: a.action_input,
        log: e
      };
    } catch {
      throw new Vt(`Unable to parse JSON response from chat agent.

${e}`);
    }
  }
  /**
   * Returns the format instructions used in the output parser for the
   * ChatAgent class.
   * @returns The format instructions as a string.
   */
  getFormatInstructions() {
    return KM;
  }
}
const j4 = `{input}

{agent_scratchpad}`;
class Iu extends VM {
  static lc_name() {
    return "ChatAgent";
  }
  constructor(e) {
    const n = e?.outputParser ?? Iu.getDefaultOutputParser();
    super({ ...e, outputParser: n }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "chat"]
    });
  }
  _agentType() {
    return "chat-zero-shot-react-description";
  }
  observationPrefix() {
    return "Observation: ";
  }
  llmPrefix() {
    return "Thought:";
  }
  _stop() {
    return ["Observation:"];
  }
  /**
   * Validates that all tools have descriptions. Throws an error if a tool
   * without a description is found.
   * @param tools Array of Tool instances to validate.
   * @returns void
   */
  static validateTools(e) {
    const n = e.find((a) => !a.description);
    if (n) {
      const a = `Got a tool ${n.name} without a description. This agent requires descriptions for all tools.`;
      throw new Error(a);
    }
  }
  /**
   * Returns a default output parser for the ChatAgent.
   * @param _fields Optional OutputParserArgs to customize the output parser.
   * @returns ChatAgentOutputParser instance
   */
  static getDefaultOutputParser(e) {
    return new O4();
  }
  /**
   * Constructs the agent's scratchpad, which is a string representation of
   * the agent's previous steps.
   * @param steps Array of AgentStep instances representing the agent's previous steps.
   * @returns Promise resolving to a string representing the agent's scratchpad.
   */
  async constructScratchPad(e) {
    const n = await super.constructScratchPad(e);
    return n && `This was your previous work (but I haven't seen any of it! I only see what you return as final answer):
${n}`;
  }
  /**
   * Create prompt in the style of the zero shot agent.
   *
   * @param tools - List of tools the agent will have access to, used to format the prompt.
   * @param args - Arguments to create the prompt with.
   * @param args.suffix - String to put after the list of tools.
   * @param args.prefix - String to put before the list of tools.
   * @param args.humanMessageTemplate - String to use directly as the human message template
   * @param args.formatInstructions - Formattable string to use as the instructions template
   */
  static createPrompt(e, n) {
    const { prefix: a = v4, suffix: r = S4, humanMessageTemplate: i = j4, formatInstructions: s = KM } = n ?? {}, o = e.map((u) => `${u.name}: ${u.description}`).join(`
`), l = [a, o, s, r].join(`

`), f = [
      gc.fromTemplate(l),
      Zs.fromTemplate(i)
    ];
    return da.fromMessages(f);
  }
  /**
   * Creates a ChatAgent instance using a language model, tools, and
   * optional arguments.
   * @param llm BaseLanguageModelInterface instance to use in the agent.
   * @param tools Array of Tool instances to include in the agent.
   * @param args Optional arguments to customize the agent and prompt.
   * @returns ChatAgent instance
   */
  static fromLLMAndTools(e, n, a) {
    Iu.validateTools(n);
    const r = Iu.createPrompt(n, a), i = new nt({
      prompt: r,
      llm: e,
      callbacks: a?.callbacks ?? a?.callbackManager
    }), s = a?.outputParser ?? Iu.getDefaultOutputParser();
    return new Iu({
      llmChain: i,
      outputParser: s,
      allowedTools: n.map((o) => o.name)
    });
  }
}
const P4 = `Instructions:
--------------
{instructions}
--------------
Completion:
--------------
{completion}
--------------

Above, the Completion did not satisfy the constraints given in the Instructions.
Error:
--------------
{error}
--------------

Please try again. Please only respond with an answer that satisfies the constraints laid out in the Instructions:`, R4 = /* @__PURE__ */ We.fromTemplate(P4);
function C4(t) {
  return t.prompt !== void 0 && t.llm !== void 0;
}
class hy extends Kd {
  static lc_name() {
    return "OutputFixingParser";
  }
  /**
   * Static method to create a new instance of OutputFixingParser using a
   * given language model, parser, and optional fields.
   * @param llm The language model to be used.
   * @param parser The parser to be used.
   * @param fields Optional fields which may contain a prompt.
   * @returns A new instance of OutputFixingParser.
   */
  static fromLLM(e, n, a) {
    const r = a?.prompt ?? R4, i = new nt({ llm: e, prompt: r });
    return new hy({ parser: n, retryChain: i });
  }
  constructor({ parser: e, retryChain: n }) {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "output_parsers", "fix"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "parser", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "retryChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.parser = e, this.retryChain = n;
  }
  /**
   * Method to parse the completion using the parser. If the initial parsing
   * fails, it uses the retryChain to attempt to fix the output and retry
   * the parsing process.
   * @param completion The completion to be parsed.
   * @param callbacks Optional callbacks to be used during parsing.
   * @returns The parsed output.
   */
  async parse(e, n) {
    try {
      return await this.parser.parse(e, n);
    } catch (a) {
      if (a instanceof Vt) {
        const r = {
          instructions: this.parser.getFormatInstructions(),
          completion: e,
          error: a
        };
        if (C4(this.retryChain)) {
          const s = (await this.retryChain.call(r, n))[this.retryChain.outputKey];
          return this.parser.parse(s, n);
        } else
          return await this.retryChain.invoke(r, {
            callbacks: n
          });
      }
      throw a;
    }
  }
  /**
   * Method to get the format instructions for the parser.
   * @returns The format instructions for the parser.
   */
  getFormatInstructions() {
    return this.parser.getFormatInstructions();
  }
}
const HM = `Output a JSON markdown code snippet containing a valid JSON blob (denoted below by $JSON_BLOB).
This $JSON_BLOB must have a "action" key (with the name of the tool to use) and an "action_input" key (tool input).

Valid "action" values: "Final Answer" (which you must use when giving your final response to the user), or one of [{tool_names}].

The $JSON_BLOB must be valid, parseable JSON and only contain a SINGLE action. Here is an example of an acceptable output:

\`\`\`json
{{
  "action": $TOOL_NAME,
  "action_input": $INPUT
}}
\`\`\`

Remember to include the surrounding markdown code snippet delimiters (begin with "\`\`\`" json and close with "\`\`\`")!
`, T4 = `You have access to the following tools.
You must format your inputs to these tools to match their "JSON schema" definitions below.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Here are the JSON Schema instances for the tools you have access to:

{tool_schemas}

The way you use the tools is as follows:

------------------------

${HM}

If you are using a tool, "action_input" must adhere to the tool's input schema, given above.

------------------------

ALWAYS use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action:
\`\`\`json
$JSON_BLOB
\`\`\`
Observation: the result of the action
... (this Thought/Action/Observation can repeat N times)
Thought: I now know the final answer
Action:
\`\`\`json
{{
  "action": "Final Answer",
  "action_input": "Final response to human"
}}
\`\`\``;
class OP extends _c {
  constructor(e) {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "structured_chat"]
    }), Object.defineProperty(this, "toolNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.toolNames = e.toolNames;
  }
  /**
   * Parses the given text and returns an `AgentAction` or `AgentFinish`
   * object. If an `OutputFixingParser` is provided, it is used for parsing;
   * otherwise, the base parser is used.
   * @param text The text to parse.
   * @param callbacks Optional callbacks for asynchronous operations.
   * @returns A Promise that resolves to an `AgentAction` or `AgentFinish` object.
   */
  async parse(e) {
    try {
      const a = /```(?:json)?(.*)(```)/gs.exec(e);
      if (a === null)
        throw new Vt('Could not parse an action. The agent action must be within a markdown code block, and "action" must be a provided tool or "Final Answer"');
      const r = JSON.parse(a[1].trim()), { action: i, action_input: s } = r;
      return i === "Final Answer" ? { returnValues: { output: s }, log: e } : { tool: i, toolInput: s || {}, log: e };
    } catch (n) {
      throw new Vt(`Failed to parse. Text: "${e}". Error: ${n}`);
    }
  }
  /**
   * Returns the format instructions for parsing the output of an agent
   * action in the style of the StructuredChatAgent.
   * @returns A string representing the format instructions.
   */
  getFormatInstructions() {
    return dr(HM, "f-string", {
      tool_names: this.toolNames.join(", ")
    });
  }
}
class py extends _c {
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "structured_chat"]
    }), Object.defineProperty(this, "baseParser", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputFixingParser", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "toolNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this.toolNames = e.toolNames ?? this.toolNames, this.baseParser = e?.baseParser ?? new OP({ toolNames: this.toolNames }), this.outputFixingParser = e?.outputFixingParser;
  }
  /**
   * Parses the given text and returns an `AgentAction` or `AgentFinish`
   * object. Throws an `OutputParserException` if the parsing fails.
   * @param text The text to parse.
   * @returns A Promise that resolves to an `AgentAction` or `AgentFinish` object.
   */
  async parse(e, n) {
    return this.outputFixingParser !== void 0 ? this.outputFixingParser.parse(e, n) : this.baseParser.parse(e);
  }
  /**
   * Returns the format instructions for parsing the output of an agent
   * action in the style of the StructuredChatAgent.
   * @returns A string representing the format instructions.
   */
  getFormatInstructions() {
    return dr(T4, "f-string", {
      tool_names: this.toolNames.join(", ")
    });
  }
  /**
   * Creates a new `StructuredChatOutputParserWithRetries` instance from a
   * `BaseLanguageModel` and options. The options can include a base parser
   * and tool names.
   * @param llm A `BaseLanguageModel` instance.
   * @param options Options for creating a `StructuredChatOutputParserWithRetries` instance.
   * @returns A new `StructuredChatOutputParserWithRetries` instance.
   */
  static fromLLM(e, n) {
    const a = n.baseParser ?? new OP({ toolNames: n.toolNames ?? [] }), r = hy.fromLLM(e, a);
    return new py({
      baseParser: a,
      outputFixingParser: r,
      toolNames: n.toolNames
    });
  }
}
function $4(t) {
  return t.every(fc) ? t.map((e) => `${e.function.name}${e.function.description ? `: ${e.function.description}` : ""}`).join(`
`) : t.map((e) => `${e.name}: ${e.description}`).join(`
`);
}
function M4(t) {
  return t.every(fc) ? t.map((e) => `${e.function.name}${e.function.description ? `: ${e.function.description}` : ""}, args: ${JSON.stringify(e.function.parameters)}`).join(`
`) : t.map((e) => `${e.name}: ${e.description}, args: ${JSON.stringify(Cn(e.schema).properties)}`).join(`
`);
}
function GM(t, e = "Observation: ", n = "Thought: ") {
  return t.reduce((r, { action: i, observation: s }) => r + [i.log, `
${e}${s}`, n].join(`
`), "");
}
async function pK({ llm: t, tools: e, prompt: n, streamRunnable: a }) {
  const r = ["tools", "tool_names", "agent_scratchpad"].filter((f) => !n.inputVariables.includes(f));
  if (r.length > 0)
    throw new Error(`Provided prompt is missing required input variables: ${JSON.stringify(r)}`);
  let i = [];
  if (e.every(fc))
    i = e.map((f) => f.function.name);
  else if (e.every(XC))
    i = e.map((f) => f.name);
  else
    throw new Error("All tools must be either OpenAI or Structured tools, not a mix.");
  const s = await n.partial({
    tools: M4(e),
    tool_names: i.join(", ")
  }), o = t.bind({
    stop: ["Observation"]
  });
  return Xp.fromRunnables([
    Mt.assign({
      agent_scratchpad: (f) => GM(f.steps)
    }),
    s,
    o,
    py.fromLLM(t, {
      toolNames: i
    })
  ], {
    name: "StructuredChatAgent",
    streamRunnable: a,
    singleAction: !0
  });
}
class A4 extends _c {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "openai"]
    });
  }
  static lc_name() {
    return "OpenAIFunctionsAgentOutputParser";
  }
  async parse(e) {
    throw new Error(`OpenAIFunctionsAgentOutputParser can only parse messages.
Passed input: ${e}`);
  }
  async parseResult(e) {
    if ("message" in e[0] && an(e[0].message))
      return this.parseAIMessage(e[0].message);
    throw new Error("parseResult on OpenAIFunctionsAgentOutputParser only works on ChatGeneration output");
  }
  /**
   * Parses the output message into a FunctionsAgentAction or AgentFinish
   * object.
   * @param message The BaseMessage to parse.
   * @returns A FunctionsAgentAction or AgentFinish object.
   */
  parseAIMessage(e) {
    if (e.content && typeof e.content != "string")
      throw new Error("This agent cannot parse non-string model responses.");
    if (e.additional_kwargs.function_call) {
      const n = e.additional_kwargs.function_call;
      try {
        const a = n.arguments ? JSON.parse(n.arguments) : {};
        return {
          tool: n.name,
          toolInput: a,
          log: `Invoking "${n.name}" with ${n.arguments ?? "{}"}
${e.content}`,
          messageLog: [e]
        };
      } catch (a) {
        throw new Vt(`Failed to parse function arguments from chat model response. Text: "${n.arguments}". ${a}`);
      }
    } else
      return {
        returnValues: { output: e.content },
        log: e.content
      };
  }
  getFormatInstructions() {
    throw new Error("getFormatInstructions not implemented inside OpenAIFunctionsAgentOutputParser.");
  }
}
function E4(t) {
  return t.flatMap(({ action: e, observation: n }) => "messageLog" in e && e.messageLog !== void 0 ? e.messageLog.concat(new $I(n, e.tool)) : [new $t(e.log)]);
}
async function mK({ llm: t, tools: e, prompt: n, streamRunnable: a }) {
  if (!n.inputVariables.includes("agent_scratchpad"))
    throw new Error([
      'Prompt must have an input variable named "agent_scratchpad".',
      `Found ${JSON.stringify(n.inputVariables)} instead.`
    ].join(`
`));
  const r = t.bind({
    functions: e.map((s) => w_(s))
  });
  return Xp.fromRunnables([
    Mt.assign({
      agent_scratchpad: (s) => E4(s.steps)
    }),
    n,
    r,
    new A4()
  ], {
    name: "OpenAIFunctionsAgent",
    streamRunnable: a,
    singleAction: !0
  });
}
const I4 = `Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question`, jP = "Final Answer:", N4 = "Parsing LLM output produced both a final answer and a parse-able action:";
class k4 extends _c {
  constructor(e) {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "react"]
    }), Object.defineProperty(this, "toolNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.toolNames = e.toolNames;
  }
  /**
   * Parses the given text into an AgentAction or AgentFinish object. If an
   * output fixing parser is defined, uses it to parse the text.
   * @param text Text to parse.
   * @returns Promise that resolves to an AgentAction or AgentFinish object.
   */
  async parse(e) {
    const n = e.includes(jP), a = /Action\s*\d*\s*:[\s]*(.*?)[\s]*Action\s*\d*\s*Input\s*\d*\s*:[\s]*(.*)/, r = e.match(a);
    if (r) {
      if (n)
        throw new Vt(`${N4}: ${e}`);
      const i = r[1], o = r[2].trim().replace(/"/g, "");
      return {
        tool: i,
        toolInput: o,
        log: e
      };
    }
    if (n)
      return {
        returnValues: {
          output: e.split(jP)[1].trim()
        },
        log: e
      };
    throw new Vt(`Could not parse LLM output: ${e}`);
  }
  /**
   * Returns the format instructions as a string. If the 'raw' option is
   * true, returns the raw FORMAT_INSTRUCTIONS.
   * @param options Options for getting the format instructions.
   * @returns Format instructions as a string.
   */
  getFormatInstructions() {
    return dr(I4, "f-string", {
      tool_names: this.toolNames.join(", ")
    });
  }
}
async function bK({ llm: t, tools: e, prompt: n, streamRunnable: a }) {
  const r = ["tools", "tool_names", "agent_scratchpad"].filter((f) => !n.inputVariables.includes(f));
  if (r.length > 0)
    throw new Error(`Provided prompt is missing required input variables: ${JSON.stringify(r)}`);
  const i = e.map((f) => f.name), s = await n.partial({
    tools: $4(e),
    tool_names: i.join(", ")
  }), o = t.bind({
    stop: [`
Observation:`]
  });
  return Xp.fromRunnables([
    Mt.assign({
      agent_scratchpad: (f) => GM(f.steps)
    }),
    s,
    o,
    new k4({
      toolNames: i
    })
  ], {
    name: "ReactAgent",
    streamRunnable: a,
    singleAction: !0
  });
}
class gK extends Mp {
  static lc_name() {
    return "SearxngSearch";
  }
  get lc_secrets() {
    return {
      apiBase: "SEARXNG_API_BASE"
    };
  }
  /**
   * Constructor for the SearxngSearch class
   * @param apiBase Base URL of the Searxng instance
   * @param params SearxNG parameters
   * @param headers Custom headers
   */
  constructor({ apiBase: e, params: n, headers: a }) {
    if (super(...arguments), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "searxng-search"
    }), Object.defineProperty(this, "description", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "A meta search engine. Useful for when you need to answer questions about current events. Input should be a search query. Output is a JSON array of the query results"
    }), Object.defineProperty(this, "apiBase", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        numResults: 10,
        pageNumber: 1,
        format: "json",
        imageProxy: !0,
        safesearch: 0
      }
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.apiBase = ft("SEARXNG_API_BASE") || e, this.headers = { "content-type": "application/json", ...a }, !this.apiBase)
      throw new Error('SEARXNG_API_BASE not set. You can set it as "SEARXNG_API_BASE" in your environment variables.');
    n && (this.params = { ...this.params, ...n });
  }
  /**
   * Builds the URL for the Searxng search.
   * @param path The path for the URL.
   * @param parameters The parameters for the URL.
   * @param baseUrl The base URL.
   * @returns The complete URL as a string.
   */
  buildUrl(e, n, a) {
    const r = Object.entries(n).filter(([s, o]) => o !== void 0).map(([s, o]) => [s, o.toString()]), i = new URLSearchParams(r);
    return `${a}/${e}?${i}`;
  }
  async _call(e) {
    const n = {
      q: e,
      ...this.params
    }, a = this.buildUrl("search", n, this.apiBase), r = await fetch(a, {
      method: "POST",
      headers: this.headers,
      signal: AbortSignal.timeout(5 * 1e3)
      // 5 seconds
    });
    if (!r.ok)
      throw new Error(r.statusText);
    const i = await r.json();
    if (!i.results.length && !i.answers.length && !i.infoboxes.length && !i.suggestions.length)
      return "No good results found.";
    if (i.results.length) {
      const s = [];
      return i.results.forEach((o) => {
        s.push(JSON.stringify({
          title: o.title || "",
          link: o.url || "",
          snippet: o.content || ""
        }));
      }), s.slice(0, this.params?.numResults).toString();
    } else {
      if (i.answers.length)
        return i.answers[0];
      if (i.infoboxes.length)
        return i.infoboxes[0]?.content.replaceAll(/<[^>]+>/gi, "");
      if (i.suggestions.length) {
        let s = "Suggestions: ";
        return i.suggestions.forEach((o) => {
          s += `${o}, `;
        }), s;
      } else
        return "No good results found.";
    }
  }
}
class _K extends Mp {
  static lc_name() {
    return "WikipediaQueryRun";
  }
  constructor(e = {}) {
    super(), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "wikipedia-api"
    }), Object.defineProperty(this, "description", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "A tool for interacting with and fetching data from the Wikipedia API."
    }), Object.defineProperty(this, "topKResults", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "maxDocContentLength", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4e3
    }), Object.defineProperty(this, "baseUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "https://en.wikipedia.org/w/api.php"
    }), this.topKResults = e.topKResults ?? this.topKResults, this.maxDocContentLength = e.maxDocContentLength ?? this.maxDocContentLength, this.baseUrl = e.baseUrl ?? this.baseUrl;
  }
  async _call(e) {
    const n = await this._fetchSearchResults(e), a = [];
    for (let r = 0; r < Math.min(this.topKResults, n.query.search.length); r += 1) {
      const i = n.query.search[r].title, s = await this._fetchPage(i, !0);
      if (s) {
        const o = `Page: ${i}
Summary: ${s.extract}`;
        a.push(o);
      }
    }
    return a.length === 0 ? "No good Wikipedia Search Result was found" : a.join(`

`).slice(0, this.maxDocContentLength);
  }
  /**
   * Fetches the content of a specific Wikipedia page. It returns the
   * extracted content as a string.
   * @param page The specific Wikipedia page to fetch its content.
   * @param redirect A boolean value to indicate whether to redirect or not.
   * @returns The extracted content of the specific Wikipedia page as a string.
   */
  async content(e, n = !0) {
    try {
      return (await this._fetchPage(e, n)).extract;
    } catch (a) {
      throw new Error(`Failed to fetch content for page "${e}": ${a}`);
    }
  }
  /**
   * Builds a URL for the Wikipedia API using the provided parameters.
   * @param parameters The parameters to be used in building the URL.
   * @returns A string representing the built URL.
   */
  buildUrl(e) {
    const n = Object.entries(e).filter(([r, i]) => i !== void 0).map(([r, i]) => [r, `${i}`]), a = new URLSearchParams(n);
    return `${this.baseUrl}?${a}`;
  }
  async _fetchSearchResults(e) {
    const n = new URLSearchParams({
      action: "query",
      list: "search",
      srsearch: e,
      format: "json"
    }), a = await fetch(`${this.baseUrl}?${n.toString()}`);
    if (!a.ok)
      throw new Error("Network response was not ok");
    return await a.json();
  }
  async _fetchPage(e, n) {
    const a = new URLSearchParams({
      action: "query",
      prop: "extracts",
      explaintext: "true",
      redirects: n ? "1" : "0",
      format: "json",
      titles: e
    }), r = await fetch(`${this.baseUrl}?${a.toString()}`);
    if (!r.ok)
      throw new Error("Network response was not ok");
    const i = await r.json(), { pages: s } = i.query, o = Object.keys(s)[0];
    return s[o];
  }
}
const WM = `You are given the below API Documentation:
{api_docs}
Using this documentation, generate the full API url to call for answering the user question.
You should build the API url in order to get a response that is as short as possible, while still getting the necessary information to answer the question. Pay attention to deliberately exclude any unnecessary pieces of data in the API call.

Question:{question}
API url:`, F4 = /* @__PURE__ */ new We({
  inputVariables: ["api_docs", "question"],
  template: WM
}), D4 = `${WM} {api_url}

Here is the response from the API:

{api_response}

Summarize this response to answer the original question.

Summary:`, q4 = /* @__PURE__ */ new We({
  inputVariables: ["api_docs", "question", "api_url", "api_response"],
  template: D4
});
class my extends kt {
  get inputKeys() {
    return [this.inputKey];
  }
  get outputKeys() {
    return [this.outputKey];
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "apiAnswerChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiRequestChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiDocs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "question"
    }), Object.defineProperty(this, "outputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "output"
    }), this.apiRequestChain = e.apiRequestChain, this.apiAnswerChain = e.apiAnswerChain, this.apiDocs = e.apiDocs, this.inputKey = e.inputKey ?? this.inputKey, this.outputKey = e.outputKey ?? this.outputKey, this.headers = e.headers ?? this.headers;
  }
  /** @ignore */
  async _call(e, n) {
    const a = e[this.inputKey], r = await this.apiRequestChain.predict({ question: a, api_docs: this.apiDocs }, n?.getChild("request")), s = await (await fetch(r, { headers: this.headers })).text(), o = await this.apiAnswerChain.predict({ question: a, api_docs: this.apiDocs, api_url: r, api_response: s }, n?.getChild("response"));
    return { [this.outputKey]: o };
  }
  _chainType() {
    return "api_chain";
  }
  static async deserialize(e) {
    const { api_request_chain: n, api_answer_chain: a, api_docs: r } = e;
    if (!n)
      throw new Error("LLMChain must have api_request_chain");
    if (!a)
      throw new Error("LLMChain must have api_answer_chain");
    if (!r)
      throw new Error("LLMChain must have api_docs");
    return new my({
      apiAnswerChain: await nt.deserialize(a),
      apiRequestChain: await nt.deserialize(n),
      apiDocs: r
    });
  }
  serialize() {
    return {
      _type: this._chainType(),
      api_answer_chain: this.apiAnswerChain.serialize(),
      api_request_chain: this.apiRequestChain.serialize(),
      api_docs: this.apiDocs
    };
  }
  /**
   * Static method to create a new APIChain from a BaseLanguageModel and API
   * documentation.
   * @param llm BaseLanguageModel instance.
   * @param apiDocs API documentation.
   * @param options Optional configuration options for the APIChain.
   * @returns New APIChain instance.
   */
  static fromLLMAndAPIDocs(e, n, a = {}) {
    const { apiUrlPrompt: r = F4, apiResponsePrompt: i = q4 } = a, s = new nt({ prompt: r, llm: e }), o = new nt({ prompt: i, llm: e });
    return new this({
      apiAnswerChain: o,
      apiRequestChain: s,
      apiDocs: n,
      ...a
    });
  }
}
const J4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  APIChain: my
}, Symbol.toStringTag, { value: "Module" })), L4 = `The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.

Current conversation:
{history}
Human: {input}
AI:`;
class yK extends nt {
  static lc_name() {
    return "ConversationChain";
  }
  constructor({ prompt: e, outputKey: n, memory: a, ...r }) {
    super({
      prompt: e ?? new We({
        template: L4,
        inputVariables: ["history", "input"]
      }),
      outputKey: n ?? "response",
      memory: a ?? new hx(),
      ...r
    });
  }
}
function PP(t, e) {
  const n = /* @__PURE__ */ new Set();
  for (const a of e)
    t.has(a) && n.add(a);
  return n;
}
function U4(t, e) {
  const n = new Set(t);
  for (const a of e)
    n.add(a);
  return n;
}
function eh(t, e) {
  const n = new Set(t);
  for (const a of e)
    n.delete(a);
  return n;
}
function El(t) {
  return Array.from(t).map((e) => `"${e}"`).join(", ");
}
class by extends kt {
  static lc_name() {
    return "SequentialChain";
  }
  get inputKeys() {
    return this.inputVariables;
  }
  get outputKeys() {
    return this.outputVariables;
  }
  constructor(e) {
    if (super(e), Object.defineProperty(this, "chains", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnAll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.chains = e.chains, this.inputVariables = e.inputVariables, this.outputVariables = e.outputVariables ?? [], this.outputVariables.length > 0 && e.returnAll)
      throw new Error("Either specify variables to return using `outputVariables` or use `returnAll` param. Cannot apply both conditions at the same time.");
    this.returnAll = e.returnAll ?? !1, this._validateChains();
  }
  /** @ignore */
  _validateChains() {
    if (this.chains.length === 0)
      throw new Error("Sequential chain must have at least one chain.");
    const e = this.memory?.memoryKeys ?? [], n = new Set(this.inputKeys), a = new Set(e), r = PP(n, a);
    if (r.size > 0)
      throw new Error(`The following keys: ${El(r)} are overlapping between memory and input keys of the chain variables. This can lead to unexpected behaviour. Please use input and memory keys that don't overlap.`);
    const i = U4(n, a);
    for (const s of this.chains) {
      let o = eh(new Set(s.inputKeys), i);
      if (s.memory && (o = eh(o, new Set(s.memory.memoryKeys))), o.size > 0)
        throw new Error(`Missing variables for chain "${s._chainType()}": ${El(o)}. Only got the following variables: ${El(i)}.`);
      const l = new Set(s.outputKeys), f = PP(i, l);
      if (f.size > 0)
        throw new Error(`The following output variables for chain "${s._chainType()}" are overlapping: ${El(f)}. This can lead to unexpected behaviour.`);
      for (const u of l)
        i.add(u);
    }
    if (this.outputVariables.length === 0)
      if (this.returnAll) {
        const s = eh(i, n);
        this.outputVariables = Array.from(s);
      } else
        this.outputVariables = this.chains[this.chains.length - 1].outputKeys;
    else {
      const s = eh(new Set(this.outputVariables), new Set(i));
      if (s.size > 0)
        throw new Error(`The following output variables were expected to be in the final chain output but were not found: ${El(s)}.`);
    }
  }
  /** @ignore */
  async _call(e, n) {
    let a = {};
    const r = e;
    let i = 0;
    for (const o of this.chains) {
      i += 1, a = await o.call(r, n?.getChild(`step_${i}`));
      for (const l of Object.keys(a))
        r[l] = a[l];
    }
    const s = {};
    for (const o of this.outputVariables)
      s[o] = r[o];
    return s;
  }
  _chainType() {
    return "sequential_chain";
  }
  static async deserialize(e) {
    const n = [], a = e.input_variables, r = e.output_variables, i = e.chains;
    for (const s of i) {
      const o = await kt.deserialize(s);
      n.push(o);
    }
    return new by({ chains: n, inputVariables: a, outputVariables: r });
  }
  serialize() {
    const e = [];
    for (const n of this.chains)
      e.push(n.serialize());
    return {
      _type: this._chainType(),
      input_variables: this.inputVariables,
      output_variables: this.outputVariables,
      chains: e
    };
  }
}
class gy extends kt {
  static lc_name() {
    return "SimpleSequentialChain";
  }
  get inputKeys() {
    return [this.inputKey];
  }
  get outputKeys() {
    return [this.outputKey];
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "chains", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "input"
    }), Object.defineProperty(this, "outputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "output"
    }), Object.defineProperty(this, "trimOutputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.chains = e.chains, this.trimOutputs = e.trimOutputs ?? !1, this._validateChains();
  }
  /** @ignore */
  _validateChains() {
    for (const e of this.chains) {
      if (e.inputKeys.filter((n) => !e.memory?.memoryKeys.includes(n)).length !== 1)
        throw new Error(`Chains used in SimpleSequentialChain should all have one input, got ${e.inputKeys.length} for ${e._chainType()}.`);
      if (e.outputKeys.length !== 1)
        throw new Error(`Chains used in SimpleSequentialChain should all have one output, got ${e.outputKeys.length} for ${e._chainType()}.`);
    }
  }
  /** @ignore */
  async _call(e, n) {
    let a = e[this.inputKey], r = 0;
    for (const i of this.chains)
      r += 1, a = (await i.call({ [i.inputKeys[0]]: a, signal: e.signal }, n?.getChild(`step_${r}`)))[i.outputKeys[0]], this.trimOutputs && (a = a.trim()), await n?.handleText(a);
    return { [this.outputKey]: a };
  }
  _chainType() {
    return "simple_sequential_chain";
  }
  static async deserialize(e) {
    const n = [], a = e.chains;
    for (const r of a) {
      const i = await kt.deserialize(r);
      n.push(i);
    }
    return new gy({ chains: n });
  }
  serialize() {
    const e = [];
    for (const n of this.chains)
      e.push(n.serialize());
    return {
      _type: this._chainType(),
      chains: e
    };
  }
}
const RP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SequentialChain: by,
  SimpleSequentialChain: gy
}, Symbol.toStringTag, { value: "Module" }));
class XM extends kt {
  static lc_name() {
    return "AnalyzeDocumentChain";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "input_document"
    }), Object.defineProperty(this, "combineDocumentsChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textSplitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.combineDocumentsChain = e.combineDocumentsChain, this.inputKey = e.inputKey ?? this.inputKey, this.textSplitter = e.textSplitter ?? new op();
  }
  get inputKeys() {
    return [this.inputKey];
  }
  get outputKeys() {
    return this.combineDocumentsChain.outputKeys;
  }
  /** @ignore */
  async _call(e, n) {
    if (!(this.inputKey in e))
      throw new Error(`Document key ${this.inputKey} not found.`);
    const { [this.inputKey]: a, ...r } = e, i = a, o = { input_documents: await this.textSplitter.createDocuments([i]), ...r };
    return await this.combineDocumentsChain.call(o, n?.getChild("combine_documents"));
  }
  _chainType() {
    return "analyze_document_chain";
  }
  static async deserialize(e, n) {
    if (!("text_splitter" in n))
      throw new Error("Need to pass in a text_splitter to deserialize AnalyzeDocumentChain.");
    const { text_splitter: a } = n;
    if (!e.combine_document_chain)
      throw new Error("Need to pass in a combine_document_chain to deserialize AnalyzeDocumentChain.");
    return new XM({
      combineDocumentsChain: await kt.deserialize(e.combine_document_chain),
      textSplitter: a
    });
  }
  serialize() {
    return {
      _type: this._chainType(),
      combine_document_chain: this.combineDocumentsChain.serialize()
    };
  }
}
const B4 = `Given the following conversation and a follow up question, rephrase the follow up question to be a standalone question.

Chat History:
{chat_history}
Follow Up Input: {question}
Standalone question:`;
class QM extends kt {
  static lc_name() {
    return "ConversationalRetrievalQAChain";
  }
  get inputKeys() {
    return [this.inputKey, this.chatHistoryKey];
  }
  get outputKeys() {
    return this.combineDocumentsChain.outputKeys.concat(this.returnSourceDocuments ? ["sourceDocuments"] : []);
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "question"
    }), Object.defineProperty(this, "chatHistoryKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "chat_history"
    }), Object.defineProperty(this, "retriever", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "combineDocumentsChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "questionGeneratorChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnSourceDocuments", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "returnGeneratedQuestion", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.retriever = e.retriever, this.combineDocumentsChain = e.combineDocumentsChain, this.questionGeneratorChain = e.questionGeneratorChain, this.inputKey = e.inputKey ?? this.inputKey, this.returnSourceDocuments = e.returnSourceDocuments ?? this.returnSourceDocuments, this.returnGeneratedQuestion = e.returnGeneratedQuestion ?? this.returnGeneratedQuestion;
  }
  /**
   * Static method to convert the chat history input into a formatted
   * string.
   * @param chatHistory Chat history input which can be a string, an array of BaseMessage instances, or an array of string arrays.
   * @returns A formatted string representing the chat history.
   */
  static getChatHistoryString(e) {
    let n;
    return Array.isArray(e) ? (Array.isArray(e[0]) && typeof e[0][0] == "string" ? (console.warn(`Passing chat history as an array of strings is deprecated.
Please see https://js.langchain.com/docs/modules/chains/popular/chat_vector_db#externally-managed-memory for more information.`), n = e.flat().map((a, r) => r % 2 === 0 ? new _r(a) : new $t(a))) : n = e, n.map((a) => a._getType() === "human" ? `Human: ${a.content}` : a._getType() === "ai" ? `Assistant: ${a.content}` : `${a.content}`).join(`
`)) : e;
  }
  /** @ignore */
  async _call(e, n) {
    if (!(this.inputKey in e))
      throw new Error(`Question key ${this.inputKey} not found.`);
    if (!(this.chatHistoryKey in e))
      throw new Error(`Chat history key ${this.chatHistoryKey} not found.`);
    const a = e[this.inputKey], r = QM.getChatHistoryString(e[this.chatHistoryKey]);
    let i = a;
    if (r.length > 0) {
      const f = await this.questionGeneratorChain.call({
        question: a,
        chat_history: r
      }, n?.getChild("question_generator")), u = Object.keys(f);
      if (u.length === 1)
        i = f[u[0]];
      else
        throw new Error("Return from llm chain has multiple values, only single values supported.");
    }
    const s = await this.retriever.getRelevantDocuments(i, n?.getChild("retriever")), o = {
      question: i,
      input_documents: s,
      chat_history: r
    };
    let l = await this.combineDocumentsChain.call(o, n?.getChild("combine_documents"));
    return this.returnSourceDocuments && (l = {
      ...l,
      sourceDocuments: s
    }), this.returnGeneratedQuestion && (l = {
      ...l,
      generatedQuestion: i
    }), l;
  }
  _chainType() {
    return "conversational_retrieval_chain";
  }
  static async deserialize(e, n) {
    throw new Error("Not implemented.");
  }
  serialize() {
    throw new Error("Not implemented.");
  }
  /**
   * Static method to create a new ConversationalRetrievalQAChain from a
   * BaseLanguageModel and a BaseRetriever.
   * @param llm {@link BaseLanguageModelInterface} instance used to generate a new question.
   * @param retriever {@link BaseRetrieverInterface} instance used to retrieve relevant documents.
   * @param options.returnSourceDocuments Whether to return source documents in the final output
   * @param options.questionGeneratorChainOptions Options to initialize the standalone question generation chain used as the first internal step
   * @param options.qaChainOptions {@link QAChainParams} used to initialize the QA chain used as the second internal step
   * @returns A new instance of ConversationalRetrievalQAChain.
   */
  static fromLLM(e, n, a = {}) {
    const { questionGeneratorTemplate: r, qaTemplate: i, qaChainOptions: s = {
      type: "stuff",
      prompt: i ? We.fromTemplate(i) : void 0
    }, questionGeneratorChainOptions: o, verbose: l, ...f } = a, u = g4(e, s), c = We.fromTemplate(o?.template ?? r ?? B4), h = new nt({
      prompt: c,
      llm: o?.llm ?? e,
      verbose: l
    });
    return new this({
      retriever: n,
      combineDocumentsChain: u,
      questionGeneratorChain: h,
      verbose: l,
      ...f
    });
  }
}
class wK extends kt {
  static lc_name() {
    return "RetrievalQAChain";
  }
  get inputKeys() {
    return [this.inputKey];
  }
  get outputKeys() {
    return this.combineDocumentsChain.outputKeys.concat(this.returnSourceDocuments ? ["sourceDocuments"] : []);
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "query"
    }), Object.defineProperty(this, "retriever", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "combineDocumentsChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnSourceDocuments", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.retriever = e.retriever, this.combineDocumentsChain = e.combineDocumentsChain, this.inputKey = e.inputKey ?? this.inputKey, this.returnSourceDocuments = e.returnSourceDocuments ?? this.returnSourceDocuments;
  }
  /** @ignore */
  async _call(e, n) {
    if (!(this.inputKey in e))
      throw new Error(`Question key "${this.inputKey}" not found.`);
    const a = e[this.inputKey], r = await this.retriever.getRelevantDocuments(a, n?.getChild("retriever")), i = { question: a, input_documents: r, ...e }, s = await this.combineDocumentsChain.call(i, n?.getChild("combine_documents"));
    return this.returnSourceDocuments ? {
      ...s,
      sourceDocuments: r
    } : s;
  }
  _chainType() {
    return "retrieval_qa";
  }
  static async deserialize(e, n) {
    throw new Error("Not implemented");
  }
  serialize() {
    throw new Error("Not implemented");
  }
  /**
   * Creates a new instance of RetrievalQAChain using a BaseLanguageModel
   * and a BaseRetriever.
   * @param llm The BaseLanguageModel used to generate a new question.
   * @param retriever The BaseRetriever used to retrieve relevant documents.
   * @param options Optional parameters for the RetrievalQAChain.
   * @returns A new instance of RetrievalQAChain.
   */
  static fromLLM(e, n, a) {
    const r = dy(e, {
      prompt: a?.prompt
    });
    return new this({
      ...a,
      retriever: n,
      combineDocumentsChain: r
    });
  }
}
class vK extends kt {
  static lc_name() {
    return "TransformChain";
  }
  _chainType() {
    return "transform";
  }
  get inputKeys() {
    return this.inputVariables;
  }
  get outputKeys() {
    return this.outputVariables;
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "transformFunc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.transformFunc = e.transform, this.inputVariables = e.inputVariables, this.outputVariables = e.outputVariables;
  }
  async _call(e, n) {
    return this.transformFunc(e, n?.getChild("transform"));
  }
}
class uu extends Error {
  constructor(e, n) {
    let a = e ?? "";
    n?.lc_error_code && (a = `${a}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${n.lc_error_code}/
`), super(a), Object.defineProperty(this, "lc_error_code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.lc_error_code = n?.lc_error_code;
  }
}
class YM extends uu {
  get is_bubble_up() {
    return !0;
  }
}
class x4 extends uu {
  constructor(e, n) {
    super(e, n), this.name = "GraphRecursionError";
  }
  static get unminifiable_name() {
    return "GraphRecursionError";
  }
}
class CP extends uu {
  constructor(e, n) {
    super(e, n), this.name = "GraphValueError";
  }
  static get unminifiable_name() {
    return "GraphValueError";
  }
}
class ad extends YM {
  constructor(e, n) {
    super(JSON.stringify(e, null, 2), n), Object.defineProperty(this, "interrupts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "GraphInterrupt", this.interrupts = e ?? [];
  }
  static get unminifiable_name() {
    return "GraphInterrupt";
  }
}
class eA extends ad {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e, n) {
    super([
      {
        value: e,
        when: "during"
      }
    ], n), this.name = "NodeInterrupt";
  }
  static get unminifiable_name() {
    return "NodeInterrupt";
  }
}
class tA extends YM {
  constructor(e) {
    super(), Object.defineProperty(this, "command", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "ParentCommand", this.command = e;
  }
  static get unminifiable_name() {
    return "ParentCommand";
  }
}
function V4(t) {
  return t !== void 0 && t.name === tA.unminifiable_name;
}
function ph(t) {
  return t !== void 0 && t.is_bubble_up === !0;
}
function Zl(t) {
  return t !== void 0 && [
    ad.unminifiable_name,
    eA.unminifiable_name
  ].includes(t.name);
}
class TP extends uu {
  constructor(e, n) {
    super(e, n), this.name = "EmptyInputError";
  }
  static get unminifiable_name() {
    return "EmptyInputError";
  }
}
class un extends uu {
  constructor(e, n) {
    super(e, n), this.name = "EmptyChannelError";
  }
  static get unminifiable_name() {
    return "EmptyChannelError";
  }
}
class rt extends uu {
  constructor(e, n) {
    super(e, n), this.name = "InvalidUpdateError";
  }
  static get unminifiable_name() {
    return "InvalidUpdateError";
  }
}
class z4 extends uu {
  constructor(e, n) {
    super(e, n), this.name = "UnreachableNodeError";
  }
  static get unminifiable_name() {
    return "UnreachableNodeError";
  }
}
function nA(t) {
  return uN({ clockseq: t });
}
function Ju(t, e) {
  const n = e.replace(/-/g, "").match(/.{2}/g).map((a) => parseInt(a, 16));
  return aN(t, new Uint8Array(n));
}
const Z4 = "__error__", mh = "__scheduled__", K4 = "__interrupt__", H4 = "__resume__";
function _y(t) {
  if (typeof t != "object" || t === null)
    return t;
  const e = Array.isArray(t) ? [] : {};
  for (const n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = _y(t[n]));
  return e;
}
function rA() {
  return {
    v: 1,
    id: nA(-2),
    ts: (/* @__PURE__ */ new Date()).toISOString(),
    channel_values: {},
    channel_versions: {},
    versions_seen: {},
    pending_sends: []
  };
}
function up(t) {
  return {
    v: t.v,
    id: t.id,
    ts: t.ts,
    channel_values: { ...t.channel_values },
    channel_versions: { ...t.channel_versions },
    versions_seen: _y(t.versions_seen),
    pending_sends: [...t.pending_sends]
  };
}
function aA(t, e) {
  return typeof t == "number" && typeof e == "number" ? Math.sign(t - e) : String(t).localeCompare(String(e));
}
function $P(...t) {
  return t.reduce((e, n, a) => a === 0 ? n : aA(e, n) >= 0 ? e : n);
}
const MP = {
  [Z4]: -1,
  [mh]: -2,
  [K4]: -3,
  [H4]: -4
};
class Il extends Error {
  constructor(e) {
    super(e), this.name = "InvalidNamespaceError";
  }
}
function G4(t) {
  if (t.length === 0)
    throw new Il("Namespace cannot be empty.");
  for (const e of t) {
    if (typeof e != "string")
      throw new Il(`Invalid namespace label '${e}' found in ${t}. Namespace labels must be strings, but got ${typeof e}.`);
    if (e.includes("."))
      throw new Il(`Invalid namespace label '${e}' found in ${t}. Namespace labels cannot contain periods ('.').`);
    if (e === "")
      throw new Il(`Namespace labels cannot be empty strings. Got ${e} in ${t}`);
  }
  if (t[0] === "langgraph")
    throw new Il(`Root label for namespace cannot be "langgraph". Got: ${t}`);
}
class W4 {
  /**
   * Retrieve a single item by its namespace and key.
   *
   * @param namespace Hierarchical path for the item
   * @param key Unique identifier within the namespace
   * @returns Promise resolving to the item or null if not found
   */
  async get(e, n) {
    return (await this.batch([{ namespace: e, key: n }]))[0];
  }
  /**
   * Search for items within a namespace prefix.
   * Supports both metadata filtering and vector similarity search.
   *
   * @param namespacePrefix Hierarchical path prefix to search within
   * @param options Search options for filtering and pagination
   * @returns Promise resolving to list of matching items with relevance scores
   *
   * @example
   * // Search with filters
   * await store.search(["documents"], {
   *   filter: { type: "report", status: "active" },
   *   limit: 5,
   *   offset: 10
   * });
   *
   * // Vector similarity search
   * await store.search(["users", "content"], {
   *   query: "technical documentation about APIs",
   *   limit: 20
   * });
   */
  async search(e, n = {}) {
    const { filter: a, limit: r = 10, offset: i = 0, query: s } = n;
    return (await this.batch([
      {
        namespacePrefix: e,
        filter: a,
        limit: r,
        offset: i,
        query: s
      }
    ]))[0];
  }
  /**
   * Store or update an item.
   *
   * @param namespace Hierarchical path for the item
   * @param key Unique identifier within the namespace
   * @param value Object containing the item's data
   * @param index Optional indexing configuration
   *
   * @example
   * // Simple storage
   * await store.put(["docs"], "report", { title: "Annual Report" });
   *
   * // With specific field indexing
   * await store.put(
   *   ["docs"],
   *   "report",
   *   {
   *     title: "Q4 Report",
   *     chapters: [{ content: "..." }, { content: "..." }]
   *   },
   *   ["title", "chapters[*].content"]
   * );
   */
  async put(e, n, a, r) {
    G4(e), await this.batch([{ namespace: e, key: n, value: a, index: r }]);
  }
  /**
   * Delete an item from the store.
   *
   * @param namespace Hierarchical path for the item
   * @param key Unique identifier within the namespace
   */
  async delete(e, n) {
    await this.batch([{ namespace: e, key: n, value: null }]);
  }
  /**
   * List and filter namespaces in the store.
   * Used to explore data organization and navigate the namespace hierarchy.
   *
   * @param options Options for listing namespaces
   * @returns Promise resolving to list of namespace paths
   *
   * @example
   * // List all namespaces under "documents"
   * await store.listNamespaces({
   *   prefix: ["documents"],
   *   maxDepth: 2
   * });
   *
   * // List namespaces ending with "v1"
   * await store.listNamespaces({
   *   suffix: ["v1"],
   *   limit: 50
   * });
   */
  async listNamespaces(e = {}) {
    const { prefix: n, suffix: a, maxDepth: r, limit: i = 100, offset: s = 0 } = e, o = [];
    return n && o.push({ matchType: "prefix", path: n }), a && o.push({ matchType: "suffix", path: a }), (await this.batch([
      {
        matchConditions: o.length ? o : void 0,
        maxDepth: r,
        limit: i,
        offset: s
      }
    ]))[0];
  }
  /**
   * Start the store. Override if initialization is needed.
   */
  start() {
  }
  /**
   * Stop the store. Override if cleanup is needed.
   */
  stop() {
  }
}
class X4 extends W4 {
  constructor(e) {
    super(), Object.defineProperty(this, "store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "nextKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "running", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "processingTask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), this.store = e;
  }
  get isRunning() {
    return this.running;
  }
  /**
   * @ignore
   * Batch is not implemented here as we're only extending `BaseStore`
   * to allow it to be passed where `BaseStore` is expected, and implement
   * the convenience methods (get, search, put, delete).
   */
  async batch(e) {
    throw new Error("The `batch` method is not implemented on `AsyncBatchedStore`.\n Instead, it calls the `batch` method on the wrapped store.\n If you are seeing this error, something is wrong.");
  }
  async get(e, n) {
    return this.enqueueOperation({ namespace: e, key: n });
  }
  async search(e, n) {
    const { filter: a, limit: r = 10, offset: i = 0, query: s } = n || {};
    return this.enqueueOperation({
      namespacePrefix: e,
      filter: a,
      limit: r,
      offset: i,
      query: s
    });
  }
  async put(e, n, a) {
    return this.enqueueOperation({ namespace: e, key: n, value: a });
  }
  async delete(e, n) {
    return this.enqueueOperation({
      namespace: e,
      key: n,
      value: null
    });
  }
  start() {
    this.running || (this.running = !0, this.processingTask = this.processBatchQueue());
  }
  async stop() {
    this.running = !1, this.processingTask && await this.processingTask;
  }
  enqueueOperation(e) {
    return new Promise((n, a) => {
      const r = this.nextKey;
      this.nextKey += 1, this.queue.set(r, { operation: e, resolve: n, reject: a });
    });
  }
  async processBatchQueue() {
    for (; this.running; ) {
      if (await new Promise((n) => {
        setTimeout(n, 0);
      }), this.queue.size === 0)
        continue;
      const e = new Map(this.queue);
      this.queue.clear();
      try {
        const n = Array.from(e.values()).map(({ operation: r }) => r), a = await this.store.batch(n);
        e.forEach(({ resolve: r }, i) => {
          const s = Array.from(e.keys()).indexOf(i);
          r(a[s]);
        });
      } catch (n) {
        e.forEach(({ reject: a }) => {
          a(n);
        });
      }
    }
  }
  // AsyncBatchedStore is internal and gets passed as args into traced tasks
  // some BaseStores contain circular references so just serialize without it
  // as this causes warnings when tracing with LangSmith.
  toJSON() {
    return {
      queue: this.queue,
      nextKey: this.nextKey,
      running: this.running,
      store: "[LangGraphStore]"
    };
  }
}
function em(t) {
  return t != null && t.lg_is_channel === !0;
}
class tm {
  constructor() {
    Object.defineProperty(this, "ValueType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "UpdateType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lg_is_channel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
  }
  /**
   * Mark the current value of the channel as consumed. By default, no-op.
   * This is called by Pregel before the start of the next step, for all
   * channels that triggered a node. If the channel was updated, return true.
   */
  consume() {
    return !1;
  }
}
function cp(t, e) {
  const n = Object.fromEntries(Object.entries(t).filter(([, r]) => em(r))), a = {};
  for (const r in n)
    if (Object.prototype.hasOwnProperty.call(n, r)) {
      const i = e.channel_values[r];
      a[r] = n[r].fromCheckpoint(i);
    }
  return a;
}
function Do(t, e, n) {
  let a;
  if (e === void 0)
    a = t.channel_values;
  else {
    a = {};
    for (const r of Object.keys(e))
      try {
        a[r] = e[r].checkpoint();
      } catch (i) {
        if (i.name !== un.unminifiable_name) throw i;
      }
  }
  return {
    v: 1,
    id: nA(n),
    ts: (/* @__PURE__ */ new Date()).toISOString(),
    channel_values: a,
    channel_versions: { ...t.channel_versions },
    versions_seen: _y(t.versions_seen),
    pending_sends: t.pending_sends ?? []
  };
}
class Ed extends tm {
  constructor(e, n) {
    super(), Object.defineProperty(this, "lc_graph_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BinaryOperatorAggregate"
    }), Object.defineProperty(this, "value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "operator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "initialValueFactory", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.operator = e, this.initialValueFactory = n, this.value = n?.();
  }
  fromCheckpoint(e) {
    const n = new Ed(this.operator, this.initialValueFactory);
    return e && (n.value = e), n;
  }
  update(e) {
    let n = e;
    if (!n.length)
      return !1;
    this.value === void 0 && ([this.value] = n, n = n.slice(1));
    for (const a of n)
      this.value !== void 0 && (this.value = this.operator(this.value, a));
    return !0;
  }
  get() {
    if (this.value === void 0)
      throw new un();
    return this.value;
  }
  checkpoint() {
    if (this.value === void 0)
      throw new un();
    return this.value;
  }
}
class nm extends tm {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_graph_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "LastValue"
    }), Object.defineProperty(this, "value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  fromCheckpoint(e) {
    const n = new nm();
    return e && (n.value = [e]), n;
  }
  update(e) {
    if (e.length === 0)
      return !1;
    if (e.length !== 1)
      throw new rt("LastValue can only receive one value per step.", {
        lc_error_code: "INVALID_CONCURRENT_GRAPH_UPDATE"
      });
    return this.value = [e[e.length - 1]], !0;
  }
  get() {
    if (this.value.length === 0)
      throw new un();
    return this.value[0];
  }
  checkpoint() {
    if (this.value.length === 0)
      throw new un();
    return this.value[0];
  }
}
const Ge = "__start__", Me = "__end__", qs = "__input__", Q4 = "__copy__", Rn = "__error__", xs = "__pregel_send", Pg = "__pregel_call", zo = "__pregel_read", _t = "__pregel_checkpointer", io = "__pregel_resuming", id = "__pregel_task_id", lp = "__pregel_stream", Y4 = "__pregel_resume_value", Zo = "__pregel_scratchpad", bh = "__pregel_previous", eV = "checkpoint_id", Rg = "checkpoint_ns", tV = "__pregel_node_finished", Ln = "checkpoint_map", it = "__interrupt__", zn = "__resume__", yy = "__no_writes__", Id = "__return__", vb = "__previous__", Ou = "__pregel_runtime_placeholder__", lt = "langsmith:hidden", nV = "langsmith:nostream", Cg = "__self__", tc = "__pregel_tasks", Gt = "__pregel_push", gh = "__pregel_pull", Bn = "00000000-0000-0000-0000-000000000000", rV = [
  lt,
  qs,
  it,
  zn,
  Rn,
  yy,
  tc,
  // reserved config.configurable keys
  xs,
  zo,
  _t,
  lp,
  io,
  id,
  Pg,
  Y4,
  Zo,
  bh,
  Ln,
  Rg,
  eV
], sn = "|", Ko = ":";
function Tg(t) {
  const e = t;
  return e != null && typeof e.node == "string" && e.args !== void 0;
}
class dp {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e, n) {
    Object.defineProperty(this, "lg_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Send"
    }), Object.defineProperty(this, "node", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.node = e, this.args = Nd(n);
  }
  toJSON() {
    return {
      lg_name: this.lg_name,
      node: this.node,
      args: this.args
    };
  }
}
function Tn(t) {
  return t instanceof dp;
}
class fr {
  constructor(e) {
    Object.defineProperty(this, "lg_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Command"
    }), Object.defineProperty(this, "lc_direct_tool_output", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "graph", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "update", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "resume", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "goto", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this.resume = e.resume, this.graph = e.graph, this.update = e.update, e.goto && (this.goto = Array.isArray(e.goto) ? Nd(e.goto) : [Nd(e.goto)]);
  }
  /**
   * Convert the update field to a list of {@link PendingWrite} tuples
   * @returns List of {@link PendingWrite} tuples of the form `[channelKey, value]`.
   * @internal
   */
  _updateAsTuples() {
    return this.update && typeof this.update == "object" && !Array.isArray(this.update) ? Object.entries(this.update) : Array.isArray(this.update) && this.update.every((e) => Array.isArray(e) && e.length === 2 && typeof e[0] == "string") ? this.update : [["__root__", this.update]];
  }
  toJSON() {
    let e;
    return typeof this.goto == "string" ? e = this.goto : Tn(this.goto) ? e = this.goto.toJSON() : e = this.goto?.map((n) => typeof n == "string" ? n : n.toJSON()), {
      lg_name: this.lg_name,
      update: this.update,
      resume: this.resume,
      goto: e
    };
  }
}
Object.defineProperty(fr, "PARENT", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "__parent__"
});
function Un(t) {
  return typeof t != "object" || t == null ? !1 : "lg_name" in t && t.lg_name === "Command";
}
function Nd(t, e = /* @__PURE__ */ new Map()) {
  if (t != null && typeof t == "object") {
    if (e.has(t))
      return e.get(t);
    let n;
    if (Array.isArray(t))
      n = [], e.set(t, n), t.forEach((a, r) => {
        n[r] = Nd(a, e);
      });
    else if (Un(t) && !(t instanceof fr))
      n = new fr(t), e.set(t, n);
    else if (Tg(t) && !(t instanceof dp))
      n = new dp(t.node, t.args), e.set(t, n);
    else if (Un(t) || Tn(t))
      n = t, e.set(t, n);
    else {
      n = {}, e.set(t, n);
      for (const [a, r] of Object.entries(t))
        n[a] = Nd(r, e);
    }
    return n;
  }
  return t;
}
class aV {
  constructor(e, n) {
    Object.defineProperty(this, "runtime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_promises", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "lg_is_managed_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.config = e;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static async initialize(e, n) {
    throw new Error("Not implemented");
  }
  async promises() {
    return Promise.all(this._promises);
  }
  addPromise(e) {
    this._promises.push(e);
  }
}
const iV = "__channel_key_placeholder__";
class sV extends Map {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e) {
    super(e ? Array.from(e) : void 0);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  replaceRuntimeValues(e, n) {
    if (!(this.size === 0 || !n) && !Array.from(this.values()).every((a) => !a.runtime)) {
      if (typeof n == "object" && !Array.isArray(n))
        for (const [a, r] of Object.entries(n))
          for (const [i, s] of this.entries())
            s.runtime && s.call(e) === r && (n[a] = { [Ou]: i });
      else if (typeof n == "object" && "constructor" in n)
        for (const a of Object.getOwnPropertyNames(Object.getPrototypeOf(n)))
          try {
            const r = n[a];
            for (const [i, s] of this.entries())
              s.runtime && s.call(e) === r && (n[a] = { [Ou]: i });
          } catch (r) {
            if (r.name !== TypeError.name)
              throw r;
          }
    }
  }
  replaceRuntimePlaceholders(e, n) {
    if (!(this.size === 0 || !n) && !Array.from(this.values()).every((a) => !a.runtime)) {
      if (typeof n == "object" && !Array.isArray(n)) {
        for (const [a, r] of Object.entries(n))
          if (typeof r == "object" && r !== null && Ou in r) {
            const i = r[Ou];
            typeof i == "string" && (n[a] = this.get(i)?.call(e));
          }
      } else if (typeof n == "object" && "constructor" in n)
        for (const a of Object.getOwnPropertyNames(Object.getPrototypeOf(n)))
          try {
            const r = n[a];
            if (typeof r == "object" && r !== null && Ou in r) {
              const i = this.get(r[Ou]);
              i && (n[a] = i.call(e));
            }
          } catch (r) {
            if (r.name !== TypeError.name)
              throw r;
          }
    }
  }
}
function wy(t) {
  return !!(typeof t == "object" && t && "cls" in t && "params" in t);
}
class vy extends aV {
  call() {
  }
  static async initialize(e, n) {
    return Promise.resolve(new vy(e));
  }
}
function AP(t) {
  return typeof t == "object" && t && "reducer" in t && t.reducer ? new Ed(t.reducer, t.default) : typeof t == "object" && t && "value" in t && t.value ? new Ed(t.value, t.default) : new nm();
}
const oV = ["tags", "metadata", "callbacks", "configurable"], uV = [
  "tags",
  "metadata",
  "callbacks",
  "runName",
  "maxConcurrency",
  "recursionLimit",
  "configurable",
  "runId",
  "outputKeys",
  "streamMode",
  "store",
  "writer",
  "interruptBefore",
  "interruptAfter",
  "signal"
], cV = 25;
function iA(...t) {
  const e = {
    tags: [],
    metadata: {},
    callbacks: void 0,
    recursionLimit: cV,
    configurable: {}
  }, n = xn.getRunnableConfig();
  if (n !== void 0) {
    for (const [a, r] of Object.entries(n))
      if (r !== void 0)
        if (oV.includes(a)) {
          let i;
          Array.isArray(r) ? i = [...r] : typeof r == "object" ? a === "callbacks" && "copy" in r && typeof r.copy == "function" ? i = r.copy() : i = { ...r } : i = r, e[a] = i;
        } else
          e[a] = r;
  }
  for (const a of t)
    if (a !== void 0)
      for (const [r, i] of Object.entries(a))
        i !== void 0 && uV.includes(r) && (e[r] = i);
  for (const [a, r] of Object.entries(e.configurable))
    e.metadata = e.metadata ?? {}, !a.startsWith("__") && (typeof r == "string" || typeof r == "number" || typeof r == "boolean") && !(a in e.metadata) && (e.metadata[a] = r);
  return e;
}
function Sb(t) {
  return t.split(sn).filter((e) => !e.match(/^\d+$/)).map((e) => e.split(Ko)[0]).join(sn);
}
function lV(t) {
  const e = t.split(sn);
  for (; e.length > 1 && e[e.length - 1].match(/^\d+$/); )
    e.pop();
  return e.slice(0, -1).join(sn);
}
class cu extends Te {
  constructor(e) {
    super(), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langgraph"]
    }), Object.defineProperty(this, "func", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "trace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "recurse", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.name = e.name ?? e.func.name, this.func = e.func, this.config = e.tags ? { tags: e.tags } : void 0, this.trace = e.trace ?? this.trace, this.recurse = e.recurse ?? this.recurse;
  }
  async _tracedInvoke(e, n, a) {
    return new Promise((r, i) => {
      const s = Ye(n, {
        callbacks: a?.getChild()
      });
      xn.runWithConfig(s, async () => {
        try {
          const o = await this.func(e, s);
          r(o);
        } catch (o) {
          i(o);
        }
      });
    });
  }
  async invoke(e, n) {
    let a;
    const r = iA(n), i = oa(this.config, r);
    return this.trace ? a = await this._callWithConfig(this._tracedInvoke, e, i) : a = await xn.runWithConfig(i, async () => this.func(e, i)), Te.isRunnable(a) && this.recurse ? await xn.runWithConfig(i, async () => a.invoke(e, i)) : a;
  }
}
function* ro(t, e) {
  if (e === void 0)
    yield* t;
  else
    for (const n of t)
      yield [e, n];
}
async function uo(t) {
  const e = [];
  for await (const n of await t)
    e.push(n);
  return e;
}
function Kl(t) {
  const e = [];
  for (const n of t)
    e.push(n);
  return e;
}
function Nl(t, e) {
  return t ? "configurable" in t ? {
    ...t,
    configurable: {
      ...t.configurable,
      ...e
    }
  } : {
    ...t,
    configurable: e
  } : {
    configurable: e
  };
}
function dV(t) {
  return typeof t == "object" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  t?.[Symbol.for("LG_SKIP_WRITE")] !== void 0;
}
const Ho = {
  [Symbol.for("LG_PASSTHROUGH")]: !0
};
function th(t) {
  return typeof t == "object" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  t?.[Symbol.for("LG_PASSTHROUGH")] !== void 0;
}
const Ob = Symbol("IS_WRITER");
class Ct extends cu {
  constructor(e, n) {
    const a = `ChannelWrite<${e.map((r) => Tn(r) ? r.node : "channel" in r ? r.channel : "...").join(",")}>`;
    super({
      writes: e,
      name: a,
      tags: n,
      func: async (r, i) => this._write(r, i ?? {})
    }), Object.defineProperty(this, "writes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.writes = e;
  }
  async _write(e, n) {
    const a = this.writes.map((r) => jb(r) && th(r.value) ? {
      mapper: r.mapper,
      value: e
    } : _h(r) && th(r.value) ? {
      channel: r.channel,
      value: e,
      skipNone: r.skipNone,
      mapper: r.mapper
    } : r);
    return await Ct.doWrite(n, a), e;
  }
  // TODO: Support requireAtLeastOneOf
  static async doWrite(e, n) {
    for (const i of n) {
      if (_h(i)) {
        if (i.channel === tc)
          throw new rt("Cannot write to the reserved channel TASKS");
        if (th(i.value))
          throw new rt("PASSTHROUGH value must be replaced");
      }
      if (jb(i) && th(i.value))
        throw new rt("PASSTHROUGH value must be replaced");
    }
    const a = [];
    for (const i of n)
      if (Tn(i))
        a.push([tc, i]);
      else if (jb(i)) {
        const s = await i.mapper.invoke(i.value, e);
        s != null && s.length > 0 && a.push(...s);
      } else if (_h(i)) {
        const s = i.mapper !== void 0 ? await i.mapper.invoke(i.value, e) : i.value;
        if (dV(s) || i.skipNone && s === void 0)
          continue;
        a.push([i.channel, s]);
      } else
        throw new Error(`Invalid write entry: ${JSON.stringify(i)}`);
    const r = e.configurable?.[xs];
    r(a);
  }
  static isWriter(e) {
    return (
      // eslint-disable-next-line no-instanceof/no-instanceof
      e instanceof Ct || Ob in e && !!e[Ob]
    );
  }
  static registerWriter(e) {
    return Object.defineProperty(e, Ob, { value: !0 });
  }
}
function _h(t) {
  return t !== void 0 && typeof t.channel == "string";
}
function jb(t) {
  return t !== void 0 && !_h(t) && Te.isRunnable(t.mapper);
}
class Sy extends cu {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e, n, a = !1) {
    super({
      func: (r, i) => Sy.doRead(i, this.channel, this.fresh, this.mapper)
    }), Object.defineProperty(this, "lc_graph_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChannelRead"
    }), Object.defineProperty(this, "channel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fresh", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "mapper", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.fresh = a, this.mapper = n, this.channel = e, this.name = Array.isArray(e) ? `ChannelRead<${e.join(",")}>` : `ChannelRead<${e}>`;
  }
  static doRead(e, n, a, r) {
    const i = e.configurable?.[zo];
    if (!i)
      throw new Error(`Runnable ${this} is not configured with a read function. Make sure to call in the context of a Pregel process`);
    return r ? r(i(n, a)) : i(n, a);
  }
}
const ju = /* @__PURE__ */ new Mt();
class ua extends fo {
  constructor(e) {
    const { channels: n, triggers: a, mapper: r, writers: i, bound: s, kwargs: o, metadata: l, retryPolicy: f, tags: u, subgraphs: c, ends: h } = e, p = [
      ...e.config?.tags ? e.config.tags : [],
      ...u ?? []
    ];
    super({
      ...e,
      bound: e.bound ?? ju,
      config: {
        ...e.config ? e.config : {},
        tags: p
      }
    }), Object.defineProperty(this, "lc_graph_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "PregelNode"
    }), Object.defineProperty(this, "channels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "triggers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "mapper", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "writers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "bound", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ju
    }), Object.defineProperty(this, "kwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "retryPolicy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subgraphs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ends", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.channels = n, this.triggers = a, this.mapper = r, this.writers = i ?? this.writers, this.bound = s ?? this.bound, this.kwargs = o ?? this.kwargs, this.metadata = l ?? this.metadata, this.tags = p, this.retryPolicy = f, this.subgraphs = c, this.ends = h;
  }
  getWriters() {
    const e = [...this.writers];
    for (; e.length > 1 && // eslint-disable-next-line no-instanceof/no-instanceof
    e[e.length - 1] instanceof Ct && // eslint-disable-next-line no-instanceof/no-instanceof
    e[e.length - 2] instanceof Ct; ) {
      const n = e.slice(-2), a = n[0].writes.concat(n[1].writes);
      e[e.length - 2] = new Ct(a, n[0].config?.tags), e.pop();
    }
    return e;
  }
  getNode() {
    const e = this.getWriters();
    if (!(this.bound === ju && e.length === 0))
      return this.bound === ju && e.length === 1 ? e[0] : this.bound === ju ? new dt({
        first: e[0],
        middle: e.slice(1, e.length - 1),
        last: e[e.length - 1],
        omitSequenceTags: !0
      }) : e.length > 0 ? new dt({
        first: this.bound,
        middle: e.slice(0, e.length - 1),
        last: e[e.length - 1],
        omitSequenceTags: !0
      }) : this.bound;
  }
  join(e) {
    if (!Array.isArray(e))
      throw new Error("channels must be a list");
    if (typeof this.channels != "object")
      throw new Error("all channels must be named when using .join()");
    return new ua({
      channels: {
        ...this.channels,
        ...Object.fromEntries(e.map((n) => [n, n]))
      },
      triggers: this.triggers,
      mapper: this.mapper,
      writers: this.writers,
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      retryPolicy: this.retryPolicy
    });
  }
  pipe(e) {
    return Ct.isWriter(e) ? new ua({
      channels: this.channels,
      triggers: this.triggers,
      mapper: this.mapper,
      writers: [...this.writers, e],
      bound: this.bound,
      config: this.config,
      kwargs: this.kwargs,
      retryPolicy: this.retryPolicy
    }) : this.bound === ju ? new ua({
      channels: this.channels,
      triggers: this.triggers,
      mapper: this.mapper,
      writers: this.writers,
      bound: Pn(e),
      config: this.config,
      kwargs: this.kwargs,
      retryPolicy: this.retryPolicy
    }) : new ua({
      channels: this.channels,
      triggers: this.triggers,
      mapper: this.mapper,
      writers: this.writers,
      bound: this.bound.pipe(e),
      config: this.config,
      kwargs: this.kwargs,
      retryPolicy: this.retryPolicy
    });
  }
}
class Is extends Error {
  constructor(e) {
    super(e), this.name = "GraphValidationError";
  }
}
function fV({ nodes: t, channels: e, inputChannels: n, outputChannels: a, streamChannels: r, interruptAfterNodes: i, interruptBeforeNodes: s }) {
  if (!e)
    throw new Is("Channels not provided");
  const o = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  for (const [f, u] of Object.entries(t)) {
    if (f === it)
      throw new Is(`"Node name ${it} is reserved"`);
    if (u.constructor === ua)
      u.triggers.forEach((c) => o.add(c));
    else
      throw new Is(`Invalid node type ${typeof u}, expected PregelNode`);
  }
  for (const f of o)
    if (!(f in e))
      throw new Is(`Subcribed channel '${String(f)}' not in channels`);
  if (Array.isArray(n)) {
    if (n.every((f) => !o.has(f)))
      throw new Is(`None of the input channels ${n} are subscribed to by any node`);
  } else if (!o.has(n))
    throw new Is(`Input channel ${String(n)} is not subscribed to by any node`);
  Array.isArray(a) ? a.forEach((f) => l.add(f)) : l.add(a), r && !Array.isArray(r) ? l.add(r) : Array.isArray(r) && r.forEach((f) => l.add(f));
  for (const f of l)
    if (!(f in e))
      throw new Is(`Output channel '${String(f)}' not in channels`);
  if (i && i !== "*") {
    for (const f of i)
      if (!(f in t))
        throw new Is(`Node ${String(f)} not in nodes`);
  }
  if (s && s !== "*") {
    for (const f of s)
      if (!(f in t))
        throw new Is(`Node ${String(f)} not in nodes`);
  }
}
function EP(t, e) {
  if (Array.isArray(t)) {
    for (const n of t)
      if (!(n in e))
        throw new Error(`Key ${String(n)} not found in channels`);
  } else if (!(t in e))
    throw new Error(`Key ${String(t)} not found in channels`);
}
function Go(t, e, n = !0, a = !1) {
  try {
    return t[e].get();
  } catch (r) {
    if (r.name === un.unminifiable_name) {
      if (a)
        return r;
      if (n)
        return null;
    }
    throw r;
  }
}
function nu(t, e, n = !0) {
  if (Array.isArray(e)) {
    const a = {};
    for (const r of e)
      try {
        a[r] = Go(t, r, !n);
      } catch (i) {
        if (i.name === un.unminifiable_name)
          continue;
      }
    return a;
  } else
    return Go(t, e);
}
function* hV(t, e) {
  if (t.graph === fr.PARENT)
    throw new rt("There is no parent graph.");
  if (t.goto) {
    let n;
    Array.isArray(t.goto) ? n = t.goto : n = [t.goto];
    for (const a of n)
      if (Tn(a))
        yield [Bn, tc, a];
      else if (typeof a == "string")
        yield [Bn, `branch:__start__:${Cg}:${a}`, "__start__"];
      else
        throw new Error(`In Command.send, expected Send or string, got ${typeof a}`);
  }
  if (t.resume)
    if (typeof t.resume == "object" && Object.keys(t.resume).length && Object.keys(t.resume).every(Us))
      for (const [n, a] of Object.entries(t.resume)) {
        const r = e.filter((i) => i[0] === n && i[1] === zn).map((i) => i[2]).slice(0, 1) ?? [];
        r.push(a), yield [n, zn, r];
      }
    else
      yield [Bn, zn, t.resume];
  if (t.update) {
    if (typeof t.update != "object" || !t.update)
      throw new Error("Expected cmd.update to be a dict mapping channel names to update values");
    if (Array.isArray(t.update))
      for (const [n, a] of t.update)
        yield [Bn, n, a];
    else
      for (const [n, a] of Object.entries(t.update))
        yield [Bn, n, a];
  }
}
function* sA(t, e) {
  if (e != null)
    if (Array.isArray(t) && typeof e == "object" && !Array.isArray(e))
      for (const n in e)
        t.includes(n) && (yield [n, e[n]]);
    else {
      if (Array.isArray(t))
        throw new Error('Input chunk must be an object when "inputChannels" is an array');
      yield [t, e];
    }
}
function* Pb(t, e, n) {
  Array.isArray(t) ? (e === !0 || e.find(([a, r]) => t.includes(a))) && (yield nu(n, t)) : (e === !0 || e.some(([a, r]) => a === t)) && (yield Go(n, t));
}
function* IP(t, e, n) {
  const a = e.filter(([o, l]) => (o.config === void 0 || !o.config.tags?.includes(lt)) && l[0][0] !== Rn && l[0][0] !== it);
  if (!a.length)
    return;
  let r;
  a.some(([o]) => o.writes.some(([l, f]) => l === Id)) ? r = a.flatMap(([o]) => o.writes.filter(([l, f]) => l === Id).map(([l, f]) => [o.name, f])) : Array.isArray(t) ? r = a.flatMap(([o]) => {
    const { writes: l } = o, f = {};
    for (const [u] of l)
      t.includes(u) && (f[u] = (f[u] || 0) + 1);
    return Object.values(f).some((u) => u > 1) ? l.filter(([u]) => t.includes(u)).map(([u, c]) => [o.name, { [u]: c }]) : [
      [
        o.name,
        Object.fromEntries(l.filter(([u]) => t.includes(u)))
      ]
    ];
  }) : r = a.flatMap(([o]) => o.writes.filter(([l, f]) => l === t).map(([l, f]) => [o.name, f]));
  const i = {};
  for (const [o, l] of r)
    o in i || (i[o] = []), i[o].push(l);
  const s = {};
  for (const o in i)
    if (i[o].length === 1) {
      const [l] = i[o];
      s[o] = l;
    } else
      s[o] = i[o];
  n && (s.__metadata__ = { cached: n }), yield s;
}
function pV(t) {
  return "steps" in t && Array.isArray(t.steps);
}
function Oy(t) {
  return "lg_is_pregel" in t && t.lg_is_pregel === !0;
}
function oA(t) {
  const e = [t];
  for (const n of e) {
    if (Oy(n))
      return n;
    pV(n) && e.push(...n.steps);
  }
}
const kd = {
  blue: {
    start: "\x1B[34m",
    end: "\x1B[0m"
  },
  green: {
    start: "\x1B[32m",
    end: "\x1B[0m"
  },
  yellow: {
    start: "\x1B[33;1m",
    end: "\x1B[0m"
  }
}, Fd = (t, e) => `${t.start}${e}${t.end}`;
function* NP(t, e) {
  const n = (/* @__PURE__ */ new Date()).toISOString();
  for (const { id: a, name: r, input: i, config: s, triggers: o, writes: l } of e) {
    if (s?.tags?.includes(lt))
      continue;
    const f = l.filter(([u, c]) => u === a && c === it).map(([, u]) => u);
    yield {
      type: "task",
      timestamp: n,
      step: t,
      payload: {
        id: a,
        name: r,
        input: i,
        triggers: o,
        interrupts: f
      }
    };
  }
}
function* mV(t, e, n) {
  const a = (/* @__PURE__ */ new Date()).toISOString();
  for (const [{ id: r, name: i, config: s }, o] of e)
    s?.tags?.includes(lt) || (yield {
      type: "task_result",
      timestamp: a,
      step: t,
      payload: {
        id: r,
        name: i,
        result: o.filter(([l]) => Array.isArray(n) ? n.includes(l) : l === n),
        interrupts: o.filter((l) => l[0] === it).map((l) => l[1])
      }
    });
}
function* bV(t, e, n, a, r, i, s, o) {
  function l(h) {
    const p = {};
    return h.callbacks != null && (p.callbacks = h.callbacks), h.configurable != null && (p.configurable = h.configurable), h.maxConcurrency != null && (p.max_concurrency = h.maxConcurrency), h.metadata != null && (p.metadata = h.metadata), h.recursionLimit != null && (p.recursion_limit = h.recursionLimit), h.runId != null && (p.run_id = h.runId), h.runName != null && (p.run_name = h.runName), h.tags != null && (p.tags = h.tags), p;
  }
  const f = e.configurable?.checkpoint_ns, u = {};
  for (const h of i) {
    if (!(h.subgraphs?.length ? h.subgraphs : [h.proc]).find(oA))
      continue;
    let d = `${h.name}:${h.id}`;
    f && (d = `${f}|${d}`), u[h.id] = {
      configurable: {
        thread_id: e.configurable?.thread_id,
        checkpoint_ns: d
      }
    };
  }
  yield {
    type: "checkpoint",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    step: t,
    payload: {
      config: l(e),
      values: nu(n, a),
      metadata: r,
      next: i.map((h) => h.name),
      tasks: uA(i, s, u),
      parentConfig: o ? l(o) : void 0
    }
  };
}
function uA(t, e, n) {
  return t.map((a) => {
    const r = e.find(([o, l]) => o === a.id && l === Rn)?.[2], i = e.filter(([o, l]) => o === a.id && l === it).map(([, , o]) => o);
    if (r)
      return {
        id: a.id,
        name: a.name,
        path: a.path,
        error: r,
        interrupts: i
      };
    const s = n?.[a.id];
    return {
      id: a.id,
      name: a.name,
      path: a.path,
      interrupts: i,
      ...s !== void 0 ? { state: s } : {}
    };
  });
}
function gV(t, e, n) {
  console.log([
    `${Fd(kd.blue, `[${t}:checkpoint]`)}`,
    `\x1B[1m State at the end of step ${t}:\x1B[0m
`,
    JSON.stringify(nu(e, n), null, 2)
  ].join(""));
}
function cA(t, e) {
  const n = e.length;
  console.log([
    `${Fd(kd.blue, `[${t}:tasks]`)}`,
    `\x1B[1m Starting step ${t} with ${n} task${n === 1 ? "" : "s"}:\x1B[0m
`,
    e.map((a) => `- ${Fd(kd.green, String(a.name))} -> ${JSON.stringify(a.input, null, 2)}`).join(`
`)
  ].join(""));
}
function _V(t, e, n) {
  const a = {};
  for (const [r, i] of e)
    n.includes(r) && (a[r] || (a[r] = []), a[r].push(i));
  console.log([
    `${Fd(kd.blue, `[${t}:writes]`)}`,
    `\x1B[1m Finished step ${t} with writes to ${Object.keys(a).length} channel${Object.keys(a).length !== 1 ? "s" : ""}:\x1B[0m
`,
    Object.entries(a).map(([r, i]) => `- ${Fd(kd.yellow, r)} -> ${i.map((s) => JSON.stringify(s)).join(", ")}`).join(`
`)
  ].join(""));
}
class yV {
  constructor({ func: e, name: n, input: a, retry: r, callbacks: i }) {
    Object.defineProperty(this, "func", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "input", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "retry", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "__lg_type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "call"
    }), this.func = e, this.name = n, this.input = a, this.retry = r, this.callbacks = i;
  }
}
function wV(t) {
  return typeof t == "object" && t !== null && "__lg_type" in t && t.__lg_type === "call";
}
function lA(t) {
  const e = Object.values(t), n = e.length > 0 ? typeof e[0] : void 0;
  let a;
  return n === "number" ? a = 0 : n === "string" && (a = ""), a;
}
function $g(t, e) {
  if (Object.keys(t).length > 0) {
    const n = lA(e);
    return Object.fromEntries(Object.entries(e).filter(([a, r]) => r > (t[a] ?? n)));
  } else
    return e;
}
function vV(t, e) {
  return t && !Array.isArray(t) && // eslint-disable-next-line no-instanceof/no-instanceof
  !(t instanceof Date) && typeof t == "object" ? t : { [e]: t };
}
function Uo(t, e) {
  return t === null ? { configurable: e } : t?.configurable === void 0 ? { ...t, configurable: e } : {
    ...t,
    configurable: { ...t.configurable, ...e }
  };
}
function Pu(t, e) {
  const n = e?.parents ?? {};
  return Object.keys(n).length > 0 ? Uo(t, {
    [Ln]: {
      ...n,
      [t.configurable?.checkpoint_ns ?? ""]: t.configurable?.checkpoint_id
    }
  }) : t;
}
function SV(t, e) {
  const n = new cu({
    func: (a) => e(...a),
    name: t,
    trace: !1,
    recurse: !1
  });
  return new dt({
    name: t,
    first: n,
    last: new Ct([{ channel: Id, value: Ho }], [lt])
  });
}
const OV = (t) => t !== void 0 ? t + 1 : 1;
function nh(t, e, n) {
  const a = Object.values(t.channel_versions), r = a.length > 0 ? typeof a[0] : void 0;
  let i;
  r === "number" ? i = 0 : r === "string" && (i = "");
  const s = t.versions_seen[it] ?? {}, o = Object.entries(t.channel_versions).some(([f, u]) => u > (s[f] ?? i)), l = n.some((f) => e === "*" ? !f.config?.tags?.includes(lt) : e.includes(f.name));
  return o && l;
}
function yh(t, e, n, a, r, i, s = !1) {
  let o = [], l = /* @__PURE__ */ new Set();
  if (Array.isArray(i))
    o = i.filter((u) => a.get(u)), i = i.filter((u) => !a.get(u)), l = new Set(i.filter((u) => r.writes.some(([c, h]) => c === u)));
  else {
    for (const [u] of r.writes)
      if (u === i) {
        l = /* @__PURE__ */ new Set([u]);
        break;
      }
    l = l || /* @__PURE__ */ new Set();
  }
  let f;
  if (s && l.size > 0) {
    const u = Object.fromEntries(Object.entries(n).filter(([p, d]) => l.has(p))), c = Do(e, u, -1), h = cp(u, c);
    vn(up(c), h, [r]), f = nu({ ...n, ...h }, i);
  } else
    f = nu(n, i);
  if (o.length > 0)
    for (const u of o) {
      const c = a.get(u);
      if (c) {
        const h = c.call(t);
        f[u] = h;
      }
    }
  return f;
}
function Rb(t, e, n, a, r) {
  for (const [i, s] of r)
    if ([Gt, tc].includes(i) && s != null) {
      if (!Tn(s))
        throw new rt(`Invalid packet type, expected SendProtocol, got ${JSON.stringify(s)}`);
      if (!(s.node in n))
        throw new rt(`Invalid node name "${s.node}" in Send packet`);
      a.replaceRuntimeValues(t, s.args);
    }
  e(r);
}
const jV = /* @__PURE__ */ new Set([
  yy,
  Gt,
  zn,
  it,
  Id,
  Rn
]);
function vn(t, e, n, a) {
  n.sort((c, h) => {
    const p = c.path?.slice(0, 3) || [], d = h.path?.slice(0, 3) || [];
    for (let m = 0; m < Math.min(p.length, d.length); m += 1) {
      if (p[m] < d[m])
        return -1;
      if (p[m] > d[m])
        return 1;
    }
    return p.length - d.length;
  });
  const r = n.some((c) => c.triggers.length > 0), i = Object.fromEntries(Object.entries(e).filter(([c, h]) => em(h)));
  for (const c of n) {
    t.versions_seen[c.name] === void 0 && (t.versions_seen[c.name] = {});
    for (const h of c.triggers)
      h in t.channel_versions && (t.versions_seen[c.name][h] = t.channel_versions[h]);
  }
  let s;
  Object.keys(t.channel_versions).length > 0 && (s = $P(...Object.values(t.channel_versions)));
  const o = new Set(n.flatMap((c) => c.triggers).filter((c) => !rV.includes(c)));
  for (const c of o)
    c in i && i[c].consume() && a !== void 0 && (t.channel_versions[c] = a(s, i[c]));
  t.pending_sends?.length && r && (t.pending_sends = []);
  const l = {}, f = {};
  for (const c of n)
    for (const [h, p] of c.writes)
      jV.has(h) || (h === tc ? t.pending_sends.push({
        node: p.node,
        args: p.args
      }) : h in i ? h in l ? l[h].push(p) : l[h] = [p] : h in f ? f[h].push(p) : f[h] = [p]);
  s = void 0, Object.keys(t.channel_versions).length > 0 && (s = $P(...Object.values(t.channel_versions)));
  const u = /* @__PURE__ */ new Set();
  for (const [c, h] of Object.entries(l))
    if (c in i) {
      let p;
      try {
        p = i[c].update(h);
      } catch (d) {
        if (d.name === rt.unminifiable_name) {
          const m = new rt(`Invalid update for channel "${c}" with values ${JSON.stringify(h)}: ${d.message}`);
          throw m.lc_error_code = d.lc_error_code, m;
        } else
          throw d;
      }
      p && a !== void 0 && (t.channel_versions[c] = a(s, i[c])), u.add(c);
    }
  if (r)
    for (const c of Object.keys(i))
      u.has(c) || i[c].update([]) && a !== void 0 && (t.channel_versions[c] = a(s, i[c]));
  return f;
}
function sd(t, e, n, a, r, i, s, o) {
  const l = {};
  for (let f = 0; f < t.pending_sends.length; f += 1) {
    const u = Mg([Gt, f], t, e, n, a, r, i, s, o);
    u !== void 0 && (l[u.id] = u);
  }
  for (const f of Object.keys(n)) {
    const u = Mg([gh, f], t, e, n, a, r, i, s, o);
    u !== void 0 && (l[u.id] = u);
  }
  return l;
}
function Mg(t, e, n, a, r, i, s, o, l) {
  const { step: f, checkpointer: u, manager: c } = l, h = s.configurable ?? {}, p = h.checkpoint_ns ?? "";
  if (t[0] === Gt && wV(t[t.length - 1])) {
    const d = t[t.length - 1], m = SV(d.name, d.func), b = [Gt], g = p === "" ? d.name : `${p}${sn}${d.name}`, _ = Ju(JSON.stringify([
      g,
      f.toString(),
      d.name,
      Gt,
      t[1],
      t[2]
    ]), e.id), P = `${g}${Ko}${_}`, C = {
      langgraph_step: f,
      langgraph_node: d.name,
      langgraph_triggers: b,
      langgraph_path: t.slice(0, 3),
      langgraph_checkpoint_ns: P
    };
    {
      const R = [];
      return {
        name: d.name,
        input: d.input,
        proc: m,
        writes: R,
        config: Ye(oa(s, {
          metadata: C,
          store: l.store ?? s.store
        }), {
          runName: d.name,
          callbacks: c?.getChild(`graph:step:${f}`),
          configurable: {
            [id]: _,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            [xs]: (O) => Rb(f, (A) => R.push(...A), a, i, O),
            [zo]: (O, A = !1) => yh(f, e, r, i, {
              name: d.name,
              writes: R,
              triggers: b,
              path: t.slice(0, 3)
            }, O, A),
            [_t]: u ?? h[_t],
            [Ln]: {
              ...h[Ln],
              [p]: e.id
            },
            [Zo]: Cb({
              pendingWrites: n ?? [],
              taskId: _,
              currentTaskInput: d.input
            }),
            [bh]: e.channel_values[vb],
            checkpoint_id: void 0,
            checkpoint_ns: P
          }
        }),
        triggers: b,
        retry_policy: d.retry,
        id: _,
        path: t.slice(0, 3),
        writers: []
      };
    }
  } else if (t[0] === Gt) {
    const d = typeof t[1] == "number" ? t[1] : parseInt(t[1], 10);
    if (d >= e.pending_sends.length)
      return;
    const m = Tg(e.pending_sends[d]) && !Tn(e.pending_sends[d]) ? new dp(e.pending_sends[d].node, e.pending_sends[d].args) : e.pending_sends[d];
    if (!Tg(m)) {
      console.warn(`Ignoring invalid packet ${JSON.stringify(m)} in pending sends.`);
      return;
    }
    if (!(m.node in a)) {
      console.warn(`Ignoring unknown node name ${m.node} in pending sends.`);
      return;
    }
    const b = [Gt], g = p === "" ? m.node : `${p}${sn}${m.node}`, _ = Ju(JSON.stringify([
      g,
      f.toString(),
      m.node,
      Gt,
      d.toString()
    ]), e.id), P = `${g}${Ko}${_}`;
    let C = {
      langgraph_step: f,
      langgraph_node: m.node,
      langgraph_triggers: b,
      langgraph_path: t.slice(0, 3),
      langgraph_checkpoint_ns: P
    };
    {
      const R = a[m.node], T = R.getNode();
      if (T !== void 0) {
        i.replaceRuntimePlaceholders(f, m.args), R.metadata !== void 0 && (C = { ...C, ...R.metadata });
        const O = [];
        return {
          name: m.node,
          input: m.args,
          proc: T,
          subgraphs: R.subgraphs,
          writes: O,
          config: Ye(oa(s, {
            metadata: C,
            tags: R.tags,
            store: l.store ?? s.store
          }), {
            runName: m.node,
            callbacks: c?.getChild(`graph:step:${f}`),
            configurable: {
              [id]: _,
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              [xs]: (A) => Rb(f, (M) => O.push(...M), a, i, A),
              [zo]: (A, M = !1) => yh(f, e, r, i, {
                name: m.node,
                writes: O,
                triggers: b,
                path: t
              }, A, M),
              [_t]: u ?? h[_t],
              [Ln]: {
                ...h[Ln],
                [p]: e.id
              },
              [Zo]: Cb({
                pendingWrites: n ?? [],
                taskId: _,
                currentTaskInput: m.args
              }),
              [bh]: e.channel_values[vb],
              checkpoint_id: void 0,
              checkpoint_ns: P
            }
          }),
          triggers: b,
          retry_policy: R.retryPolicy,
          id: _,
          path: t,
          writers: R.getWriters()
        };
      }
    }
  } else if (t[0] === gh) {
    const d = t[1].toString(), m = a[d];
    if (m === void 0)
      return;
    if (n?.length) {
      const P = p === "" ? d : `${p}${sn}${d}`, C = Ju(JSON.stringify([
        P,
        f.toString(),
        d,
        gh,
        d
      ]), e.id);
      if (n.some((T) => T[0] === C && T[1] !== Rn))
        return;
    }
    const b = lA(e.channel_versions);
    if (b === void 0)
      return;
    const g = e.versions_seen[d] ?? {}, _ = m.triggers.filter((P) => {
      const C = Go(r, P, !1, !0);
      return !// eslint-disable-next-line no-instanceof/no-instanceof
      (C instanceof Error && C.name === un.unminifiable_name) && (e.channel_versions[P] ?? b) > (g[P] ?? b);
    }).sort();
    if (_.length > 0) {
      const P = PV(f, m, i, r);
      if (P === void 0)
        return;
      const C = p === "" ? d : `${p}${sn}${d}`, R = Ju(JSON.stringify([
        C,
        f.toString(),
        d,
        gh,
        _
      ]), e.id), T = `${C}${Ko}${R}`;
      let O = {
        langgraph_step: f,
        langgraph_node: d,
        langgraph_triggers: _,
        langgraph_path: t,
        langgraph_checkpoint_ns: T
      };
      {
        const A = m.getNode();
        if (A !== void 0) {
          m.metadata !== void 0 && (O = { ...O, ...m.metadata });
          const M = [];
          return {
            name: d,
            input: P,
            proc: A,
            subgraphs: m.subgraphs,
            writes: M,
            config: Ye(oa(s, {
              metadata: O,
              tags: m.tags,
              store: l.store ?? s.store
            }), {
              runName: d,
              callbacks: c?.getChild(`graph:step:${f}`),
              configurable: {
                [id]: R,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                [xs]: (I) => Rb(f, (N) => {
                  M.push(...N);
                }, a, i, I),
                [zo]: (I, N = !1) => yh(f, e, r, i, {
                  name: d,
                  writes: M,
                  triggers: _,
                  path: t
                }, I, N),
                [_t]: u ?? h[_t],
                [Ln]: {
                  ...h[Ln],
                  [p]: e.id
                },
                [Zo]: Cb({
                  pendingWrites: n ?? [],
                  taskId: R,
                  currentTaskInput: P
                }),
                [bh]: e.channel_values[vb],
                checkpoint_id: void 0,
                checkpoint_ns: T
              }
            }),
            triggers: _,
            retry_policy: m.retryPolicy,
            id: R,
            path: t,
            writers: m.getWriters()
          };
        }
      }
    }
  }
}
function PV(t, e, n, a, r) {
  let i;
  if (typeof e.channels == "object" && !Array.isArray(e.channels)) {
    i = {};
    for (const [s, o] of Object.entries(e.channels))
      if (e.triggers.includes(o))
        try {
          i[s] = Go(a, o, !1);
        } catch (l) {
          if (l.name === un.unminifiable_name)
            return;
          throw l;
        }
      else if (o in a)
        try {
          i[s] = Go(a, o, !1);
        } catch (l) {
          if (l.name === un.unminifiable_name)
            continue;
          throw l;
        }
      else
        i[s] = n.get(s)?.call(t);
  } else if (Array.isArray(e.channels)) {
    let s = !1;
    for (const o of e.channels)
      try {
        i = Go(a, o, !1), s = !0;
        break;
      } catch (l) {
        if (l.name === un.unminifiable_name)
          continue;
        throw l;
      }
    if (!s)
      return;
  } else
    throw new Error(`Invalid channels type, expected list or dict, got ${e.channels}`);
  return e.mapper !== void 0 && (i = e.mapper(i)), i;
}
function Cb({ pendingWrites: t, taskId: e, currentTaskInput: n }) {
  const a = t.find(([i, s]) => i === Bn && s === zn)?.[2], r = {
    callCounter: 0,
    interruptCounter: -1,
    resume: t.filter(([i, s]) => i === e && s === zn).flatMap(([i, s, o]) => o),
    nullResume: a,
    subgraphCounter: 0,
    currentTaskInput: n,
    consumeNullResume: () => {
      if (r.nullResume)
        return delete r.nullResume, t.splice(t.findIndex(([i, s]) => i === Bn && s === zn), 1), a;
    }
  };
  return r;
}
class dA extends ln {
  get closed() {
    return this._closed;
  }
  constructor(e) {
    let n;
    const a = new Promise((r) => {
      n = r;
    });
    super({
      start: (r) => {
        n(r);
      }
    }), Object.defineProperty(this, "modes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "controller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "passthroughFn", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_closed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), a.then((r) => {
      this.controller = r;
    }), this.passthroughFn = e.passthroughFn, this.modes = e.modes;
  }
  push(e) {
    this.passthroughFn?.(e), this.controller.enqueue(e);
  }
  close() {
    try {
      this.controller.close();
    } catch {
    } finally {
      this._closed = !0;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  error(e) {
    this.controller.error(e);
  }
}
const Tb = Symbol.for("INPUT_DONE"), $b = Symbol.for("INPUT_RESUMING"), RV = 25;
function CV(...t) {
  return new dA({
    passthroughFn: (e) => {
      for (const n of t)
        n.modes.has(e[1]) && n.push(e);
    },
    modes: new Set(t.flatMap((e) => Array.from(e.modes)))
  });
}
class jy {
  get isResuming() {
    const e = Object.keys(this.checkpoint.channel_versions).length !== 0, a = this.config.configurable?.[io] !== void 0 && this.config.configurable?.[io], r = this.input === null || this.input === void 0, i = Un(this.input), s = this.input === $b;
    return e && (a || r || i || s);
  }
  constructor(e) {
    Object.defineProperty(this, "input", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "output", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointerGetNextVersion", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "channels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "managed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointConfig", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointMetadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointNamespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointPendingWrites", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "checkpointPreviousVersions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "step", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputKeys", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streamKeys", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "nodes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "skipDoneTasks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "prevCheckpointConfig", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "pending"
    }), Object.defineProperty(this, "tasks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "stream", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointerPromises", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "isNested", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_checkpointerChainedPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Promise.resolve()
    }), Object.defineProperty(this, "store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "manager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interruptAfter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interruptBefore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "toInterrupt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "debug", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.input = e.input, this.checkpointer = e.checkpointer, this.checkpointer !== void 0 ? this.checkpointerGetNextVersion = this.checkpointer.getNextVersion.bind(this.checkpointer) : this.checkpointerGetNextVersion = OV, this.checkpoint = e.checkpoint, this.checkpointMetadata = e.checkpointMetadata, this.checkpointPreviousVersions = e.checkpointPreviousVersions, this.channels = e.channels, this.managed = e.managed, this.checkpointPendingWrites = e.checkpointPendingWrites, this.step = e.step, this.stop = e.stop, this.config = e.config, this.checkpointConfig = e.checkpointConfig, this.isNested = e.isNested, this.manager = e.manager, this.outputKeys = e.outputKeys, this.streamKeys = e.streamKeys, this.nodes = e.nodes, this.skipDoneTasks = e.skipDoneTasks, this.store = e.store, this.stream = e.stream, this.checkpointNamespace = e.checkpointNamespace, this.prevCheckpointConfig = e.prevCheckpointConfig, this.interruptAfter = e.interruptAfter, this.interruptBefore = e.interruptBefore, this.debug = e.debug;
  }
  static async initialize(e) {
    let { config: n, stream: a } = e;
    a !== void 0 && n.configurable?.[lp] !== void 0 && (a = CV(a, n.configurable[lp]));
    const r = n.configurable ? !("checkpoint_id" in n.configurable) : !0, i = n.configurable?.[Zo];
    n.configurable && i && (i.subgraphCounter > 0 && (n = Uo(n, {
      [Rg]: [
        n.configurable[Rg],
        i.subgraphCounter.toString()
      ].join(sn)
    })), i.subgraphCounter += 1);
    const s = zo in (n.configurable ?? {});
    !s && n.configurable?.checkpoint_ns !== void 0 && n.configurable?.checkpoint_ns !== "" && (n = Uo(n, {
      checkpoint_ns: "",
      checkpoint_id: void 0
    }));
    let o = n;
    n.configurable?.[Ln] !== void 0 && n.configurable?.[Ln]?.[n.configurable?.checkpoint_ns] && (o = Uo(n, {
      checkpoint_id: n.configurable[Ln][n.configurable?.checkpoint_ns]
    }));
    const l = n.configurable?.checkpoint_ns?.split(sn) ?? [], f = await e.checkpointer?.getTuple(o) ?? {
      config: n,
      checkpoint: rA(),
      metadata: {
        source: "input",
        step: -2,
        writes: null,
        parents: {}
      },
      pendingWrites: []
    };
    o = {
      ...n,
      ...f.config,
      configurable: {
        checkpoint_ns: "",
        ...n.configurable,
        ...f.config.configurable
      }
    };
    const u = f.parentConfig, c = up(f.checkpoint), h = { ...f.metadata }, p = f.pendingWrites ?? [], d = cp(e.channelSpecs, c), m = (h.step ?? 0) + 1, b = m + (n.recursionLimit ?? RV) + 1, g = { ...c.channel_versions }, _ = e.store ? new X4(e.store) : void 0;
    return _ && _.start(), new jy({
      input: e.input,
      config: n,
      checkpointer: e.checkpointer,
      checkpoint: c,
      checkpointMetadata: h,
      checkpointConfig: o,
      prevCheckpointConfig: u,
      checkpointNamespace: l,
      channels: d,
      managed: e.managed,
      isNested: s,
      manager: e.manager,
      skipDoneTasks: r,
      step: m,
      stop: b,
      checkpointPreviousVersions: g,
      checkpointPendingWrites: p,
      outputKeys: e.outputKeys ?? [],
      streamKeys: e.streamKeys ?? [],
      nodes: e.nodes,
      stream: a,
      store: _,
      interruptAfter: e.interruptAfter,
      interruptBefore: e.interruptBefore,
      debug: e.debug
    });
  }
  _checkpointerPutAfterPrevious(e) {
    this._checkpointerChainedPromise = this._checkpointerChainedPromise.then(() => this.checkpointer?.put(e.config, e.checkpoint, e.metadata, e.newVersions)), this.checkpointerPromises.push(this._checkpointerChainedPromise);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async updateManagedValues(e, n) {
    const a = this.managed.get(e);
    a && "update" in a && typeof a.update == "function" && await a.update(n);
  }
  /**
   * Put writes for a task, to be read by the next tick.
   * @param taskId
   * @param writes
   */
  putWrites(e, n) {
    let a = n;
    if (a.length === 0)
      return;
    a.every(([i]) => i in MP) && (a = Array.from(new Map(a.map((i) => [i[0], i])).values()));
    for (const [i, s] of a) {
      const o = this.checkpointPendingWrites.findIndex((l) => l[0] === e && l[1] === i);
      i in MP && o !== -1 ? this.checkpointPendingWrites[o] = [e, i, s] : this.checkpointPendingWrites.push([e, i, s]);
    }
    const r = this.checkpointer?.putWrites({
      ...this.checkpointConfig,
      configurable: {
        ...this.checkpointConfig.configurable,
        checkpoint_ns: this.config.configurable?.checkpoint_ns ?? "",
        checkpoint_id: this.checkpoint.id
      }
    }, a, e);
    r !== void 0 && this.checkpointerPromises.push(r), this.tasks && this._outputWrites(e, a);
  }
  _outputWrites(e, n, a = !1) {
    const r = this.tasks[e];
    if (r !== void 0) {
      if (r.config !== void 0 && (r.config.tags ?? []).includes(lt))
        return;
      n.length > 0 && n[0][0] !== Rn && n[0][0] !== it && this._emit(Kl(ro(IP(this.outputKeys, [[r, n]], a), "updates"))), a || this._emit(Kl(ro(mV(this.step, [[r, n]], this.streamKeys), "debug")));
    }
  }
  /**
   * Execute a single iteration of the Pregel loop.
   * Returns true if more iterations are needed.
   * @param params
   */
  async tick(e) {
    this.store && !this.store.isRunning && this.store?.start();
    const { inputKeys: n = [] } = e;
    if (this.status !== "pending")
      throw new Error(`Cannot tick when status is no longer "pending". Current status: "${this.status}"`);
    if (![Tb, $b].includes(this.input))
      await this._first(n);
    else {
      if (this.toInterrupt.length > 0)
        throw this.status = "interrupt_before", new ad();
      if (Object.values(this.tasks).every((i) => i.writes.length > 0)) {
        const i = Object.values(this.tasks).flatMap((l) => l.writes), s = vn(this.checkpoint, this.channels, Object.values(this.tasks), this.checkpointerGetNextVersion);
        for (const [l, f] of Object.entries(s))
          await this.updateManagedValues(l, f);
        const o = await uo(ro(Pb(this.outputKeys, i, this.channels), "values"));
        if (this._emit(o), this.checkpointPendingWrites = [], await this._putCheckpoint({
          source: "loop",
          writes: IP(this.outputKeys, Object.values(this.tasks).map((l) => [l, l.writes])).next().value ?? null
        }), nh(this.checkpoint, this.interruptAfter, Object.values(this.tasks)))
          throw this.status = "interrupt_after", new ad();
        this.config.configurable?.[io] !== void 0 && delete this.config.configurable?.[io];
      } else
        return !1;
    }
    if (this.step > this.stop)
      return this.status = "out_of_steps", !1;
    const a = sd(this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.managed, this.config, !0, {
      step: this.step,
      checkpointer: this.checkpointer,
      manager: this.manager,
      store: this.store
    });
    if (this.tasks = a, this.checkpointer && this._emit(await uo(ro(bV(
      this.step - 1,
      // printing checkpoint for previous step
      this.checkpointConfig,
      this.channels,
      this.streamKeys,
      this.checkpointMetadata,
      Object.values(this.tasks),
      this.checkpointPendingWrites,
      this.prevCheckpointConfig
    ), "debug"))), Object.values(this.tasks).length === 0)
      return this.status = "done", !1;
    if (this.skipDoneTasks && this.checkpointPendingWrites.length > 0) {
      for (const [i, s, o] of this.checkpointPendingWrites) {
        if (s === Rn || s === it || s === zn)
          continue;
        const l = Object.values(this.tasks).find((f) => f.id === i);
        l && l.writes.push([s, o]);
      }
      for (const i of Object.values(this.tasks))
        i.writes.length > 0 && this._outputWrites(i.id, i.writes, !0);
    }
    if (Object.values(this.tasks).every((i) => i.writes.length > 0))
      return this.tick({ inputKeys: n });
    if (nh(this.checkpoint, this.interruptBefore, Object.values(this.tasks)))
      throw this.status = "interrupt_before", new ad();
    const r = await uo(ro(NP(this.step, Object.values(this.tasks)), "debug"));
    return this._emit(r), !0;
  }
  async finishAndHandleError(e) {
    const n = this._suppressInterrupt(e);
    if ((n || e === void 0) && (this.output = nu(this.channels, this.outputKeys)), n) {
      if (this.tasks !== void 0 && this.checkpointPendingWrites.length > 0 && Object.values(this.tasks).some((a) => a.writes.length > 0)) {
        const a = vn(this.checkpoint, this.channels, Object.values(this.tasks), this.checkpointerGetNextVersion);
        for (const [r, i] of Object.entries(a))
          await this.updateManagedValues(r, i);
        this._emit(Kl(ro(Pb(this.outputKeys, Object.values(this.tasks).flatMap((r) => r.writes), this.channels), "values")));
      }
      this._emit([
        [
          "updates",
          {
            [it]: e.interrupts
          }
        ]
      ]);
    }
    return n;
  }
  acceptPush(e, n, a) {
    if (this.interruptAfter?.length > 0 && nh(this.checkpoint, this.interruptAfter, [e])) {
      this.toInterrupt.push(e);
      return;
    }
    const r = Mg([Gt, e.path ?? [], n, e.id, a], this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.managed, e.config ?? {}, !0, {
      step: this.step,
      checkpointer: this.checkpointer,
      manager: this.manager,
      store: this.store
    });
    if (r) {
      if (this.interruptBefore?.length > 0 && nh(this.checkpoint, this.interruptBefore, [r])) {
        this.toInterrupt.push(r);
        return;
      }
      return this._emit(Kl(ro(NP(this.step, [r]), "debug"))), this.debug && cA(this.step, [r]), this.tasks[r.id] = r, this.skipDoneTasks && this._matchWrites({ [r.id]: r }), r;
    }
  }
  _suppressInterrupt(e) {
    return Zl(e) && !this.isNested;
  }
  async _first(e) {
    const { configurable: n } = this.config, a = n?.[Zo];
    if (a && a.nullResume !== void 0 && this.putWrites(Bn, [[zn, a.nullResume]]), Un(this.input)) {
      if (this.input.resume != null && this.checkpointer == null)
        throw new Error("Cannot use Command(resume=...) without checkpointer");
      const i = {};
      for (const [s, o, l] of hV(this.input, this.checkpointPendingWrites))
        i[s] === void 0 && (i[s] = []), i[s].push([o, l]);
      if (Object.keys(i).length === 0)
        throw new TP("Received empty Command input");
      for (const [s, o] of Object.entries(i))
        this.putWrites(s, o);
    }
    const r = (this.checkpointPendingWrites ?? []).filter((i) => i[0] === Bn).map((i) => i.slice(1));
    if (r.length > 0 && vn(this.checkpoint, this.channels, [
      {
        name: qs,
        writes: r,
        triggers: []
      }
    ], this.checkpointerGetNextVersion), this.isResuming) {
      for (const s of Object.keys(this.channels))
        if (this.checkpoint.channel_versions[s] !== void 0) {
          const o = this.checkpoint.channel_versions[s];
          this.checkpoint.versions_seen[it] = {
            ...this.checkpoint.versions_seen[it],
            [s]: o
          };
        }
      const i = await uo(ro(Pb(this.outputKeys, !0, this.channels), "values"));
      this._emit(i), this.input = $b;
    } else {
      const i = await uo(sA(e, this.input));
      if (i.length > 0) {
        const s = sd(this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.managed, this.config, !0, { step: this.step });
        vn(this.checkpoint, this.channels, Object.values(s).concat([
          {
            name: qs,
            writes: i,
            triggers: []
          }
        ]), this.checkpointerGetNextVersion), await this._putCheckpoint({
          source: "input",
          writes: Object.fromEntries(i)
        }), this.input = Tb;
      } else if (io in (this.config.configurable ?? {}))
        this.input = Tb;
      else
        throw new TP(`Received no input writes for ${JSON.stringify(e, null, 2)}`);
    }
    this.isNested || (this.config = Uo(this.config, {
      [io]: this.isResuming
    }));
  }
  _emit(e) {
    for (const n of e)
      this.stream.modes.has(n[0]) && this.stream.push([this.checkpointNamespace, ...n]);
  }
  async _putCheckpoint(e) {
    const n = {
      ...e,
      step: this.step,
      parents: this.config.configurable?.[Ln] ?? {}
    };
    if (this.checkpointer !== void 0) {
      this.prevCheckpointConfig = this.checkpointConfig?.configurable?.checkpoint_id ? this.checkpointConfig : void 0, this.checkpointMetadata = n, this.checkpoint = Do(this.checkpoint, this.channels, this.step), this.checkpointConfig = {
        ...this.checkpointConfig,
        configurable: {
          ...this.checkpointConfig.configurable,
          checkpoint_ns: this.config.configurable?.checkpoint_ns ?? ""
        }
      };
      const a = { ...this.checkpoint.channel_versions }, r = $g(this.checkpointPreviousVersions, a);
      this.checkpointPreviousVersions = a, this._checkpointerPutAfterPrevious({
        config: { ...this.checkpointConfig },
        checkpoint: up(this.checkpoint),
        metadata: { ...this.checkpointMetadata },
        newVersions: r
      }), this.checkpointConfig = {
        ...this.checkpointConfig,
        configurable: {
          ...this.checkpointConfig.configurable,
          checkpoint_id: this.checkpoint.id
        }
      };
    }
    this.step += 1;
  }
  _matchWrites(e) {
    for (const [n, a, r] of this.checkpointPendingWrites) {
      if (a === Rn || a === it || a === zn)
        continue;
      const i = Object.values(e).find((s) => s.id === n);
      i && i.writes.push([a, r]);
    }
    for (const n of Object.values(e))
      n.writes.length > 0 && this._outputWrites(n.id, n.writes, !0);
  }
}
function TV(t) {
  return an(t?.message);
}
class $V extends cc {
  constructor(e) {
    super(), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "StreamMessagesHandler"
    }), Object.defineProperty(this, "streamFn", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadatas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "seen", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "emittedChatModelRunIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "stableMessageIdMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "lc_prefer_streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.streamFn = e;
  }
  _emit(e, n, a, r = !1) {
    if (r && n.id !== void 0 && this.seen[n.id] !== void 0)
      return;
    let i = n.id;
    TI(n) ? i ??= `run-${a}-tool-${n.tool_call_id}` : ((i == null || i === `run-${a}`) && (i = this.stableMessageIdMap[a] ?? i ?? `run-${a}`), this.stableMessageIdMap[a] ??= i), i !== n.id && (n.id = i, n.lc_kwargs.id = i), n.id != null && (this.seen[n.id] = n), this.streamFn([e[0], "messages", [n, e[1]]]);
  }
  handleChatModelStart(e, n, a, r, i, s, o, l) {
    o && // Include legacy LangGraph SDK tag
    (!s || !s.includes(nV) && !s.includes("nostream")) && (this.metadatas[a] = [
      o.langgraph_checkpoint_ns.split("|"),
      { tags: s, name: l, ...o }
    ]);
  }
  handleLLMNewToken(e, n, a, r, i, s) {
    const o = s?.chunk;
    this.emittedChatModelRunIds[a] = !0, this.metadatas[a] !== void 0 && (TV(o) ? this._emit(this.metadatas[a], o.message, a) : this._emit(this.metadatas[a], new Ze({ content: e }), a));
  }
  handleLLMEnd(e, n) {
    if (!this.emittedChatModelRunIds[n]) {
      const a = e.generations?.[0]?.[0];
      an(a?.message) && this._emit(this.metadatas[n], a?.message, n, !0), delete this.emittedChatModelRunIds[n];
    }
    delete this.metadatas[n], delete this.stableMessageIdMap[n];
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  handleLLMError(e, n) {
    delete this.metadatas[n];
  }
  handleChainStart(e, n, a, r, i, s, o, l) {
    if (s !== void 0 && l === s.langgraph_node && (i === void 0 || !i.includes(lt)) && (this.metadatas[a] = [
      s.langgraph_checkpoint_ns.split("|"),
      { tags: i, name: l, ...s }
    ], typeof n == "object")) {
      for (const f of Object.values(n))
        if ((an(f) || Zb(f)) && f.id !== void 0)
          this.seen[f.id] = f;
        else if (Array.isArray(f))
          for (const u of f)
            (an(u) || Zb(u)) && u.id !== void 0 && (this.seen[u.id] = u);
    }
  }
  handleChainEnd(e, n) {
    const a = this.metadatas[n];
    if (delete this.metadatas[n], a !== void 0) {
      if (an(e))
        this._emit(a, e, n, !0);
      else if (Array.isArray(e))
        for (const r of e)
          an(r) && this._emit(a, r, n, !0);
      else if (e != null && typeof e == "object") {
        for (const r of Object.values(e))
          if (an(r))
            this._emit(a, r, n, !0);
          else if (Array.isArray(r))
            for (const i of r)
              an(i) && this._emit(a, i, n, !0);
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  handleChainError(e, n) {
    delete this.metadatas[n];
  }
}
const MV = 500, AV = 2, EV = 128e3, IV = 3, NV = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  409
  // Conflict
], kV = (t) => {
  if (t.message.startsWith("Cancel") || t.message.startsWith("AbortError") || t.name === "AbortError" || t?.code === "ECONNABORTED")
    return !1;
  const e = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    t?.response?.status ?? t?.status
  );
  return !(e && NV.includes(+e) || t?.error?.code === "insufficient_quota");
};
async function kP(t, e, n, a) {
  const r = t.retry_policy ?? e;
  let i = r !== void 0 ? r.initialInterval ?? MV : 0, s = 0, o, l, { config: f } = t;
  for (n && (f = Uo(f, n)); ; ) {
    t.writes.splice(0, t.writes.length), o = void 0;
    try {
      l = await t.proc.invoke(t.input, f);
      break;
    } catch (u) {
      if (o = u, o.pregelTaskId = t.id, V4(o)) {
        const d = f?.configurable?.checkpoint_ns, m = o.command;
        if (m.graph === d) {
          for (const b of t.writers)
            await b.invoke(m, f);
          o = void 0;
          break;
        } else if (m.graph === fr.PARENT) {
          const b = lV(d);
          o.command = new fr({
            ...o.command,
            graph: b
          });
        }
      }
      if (ph(o) || r === void 0 || (s += 1, s >= (r.maxAttempts ?? IV)) || !(r.retryOn ?? kV)(o))
        break;
      i = Math.min(r.maxInterval ?? EV, i * (r.backoffFactor ?? AV));
      const h = r.jitter ? Math.floor(i + Math.random() * 1e3) : i;
      await new Promise((d) => setTimeout(d, h));
      const p = o.name ?? // eslint-disable-next-line @typescript-eslint/no-explicit-any
      o.constructor.unminifiable_name ?? o.constructor.name;
      (r?.logWarning ?? !0) && console.log(`Retrying task "${String(t.name)}" after ${i.toFixed(2)}ms (attempt ${s}) after ${p}: ${o}`), f = Uo(f, { [io]: !0 });
    }
  }
  return {
    task: t,
    result: l,
    error: o
  };
}
class FV {
  /**
   * Construct a new PregelRunner, which executes tasks from the provided PregelLoop.
   * @param loop - The PregelLoop that produces tasks for this runner to execute.
   */
  constructor({ loop: e, nodeFinished: n }) {
    Object.defineProperty(this, "nodeFinished", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "loop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.loop = e, this.nodeFinished = n;
  }
  /**
   * Execute tasks from the current step of the PregelLoop.
   *
   * Note: this method does NOT call {@link PregelLoop}#tick. That must be handled externally.
   * @param options - Options for the execution.
   */
  async tick(e = {}) {
    const { timeout: n, signal: a, retryPolicy: r, onStepWrite: i, maxConcurrency: s } = e, o = /* @__PURE__ */ new Set();
    let l;
    const f = Object.values(this.loop.tasks).filter((c) => c.writes.length === 0), u = this._executeTasksWithRetry(f, {
      stepTimeout: n,
      signal: a,
      retryPolicy: r,
      maxConcurrency: s
    });
    for await (const { task: c, error: h } of u)
      this._commit(c, h), Zl(h) || ph(h) && !Zl(l) ? l = h : h && o.add(h);
    if (i?.(this.loop.step, Object.values(this.loop.tasks).map((c) => c.writes).flat()), o.size === 1)
      throw Array.from(o)[0];
    if (o.size > 1)
      throw new AggregateError(Array.from(o), `Multiple errors occurred during superstep ${this.loop.step}. See the "errors" field of this exception for more details.`);
    if (Zl(l) || ph(l) && this.loop.isNested)
      throw l;
  }
  /**
   * Concurrently executes tasks with the requested retry policy, yielding a {@link SettledPregelTask} for each task as it completes.
   * @param tasks - The tasks to execute.
   * @param options - Options for the execution.
   */
  async *_executeTasksWithRetry(e, n) {
    const { stepTimeout: a, retryPolicy: r, maxConcurrency: i } = n ?? {};
    let s = n?.signal;
    const o = Symbol.for("promiseAdded");
    let l, f;
    function u(g) {
      l = () => {
        f = new Promise(u), g(o);
      };
    }
    f = new Promise(u);
    const c = {};
    function h(g, _, P, { calls: C } = {}) {
      if (P.every(([O]) => O !== Gt))
        return _.config?.configurable?.[xs]?.(P) ?? [];
      const R = _.config?.configurable?.[Zo];
      if (!R)
        throw new Error(`BUG: No scratchpad found on task ${_.name}__${_.id}`);
      const T = {};
      for (const [O, A] of P.entries()) {
        const [M] = A;
        if (M !== Gt)
          continue;
        const I = C?.[O], N = R.callCounter;
        if (R.callCounter += 1, I == null)
          throw new Error("BUG: No call found");
        const w = g.loop.acceptPush(_, N, I);
        if (!w)
          continue;
        const k = c[w.id];
        if (k !== void 0)
          T[O] = k;
        else if (w.writes.length > 0) {
          const L = w.writes.filter(([V]) => V === Id), B = w.writes.filter(([V]) => V === Rn);
          if (L.length > 0)
            if (L.length === 1)
              T[O] = Promise.resolve(L[0][1]);
            else
              throw new Error(`BUG: multiple returns found for task ${w.name}__${w.id}`);
          else if (B.length > 0)
            if (B.length === 1) {
              const V = B[0][1], ce = (
                // eslint-disable-next-line no-instanceof/no-instanceof
                V instanceof Error ? V : new Error(String(V))
              );
              T[O] = Promise.reject(ce);
            } else
              throw new Error(`BUG: multiple errors found for task ${w.name}__${w.id}`);
        } else {
          const L = kP(w, r, {
            [xs]: h.bind(null, g, w),
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            [Pg]: p.bind(null, g, w)
          });
          c[w.id] = L, l(), T[O] = L.then(({ result: B, error: V }) => V ? Promise.reject(V) : B);
        }
      }
      return Object.values(T);
    }
    function p(g, _, P, C, R, T = {}) {
      const O = h(g, _, [[Gt, null]], {
        calls: [
          new yV({
            func: P,
            name: C,
            input: R,
            retry: T.retry,
            callbacks: T.callbacks
          })
        ]
      });
      return O !== void 0 ? O.length === 1 ? O[0] : Promise.all(O) : Promise.resolve();
    }
    if (a && s ? "any" in AbortSignal && (s = AbortSignal.any([
      s,
      AbortSignal.timeout(a)
    ])) : a && (s = AbortSignal.timeout(a)), s?.aborted)
      throw new Error("Abort");
    let d = 0, m;
    const b = new Promise((g, _) => {
      m = () => _(new Error("Abort")), s?.addEventListener("abort", m);
    }).finally(() => s?.removeEventListener("abort", m));
    for (; (d === 0 || Object.keys(c).length > 0) && e.length; ) {
      for (; Object.values(c).length < (i ?? e.length) && d < e.length; d += 1) {
        const _ = e[d];
        c[_.id] = kP(_, r, {
          [xs]: h?.bind(null, this, _),
          [Pg]: p?.bind(null, this, _)
        }).catch((P) => ({ task: _, error: P }));
      }
      const g = await Promise.race([
        ...Object.values(c),
        b,
        f
      ]);
      g !== o && (yield g, delete c[g.task.id]);
    }
  }
  /**
   * Determines what writes to apply based on whether the task completed successfully, and what type of error occurred.
   *
   * Throws an error if the error is a {@link GraphBubbleUp} error and {@link PregelLoop}#isNested is true.
   *
   * @param task - The task to commit.
   * @param error - The error that occurred, if any.
   */
  _commit(e, n) {
    if (n !== void 0)
      if (Zl(n)) {
        if (n.interrupts.length) {
          const a = n.interrupts.map((i) => [it, i]), r = e.writes.filter((i) => i[0] === zn);
          r.length && a.push(...r), this.loop.putWrites(e.id, a);
        }
      } else ph(n) && e.writes.length ? this.loop.putWrites(e.id, e.writes) : this.loop.putWrites(e.id, [
        [Rn, { message: n.message, name: n.name }]
      ]);
    else
      this.nodeFinished && (e.config?.tags == null || !e.config.tags.includes(lt)) && this.nodeFinished(String(e.name)), e.writes.length === 0 && e.writes.push([yy, null]), this.loop.putWrites(e.id, e.writes);
  }
}
function DV(t) {
  return typeof t == "string";
}
class qV {
  static subscribeTo(e, n) {
    const { key: a, tags: r } = {
      key: void 0,
      tags: void 0,
      ...n ?? {}
    };
    if (Array.isArray(e) && a !== void 0)
      throw new Error("Can't specify a key when subscribing to multiple channels");
    let i;
    DV(e) ? a ? i = { [a]: e } : i = [e] : i = Object.fromEntries(e.map((o) => [o, o]));
    const s = Array.isArray(e) ? e : [e];
    return new ua({
      channels: i,
      triggers: s,
      tags: r
    });
  }
  /**
   * Creates a ChannelWrite that specifies how to write values to channels.
   * This is used to define how nodes send output to channels.
   *
   * @example
   * ```typescript
   * // Write to multiple channels
   * const write = Channel.writeTo(["output", "state"]);
   *
   * // Write with specific values
   * const write = Channel.writeTo(["output"], {
   *   state: "completed",
   *   result: calculateResult()
   * });
   *
   * // Write with a transformation function
   * const write = Channel.writeTo(["output"], {
   *   result: (x) => processResult(x)
   * });
   * ```
   *
   * @param channels - Array of channel names to write to
   * @param writes - Optional map of channel names to values or transformations
   * @returns A ChannelWrite object that can be used to write to the specified channels
   */
  static writeTo(e, n) {
    const a = [];
    for (const r of e)
      a.push({
        channel: r,
        value: Ho,
        skipNone: !1
      });
    for (const [r, i] of Object.entries(n ?? {}))
      Te.isRunnable(i) || typeof i == "function" ? a.push({
        channel: r,
        value: Ho,
        skipNone: !0,
        mapper: Pn(i)
      }) : a.push({
        channel: r,
        value: i,
        skipNone: !1
      });
    return new Ct(a);
  }
}
class JV extends Te {
  /**
   * Name of the class when serialized
   * @internal
   */
  static lc_name() {
    return "LangGraph";
  }
  /**
   * Constructor for Pregel - meant for internal use only.
   *
   * @internal
   */
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langgraph", "pregel"]
    }), Object.defineProperty(this, "lg_is_pregel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "nodes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "channels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputChannels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputChannels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "autoValidate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "streamMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["values"]
    }), Object.defineProperty(this, "streamChannels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interruptAfter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interruptBefore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stepTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "debug", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "checkpointer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "retryPolicy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    let { streamMode: n } = e;
    n != null && !Array.isArray(n) && (n = [n]), this.nodes = e.nodes, this.channels = e.channels, this.autoValidate = e.autoValidate ?? this.autoValidate, this.streamMode = n ?? this.streamMode, this.inputChannels = e.inputChannels, this.outputChannels = e.outputChannels, this.streamChannels = e.streamChannels ?? this.streamChannels, this.interruptAfter = e.interruptAfter, this.interruptBefore = e.interruptBefore, this.stepTimeout = e.stepTimeout ?? this.stepTimeout, this.debug = e.debug ?? this.debug, this.checkpointer = e.checkpointer, this.retryPolicy = e.retryPolicy, this.config = e.config, this.store = e.store, this.name = e.name, this.autoValidate && this.validate();
  }
  /**
   * Creates a new instance of the Pregel graph with updated configuration.
   * This method follows the immutable pattern - instead of modifying the current instance,
   * it returns a new instance with the merged configuration.
   *
   * @example
   * ```typescript
   * // Create a new instance with debug enabled
   * const debugGraph = graph.withConfig({ debug: true });
   *
   * // Create a new instance with a specific thread ID
   * const threadGraph = graph.withConfig({
   *   configurable: { thread_id: "123" }
   * });
   * ```
   *
   * @param config - The configuration to merge with the current configuration
   * @returns A new Pregel instance with the merged configuration
   */
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore Remove ignore when we remove support for 0.2 versions of core
  withConfig(e) {
    const n = oa(this.config, e);
    return new this.constructor({ ...this, config: n });
  }
  /**
   * Validates the graph structure to ensure it is well-formed.
   * Checks for:
   * - No orphaned nodes
   * - Valid input/output channel configurations
   * - Valid interrupt configurations
   *
   * @returns this - The Pregel instance for method chaining
   * @throws {GraphValidationError} If the graph structure is invalid
   */
  validate() {
    return fV({
      nodes: this.nodes,
      channels: this.channels,
      outputChannels: this.outputChannels,
      inputChannels: this.inputChannels,
      streamChannels: this.streamChannels,
      interruptAfterNodes: this.interruptAfter,
      interruptBeforeNodes: this.interruptBefore
    }), this;
  }
  /**
   * Gets a list of all channels that should be streamed.
   * If streamChannels is specified, returns those channels.
   * Otherwise, returns all channels in the graph.
   *
   * @returns Array of channel keys to stream
   */
  get streamChannelsList() {
    return Array.isArray(this.streamChannels) ? this.streamChannels : this.streamChannels ? [this.streamChannels] : Object.keys(this.channels);
  }
  /**
   * Gets the channels to stream in their original format.
   * If streamChannels is specified, returns it as-is (either single key or array).
   * Otherwise, returns all channels in the graph as an array.
   *
   * @returns Channel keys to stream, either as a single key or array
   */
  get streamChannelsAsIs() {
    return this.streamChannels ? this.streamChannels : Object.keys(this.channels);
  }
  /**
   * Gets a drawable representation of the graph structure.
   * This is an async version of getGraph() and is the preferred method to use.
   *
   * @param config - Configuration for generating the graph visualization
   * @returns A representation of the graph that can be visualized
   */
  async getGraphAsync(e) {
    return this.getGraph(e);
  }
  /**
   * Gets all subgraphs within this graph.
   * A subgraph is a Pregel instance that is nested within a node of this graph.
   *
   * @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release.
   * @param namespace - Optional namespace to filter subgraphs
   * @param recurse - Whether to recursively get subgraphs of subgraphs
   * @returns Generator yielding tuples of [name, subgraph]
   */
  *getSubgraphs(e, n) {
    for (const [a, r] of Object.entries(this.nodes)) {
      if (e !== void 0 && !e.startsWith(a))
        continue;
      const i = r.subgraphs?.length ? r.subgraphs : [r.bound];
      for (const s of i) {
        const o = oA(s);
        if (o !== void 0) {
          if (a === e) {
            yield [a, o];
            return;
          }
          if (e === void 0 && (yield [a, o]), n) {
            let l = e;
            e !== void 0 && (l = e.slice(a.length + 1));
            for (const [f, u] of o.getSubgraphs(l, n))
              yield [
                `${a}${sn}${f}`,
                u
              ];
          }
        }
      }
    }
  }
  /**
   * Gets all subgraphs within this graph asynchronously.
   * A subgraph is a Pregel instance that is nested within a node of this graph.
   *
   * @param namespace - Optional namespace to filter subgraphs
   * @param recurse - Whether to recursively get subgraphs of subgraphs
   * @returns AsyncGenerator yielding tuples of [name, subgraph]
   */
  async *getSubgraphsAsync(e, n) {
    yield* this.getSubgraphs(e, n);
  }
  /**
   * Prepares a state snapshot from saved checkpoint data.
   * This is an internal method used by getState and getStateHistory.
   *
   * @param config - Configuration for preparing the snapshot
   * @param saved - Optional saved checkpoint data
   * @param subgraphCheckpointer - Optional checkpointer for subgraphs
   * @param applyPendingWrites - Whether to apply pending writes to tasks and then to channels
   * @returns A snapshot of the graph state
   * @internal
   */
  async _prepareStateSnapshot({ config: e, saved: n, subgraphCheckpointer: a, applyPendingWrites: r = !1 }) {
    if (n === void 0)
      return {
        values: {},
        next: [],
        config: e,
        tasks: []
      };
    const { managed: i } = await this.prepareSpecs(e, {
      skipManaged: !0
    }), s = cp(this.channels, n.checkpoint);
    if (n.pendingWrites?.length) {
      const p = n.pendingWrites.filter(([d, m]) => d === Bn).map(([d, m, b]) => [String(m), b]);
      p.length > 0 && vn(n.checkpoint, s, [
        {
          name: qs,
          writes: p,
          triggers: []
        }
      ]);
    }
    const o = Object.values(sd(n.checkpoint, n.pendingWrites, this.nodes, s, i, n.config, !0, { step: (n.metadata?.step ?? -1) + 1, store: this.store })), l = await uo(this.getSubgraphsAsync()), f = n.config.configurable?.checkpoint_ns ?? "", u = {};
    for (const p of o) {
      const d = l.find(([b]) => b === p.name);
      if (!d)
        continue;
      let m = `${String(p.name)}${Ko}${p.id}`;
      if (f && (m = `${f}${sn}${m}`), a === void 0) {
        const b = {
          configurable: {
            thread_id: n.config.configurable?.thread_id,
            checkpoint_ns: m
          }
        };
        u[p.id] = b;
      } else {
        const b = {
          configurable: {
            [_t]: a,
            thread_id: n.config.configurable?.thread_id,
            checkpoint_ns: m
          }
        }, g = d[1];
        u[p.id] = await g.getState(b, {
          subgraphs: !0
        });
      }
    }
    if (r && n.pendingWrites?.length) {
      const p = Object.fromEntries(o.map((m) => [m.id, m]));
      for (const [m, b, g] of n.pendingWrites)
        [Rn, it, mh].includes(b) || m in p && p[m].writes.push([String(b), g]);
      const d = o.filter((m) => m.writes.length > 0);
      d.length > 0 && vn(n.checkpoint, s, d);
    }
    let c = n?.metadata;
    c && n?.config?.configurable?.thread_id && (c = {
      ...c,
      thread_id: n.config.configurable.thread_id
    });
    const h = o.filter((p) => p.writes.length === 0).map((p) => p.name);
    return {
      values: nu(s, this.streamChannelsAsIs),
      next: h,
      tasks: uA(o, n?.pendingWrites ?? [], u),
      metadata: c,
      config: Pu(n.config, n.metadata),
      createdAt: n.checkpoint.ts,
      parentConfig: n.parentConfig
    };
  }
  /**
   * Gets the current state of the graph.
   * Requires a checkpointer to be configured.
   *
   * @param config - Configuration for retrieving the state
   * @param options - Additional options
   * @returns A snapshot of the current graph state
   * @throws {GraphValueError} If no checkpointer is configured
   */
  async getState(e, n) {
    const a = e.configurable?.[_t] ?? this.checkpointer;
    if (!a)
      throw new CP("No checkpointer set");
    const r = e.configurable?.checkpoint_ns ?? "";
    if (r !== "" && e.configurable?.[_t] === void 0) {
      const l = Sb(r);
      for await (const [f, u] of this.getSubgraphsAsync(l, !0))
        if (f === l)
          return await u.getState(Nl(e, {
            [_t]: a
          }), { subgraphs: n?.subgraphs });
      throw new Error(`Subgraph with namespace "${l}" not found.`);
    }
    const i = oa(this.config, e), s = await a.getTuple(e);
    return await this._prepareStateSnapshot({
      config: i,
      saved: s,
      subgraphCheckpointer: n?.subgraphs ? a : void 0,
      applyPendingWrites: !e.configurable?.checkpoint_id
    });
  }
  /**
   * Gets the history of graph states.
   * Requires a checkpointer to be configured.
   * Useful for:
   * - Debugging execution history
   * - Implementing time travel
   * - Analyzing graph behavior
   *
   * @param config - Configuration for retrieving the history
   * @param options - Options for filtering the history
   * @returns An async iterator of state snapshots
   * @throws {Error} If no checkpointer is configured
   */
  async *getStateHistory(e, n) {
    const a = e.configurable?.[_t] ?? this.checkpointer;
    if (!a)
      throw new Error("No checkpointer set");
    const r = e.configurable?.checkpoint_ns ?? "";
    if (r !== "" && e.configurable?.[_t] === void 0) {
      const s = Sb(r);
      for await (const [o, l] of this.getSubgraphsAsync(s, !0))
        if (o === s) {
          yield* l.getStateHistory(Nl(e, {
            [_t]: a
          }), n);
          return;
        }
      throw new Error(`Subgraph with namespace "${s}" not found.`);
    }
    const i = oa(this.config, e, {
      configurable: { checkpoint_ns: r }
    });
    for await (const s of a.list(i, n))
      yield this._prepareStateSnapshot({
        config: s.config,
        saved: s
      });
  }
  /**
   * Apply updates to the graph state in bulk.
   * Requires a checkpointer to be configured.
   *
   * This method is useful for recreating a thread
   * from a list of updates, especially if a checkpoint
   * is created as a result of multiple tasks.
   *
   * @internal The API might change in the future.
   *
   * @param startConfig - Configuration for the update
   * @param updates - The list of updates to apply to graph state
   * @returns Updated configuration
   * @throws {GraphValueError} If no checkpointer is configured
   * @throws {InvalidUpdateError} If the update cannot be attributed to a node or an update can be only applied in sequence.
   */
  async bulkUpdateState(e, n) {
    const a = e.configurable?.[_t] ?? this.checkpointer;
    if (!a)
      throw new CP("No checkpointer set");
    if (n.length === 0)
      throw new Error("No supersteps provided");
    if (n.some((o) => o.updates.length === 0))
      throw new Error("No updates provided");
    const r = e.configurable?.checkpoint_ns ?? "";
    if (r !== "" && e.configurable?.[_t] === void 0) {
      const o = Sb(r);
      for await (const [, l] of this.getSubgraphsAsync(o, !0))
        return await l.bulkUpdateState(Nl(e, {
          [_t]: a
        }), n);
      throw new Error(`Subgraph "${o}" not found`);
    }
    const i = async (o, l) => {
      const f = this.config ? oa(this.config, o) : o, u = await a.getTuple(f), c = u !== void 0 ? up(u.checkpoint) : rA(), h = {
        ...u?.checkpoint.channel_versions
      }, p = u?.metadata?.step ?? -1;
      let d = Nl(f, {
        checkpoint_ns: f.configurable?.checkpoint_ns ?? ""
      }), m = f.metadata ?? {};
      u?.config.configurable && (d = Nl(f, u.config.configurable), m = {
        ...u.metadata,
        ...m
      });
      const { values: b, asNode: g } = l[0];
      if (b == null && g === void 0) {
        if (l.length > 1)
          throw new rt("Cannot create empty checkpoint with multiple updates");
        const M = await a.put(d, Do(c, void 0, p), {
          source: "update",
          step: p + 1,
          writes: {},
          parents: u?.metadata?.parents ?? {}
        }, {});
        return Pu(M, u ? u.metadata : void 0);
      }
      const _ = cp(this.channels, c), { managed: P } = await this.prepareSpecs(f, {
        skipManaged: !0
      });
      if (b === null && g === Me) {
        if (l.length > 1)
          throw new rt("Cannot apply multiple updates when clearing state");
        if (u) {
          const I = sd(c, u.pendingWrites || [], this.nodes, _, P, u.config, !0, {
            step: (u.metadata?.step ?? -1) + 1,
            checkpointer: this.checkpointer || void 0,
            store: this.store
          }), N = (u.pendingWrites || []).filter((w) => w[0] === Bn).map((w) => w.slice(1));
          N.length > 0 && vn(u.checkpoint, _, [
            {
              name: qs,
              writes: N,
              triggers: []
            }
          ]);
          for (const [w, k, L] of u.pendingWrites || [])
            [Rn, it, mh].includes(k) || w in I && I[w].writes.push([k, L]);
          vn(c, _, Object.values(I));
        }
        const M = await a.put(d, Do(c, void 0, p), {
          ...m,
          source: "update",
          step: p + 1,
          writes: {},
          parents: u?.metadata?.parents ?? {}
        }, {});
        return Pu(M, u ? u.metadata : void 0);
      }
      if (b == null && g === Q4) {
        if (l.length > 1)
          throw new rt("Cannot copy checkpoint with multiple updates");
        const M = await a.put(u?.parentConfig ?? d, Do(c, void 0, p), {
          source: "fork",
          step: p + 1,
          writes: {},
          parents: u?.metadata?.parents ?? {}
        }, {});
        return Pu(M, u ? u.metadata : void 0);
      }
      if (g === qs) {
        if (l.length > 1)
          throw new rt("Cannot apply multiple updates when updating as input");
        const M = await uo(sA(this.inputChannels, b));
        if (M.length === 0)
          throw new rt(`Received no input writes for ${JSON.stringify(this.inputChannels, null, 2)}`);
        vn(c, _, [
          {
            name: qs,
            writes: M,
            triggers: []
          }
        ], a.getNextVersion.bind(this.checkpointer));
        const I = u?.metadata?.step != null ? u.metadata.step + 1 : -1, N = await a.put(d, Do(c, _, I), {
          source: "input",
          step: I,
          writes: Object.fromEntries(M),
          parents: u?.metadata?.parents ?? {}
        }, $g(h, c.channel_versions));
        return await a.putWrites(N, M, Ju(qs, c.id)), Pu(N, u ? u.metadata : void 0);
      }
      if (f.configurable?.checkpoint_id === void 0 && u?.pendingWrites !== void 0 && u.pendingWrites.length > 0) {
        const M = sd(c, u.pendingWrites, this.nodes, _, P, u.config, !0, {
          store: this.store,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          checkpointer: this.checkpointer,
          step: (u.metadata?.step ?? -1) + 1
        }), I = (u.pendingWrites ?? []).filter((w) => w[0] === Bn).map((w) => w.slice(1));
        I.length > 0 && vn(u.checkpoint, _, [
          {
            name: qs,
            writes: I,
            triggers: []
          }
        ]);
        for (const [w, k, L] of u.pendingWrites)
          [Rn, it, mh].includes(k) || M[w] === void 0 || M[w].writes.push([k, L]);
        const N = Object.values(M).filter((w) => w.writes.length > 0);
        N.length > 0 && vn(c, _, N);
      }
      const C = Object.values(c.versions_seen).map((M) => Object.values(M)).flat().find((M) => !!M), R = [];
      if (l.length === 1) {
        let { values: M, asNode: I } = l[0];
        if (I === void 0 && C === void 0)
          typeof this.inputChannels == "string" && this.nodes[this.inputChannels] !== void 0 && (I = this.inputChannels);
        else if (I === void 0) {
          const N = Object.entries(c.versions_seen).map(([w, k]) => Object.values(k).map((L) => [L, w])).flat().sort(([w], [k]) => aA(w, k));
          N && (N.length === 1 ? I = N[0][1] : N[N.length - 1][0] !== N[N.length - 2][0] && (I = N[N.length - 1][1]));
        }
        if (I === void 0)
          throw new rt('Ambiguous update, specify "asNode"');
        R.push({ values: M, asNode: I });
      } else
        for (const { asNode: M, values: I } of l) {
          if (M == null)
            throw new rt('"asNode" is required when applying multiple updates');
          R.push({ values: I, asNode: M });
        }
      const T = [];
      for (const { asNode: M, values: I } of R) {
        if (this.nodes[M] === void 0)
          throw new rt(`Node "${M.toString()}" does not exist`);
        const N = this.nodes[M].getWriters();
        if (!N.length)
          throw new rt(`No writers found for node "${M.toString()}"`);
        T.push({
          name: M,
          input: I,
          proc: N.length > 1 ? (
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            dt.from(N, {
              omitSequenceTags: !0
            })
          ) : N[0],
          writes: [],
          triggers: [it],
          id: Ju(it, c.id),
          writers: []
        });
      }
      for (const M of T)
        await M.proc.invoke(M.input, Ye({
          ...f,
          store: f?.store ?? this.store
        }, {
          runName: f.runName ?? `${this.getName()}UpdateState`,
          configurable: {
            [xs]: (I) => M.writes.push(...I),
            [zo]: (I, N = !1) => yh(
              p,
              c,
              _,
              P,
              // TODO: Why does keyof StrRecord allow number and symbol?
              M,
              I,
              N
            )
          }
        }));
      for (const M of T) {
        const I = M.writes.filter((N) => N[0] !== Gt);
        u !== void 0 && I.length > 0 && await a.putWrites(d, I, M.id);
      }
      vn(c, _, T, a.getNextVersion.bind(this.checkpointer));
      const O = $g(h, c.channel_versions), A = await a.put(d, Do(c, _, p + 1), {
        source: "update",
        step: p + 1,
        writes: Object.fromEntries(R.map((M) => [M.asNode, M.values])),
        parents: u?.metadata?.parents ?? {}
      }, O);
      for (const M of T) {
        const I = M.writes.filter((N) => N[0] === Gt);
        I.length > 0 && await a.putWrites(A, I, M.id);
      }
      return Pu(A, u ? u.metadata : void 0);
    };
    let s = e;
    for (const { updates: o } of n)
      s = await i(s, o);
    return s;
  }
  /**
   * Updates the state of the graph with new values.
   * Requires a checkpointer to be configured.
   *
   * This method can be used for:
   * - Implementing human-in-the-loop workflows
   * - Modifying graph state during breakpoints
   * - Integrating external inputs into the graph
   *
   * @param inputConfig - Configuration for the update
   * @param values - The values to update the state with
   * @param asNode - Optional node name to attribute the update to
   * @returns Updated configuration
   * @throws {GraphValueError} If no checkpointer is configured
   * @throws {InvalidUpdateError} If the update cannot be attributed to a node
   */
  async updateState(e, n, a) {
    return this.bulkUpdateState(e, [
      { updates: [{ values: n, asNode: a }] }
    ]);
  }
  /**
   * Gets the default values for various graph configuration options.
   * This is an internal method used to process and normalize configuration options.
   *
   * @param config - The input configuration options
   * @returns A tuple containing normalized values for:
   * - debug mode
   * - stream modes
   * - input keys
   * - output keys
   * - remaining config
   * - interrupt before nodes
   * - interrupt after nodes
   * - checkpointer
   * - store
   * - whether stream mode is single
   * @internal
   */
  _defaults(e) {
    const { debug: n, streamMode: a, inputKeys: r, outputKeys: i, interruptAfter: s, interruptBefore: o, ...l } = e;
    let f = !0;
    const u = n !== void 0 ? n : this.debug;
    let c = i;
    c === void 0 ? c = this.streamChannelsAsIs : EP(c, this.channels);
    let h = r;
    h === void 0 ? h = this.inputChannels : EP(h, this.channels);
    const p = o ?? this.interruptBefore ?? [], d = s ?? this.interruptAfter ?? [];
    let m;
    a !== void 0 ? (m = Array.isArray(a) ? a : [a], f = typeof a == "string") : (m = this.streamMode, f = !0), e.configurable?.[id] !== void 0 && (m = ["values"]);
    let b;
    this.checkpointer === !1 ? b = void 0 : e !== void 0 && e.configurable?.[_t] !== void 0 ? b = e.configurable[_t] : b = this.checkpointer;
    const g = e.store ?? this.store;
    return [
      u,
      m,
      h,
      c,
      l,
      p,
      d,
      b,
      g,
      f
    ];
  }
  /**
   * Streams the execution of the graph, emitting state updates as they occur.
   * This is the primary method for observing graph execution in real-time.
   *
   * Stream modes:
   * - "values": Emits complete state after each step
   * - "updates": Emits only state changes after each step
   * - "debug": Emits detailed debug information
   * - "messages": Emits messages from within nodes
   *
   * For more details, see the [Streaming how-to guides](../../how-tos/#streaming_1).
   *
   * @param input - The input to start graph execution with
   * @param options - Configuration options for streaming
   * @returns An async iterable stream of graph state updates
   */
  async stream(e, n) {
    const a = {
      recursionLimit: this.config?.recursionLimit,
      ...n
    };
    return super.stream(e, a);
  }
  streamEvents(e, n, a) {
    const r = {
      recursionLimit: this.config?.recursionLimit,
      callbacks: this.config?.callbacks,
      ...n
    };
    return super.streamEvents(e, r, a);
  }
  /**
   * Prepares channel specifications and managed values for graph execution.
   * This is an internal method used to set up the graph's communication channels
   * and managed state before execution.
   *
   * @param config - Configuration for preparing specs
   * @param options - Additional options
   * @param options.skipManaged - Whether to skip initialization of managed values
   * @returns Object containing channel specs and managed value mapping
   * @internal
   */
  async prepareSpecs(e, n) {
    const a = {
      ...e,
      store: this.store
    }, r = {}, i = {};
    for (const [o, l] of Object.entries(this.channels))
      em(l) ? r[o] = l : n?.skipManaged ? i[o] = {
        cls: vy,
        params: { config: {} }
      } : i[o] = l;
    const s = new sV(await Object.entries(i).reduce(async (o, [l, f]) => {
      const u = await o;
      let c;
      return wy(f) ? ("key" in f.params && f.params.key === iV && (f.params.key = l), c = await f.cls.initialize(a, f.params)) : c = await f.initialize(a), c !== void 0 && u.push([l, c]), u;
    }, Promise.resolve([])));
    return {
      channelSpecs: r,
      managed: s
    };
  }
  /**
   * Validates the input for the graph.
   * @param input - The input to validate
   * @returns The validated input
   * @internal
   */
  async _validateInput(e) {
    return e;
  }
  /**
   * Validates the configurable options for the graph.
   * @param config - The configurable options to validate
   * @returns The validated configurable options
   * @internal
   */
  async _validateConfigurable(e) {
    return e;
  }
  /**
   * Internal iterator used by stream() to generate state updates.
   * This method handles the core logic of graph execution and streaming.
   *
   * @param input - The input to start graph execution with
   * @param options - Configuration options for streaming
   * @returns AsyncGenerator yielding state updates
   * @internal
   */
  async *_streamIterator(e, n) {
    const a = n?.subgraphs, r = iA(this.config, n);
    if (r.recursionLimit === void 0 || r.recursionLimit < 1)
      throw new Error('Passed "recursionLimit" must be at least 1.');
    if (this.checkpointer !== void 0 && this.checkpointer !== !1 && r.configurable === void 0)
      throw new Error('Checkpointer requires one or more of the following "configurable" keys: "thread_id", "checkpoint_ns", "checkpoint_id"');
    const i = await this._validateInput(e), { runId: s, ...o } = r, [l, f, , u, c, h, p, d, m, b] = this._defaults(o);
    c.configurable = await this._validateConfigurable(c.configurable);
    const g = new dA({
      modes: new Set(f)
    });
    if (f.includes("messages")) {
      const I = new $V((w) => g.push(w)), { callbacks: N } = c;
      if (N === void 0)
        c.callbacks = [I];
      else if (Array.isArray(N))
        c.callbacks = N.concat(I);
      else {
        const w = N.copy();
        w.addHandler(I, !0), c.callbacks = w;
      }
    }
    f.includes("custom") && (c.writer = (I) => g.push([[], "custom", I]));
    const P = await (await Vn(c))?.handleChainStart(
      this.toJSON(),
      // chain
      vV(e, "input"),
      // inputs
      s,
      // run_id
      void 0,
      // run_type
      void 0,
      // tags
      void 0,
      // metadata
      c?.runName ?? this.getName()
      // run_name
    ), { channelSpecs: C, managed: R } = await this.prepareSpecs(c);
    let T, O;
    const M = (async () => {
      try {
        T = await jy.initialize({
          input: i,
          config: c,
          checkpointer: d,
          nodes: this.nodes,
          channelSpecs: C,
          managed: R,
          outputKeys: u,
          streamKeys: this.streamChannelsAsIs,
          store: m,
          stream: g,
          interruptAfter: p,
          interruptBefore: h,
          manager: P,
          debug: this.debug
        });
        const I = new FV({
          loop: T,
          nodeFinished: c.configurable?.[tV]
        });
        n?.subgraphs && (T.config.configurable = {
          ...T.config.configurable,
          [lp]: T.stream
        }), await this._runLoop({ loop: T, runner: I, debug: l, config: c });
      } catch (I) {
        O = I;
      } finally {
        try {
          T && await T.store?.stop(), await Promise.all([
            ...T?.checkpointerPromises ?? [],
            ...Array.from(R.values()).map((I) => I.promises())
          ]);
        } catch (I) {
          O = O ?? I;
        }
        O ? g.error(O) : g.close();
      }
    })();
    try {
      for await (const I of g) {
        if (I === void 0)
          throw new Error("Data structure error.");
        const [N, w, k] = I;
        f.includes(w) && (a && !b ? yield [N, w, k] : b ? a ? yield [N, k] : yield k : yield [w, k]);
      }
    } catch (I) {
      throw await P?.handleChainError(O), I;
    } finally {
      await M;
    }
    await P?.handleChainEnd(
      T?.output ?? {},
      s,
      // run_id
      void 0,
      // run_type
      void 0,
      // tags
      void 0
      // metadata
    );
  }
  /**
   * Run the graph with a single input and config.
   * @param input The input to the graph.
   * @param options The configuration to use for the run.
   */
  async invoke(e, n) {
    const a = n?.streamMode ?? "values", r = {
      ...n,
      outputKeys: n?.outputKeys ?? this.outputChannels,
      streamMode: a
    }, i = [], s = await this.stream(e, r);
    for await (const o of s)
      i.push(o);
    return a === "values" ? i[i.length - 1] : i;
  }
  async _runLoop(e) {
    const { loop: n, runner: a, debug: r, config: i } = e;
    let s;
    try {
      for (; await n.tick({
        inputKeys: this.inputChannels
      }); )
        r && gV(n.checkpointMetadata.step, n.channels, this.streamChannelsList), r && cA(n.step, Object.values(n.tasks)), await a.tick({
          timeout: this.stepTimeout,
          retryPolicy: this.retryPolicy,
          onStepWrite: (o, l) => {
            r && _V(o, l, this.streamChannelsList);
          },
          maxConcurrency: i.maxConcurrency,
          signal: i.signal
        });
      if (n.status === "out_of_steps")
        throw new x4([
          `Recursion limit of ${i.recursionLimit} reached`,
          "without hitting a stop condition. You can increase the",
          'limit by setting the "recursionLimit" config key.'
        ].join(" "), {
          lc_error_code: "GRAPH_RECURSION_LIMIT"
        });
    } catch (o) {
      if (s = o, !await n.finishAndHandleError(s))
        throw o;
    } finally {
      s === void 0 && await n.finishAndHandleError();
    }
  }
}
class fa extends tm {
  constructor(e = !0) {
    super(), Object.defineProperty(this, "lc_graph_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EphemeralValue"
    }), Object.defineProperty(this, "guard", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this.guard = e;
  }
  fromCheckpoint(e) {
    const n = new fa(this.guard);
    return e && (n.value = [e]), n;
  }
  update(e) {
    if (e.length === 0) {
      const n = this.value.length > 0;
      return this.value = [], n;
    }
    if (e.length !== 1 && this.guard)
      throw new rt("EphemeralValue can only receive one value per step.");
    return this.value = [e[e.length - 1]], !0;
  }
  get() {
    if (this.value.length === 0)
      throw new un();
    return this.value[0];
  }
  checkpoint() {
    if (this.value.length === 0)
      throw new un();
    return this.value[0];
  }
}
class fA {
  constructor(e) {
    Object.defineProperty(this, "condition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ends", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Te.isRunnable(e.path) ? this.condition = e.path : this.condition = Pn(e.path).withConfig({
      runName: "Branch"
    }), this.ends = Array.isArray(e.pathMap) ? e.pathMap.reduce((n, a) => (n[a] = a, n), {}) : e.pathMap;
  }
  run(e, n) {
    return Ct.registerWriter(new cu({
      name: "<branch_run>",
      trace: !1,
      func: async (a, r) => {
        try {
          return await this._route(a, r, e, n);
        } catch (i) {
          throw i.name === eA.unminifiable_name && console.warn(`[WARN]: 'NodeInterrupt' thrown in conditional edge. This is likely a bug in your graph implementation.
NodeInterrupt should only be thrown inside a node, not in edge conditions.`), i;
        }
      }
    }));
  }
  async _route(e, n, a, r) {
    let i = await this.condition.invoke(r ? r(n) : e, n);
    Array.isArray(i) || (i = [i]);
    let s;
    if (this.ends ? s = i.map((l) => Tn(l) ? l : this.ends[l]) : s = i, s.some((l) => !l))
      throw new Error("Branch condition returned unknown or null destination");
    if (s.filter(Tn).some((l) => l.node === Me))
      throw new rt("Cannot send a packet to the END node");
    return await a(s, n) ?? e;
  }
}
class LV {
  constructor() {
    Object.defineProperty(this, "nodes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "edges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "branches", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "entryPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "compiled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.nodes = {}, this.edges = /* @__PURE__ */ new Set(), this.branches = {};
  }
  warnIfCompiled(e) {
    this.compiled && console.warn(e);
  }
  get allEdges() {
    return this.edges;
  }
  addNode(e, n, a) {
    for (const i of [
      sn,
      Ko
    ])
      if (e.includes(i))
        throw new Error(`"${i}" is a reserved character and is not allowed in node names.`);
    if (this.warnIfCompiled("Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph."), e in this.nodes)
      throw new Error(`Node \`${e}\` already present.`);
    if (e === Me)
      throw new Error(`Node \`${e}\` is reserved.`);
    const r = Pn(
      // Account for arbitrary state due to Send API
      n
    );
    return this.nodes[e] = {
      runnable: r,
      metadata: a?.metadata,
      subgraphs: Oy(r) ? [r] : a?.subgraphs,
      ends: a?.ends
    }, this;
  }
  addEdge(e, n) {
    if (this.warnIfCompiled("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph."), e === Me)
      throw new Error("END cannot be a start node");
    if (n === Ge)
      throw new Error("START cannot be an end node");
    if (Array.from(this.edges).some(([a]) => a === e) && !("channels" in this))
      throw new Error(`Already found path for ${e}. For multiple edges, use StateGraph.`);
    return this.edges.add([e, n]), this;
  }
  addConditionalEdges(e, n, a) {
    const r = typeof e == "object" ? e : {
      source: e,
      path: n,
      pathMap: a
    };
    if (this.warnIfCompiled("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph."), !Te.isRunnable(r.path)) {
      const s = Array.isArray(r.pathMap) ? r.pathMap.join(",") : Object.keys(r.pathMap ?? {}).join(",");
      r.path = Pn(r.path).withConfig({
        runName: `Branch<${r.source}${s !== "" ? `,${s}` : ""}>`.slice(0, 63)
      });
    }
    const i = r.path.getName() === "RunnableLambda" ? "condition" : r.path.getName();
    if (this.branches[r.source] && this.branches[r.source][i])
      throw new Error(`Condition \`${i}\` already present for node \`${e}\``);
    return this.branches[r.source] || (this.branches[r.source] = {}), this.branches[r.source][i] = new fA(r), this;
  }
  /**
   * @deprecated use `addEdge(START, key)` instead
   */
  setEntryPoint(e) {
    return this.warnIfCompiled("Setting the entry point of a graph that has already been compiled. This will not be reflected in the compiled graph."), this.addEdge(Ge, e);
  }
  /**
   * @deprecated use `addEdge(key, END)` instead
   */
  setFinishPoint(e) {
    return this.warnIfCompiled("Setting a finish point of a graph that has already been compiled. This will not be reflected in the compiled graph."), this.addEdge(e, Me);
  }
  compile({ checkpointer: e, interruptBefore: n, interruptAfter: a, name: r } = {}) {
    this.validate([
      ...Array.isArray(n) ? n : [],
      ...Array.isArray(a) ? a : []
    ]);
    const i = new hA({
      builder: this,
      checkpointer: e,
      interruptAfter: a,
      interruptBefore: n,
      autoValidate: !1,
      nodes: {},
      channels: {
        [Ge]: new fa(),
        [Me]: new fa()
      },
      inputChannels: Ge,
      outputChannels: Me,
      streamChannels: [],
      streamMode: "values",
      name: r
    });
    for (const [s, o] of Object.entries(this.nodes))
      i.attachNode(s, o);
    for (const [s, o] of this.edges)
      i.attachEdge(s, o);
    for (const [s, o] of Object.entries(this.branches))
      for (const [l, f] of Object.entries(o))
        i.attachBranch(s, l, f);
    return i.validate();
  }
  validate(e) {
    const n = new Set([...this.allEdges].map(([r, i]) => r));
    for (const [r] of Object.entries(this.branches))
      n.add(r);
    for (const r of n)
      if (r !== Ge && !(r in this.nodes))
        throw new Error(`Found edge starting at unknown node \`${r}\``);
    const a = new Set([...this.allEdges].map(([r, i]) => i));
    for (const [r, i] of Object.entries(this.branches))
      for (const s of Object.values(i))
        if (s.ends)
          for (const o of Object.values(s.ends))
            a.add(o);
        else {
          a.add(Me);
          for (const o of Object.keys(this.nodes))
            o !== r && a.add(o);
        }
    for (const r of Object.values(this.nodes))
      for (const i of r.ends ?? [])
        a.add(i);
    for (const r of Object.keys(this.nodes))
      if (!a.has(r))
        throw new z4([
          `Node \`${r}\` is not reachable.`,
          "",
          "If you are returning Command objects from your node,",
          'make sure you are passing names of potential destination nodes as an "ends" array',
          'into ".addNode(..., { ends: ["node1", "node2"] })".'
        ].join(`
`), {
          lc_error_code: "UNREACHABLE_NODE"
        });
    for (const r of a)
      if (r !== Me && !(r in this.nodes))
        throw new Error(`Found edge ending at unknown node \`${r}\``);
    if (e) {
      for (const r of e)
        if (!(r in this.nodes))
          throw new Error(`Interrupt node \`${r}\` is not present`);
    }
    this.compiled = !0;
  }
}
class hA extends JV {
  constructor({ builder: e, ...n }) {
    super(n), Object.defineProperty(this, "builder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.builder = e;
  }
  attachNode(e, n) {
    this.channels[e] = new fa(), this.nodes[e] = new ua({
      channels: [],
      triggers: [],
      metadata: n.metadata,
      subgraphs: n.subgraphs,
      ends: n.ends
    }).pipe(n.runnable).pipe(new Ct([{ channel: e, value: Ho }], [lt])), this.streamChannels.push(e);
  }
  attachEdge(e, n) {
    if (n === Me) {
      if (e === Ge)
        throw new Error("Cannot have an edge from START to END");
      this.nodes[e].writers.push(new Ct([{ channel: Me, value: Ho }], [lt]));
    } else
      this.nodes[n].triggers.push(e), this.nodes[n].channels.push(e);
  }
  attachBranch(e, n, a) {
    e === Ge && !this.nodes[Ge] && (this.nodes[Ge] = qV.subscribeTo(Ge, { tags: [lt] })), this.nodes[e].pipe(a.run((i) => {
      const s = i.map((o) => Tn(o) ? o : {
        channel: o === Me ? Me : `branch:${e}:${n}:${o}`,
        value: Ho
      });
      return new Ct(s, [lt]);
    }));
    const r = a.ends ? Object.values(a.ends) : Object.keys(this.nodes);
    for (const i of r)
      if (i !== Me) {
        const s = `branch:${e}:${n}:${i}`;
        this.channels[s] = new fa(), this.nodes[i].triggers.push(s), this.nodes[i].channels.push(s);
      }
  }
  /**
   * Returns a drawable representation of the computation graph.
   */
  async getGraphAsync(e) {
    const n = e?.xray, a = new Lh(), r = {
      [Ge]: a.addNode({
        schema: jn.any()
      }, Ge)
    }, i = {};
    let s = {};
    n && (s = Object.fromEntries((await uo(this.getSubgraphsAsync())).filter(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (f) => FP(f[1])
    )));
    function o(f, u, c, h = !1) {
      if (u === Me && i[Me] === void 0 && (i[Me] = a.addNode({ schema: jn.any() }, Me)), r[f] !== void 0) {
        if (i[u] === void 0)
          throw new Error(`End node ${u} not found!`);
        return a.addEdge(r[f], i[u], c !== u ? c : void 0, h);
      }
    }
    for (const [f, u] of Object.entries(this.builder.nodes)) {
      const c = Lt(f), h = u.runnable, p = u.metadata ?? {};
      if (this.interruptBefore?.includes(f) && this.interruptAfter?.includes(f) ? p.__interrupt = "before,after" : this.interruptBefore?.includes(f) ? p.__interrupt = "before" : this.interruptAfter?.includes(f) && (p.__interrupt = "after"), n) {
        const d = typeof n == "number" ? n - 1 : n, m = s[f] !== void 0 ? await s[f].getGraphAsync({
          ...e,
          xray: d
        }) : h.getGraph(e);
        if (m.trimFirstNode(), m.trimLastNode(), Object.keys(m.nodes).length > 1) {
          let _ = function(C) {
            return C ? C.lc_runnable : !1;
          }, P = function(C, R) {
            if (C !== void 0 && !Us(C))
              return C;
            if (_(R))
              try {
                let T = R.getName();
                return T = T.startsWith("Runnable") ? T.slice(8) : T, T;
              } catch {
                return R.getName();
              }
            else
              return R.name ?? "UnknownSchema";
          };
          const [b, g] = a.extend(m, c);
          if (b === void 0)
            throw new Error(`Could not extend subgraph "${f}" due to missing entrypoint.`);
          g !== void 0 && (r[c] = {
            name: P(g.id, g.data),
            ...g
          }), i[c] = {
            name: P(b.id, b.data),
            ...b
          };
        } else {
          const b = a.addNode(h, c, p);
          r[c] = b, i[c] = b;
        }
      } else {
        const d = a.addNode(h, c, p);
        r[c] = d, i[c] = d;
      }
    }
    const l = [...this.builder.allEdges].sort(([f], [u]) => f < u ? -1 : u > f ? 1 : 0);
    for (const [f, u] of l)
      o(Lt(f), Lt(u));
    for (const [f, u] of Object.entries(this.builder.branches)) {
      const c = {
        ...Object.fromEntries(Object.keys(this.builder.nodes).filter((h) => h !== f).map((h) => [Lt(h), Lt(h)])),
        [Me]: Me
      };
      for (const h of Object.values(u)) {
        let p;
        h.ends !== void 0 ? p = h.ends : p = c;
        for (const [d, m] of Object.entries(p))
          o(Lt(f), Lt(m), d, !0);
      }
    }
    for (const [f, u] of Object.entries(this.builder.nodes))
      if (u.ends !== void 0)
        for (const c of u.ends)
          o(Lt(f), Lt(c), void 0, !0);
    return a;
  }
  /**
   * Returns a drawable representation of the computation graph.
   *
   * @deprecated Use getGraphAsync instead. The async method will be the default in the next minor core release.
   */
  getGraph(e) {
    const n = e?.xray, a = new Lh(), r = {
      [Ge]: a.addNode({
        schema: jn.any()
      }, Ge)
    }, i = {};
    let s = {};
    n && (s = Object.fromEntries(Kl(this.getSubgraphs()).filter(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (f) => FP(f[1])
    )));
    function o(f, u, c, h = !1) {
      return u === Me && i[Me] === void 0 && (i[Me] = a.addNode({ schema: jn.any() }, Me)), a.addEdge(r[f], i[u], c !== u ? c : void 0, h);
    }
    for (const [f, u] of Object.entries(this.builder.nodes)) {
      const c = Lt(f), h = u.runnable, p = u.metadata ?? {};
      if (this.interruptBefore?.includes(f) && this.interruptAfter?.includes(f) ? p.__interrupt = "before,after" : this.interruptBefore?.includes(f) ? p.__interrupt = "before" : this.interruptAfter?.includes(f) && (p.__interrupt = "after"), n) {
        const d = typeof n == "number" ? n - 1 : n, m = s[f] !== void 0 ? s[f].getGraph({
          ...e,
          xray: d
        }) : h.getGraph(e);
        if (m.trimFirstNode(), m.trimLastNode(), Object.keys(m.nodes).length > 1) {
          let _ = function(C) {
            return C ? C.lc_runnable : !1;
          }, P = function(C, R) {
            if (C !== void 0 && !Us(C))
              return C;
            if (_(R))
              try {
                let T = R.getName();
                return T = T.startsWith("Runnable") ? T.slice(8) : T, T;
              } catch {
                return R.getName();
              }
            else
              return R.name ?? "UnknownSchema";
          };
          const [b, g] = a.extend(m, c);
          if (b === void 0)
            throw new Error(`Could not extend subgraph "${f}" due to missing entrypoint.`);
          g !== void 0 && (r[c] = {
            name: P(g.id, g.data),
            ...g
          }), i[c] = {
            name: P(b.id, b.data),
            ...b
          };
        } else {
          const b = a.addNode(h, c, p);
          r[c] = b, i[c] = b;
        }
      } else {
        const d = a.addNode(h, c, p);
        r[c] = d, i[c] = d;
      }
    }
    const l = [...this.builder.allEdges].sort(([f], [u]) => f < u ? -1 : u > f ? 1 : 0);
    for (const [f, u] of l)
      o(Lt(f), Lt(u));
    for (const [f, u] of Object.entries(this.builder.branches)) {
      const c = {
        ...Object.fromEntries(Object.keys(this.builder.nodes).filter((h) => h !== f).map((h) => [Lt(h), Lt(h)])),
        [Me]: Me
      };
      for (const h of Object.values(u)) {
        let p;
        h.ends !== void 0 ? p = h.ends : p = c;
        for (const [d, m] of Object.entries(p))
          o(Lt(f), Lt(m), d, !0);
      }
    }
    return a;
  }
}
function FP(t) {
  return (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof t.attachNode == "function" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof t.attachEdge == "function"
  );
}
function Lt(t) {
  return t === "subgraph" ? `"${t}"` : t;
}
const DP = (t, e) => t.size === e.size && [...t].every((n) => e.has(n));
class Py extends tm {
  constructor(e) {
    super(), Object.defineProperty(this, "lc_graph_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NamedBarrierValue"
    }), Object.defineProperty(this, "names", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "seen", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.names = e, this.seen = /* @__PURE__ */ new Set();
  }
  fromCheckpoint(e) {
    const n = new Py(this.names);
    return e && (n.seen = new Set(e)), n;
  }
  update(e) {
    let n = !1;
    for (const a of e)
      if (this.names.has(a))
        this.seen.has(a) || (this.seen.add(a), n = !0);
      else
        throw new rt(`Value ${JSON.stringify(a)} not in names ${JSON.stringify(this.names)}`);
    return n;
  }
  // If we have not yet seen all the node names we want to wait for,
  // throw an error to prevent continuing.
  get() {
    if (!DP(this.names, this.seen))
      throw new un();
  }
  checkpoint() {
    return [...this.seen];
  }
  consume() {
    return this.seen && this.names && DP(this.seen, this.names) ? (this.seen = /* @__PURE__ */ new Set(), !0) : !1;
  }
}
const UV = /* @__PURE__ */ new WeakMap();
function BV(t) {
  return typeof t == "object" && t != null && "_parse" in t && typeof t._parse == "function";
}
function Wo(t) {
  return BV(t) && "partial" in t && typeof t.partial == "function";
}
function xV(t) {
  return UV.get(t);
}
function rh(t) {
  const e = {};
  for (const n in t.shape)
    if (Object.prototype.hasOwnProperty.call(t.shape, n)) {
      const a = t.shape[n], r = xV(a);
      r?.reducer ? e[n] = new Ed(r.reducer.fn, r.default) : e[n] = new nm();
    }
  return e;
}
const Ls = "__root__";
class SK extends LV {
  constructor(e, n) {
    if (super(), Object.defineProperty(this, "channels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "waitingEdges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "_schemaDefinition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_schemaRuntimeDefinition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_inputDefinition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_inputRuntimeDefinition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_outputDefinition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_outputRuntimeDefinition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_schemaDefinitions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "_configSchema", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), WV(e)) {
      const a = rh(e.state), r = e.input != null ? rh(e.input) : a, i = e.output != null ? rh(e.output) : a;
      this._schemaDefinition = a, this._schemaRuntimeDefinition = e.state, this._inputDefinition = r, this._inputRuntimeDefinition = e.input ?? e.state.partial(), this._outputDefinition = i, this._outputRuntimeDefinition = e.output ?? e.state;
    } else if (Wo(e)) {
      const a = rh(e);
      this._schemaDefinition = a, this._schemaRuntimeDefinition = e, this._inputDefinition = a, this._inputRuntimeDefinition = e.partial(), this._outputDefinition = a, this._outputRuntimeDefinition = e;
    } else if (GV(e))
      this._schemaDefinition = e.input.spec, this._inputDefinition = e.input.spec, this._outputDefinition = e.output.spec;
    else if (HV(e))
      this._schemaDefinition = e.stateSchema.spec, this._inputDefinition = e.input?.spec ?? this._schemaDefinition, this._outputDefinition = e.output?.spec ?? this._schemaDefinition;
    else if (ZV(e) || qP(e)) {
      const a = qP(e) ? e.spec : e;
      this._schemaDefinition = a;
    } else if (KV(e)) {
      const a = VV(e.channels);
      this._schemaDefinition = a;
    } else
      throw new Error("Invalid StateGraph input.");
    this._inputDefinition ??= this._schemaDefinition, this._outputDefinition ??= this._schemaDefinition, this._addSchema(this._schemaDefinition), this._addSchema(this._inputDefinition), this._addSchema(this._outputDefinition), this._configSchema = n != null && "spec" in n ? n.spec : Wo(n) ? n.passthrough() : n;
  }
  get allEdges() {
    return /* @__PURE__ */ new Set([
      ...this.edges,
      ...Array.from(this.waitingEdges).flatMap(([e, n]) => e.map((a) => [a, n]))
    ]);
  }
  _addSchema(e) {
    if (!this._schemaDefinitions.has(e)) {
      this._schemaDefinitions.set(e, e);
      for (const [n, a] of Object.entries(e)) {
        let r;
        if (typeof a == "function" ? r = a() : r = a, this.channels[n] !== void 0) {
          if (this.channels[n] !== r && !wy(r) && r.lc_graph_name !== "LastValue")
            throw new Error(`Channel "${n}" already exists with a different type.`);
        } else
          this.channels[n] = r;
      }
    }
  }
  addNode(e, n, a) {
    if (e in this.channels)
      throw new Error(`${e} is already being used as a state attribute (a.k.a. a channel), cannot also be used as a node name.`);
    for (const s of [
      sn,
      Ko
    ])
      if (e.includes(s))
        throw new Error(`"${s}" is a reserved character and is not allowed in node names.`);
    if (this.warnIfCompiled("Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph."), e in this.nodes)
      throw new Error(`Node \`${e}\` already present.`);
    if (e === Me || e === Ge)
      throw new Error(`Node \`${e}\` is reserved.`);
    a?.input !== void 0 && this._addSchema(a.input.spec);
    let r;
    Te.isRunnable(n) ? r = n : typeof n == "function" ? r = new cu({
      func: n,
      name: e,
      trace: !1
    }) : r = Pn(n);
    const i = {
      runnable: r,
      retryPolicy: a?.retryPolicy,
      metadata: a?.metadata,
      input: a?.input?.spec ?? this._schemaDefinition,
      subgraphs: Oy(r) ? (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        [r]
      ) : a?.subgraphs,
      ends: a?.ends
    };
    return this.nodes[e] = i, this;
  }
  addEdge(e, n) {
    if (typeof e == "string")
      return super.addEdge(e, n);
    this.compiled && console.warn("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.");
    for (const a of e) {
      if (a === Me)
        throw new Error("END cannot be a start node");
      if (!Object.keys(this.nodes).some((r) => r === a))
        throw new Error(`Need to add a node named "${a}" first`);
    }
    if (n === Me)
      throw new Error("END cannot be an end node");
    if (!Object.keys(this.nodes).some((a) => a === n))
      throw new Error(`Need to add a node named "${n}" first`);
    return this.waitingEdges.add([e, n]), this;
  }
  compile({ checkpointer: e, store: n, interruptBefore: a, interruptAfter: r, name: i } = {}) {
    this.validate([
      ...Array.isArray(a) ? a : [],
      ...Array.isArray(r) ? r : []
    ]);
    const s = Object.keys(this._schemaDefinitions.get(this._outputDefinition)), o = s.length === 1 && s[0] === Ls ? Ls : s, l = Object.keys(this.channels), f = l.length === 1 && l[0] === Ls ? Ls : l, u = new zV({
      builder: this,
      checkpointer: e,
      interruptAfter: r,
      interruptBefore: a,
      autoValidate: !1,
      nodes: {},
      channels: {
        ...this.channels,
        [Ge]: new fa()
      },
      inputChannels: Ge,
      outputChannels: o,
      streamChannels: f,
      streamMode: "updates",
      store: n,
      name: i
    });
    u.attachNode(Ge);
    for (const [c, h] of Object.entries(this.nodes))
      u.attachNode(c, h);
    u.attachBranch(Ge, Cg, JP(), {
      withReader: !1
    });
    for (const [c] of Object.entries(this.nodes))
      u.attachBranch(c, Cg, JP(), {
        withReader: !1
      });
    for (const [c, h] of this.edges)
      u.attachEdge(c, h);
    for (const [c, h] of this.waitingEdges)
      u.attachEdge(c, h);
    for (const [c, h] of Object.entries(this.branches))
      for (const [p, d] of Object.entries(h))
        u.attachBranch(c, p, d);
    return u.validate();
  }
}
function VV(t) {
  const e = {};
  for (const [n, a] of Object.entries(t))
    e[n] = AP(a);
  return e;
}
class zV extends hA {
  attachNode(e, n) {
    let a;
    e === Ge ? a = Object.entries(this.builder._schemaDefinitions.get(this.builder._inputDefinition)).filter(([l, f]) => !wy(f)).map(([l]) => l) : a = Object.keys(this.builder.channels);
    function r(l) {
      if (Un(l))
        return l.graph === fr.PARENT ? null : l._updateAsTuples();
      if (Array.isArray(l) && l.length > 0 && l.some((f) => Un(f))) {
        const f = [];
        for (const u of l)
          if (Un(u)) {
            if (u.graph === fr.PARENT)
              continue;
            f.push(...u._updateAsTuples());
          } else
            f.push([Ls, u]);
        return f;
      } else if (l != null)
        return [[Ls, l]];
      return null;
    }
    const i = e;
    function s(l) {
      if (l) {
        if (Un(l))
          return l.graph === fr.PARENT ? null : l._updateAsTuples().filter(([f]) => a.includes(f));
        if (Array.isArray(l) && l.length > 0 && l.some(Un)) {
          const f = [];
          for (const u of l)
            if (Un(u)) {
              if (u.graph === fr.PARENT)
                continue;
              f.push(...u._updateAsTuples().filter(([c]) => a.includes(c)));
            } else {
              const c = s(u);
              c && f.push(...c ?? []);
            }
          return f;
        } else {
          if (typeof l == "object" && !Array.isArray(l))
            return Object.entries(l).filter(([f]) => a.includes(f));
          {
            const f = Array.isArray(l) ? "array" : typeof l;
            throw new rt(`Expected node "${i.toString()}" to return an object or an array containing at least one Command object, received ${f}`, {
              lc_error_code: "INVALID_GRAPH_NODE_RETURN_VALUE"
            });
          }
        }
      } else return null;
    }
    const o = [
      {
        value: Ho,
        mapper: new cu({
          func: a.length && a[0] === Ls ? r : s,
          trace: !1,
          recurse: !1
        })
      }
    ];
    if (e === Ge)
      this.nodes[e] = new ua({
        tags: [lt],
        triggers: [Ge],
        channels: [Ge],
        writers: [new Ct(o, [lt])]
      });
    else {
      const l = n?.input ?? this.builder._schemaDefinition, f = Object.fromEntries(Object.keys(this.builder._schemaDefinitions.get(l)).map((c) => [c, c])), u = Object.keys(f).length === 1 && Ls in f;
      this.channels[e] = new fa(!1), this.nodes[e] = new ua({
        triggers: [],
        // read state keys
        channels: u ? Object.keys(f) : f,
        // publish to this channel and state keys
        writers: [
          new Ct(o.concat({ channel: e, value: e }), [lt])
        ],
        mapper: u ? void 0 : (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (c) => Object.fromEntries(Object.entries(c).filter(([h]) => h in f))
        ),
        bound: n?.runnable,
        metadata: n?.metadata,
        retryPolicy: n?.retryPolicy,
        subgraphs: n?.subgraphs,
        ends: n?.ends
      });
    }
  }
  attachEdge(e, n) {
    if (n !== Me)
      if (Array.isArray(e)) {
        const a = `join:${e.join("+")}:${n}`;
        this.channels[a] = new Py(new Set(e)), this.nodes[n].triggers.push(a);
        for (const r of e)
          this.nodes[r].writers.push(new Ct([{ channel: a, value: r }], [lt]));
      } else if (e === Ge) {
        const a = `${Ge}:${n}`;
        this.channels[a] = new fa(), this.nodes[n].triggers.push(a), this.nodes[Ge].writers.push(new Ct([{ channel: a, value: Ge }], [lt]));
      } else
        this.nodes[n].triggers.push(e);
  }
  attachBranch(e, n, a, r = { withReader: !0 }) {
    const i = async (o, l) => {
      const f = o.filter((c) => c !== Me);
      if (!f.length)
        return;
      const u = f.map((c) => Tn(c) ? c : {
        channel: `branch:${e}:${n}:${c}`,
        value: e
      });
      await Ct.doWrite({ ...l, tags: (l.tags ?? []).concat([lt]) }, u);
    };
    this.nodes[e].writers.push(a.run(
      i,
      // reader
      r.withReader ? (o) => Sy.doRead(o, this.streamChannels ?? this.outputChannels, !0) : void 0
    ));
    const s = a.ends ? Object.values(a.ends) : Object.keys(this.builder.nodes);
    for (const o of s) {
      if (o === Me)
        continue;
      const l = `branch:${e}:${n}:${o}`;
      this.channels[l] = new fa(!1), this.nodes[o].triggers.push(l);
    }
  }
  async _validateInput(e) {
    const n = this.builder._inputRuntimeDefinition;
    return Wo(n) ? n.parse(e) : e;
  }
  async _validateConfigurable(e) {
    const n = this.builder._configSchema;
    return Wo(n) && n.parse(e), e;
  }
}
function ZV(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t) && Object.keys(t).length > 0 && Object.values(t).every((e) => typeof e == "function" || em(e));
}
function qP(t) {
  return typeof t == "object" && t !== null && "lc_graph_name" in t && t.lc_graph_name === "AnnotationRoot";
}
function KV(t) {
  return typeof t == "object" && t !== null && t.channels !== void 0;
}
function HV(t) {
  return typeof t == "object" && t !== null && t.stateSchema !== void 0;
}
function GV(t) {
  return typeof t == "object" && t !== null && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  t.stateSchema === void 0 && t.input !== void 0 && t.output !== void 0;
}
function WV(t) {
  return !(typeof t != "object" || t == null || !("state" in t) || !Wo(t.state) || "input" in t && !Wo(t.input) || "output" in t && !Wo(t.output));
}
function XV(t) {
  if (Tn(t))
    return [t];
  const e = [];
  Un(t) ? e.push(t) : Array.isArray(t) && e.push(...t.filter(Un));
  const n = [];
  for (const a of e) {
    if (a.graph === fr.PARENT)
      throw new tA(a);
    Tn(a.goto) || typeof a.goto == "string" ? n.push(a.goto) : Array.isArray(a.goto) && n.push(...a.goto);
  }
  return n;
}
function JP() {
  const t = new cu({
    func: XV,
    tags: [lt],
    trace: !1,
    recurse: !1,
    name: "<control_branch>"
  });
  return new fA({
    path: t
  });
}
const QV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), YV = {}, ez = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: YV
}, Symbol.toStringTag, { value: "Module" }));
export {
  $t as AIMessage,
  DM as AIMessagePromptTemplate,
  my as APIChain,
  ZM as AgentExecutor,
  XM as AnalyzeDocumentChain,
  cc as BaseCallbackHandler,
  uy as BaseChatMemory,
  Lo as BaseLLM,
  ca as BaseMessage,
  Kd as BaseOutputParser,
  Wp as BasePromptTemplate,
  hx as BufferMemory,
  st as CallbackManager,
  oK as CharacterTextSplitter,
  Iu as ChatAgent,
  OZ as ChatAnthropic,
  nK as ChatCerebras,
  WZ as ChatGroq,
  yo as ChatMessage,
  fx as ChatMessageHistory,
  jZ as ChatMistralAI,
  aK as ChatOllama,
  Zz as ChatOpenAI,
  da as ChatPromptTemplate,
  hh as CheerioWebBaseLoader,
  Vz as CommaSeparatedListOutputParser,
  Iw as ConsoleCallbackHandler,
  yK as ConversationChain,
  cK as ConversationSummaryMemory,
  dK as ConversationTokenBufferMemory,
  QM as ConversationalRetrievalQAChain,
  lr as Document,
  Wz as DynamicTool,
  Me as END,
  $I as FunctionMessage,
  fK as HTMLWebBaseLoader,
  _r as HumanMessage,
  Zs as HumanMessagePromptTemplate,
  nq as LLM,
  nt as LLMChain,
  Qp as MapReduceDocumentsChain,
  ly as MemoryVectorStore,
  PZ as MistralAIEmbeddings,
  sK as Ollama,
  iK as OllamaEmbeddings,
  Kz as OpenAI,
  Gz as OpenAIEmbeddings,
  We as PromptTemplate,
  op as RecursiveCharacterTextSplitter,
  UM as RestorableMemoryVectorStore,
  wK as RetrievalQAChain,
  Te as Runnable,
  dc as RunnableMap,
  dt as RunnableSequence,
  Ge as START,
  gK as SearxngSearch,
  by as SequentialChain,
  gy as SimpleSequentialChain,
  SK as StateGraph,
  zz as StringOutputParser,
  Cd as StructuredOutputParser,
  rq as StructuredTool,
  jh as SystemMessage,
  gc as SystemMessagePromptTemplate,
  uK as TokenTextSplitter,
  Mp as Tool,
  vK as TransformChain,
  lK as VectorStoreRetrieverMemory,
  hK as WebPDFLoader,
  _K as WikipediaQueryRun,
  Fs as ZeroShotAgent,
  mK as createOpenAIFunctionsAgent,
  bK as createReactAgent,
  pK as createStructuredChatAgent,
  Cn as zodToJsonSchema
};
//# sourceMappingURL=langchain-js-bundle.js.map
