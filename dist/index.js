function BM(t, e) {
  for (var n = 0; n < e.length; n++) {
    const a = e[n];
    if (typeof a != "string" && !Array.isArray(a)) {
      for (const r in a)
        if (r !== "default" && !(r in t)) {
          const i = Object.getOwnPropertyDescriptor(a, r);
          i && Object.defineProperty(t, r, i.get ? i : {
            enumerable: !0,
            get: () => a[r]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
function xM(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var rP = { exports: {} }, ot = rP.exports = {}, Qr, Yr;
function cb() {
  throw new Error("setTimeout has not been defined");
}
function lb() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Qr = setTimeout : Qr = cb;
  } catch {
    Qr = cb;
  }
  try {
    typeof clearTimeout == "function" ? Yr = clearTimeout : Yr = lb;
  } catch {
    Yr = lb;
  }
})();
function aP(t) {
  if (Qr === setTimeout)
    return setTimeout(t, 0);
  if ((Qr === cb || !Qr) && setTimeout)
    return Qr = setTimeout, setTimeout(t, 0);
  try {
    return Qr(t, 0);
  } catch {
    try {
      return Qr.call(null, t, 0);
    } catch {
      return Qr.call(this, t, 0);
    }
  }
}
function VM(t) {
  if (Yr === clearTimeout)
    return clearTimeout(t);
  if ((Yr === lb || !Yr) && clearTimeout)
    return Yr = clearTimeout, clearTimeout(t);
  try {
    return Yr(t);
  } catch {
    try {
      return Yr.call(null, t);
    } catch {
      return Yr.call(this, t);
    }
  }
}
var ks = [], Nu = !1, Io, zf = -1;
function zM() {
  !Nu || !Io || (Nu = !1, Io.length ? ks = Io.concat(ks) : zf = -1, ks.length && iP());
}
function iP() {
  if (!Nu) {
    var t = aP(zM);
    Nu = !0;
    for (var e = ks.length; e; ) {
      for (Io = ks, ks = []; ++zf < e; )
        Io && Io[zf].run();
      zf = -1, e = ks.length;
    }
    Io = null, Nu = !1, VM(t);
  }
}
ot.nextTick = function(t) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n = 1; n < arguments.length; n++)
      e[n - 1] = arguments[n];
  ks.push(new sP(t, e)), ks.length === 1 && !Nu && aP(iP);
};
function sP(t, e) {
  this.fun = t, this.array = e;
}
sP.prototype.run = function() {
  this.fun.apply(null, this.array);
};
ot.title = "browser";
ot.browser = !0;
ot.env = {};
ot.argv = [];
ot.version = "";
ot.versions = {};
function xs() {
}
ot.on = xs;
ot.addListener = xs;
ot.once = xs;
ot.off = xs;
ot.removeListener = xs;
ot.removeAllListeners = xs;
ot.emit = xs;
ot.prependListener = xs;
ot.prependOnceListener = xs;
ot.listeners = function(t) {
  return [];
};
ot.binding = function(t) {
  throw new Error("process.binding is not supported");
};
ot.cwd = function() {
  return "/";
};
ot.chdir = function(t) {
  throw new Error("process.chdir is not supported");
};
ot.umask = function() {
  return 0;
};
var ZM = rP.exports;
const pe = /* @__PURE__ */ xM(ZM), db = "RFC3986", fb = {
  RFC1738: (t) => String(t).replace(/%20/g, "+"),
  RFC3986: (t) => String(t)
}, KM = "RFC1738", HM = Array.isArray, yr = (() => {
  const t = [];
  for (let e = 0; e < 256; ++e)
    t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
  return t;
})(), Jp = 1024, GM = (t, e, n, a, r) => {
  if (t.length === 0)
    return t;
  let i = t;
  if (typeof t == "symbol" ? i = Symbol.prototype.toString.call(t) : typeof t != "string" && (i = String(t)), n === "iso-8859-1")
    return escape(i).replace(/%u[0-9a-f]{4}/gi, function(u) {
      return "%26%23" + parseInt(u.slice(2), 16) + "%3B";
    });
  let s = "";
  for (let u = 0; u < i.length; u += Jp) {
    const d = i.length >= Jp ? i.slice(u, u + Jp) : i, f = [];
    for (let o = 0; o < d.length; ++o) {
      let c = d.charCodeAt(o);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      r === KM && (c === 40 || c === 41)) {
        f[f.length] = d.charAt(o);
        continue;
      }
      if (c < 128) {
        f[f.length] = yr[c];
        continue;
      }
      if (c < 2048) {
        f[f.length] = yr[192 | c >> 6] + yr[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        f[f.length] = yr[224 | c >> 12] + yr[128 | c >> 6 & 63] + yr[128 | c & 63];
        continue;
      }
      o += 1, c = 65536 + ((c & 1023) << 10 | d.charCodeAt(o) & 1023), f[f.length] = yr[240 | c >> 18] + yr[128 | c >> 12 & 63] + yr[128 | c >> 6 & 63] + yr[128 | c & 63];
    }
    s += f.join("");
  }
  return s;
};
function WM(t) {
  return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
}
function ay(t, e) {
  if (HM(t)) {
    const n = [];
    for (let a = 0; a < t.length; a += 1)
      n.push(e(t[a]));
    return n;
  }
  return e(t);
}
const XM = Object.prototype.hasOwnProperty, oP = {
  brackets(t) {
    return String(t) + "[]";
  },
  comma: "comma",
  indices(t, e) {
    return String(t) + "[" + e + "]";
  },
  repeat(t) {
    return String(t);
  }
}, ea = Array.isArray, QM = Array.prototype.push, uP = function(t, e) {
  QM.apply(t, ea(e) ? e : [e]);
}, YM = Date.prototype.toISOString, pt = {
  addQueryPrefix: !1,
  allowDots: !1,
  allowEmptyArrays: !1,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encodeDotInKeys: !1,
  encoder: GM,
  encodeValuesOnly: !1,
  format: db,
  formatter: fb[db],
  /** @deprecated */
  indices: !1,
  serializeDate(t) {
    return YM.call(t);
  },
  skipNulls: !1,
  strictNullHandling: !1
};
function eA(t) {
  return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint";
}
const Lp = {};
function cP(t, e, n, a, r, i, s, u, d, f, o, c, h, p, l, m, b, g) {
  let _ = t, P = g, R = 0, C = !1;
  for (; (P = P.get(Lp)) !== void 0 && !C; ) {
    const I = P.get(t);
    if (R += 1, typeof I < "u") {
      if (I === R)
        throw new RangeError("Cyclic object value");
      C = !0;
    }
    typeof P.get(Lp) > "u" && (R = 0);
  }
  if (typeof f == "function" ? _ = f(e, _) : _ instanceof Date ? _ = h?.(_) : n === "comma" && ea(_) && (_ = ay(_, function(I) {
    return I instanceof Date ? h?.(I) : I;
  })), _ === null) {
    if (i)
      return d && !m ? (
        // @ts-expect-error
        d(e, pt.encoder, b, "key", p)
      ) : e;
    _ = "";
  }
  if (eA(_) || WM(_)) {
    if (d) {
      const I = m ? e : d(e, pt.encoder, b, "key", p);
      return [
        l?.(I) + "=" + // @ts-expect-error
        l?.(d(_, pt.encoder, b, "value", p))
      ];
    }
    return [l?.(e) + "=" + l?.(String(_))];
  }
  const T = [];
  if (typeof _ > "u")
    return T;
  let O;
  if (n === "comma" && ea(_))
    m && d && (_ = ay(_, d)), O = [{ value: _.length > 0 ? _.join(",") || null : void 0 }];
  else if (ea(f))
    O = f;
  else {
    const I = Object.keys(_);
    O = o ? I.sort(o) : I;
  }
  const A = u ? String(e).replace(/\./g, "%2E") : String(e), M = a && ea(_) && _.length === 1 ? A + "[]" : A;
  if (r && ea(_) && _.length === 0)
    return M + "[]";
  for (let I = 0; I < O.length; ++I) {
    const N = O[I], v = (
      // @ts-ignore
      typeof N == "object" && typeof N.value < "u" ? N.value : _[N]
    );
    if (s && v === null)
      continue;
    const F = c && u ? N.replace(/\./g, "%2E") : N, L = ea(_) ? typeof n == "function" ? n(M, F) : M : M + (c ? "." + F : "[" + F + "]");
    g.set(t, R);
    const B = /* @__PURE__ */ new WeakMap();
    B.set(Lp, g), uP(T, cP(
      v,
      L,
      n,
      a,
      r,
      i,
      s,
      u,
      // @ts-ignore
      n === "comma" && m && ea(_) ? null : d,
      f,
      o,
      c,
      h,
      p,
      l,
      m,
      b,
      B
    ));
  }
  return T;
}
function tA(t = pt) {
  if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof t.encodeDotInKeys < "u" && typeof t.encodeDotInKeys != "boolean")
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  const e = t.charset || pt.charset;
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  let n = db;
  if (typeof t.format < "u") {
    if (!XM.call(fb, t.format))
      throw new TypeError("Unknown format option provided.");
    n = t.format;
  }
  const a = fb[n];
  let r = pt.filter;
  (typeof t.filter == "function" || ea(t.filter)) && (r = t.filter);
  let i;
  if (t.arrayFormat && t.arrayFormat in oP ? i = t.arrayFormat : "indices" in t ? i = t.indices ? "indices" : "repeat" : i = pt.arrayFormat, "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  const s = typeof t.allowDots > "u" ? t.encodeDotInKeys ? !0 : pt.allowDots : !!t.allowDots;
  return {
    addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : pt.addQueryPrefix,
    // @ts-ignore
    allowDots: s,
    allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : pt.allowEmptyArrays,
    arrayFormat: i,
    charset: e,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : pt.charsetSentinel,
    commaRoundTrip: !!t.commaRoundTrip,
    delimiter: typeof t.delimiter > "u" ? pt.delimiter : t.delimiter,
    encode: typeof t.encode == "boolean" ? t.encode : pt.encode,
    encodeDotInKeys: typeof t.encodeDotInKeys == "boolean" ? t.encodeDotInKeys : pt.encodeDotInKeys,
    encoder: typeof t.encoder == "function" ? t.encoder : pt.encoder,
    encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : pt.encodeValuesOnly,
    filter: r,
    format: n,
    formatter: a,
    serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : pt.serializeDate,
    skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : pt.skipNulls,
    // @ts-ignore
    sort: typeof t.sort == "function" ? t.sort : null,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : pt.strictNullHandling
  };
}
function nA(t, e = {}) {
  let n = t;
  const a = tA(e);
  let r, i;
  typeof a.filter == "function" ? (i = a.filter, n = i("", n)) : ea(a.filter) && (i = a.filter, r = i);
  const s = [];
  if (typeof n != "object" || n === null)
    return "";
  const u = oP[a.arrayFormat], d = u === "comma" && a.commaRoundTrip;
  r || (r = Object.keys(n)), a.sort && r.sort(a.sort);
  const f = /* @__PURE__ */ new WeakMap();
  for (let h = 0; h < r.length; ++h) {
    const p = r[h];
    a.skipNulls && n[p] === null || uP(s, cP(
      n[p],
      p,
      // @ts-expect-error
      u,
      d,
      a.allowEmptyArrays,
      a.strictNullHandling,
      a.skipNulls,
      a.encodeDotInKeys,
      a.encode ? a.encoder : null,
      a.filter,
      a.sort,
      a.allowDots,
      a.serializeDate,
      a.format,
      a.formatter,
      a.encodeValuesOnly,
      a.charset,
      f
    ));
  }
  const o = s.join(a.delimiter);
  let c = a.addQueryPrefix === !0 ? "?" : "";
  return a.charsetSentinel && (a.charset === "iso-8859-1" ? c += "utf8=%26%2310003%3B&" : c += "utf8=%E2%9C%93&"), o.length > 0 ? c + o : "";
}
var lP = {}, Hh = {};
Hh.byteLength = iA;
Hh.toByteArray = oA;
Hh.fromByteArray = lA;
var na = [], Fn = [], rA = typeof Uint8Array < "u" ? Uint8Array : Array, Up = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var su = 0, aA = Up.length; su < aA; ++su)
  na[su] = Up[su], Fn[Up.charCodeAt(su)] = su;
Fn[45] = 62;
Fn[95] = 63;
function dP(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = t.indexOf("=");
  n === -1 && (n = e);
  var a = n === e ? 0 : 4 - n % 4;
  return [n, a];
}
function iA(t) {
  var e = dP(t), n = e[0], a = e[1];
  return (n + a) * 3 / 4 - a;
}
function sA(t, e, n) {
  return (e + n) * 3 / 4 - n;
}
function oA(t) {
  var e, n = dP(t), a = n[0], r = n[1], i = new rA(sA(t, a, r)), s = 0, u = r > 0 ? a - 4 : a, d;
  for (d = 0; d < u; d += 4)
    e = Fn[t.charCodeAt(d)] << 18 | Fn[t.charCodeAt(d + 1)] << 12 | Fn[t.charCodeAt(d + 2)] << 6 | Fn[t.charCodeAt(d + 3)], i[s++] = e >> 16 & 255, i[s++] = e >> 8 & 255, i[s++] = e & 255;
  return r === 2 && (e = Fn[t.charCodeAt(d)] << 2 | Fn[t.charCodeAt(d + 1)] >> 4, i[s++] = e & 255), r === 1 && (e = Fn[t.charCodeAt(d)] << 10 | Fn[t.charCodeAt(d + 1)] << 4 | Fn[t.charCodeAt(d + 2)] >> 2, i[s++] = e >> 8 & 255, i[s++] = e & 255), i;
}
function uA(t) {
  return na[t >> 18 & 63] + na[t >> 12 & 63] + na[t >> 6 & 63] + na[t & 63];
}
function cA(t, e, n) {
  for (var a, r = [], i = e; i < n; i += 3)
    a = (t[i] << 16 & 16711680) + (t[i + 1] << 8 & 65280) + (t[i + 2] & 255), r.push(uA(a));
  return r.join("");
}
function lA(t) {
  for (var e, n = t.length, a = n % 3, r = [], i = 16383, s = 0, u = n - a; s < u; s += i)
    r.push(cA(t, s, s + i > u ? u : s + i));
  return a === 1 ? (e = t[n - 1], r.push(
    na[e >> 2] + na[e << 4 & 63] + "=="
  )) : a === 2 && (e = (t[n - 2] << 8) + t[n - 1], r.push(
    na[e >> 10] + na[e >> 4 & 63] + na[e << 2 & 63] + "="
  )), r.join("");
}
var ag = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ag.read = function(t, e, n, a, r) {
  var i, s, u = r * 8 - a - 1, d = (1 << u) - 1, f = d >> 1, o = -7, c = n ? r - 1 : 0, h = n ? -1 : 1, p = t[e + c];
  for (c += h, i = p & (1 << -o) - 1, p >>= -o, o += u; o > 0; i = i * 256 + t[e + c], c += h, o -= 8)
    ;
  for (s = i & (1 << -o) - 1, i >>= -o, o += a; o > 0; s = s * 256 + t[e + c], c += h, o -= 8)
    ;
  if (i === 0)
    i = 1 - f;
  else {
    if (i === d)
      return s ? NaN : (p ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, a), i = i - f;
  }
  return (p ? -1 : 1) * s * Math.pow(2, i - a);
};
ag.write = function(t, e, n, a, r, i) {
  var s, u, d, f = i * 8 - r - 1, o = (1 << f) - 1, c = o >> 1, h = r === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = a ? 0 : i - 1, l = a ? 1 : -1, m = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (u = isNaN(e) ? 1 : 0, s = o) : (s = Math.floor(Math.log(e) / Math.LN2), e * (d = Math.pow(2, -s)) < 1 && (s--, d *= 2), s + c >= 1 ? e += h / d : e += h * Math.pow(2, 1 - c), e * d >= 2 && (s++, d /= 2), s + c >= o ? (u = 0, s = o) : s + c >= 1 ? (u = (e * d - 1) * Math.pow(2, r), s = s + c) : (u = e * Math.pow(2, c - 1) * Math.pow(2, r), s = 0)); r >= 8; t[n + p] = u & 255, p += l, u /= 256, r -= 8)
    ;
  for (s = s << r | u, f += r; f > 0; t[n + p] = s & 255, p += l, s /= 256, f -= 8)
    ;
  t[n + p - l] |= m * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
  const e = Hh, n = ag, a = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = o, t.SlowBuffer = C, t.INSPECT_MAX_BYTES = 50;
  const r = 2147483647;
  t.kMaxLength = r;
  const { Uint8Array: i, ArrayBuffer: s, SharedArrayBuffer: u } = globalThis;
  o.TYPED_ARRAY_SUPPORT = d(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function d() {
    try {
      const $ = new i(1), w = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(w, i.prototype), Object.setPrototypeOf($, w), $.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(o.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (o.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(o.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (o.isBuffer(this))
        return this.byteOffset;
    }
  });
  function f($) {
    if ($ > r)
      throw new RangeError('The value "' + $ + '" is invalid for option "size"');
    const w = new i($);
    return Object.setPrototypeOf(w, o.prototype), w;
  }
  function o($, w, S) {
    if (typeof $ == "number") {
      if (typeof w == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return l($);
    }
    return c($, w, S);
  }
  o.poolSize = 8192;
  function c($, w, S) {
    if (typeof $ == "string")
      return m($, w);
    if (s.isView($))
      return g($);
    if ($ == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $
      );
    if (wt($, s) || $ && wt($.buffer, s) || typeof u < "u" && (wt($, u) || $ && wt($.buffer, u)))
      return _($, w, S);
    if (typeof $ == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const k = $.valueOf && $.valueOf();
    if (k != null && k !== $)
      return o.from(k, w, S);
    const U = P($);
    if (U) return U;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof $[Symbol.toPrimitive] == "function")
      return o.from($[Symbol.toPrimitive]("string"), w, S);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $
    );
  }
  o.from = function($, w, S) {
    return c($, w, S);
  }, Object.setPrototypeOf(o.prototype, i.prototype), Object.setPrototypeOf(o, i);
  function h($) {
    if (typeof $ != "number")
      throw new TypeError('"size" argument must be of type number');
    if ($ < 0)
      throw new RangeError('The value "' + $ + '" is invalid for option "size"');
  }
  function p($, w, S) {
    return h($), $ <= 0 ? f($) : w !== void 0 ? typeof S == "string" ? f($).fill(w, S) : f($).fill(w) : f($);
  }
  o.alloc = function($, w, S) {
    return p($, w, S);
  };
  function l($) {
    return h($), f($ < 0 ? 0 : R($) | 0);
  }
  o.allocUnsafe = function($) {
    return l($);
  }, o.allocUnsafeSlow = function($) {
    return l($);
  };
  function m($, w) {
    if ((typeof w != "string" || w === "") && (w = "utf8"), !o.isEncoding(w))
      throw new TypeError("Unknown encoding: " + w);
    const S = T($, w) | 0;
    let k = f(S);
    const U = k.write($, w);
    return U !== S && (k = k.slice(0, U)), k;
  }
  function b($) {
    const w = $.length < 0 ? 0 : R($.length) | 0, S = f(w);
    for (let k = 0; k < w; k += 1)
      S[k] = $[k] & 255;
    return S;
  }
  function g($) {
    if (wt($, i)) {
      const w = new i($);
      return _(w.buffer, w.byteOffset, w.byteLength);
    }
    return b($);
  }
  function _($, w, S) {
    if (w < 0 || $.byteLength < w)
      throw new RangeError('"offset" is outside of buffer bounds');
    if ($.byteLength < w + (S || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let k;
    return w === void 0 && S === void 0 ? k = new i($) : S === void 0 ? k = new i($, w) : k = new i($, w, S), Object.setPrototypeOf(k, o.prototype), k;
  }
  function P($) {
    if (o.isBuffer($)) {
      const w = R($.length) | 0, S = f(w);
      return S.length === 0 || $.copy(S, 0, 0, w), S;
    }
    if ($.length !== void 0)
      return typeof $.length != "number" || _r($.length) ? f(0) : b($);
    if ($.type === "Buffer" && Array.isArray($.data))
      return b($.data);
  }
  function R($) {
    if ($ >= r)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + r.toString(16) + " bytes");
    return $ | 0;
  }
  function C($) {
    return +$ != $ && ($ = 0), o.alloc(+$);
  }
  o.isBuffer = function(w) {
    return w != null && w._isBuffer === !0 && w !== o.prototype;
  }, o.compare = function(w, S) {
    if (wt(w, i) && (w = o.from(w, w.offset, w.byteLength)), wt(S, i) && (S = o.from(S, S.offset, S.byteLength)), !o.isBuffer(w) || !o.isBuffer(S))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (w === S) return 0;
    let k = w.length, U = S.length;
    for (let z = 0, G = Math.min(k, U); z < G; ++z)
      if (w[z] !== S[z]) {
        k = w[z], U = S[z];
        break;
      }
    return k < U ? -1 : U < k ? 1 : 0;
  }, o.isEncoding = function(w) {
    switch (String(w).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, o.concat = function(w, S) {
    if (!Array.isArray(w))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (w.length === 0)
      return o.alloc(0);
    let k;
    if (S === void 0)
      for (S = 0, k = 0; k < w.length; ++k)
        S += w[k].length;
    const U = o.allocUnsafe(S);
    let z = 0;
    for (k = 0; k < w.length; ++k) {
      let G = w[k];
      if (wt(G, i))
        z + G.length > U.length ? (o.isBuffer(G) || (G = o.from(G)), G.copy(U, z)) : i.prototype.set.call(
          U,
          G,
          z
        );
      else if (o.isBuffer(G))
        G.copy(U, z);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      z += G.length;
    }
    return U;
  };
  function T($, w) {
    if (o.isBuffer($))
      return $.length;
    if (s.isView($) || wt($, s))
      return $.byteLength;
    if (typeof $ != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof $
      );
    const S = $.length, k = arguments.length > 2 && arguments[2] === !0;
    if (!k && S === 0) return 0;
    let U = !1;
    for (; ; )
      switch (w) {
        case "ascii":
        case "latin1":
        case "binary":
          return S;
        case "utf8":
        case "utf-8":
          return _o($).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return S * 2;
        case "hex":
          return S >>> 1;
        case "base64":
          return Vs($).length;
        default:
          if (U)
            return k ? -1 : _o($).length;
          w = ("" + w).toLowerCase(), U = !0;
      }
  }
  o.byteLength = T;
  function O($, w, S) {
    let k = !1;
    if ((w === void 0 || w < 0) && (w = 0), w > this.length || ((S === void 0 || S > this.length) && (S = this.length), S <= 0) || (S >>>= 0, w >>>= 0, S <= w))
      return "";
    for ($ || ($ = "utf8"); ; )
      switch ($) {
        case "hex":
          return cc(this, w, S);
        case "utf8":
        case "utf-8":
          return ue(this, w, S);
        case "ascii":
          return ha(this, w, S);
        case "latin1":
        case "binary":
          return Nt(this, w, S);
        case "base64":
          return V(this, w, S);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Tt(this, w, S);
        default:
          if (k) throw new TypeError("Unknown encoding: " + $);
          $ = ($ + "").toLowerCase(), k = !0;
      }
  }
  o.prototype._isBuffer = !0;
  function A($, w, S) {
    const k = $[w];
    $[w] = $[S], $[S] = k;
  }
  o.prototype.swap16 = function() {
    const w = this.length;
    if (w % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let S = 0; S < w; S += 2)
      A(this, S, S + 1);
    return this;
  }, o.prototype.swap32 = function() {
    const w = this.length;
    if (w % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let S = 0; S < w; S += 4)
      A(this, S, S + 3), A(this, S + 1, S + 2);
    return this;
  }, o.prototype.swap64 = function() {
    const w = this.length;
    if (w % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let S = 0; S < w; S += 8)
      A(this, S, S + 7), A(this, S + 1, S + 6), A(this, S + 2, S + 5), A(this, S + 3, S + 4);
    return this;
  }, o.prototype.toString = function() {
    const w = this.length;
    return w === 0 ? "" : arguments.length === 0 ? ue(this, 0, w) : O.apply(this, arguments);
  }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(w) {
    if (!o.isBuffer(w)) throw new TypeError("Argument must be a Buffer");
    return this === w ? !0 : o.compare(this, w) === 0;
  }, o.prototype.inspect = function() {
    let w = "";
    const S = t.INSPECT_MAX_BYTES;
    return w = this.toString("hex", 0, S).replace(/(.{2})/g, "$1 ").trim(), this.length > S && (w += " ... "), "<Buffer " + w + ">";
  }, a && (o.prototype[a] = o.prototype.inspect), o.prototype.compare = function(w, S, k, U, z) {
    if (wt(w, i) && (w = o.from(w, w.offset, w.byteLength)), !o.isBuffer(w))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof w
      );
    if (S === void 0 && (S = 0), k === void 0 && (k = w ? w.length : 0), U === void 0 && (U = 0), z === void 0 && (z = this.length), S < 0 || k > w.length || U < 0 || z > this.length)
      throw new RangeError("out of range index");
    if (U >= z && S >= k)
      return 0;
    if (U >= z)
      return -1;
    if (S >= k)
      return 1;
    if (S >>>= 0, k >>>= 0, U >>>= 0, z >>>= 0, this === w) return 0;
    let G = z - U, he = k - S;
    const Ze = Math.min(G, he), xe = this.slice(U, z), Ve = w.slice(S, k);
    for (let $e = 0; $e < Ze; ++$e)
      if (xe[$e] !== Ve[$e]) {
        G = xe[$e], he = Ve[$e];
        break;
      }
    return G < he ? -1 : he < G ? 1 : 0;
  };
  function M($, w, S, k, U) {
    if ($.length === 0) return -1;
    if (typeof S == "string" ? (k = S, S = 0) : S > 2147483647 ? S = 2147483647 : S < -2147483648 && (S = -2147483648), S = +S, _r(S) && (S = U ? 0 : $.length - 1), S < 0 && (S = $.length + S), S >= $.length) {
      if (U) return -1;
      S = $.length - 1;
    } else if (S < 0)
      if (U) S = 0;
      else return -1;
    if (typeof w == "string" && (w = o.from(w, k)), o.isBuffer(w))
      return w.length === 0 ? -1 : I($, w, S, k, U);
    if (typeof w == "number")
      return w = w & 255, typeof i.prototype.indexOf == "function" ? U ? i.prototype.indexOf.call($, w, S) : i.prototype.lastIndexOf.call($, w, S) : I($, [w], S, k, U);
    throw new TypeError("val must be string, number or Buffer");
  }
  function I($, w, S, k, U) {
    let z = 1, G = $.length, he = w.length;
    if (k !== void 0 && (k = String(k).toLowerCase(), k === "ucs2" || k === "ucs-2" || k === "utf16le" || k === "utf-16le")) {
      if ($.length < 2 || w.length < 2)
        return -1;
      z = 2, G /= 2, he /= 2, S /= 2;
    }
    function Ze(Ve, $e) {
      return z === 1 ? Ve[$e] : Ve.readUInt16BE($e * z);
    }
    let xe;
    if (U) {
      let Ve = -1;
      for (xe = S; xe < G; xe++)
        if (Ze($, xe) === Ze(w, Ve === -1 ? 0 : xe - Ve)) {
          if (Ve === -1 && (Ve = xe), xe - Ve + 1 === he) return Ve * z;
        } else
          Ve !== -1 && (xe -= xe - Ve), Ve = -1;
    } else
      for (S + he > G && (S = G - he), xe = S; xe >= 0; xe--) {
        let Ve = !0;
        for (let $e = 0; $e < he; $e++)
          if (Ze($, xe + $e) !== Ze(w, $e)) {
            Ve = !1;
            break;
          }
        if (Ve) return xe;
      }
    return -1;
  }
  o.prototype.includes = function(w, S, k) {
    return this.indexOf(w, S, k) !== -1;
  }, o.prototype.indexOf = function(w, S, k) {
    return M(this, w, S, k, !0);
  }, o.prototype.lastIndexOf = function(w, S, k) {
    return M(this, w, S, k, !1);
  };
  function N($, w, S, k) {
    S = Number(S) || 0;
    const U = $.length - S;
    k ? (k = Number(k), k > U && (k = U)) : k = U;
    const z = w.length;
    k > z / 2 && (k = z / 2);
    let G;
    for (G = 0; G < k; ++G) {
      const he = parseInt(w.substr(G * 2, 2), 16);
      if (_r(he)) return G;
      $[S + G] = he;
    }
    return G;
  }
  function v($, w, S, k) {
    return ba(_o(w, $.length - S), $, S, k);
  }
  function F($, w, S, k) {
    return ba(yo(w), $, S, k);
  }
  function L($, w, S, k) {
    return ba(Vs(w), $, S, k);
  }
  function B($, w, S, k) {
    return ba($n(w, $.length - S), $, S, k);
  }
  o.prototype.write = function(w, S, k, U) {
    if (S === void 0)
      U = "utf8", k = this.length, S = 0;
    else if (k === void 0 && typeof S == "string")
      U = S, k = this.length, S = 0;
    else if (isFinite(S))
      S = S >>> 0, isFinite(k) ? (k = k >>> 0, U === void 0 && (U = "utf8")) : (U = k, k = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const z = this.length - S;
    if ((k === void 0 || k > z) && (k = z), w.length > 0 && (k < 0 || S < 0) || S > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    U || (U = "utf8");
    let G = !1;
    for (; ; )
      switch (U) {
        case "hex":
          return N(this, w, S, k);
        case "utf8":
        case "utf-8":
          return v(this, w, S, k);
        case "ascii":
        case "latin1":
        case "binary":
          return F(this, w, S, k);
        case "base64":
          return L(this, w, S, k);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return B(this, w, S, k);
        default:
          if (G) throw new TypeError("Unknown encoding: " + U);
          U = ("" + U).toLowerCase(), G = !0;
      }
  }, o.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function V($, w, S) {
    return w === 0 && S === $.length ? e.fromByteArray($) : e.fromByteArray($.slice(w, S));
  }
  function ue($, w, S) {
    S = Math.min($.length, S);
    const k = [];
    let U = w;
    for (; U < S; ) {
      const z = $[U];
      let G = null, he = z > 239 ? 4 : z > 223 ? 3 : z > 191 ? 2 : 1;
      if (U + he <= S) {
        let Ze, xe, Ve, $e;
        switch (he) {
          case 1:
            z < 128 && (G = z);
            break;
          case 2:
            Ze = $[U + 1], (Ze & 192) === 128 && ($e = (z & 31) << 6 | Ze & 63, $e > 127 && (G = $e));
            break;
          case 3:
            Ze = $[U + 1], xe = $[U + 2], (Ze & 192) === 128 && (xe & 192) === 128 && ($e = (z & 15) << 12 | (Ze & 63) << 6 | xe & 63, $e > 2047 && ($e < 55296 || $e > 57343) && (G = $e));
            break;
          case 4:
            Ze = $[U + 1], xe = $[U + 2], Ve = $[U + 3], (Ze & 192) === 128 && (xe & 192) === 128 && (Ve & 192) === 128 && ($e = (z & 15) << 18 | (Ze & 63) << 12 | (xe & 63) << 6 | Ve & 63, $e > 65535 && $e < 1114112 && (G = $e));
        }
      }
      G === null ? (G = 65533, he = 1) : G > 65535 && (G -= 65536, k.push(G >>> 10 & 1023 | 55296), G = 56320 | G & 1023), k.push(G), U += he;
    }
    return ut(k);
  }
  const ie = 4096;
  function ut($) {
    const w = $.length;
    if (w <= ie)
      return String.fromCharCode.apply(String, $);
    let S = "", k = 0;
    for (; k < w; )
      S += String.fromCharCode.apply(
        String,
        $.slice(k, k += ie)
      );
    return S;
  }
  function ha($, w, S) {
    let k = "";
    S = Math.min($.length, S);
    for (let U = w; U < S; ++U)
      k += String.fromCharCode($[U] & 127);
    return k;
  }
  function Nt($, w, S) {
    let k = "";
    S = Math.min($.length, S);
    for (let U = w; U < S; ++U)
      k += String.fromCharCode($[U]);
    return k;
  }
  function cc($, w, S) {
    const k = $.length;
    (!w || w < 0) && (w = 0), (!S || S < 0 || S > k) && (S = k);
    let U = "";
    for (let z = w; z < S; ++z)
      U += vo[$[z]];
    return U;
  }
  function Tt($, w, S) {
    const k = $.slice(w, S);
    let U = "";
    for (let z = 0; z < k.length - 1; z += 2)
      U += String.fromCharCode(k[z] + k[z + 1] * 256);
    return U;
  }
  o.prototype.slice = function(w, S) {
    const k = this.length;
    w = ~~w, S = S === void 0 ? k : ~~S, w < 0 ? (w += k, w < 0 && (w = 0)) : w > k && (w = k), S < 0 ? (S += k, S < 0 && (S = 0)) : S > k && (S = k), S < w && (S = w);
    const U = this.subarray(w, S);
    return Object.setPrototypeOf(U, o.prototype), U;
  };
  function Je($, w, S) {
    if ($ % 1 !== 0 || $ < 0) throw new RangeError("offset is not uint");
    if ($ + w > S) throw new RangeError("Trying to access beyond buffer length");
  }
  o.prototype.readUintLE = o.prototype.readUIntLE = function(w, S, k) {
    w = w >>> 0, S = S >>> 0, k || Je(w, S, this.length);
    let U = this[w], z = 1, G = 0;
    for (; ++G < S && (z *= 256); )
      U += this[w + G] * z;
    return U;
  }, o.prototype.readUintBE = o.prototype.readUIntBE = function(w, S, k) {
    w = w >>> 0, S = S >>> 0, k || Je(w, S, this.length);
    let U = this[w + --S], z = 1;
    for (; S > 0 && (z *= 256); )
      U += this[w + --S] * z;
    return U;
  }, o.prototype.readUint8 = o.prototype.readUInt8 = function(w, S) {
    return w = w >>> 0, S || Je(w, 1, this.length), this[w];
  }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(w, S) {
    return w = w >>> 0, S || Je(w, 2, this.length), this[w] | this[w + 1] << 8;
  }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(w, S) {
    return w = w >>> 0, S || Je(w, 2, this.length), this[w] << 8 | this[w + 1];
  }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(w, S) {
    return w = w >>> 0, S || Je(w, 4, this.length), (this[w] | this[w + 1] << 8 | this[w + 2] << 16) + this[w + 3] * 16777216;
  }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(w, S) {
    return w = w >>> 0, S || Je(w, 4, this.length), this[w] * 16777216 + (this[w + 1] << 16 | this[w + 2] << 8 | this[w + 3]);
  }, o.prototype.readBigUInt64LE = Yt(function(w) {
    w = w >>> 0, qe(w, "offset");
    const S = this[w], k = this[w + 7];
    (S === void 0 || k === void 0) && Zn(w, this.length - 8);
    const U = S + this[++w] * 2 ** 8 + this[++w] * 2 ** 16 + this[++w] * 2 ** 24, z = this[++w] + this[++w] * 2 ** 8 + this[++w] * 2 ** 16 + k * 2 ** 24;
    return BigInt(U) + (BigInt(z) << BigInt(32));
  }), o.prototype.readBigUInt64BE = Yt(function(w) {
    w = w >>> 0, qe(w, "offset");
    const S = this[w], k = this[w + 7];
    (S === void 0 || k === void 0) && Zn(w, this.length - 8);
    const U = S * 2 ** 24 + this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + this[++w], z = this[++w] * 2 ** 24 + this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + k;
    return (BigInt(U) << BigInt(32)) + BigInt(z);
  }), o.prototype.readIntLE = function(w, S, k) {
    w = w >>> 0, S = S >>> 0, k || Je(w, S, this.length);
    let U = this[w], z = 1, G = 0;
    for (; ++G < S && (z *= 256); )
      U += this[w + G] * z;
    return z *= 128, U >= z && (U -= Math.pow(2, 8 * S)), U;
  }, o.prototype.readIntBE = function(w, S, k) {
    w = w >>> 0, S = S >>> 0, k || Je(w, S, this.length);
    let U = S, z = 1, G = this[w + --U];
    for (; U > 0 && (z *= 256); )
      G += this[w + --U] * z;
    return z *= 128, G >= z && (G -= Math.pow(2, 8 * S)), G;
  }, o.prototype.readInt8 = function(w, S) {
    return w = w >>> 0, S || Je(w, 1, this.length), this[w] & 128 ? (255 - this[w] + 1) * -1 : this[w];
  }, o.prototype.readInt16LE = function(w, S) {
    w = w >>> 0, S || Je(w, 2, this.length);
    const k = this[w] | this[w + 1] << 8;
    return k & 32768 ? k | 4294901760 : k;
  }, o.prototype.readInt16BE = function(w, S) {
    w = w >>> 0, S || Je(w, 2, this.length);
    const k = this[w + 1] | this[w] << 8;
    return k & 32768 ? k | 4294901760 : k;
  }, o.prototype.readInt32LE = function(w, S) {
    return w = w >>> 0, S || Je(w, 4, this.length), this[w] | this[w + 1] << 8 | this[w + 2] << 16 | this[w + 3] << 24;
  }, o.prototype.readInt32BE = function(w, S) {
    return w = w >>> 0, S || Je(w, 4, this.length), this[w] << 24 | this[w + 1] << 16 | this[w + 2] << 8 | this[w + 3];
  }, o.prototype.readBigInt64LE = Yt(function(w) {
    w = w >>> 0, qe(w, "offset");
    const S = this[w], k = this[w + 7];
    (S === void 0 || k === void 0) && Zn(w, this.length - 8);
    const U = this[w + 4] + this[w + 5] * 2 ** 8 + this[w + 6] * 2 ** 16 + (k << 24);
    return (BigInt(U) << BigInt(32)) + BigInt(S + this[++w] * 2 ** 8 + this[++w] * 2 ** 16 + this[++w] * 2 ** 24);
  }), o.prototype.readBigInt64BE = Yt(function(w) {
    w = w >>> 0, qe(w, "offset");
    const S = this[w], k = this[w + 7];
    (S === void 0 || k === void 0) && Zn(w, this.length - 8);
    const U = (S << 24) + // Overflow
    this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + this[++w];
    return (BigInt(U) << BigInt(32)) + BigInt(this[++w] * 2 ** 24 + this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + k);
  }), o.prototype.readFloatLE = function(w, S) {
    return w = w >>> 0, S || Je(w, 4, this.length), n.read(this, w, !0, 23, 4);
  }, o.prototype.readFloatBE = function(w, S) {
    return w = w >>> 0, S || Je(w, 4, this.length), n.read(this, w, !1, 23, 4);
  }, o.prototype.readDoubleLE = function(w, S) {
    return w = w >>> 0, S || Je(w, 8, this.length), n.read(this, w, !0, 52, 8);
  }, o.prototype.readDoubleBE = function(w, S) {
    return w = w >>> 0, S || Je(w, 8, this.length), n.read(this, w, !1, 52, 8);
  };
  function Le($, w, S, k, U, z) {
    if (!o.isBuffer($)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (w > U || w < z) throw new RangeError('"value" argument is out of bounds');
    if (S + k > $.length) throw new RangeError("Index out of range");
  }
  o.prototype.writeUintLE = o.prototype.writeUIntLE = function(w, S, k, U) {
    if (w = +w, S = S >>> 0, k = k >>> 0, !U) {
      const he = Math.pow(2, 8 * k) - 1;
      Le(this, w, S, k, he, 0);
    }
    let z = 1, G = 0;
    for (this[S] = w & 255; ++G < k && (z *= 256); )
      this[S + G] = w / z & 255;
    return S + k;
  }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(w, S, k, U) {
    if (w = +w, S = S >>> 0, k = k >>> 0, !U) {
      const he = Math.pow(2, 8 * k) - 1;
      Le(this, w, S, k, he, 0);
    }
    let z = k - 1, G = 1;
    for (this[S + z] = w & 255; --z >= 0 && (G *= 256); )
      this[S + z] = w / G & 255;
    return S + k;
  }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(w, S, k) {
    return w = +w, S = S >>> 0, k || Le(this, w, S, 1, 255, 0), this[S] = w & 255, S + 1;
  }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(w, S, k) {
    return w = +w, S = S >>> 0, k || Le(this, w, S, 2, 65535, 0), this[S] = w & 255, this[S + 1] = w >>> 8, S + 2;
  }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(w, S, k) {
    return w = +w, S = S >>> 0, k || Le(this, w, S, 2, 65535, 0), this[S] = w >>> 8, this[S + 1] = w & 255, S + 2;
  }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(w, S, k) {
    return w = +w, S = S >>> 0, k || Le(this, w, S, 4, 4294967295, 0), this[S + 3] = w >>> 24, this[S + 2] = w >>> 16, this[S + 1] = w >>> 8, this[S] = w & 255, S + 4;
  }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(w, S, k) {
    return w = +w, S = S >>> 0, k || Le(this, w, S, 4, 4294967295, 0), this[S] = w >>> 24, this[S + 1] = w >>> 16, this[S + 2] = w >>> 8, this[S + 3] = w & 255, S + 4;
  };
  function Xt($, w, S, k, U) {
    ma(w, k, U, $, S, 7);
    let z = Number(w & BigInt(4294967295));
    $[S++] = z, z = z >> 8, $[S++] = z, z = z >> 8, $[S++] = z, z = z >> 8, $[S++] = z;
    let G = Number(w >> BigInt(32) & BigInt(4294967295));
    return $[S++] = G, G = G >> 8, $[S++] = G, G = G >> 8, $[S++] = G, G = G >> 8, $[S++] = G, S;
  }
  function Xe($, w, S, k, U) {
    ma(w, k, U, $, S, 7);
    let z = Number(w & BigInt(4294967295));
    $[S + 7] = z, z = z >> 8, $[S + 6] = z, z = z >> 8, $[S + 5] = z, z = z >> 8, $[S + 4] = z;
    let G = Number(w >> BigInt(32) & BigInt(4294967295));
    return $[S + 3] = G, G = G >> 8, $[S + 2] = G, G = G >> 8, $[S + 1] = G, G = G >> 8, $[S] = G, S + 8;
  }
  o.prototype.writeBigUInt64LE = Yt(function(w, S = 0) {
    return Xt(this, w, S, BigInt(0), BigInt("0xffffffffffffffff"));
  }), o.prototype.writeBigUInt64BE = Yt(function(w, S = 0) {
    return Xe(this, w, S, BigInt(0), BigInt("0xffffffffffffffff"));
  }), o.prototype.writeIntLE = function(w, S, k, U) {
    if (w = +w, S = S >>> 0, !U) {
      const Ze = Math.pow(2, 8 * k - 1);
      Le(this, w, S, k, Ze - 1, -Ze);
    }
    let z = 0, G = 1, he = 0;
    for (this[S] = w & 255; ++z < k && (G *= 256); )
      w < 0 && he === 0 && this[S + z - 1] !== 0 && (he = 1), this[S + z] = (w / G >> 0) - he & 255;
    return S + k;
  }, o.prototype.writeIntBE = function(w, S, k, U) {
    if (w = +w, S = S >>> 0, !U) {
      const Ze = Math.pow(2, 8 * k - 1);
      Le(this, w, S, k, Ze - 1, -Ze);
    }
    let z = k - 1, G = 1, he = 0;
    for (this[S + z] = w & 255; --z >= 0 && (G *= 256); )
      w < 0 && he === 0 && this[S + z + 1] !== 0 && (he = 1), this[S + z] = (w / G >> 0) - he & 255;
    return S + k;
  }, o.prototype.writeInt8 = function(w, S, k) {
    return w = +w, S = S >>> 0, k || Le(this, w, S, 1, 127, -128), w < 0 && (w = 255 + w + 1), this[S] = w & 255, S + 1;
  }, o.prototype.writeInt16LE = function(w, S, k) {
    return w = +w, S = S >>> 0, k || Le(this, w, S, 2, 32767, -32768), this[S] = w & 255, this[S + 1] = w >>> 8, S + 2;
  }, o.prototype.writeInt16BE = function(w, S, k) {
    return w = +w, S = S >>> 0, k || Le(this, w, S, 2, 32767, -32768), this[S] = w >>> 8, this[S + 1] = w & 255, S + 2;
  }, o.prototype.writeInt32LE = function(w, S, k) {
    return w = +w, S = S >>> 0, k || Le(this, w, S, 4, 2147483647, -2147483648), this[S] = w & 255, this[S + 1] = w >>> 8, this[S + 2] = w >>> 16, this[S + 3] = w >>> 24, S + 4;
  }, o.prototype.writeInt32BE = function(w, S, k) {
    return w = +w, S = S >>> 0, k || Le(this, w, S, 4, 2147483647, -2147483648), w < 0 && (w = 4294967295 + w + 1), this[S] = w >>> 24, this[S + 1] = w >>> 16, this[S + 2] = w >>> 8, this[S + 3] = w & 255, S + 4;
  }, o.prototype.writeBigInt64LE = Yt(function(w, S = 0) {
    return Xt(this, w, S, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), o.prototype.writeBigInt64BE = Yt(function(w, S = 0) {
    return Xe(this, w, S, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Ft($, w, S, k, U, z) {
    if (S + k > $.length) throw new RangeError("Index out of range");
    if (S < 0) throw new RangeError("Index out of range");
  }
  function zn($, w, S, k, U) {
    return w = +w, S = S >>> 0, U || Ft($, w, S, 4), n.write($, w, S, k, 23, 4), S + 4;
  }
  o.prototype.writeFloatLE = function(w, S, k) {
    return zn(this, w, S, !0, k);
  }, o.prototype.writeFloatBE = function(w, S, k) {
    return zn(this, w, S, !1, k);
  };
  function pa($, w, S, k, U) {
    return w = +w, S = S >>> 0, U || Ft($, w, S, 8), n.write($, w, S, k, 52, 8), S + 8;
  }
  o.prototype.writeDoubleLE = function(w, S, k) {
    return pa(this, w, S, !0, k);
  }, o.prototype.writeDoubleBE = function(w, S, k) {
    return pa(this, w, S, !1, k);
  }, o.prototype.copy = function(w, S, k, U) {
    if (!o.isBuffer(w)) throw new TypeError("argument should be a Buffer");
    if (k || (k = 0), !U && U !== 0 && (U = this.length), S >= w.length && (S = w.length), S || (S = 0), U > 0 && U < k && (U = k), U === k || w.length === 0 || this.length === 0) return 0;
    if (S < 0)
      throw new RangeError("targetStart out of bounds");
    if (k < 0 || k >= this.length) throw new RangeError("Index out of range");
    if (U < 0) throw new RangeError("sourceEnd out of bounds");
    U > this.length && (U = this.length), w.length - S < U - k && (U = w.length - S + k);
    const z = U - k;
    return this === w && typeof i.prototype.copyWithin == "function" ? this.copyWithin(S, k, U) : i.prototype.set.call(
      w,
      this.subarray(k, U),
      S
    ), z;
  }, o.prototype.fill = function(w, S, k, U) {
    if (typeof w == "string") {
      if (typeof S == "string" ? (U = S, S = 0, k = this.length) : typeof k == "string" && (U = k, k = this.length), U !== void 0 && typeof U != "string")
        throw new TypeError("encoding must be a string");
      if (typeof U == "string" && !o.isEncoding(U))
        throw new TypeError("Unknown encoding: " + U);
      if (w.length === 1) {
        const G = w.charCodeAt(0);
        (U === "utf8" && G < 128 || U === "latin1") && (w = G);
      }
    } else typeof w == "number" ? w = w & 255 : typeof w == "boolean" && (w = Number(w));
    if (S < 0 || this.length < S || this.length < k)
      throw new RangeError("Out of range index");
    if (k <= S)
      return this;
    S = S >>> 0, k = k === void 0 ? this.length : k >>> 0, w || (w = 0);
    let z;
    if (typeof w == "number")
      for (z = S; z < k; ++z)
        this[z] = w;
    else {
      const G = o.isBuffer(w) ? w : o.from(w, U), he = G.length;
      if (he === 0)
        throw new TypeError('The value "' + w + '" is invalid for argument "value"');
      for (z = 0; z < k - S; ++z)
        this[z + S] = G[z % he];
    }
    return this;
  };
  const Qt = {};
  function dn($, w, S) {
    Qt[$] = class extends S {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: w.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${$}]`, delete this.name;
      }
      get code() {
        return $;
      }
      set code(U) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: U,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${$}]: ${this.message}`;
      }
    };
  }
  dn(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function($) {
      return $ ? `${$} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), dn(
    "ERR_INVALID_ARG_TYPE",
    function($, w) {
      return `The "${$}" argument must be of type number. Received type ${typeof w}`;
    },
    TypeError
  ), dn(
    "ERR_OUT_OF_RANGE",
    function($, w, S) {
      let k = `The value of "${$}" is out of range.`, U = S;
      return Number.isInteger(S) && Math.abs(S) > 2 ** 32 ? U = go(String(S)) : typeof S == "bigint" && (U = String(S), (S > BigInt(2) ** BigInt(32) || S < -(BigInt(2) ** BigInt(32))) && (U = go(U)), U += "n"), k += ` It must be ${w}. Received ${U}`, k;
    },
    RangeError
  );
  function go($) {
    let w = "", S = $.length;
    const k = $[0] === "-" ? 1 : 0;
    for (; S >= k + 4; S -= 3)
      w = `_${$.slice(S - 3, S)}${w}`;
    return `${$.slice(0, S)}${w}`;
  }
  function fn($, w, S) {
    qe(w, "offset"), ($[w] === void 0 || $[w + S] === void 0) && Zn(w, $.length - (S + 1));
  }
  function ma($, w, S, k, U, z) {
    if ($ > S || $ < w) {
      const G = typeof w == "bigint" ? "n" : "";
      let he;
      throw w === 0 || w === BigInt(0) ? he = `>= 0${G} and < 2${G} ** ${(z + 1) * 8}${G}` : he = `>= -(2${G} ** ${(z + 1) * 8 - 1}${G}) and < 2 ** ${(z + 1) * 8 - 1}${G}`, new Qt.ERR_OUT_OF_RANGE("value", he, $);
    }
    fn(k, U, z);
  }
  function qe($, w) {
    if (typeof $ != "number")
      throw new Qt.ERR_INVALID_ARG_TYPE(w, "number", $);
  }
  function Zn($, w, S) {
    throw Math.floor($) !== $ ? (qe($, S), new Qt.ERR_OUT_OF_RANGE("offset", "an integer", $)) : w < 0 ? new Qt.ERR_BUFFER_OUT_OF_BOUNDS() : new Qt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${w}`,
      $
    );
  }
  const Kn = /[^+/0-9A-Za-z-_]/g;
  function iu($) {
    if ($ = $.split("=")[0], $ = $.trim().replace(Kn, ""), $.length < 2) return "";
    for (; $.length % 4 !== 0; )
      $ = $ + "=";
    return $;
  }
  function _o($, w) {
    w = w || 1 / 0;
    let S;
    const k = $.length;
    let U = null;
    const z = [];
    for (let G = 0; G < k; ++G) {
      if (S = $.charCodeAt(G), S > 55295 && S < 57344) {
        if (!U) {
          if (S > 56319) {
            (w -= 3) > -1 && z.push(239, 191, 189);
            continue;
          } else if (G + 1 === k) {
            (w -= 3) > -1 && z.push(239, 191, 189);
            continue;
          }
          U = S;
          continue;
        }
        if (S < 56320) {
          (w -= 3) > -1 && z.push(239, 191, 189), U = S;
          continue;
        }
        S = (U - 55296 << 10 | S - 56320) + 65536;
      } else U && (w -= 3) > -1 && z.push(239, 191, 189);
      if (U = null, S < 128) {
        if ((w -= 1) < 0) break;
        z.push(S);
      } else if (S < 2048) {
        if ((w -= 2) < 0) break;
        z.push(
          S >> 6 | 192,
          S & 63 | 128
        );
      } else if (S < 65536) {
        if ((w -= 3) < 0) break;
        z.push(
          S >> 12 | 224,
          S >> 6 & 63 | 128,
          S & 63 | 128
        );
      } else if (S < 1114112) {
        if ((w -= 4) < 0) break;
        z.push(
          S >> 18 | 240,
          S >> 12 & 63 | 128,
          S >> 6 & 63 | 128,
          S & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return z;
  }
  function yo($) {
    const w = [];
    for (let S = 0; S < $.length; ++S)
      w.push($.charCodeAt(S) & 255);
    return w;
  }
  function $n($, w) {
    let S, k, U;
    const z = [];
    for (let G = 0; G < $.length && !((w -= 2) < 0); ++G)
      S = $.charCodeAt(G), k = S >> 8, U = S % 256, z.push(U), z.push(k);
    return z;
  }
  function Vs($) {
    return e.toByteArray(iu($));
  }
  function ba($, w, S, k) {
    let U;
    for (U = 0; U < k && !(U + S >= w.length || U >= $.length); ++U)
      w[U + S] = $[U];
    return U;
  }
  function wt($, w) {
    return $ instanceof w || $ != null && $.constructor != null && $.constructor.name != null && $.constructor.name === w.name;
  }
  function _r($) {
    return $ !== $;
  }
  const vo = function() {
    const $ = "0123456789abcdef", w = new Array(256);
    for (let S = 0; S < 16; ++S) {
      const k = S * 16;
      for (let U = 0; U < 16; ++U)
        w[k + U] = $[S] + $[U];
    }
    return w;
  }();
  function Yt($) {
    return typeof BigInt > "u" ? Hd : $;
  }
  function Hd() {
    throw new Error("BigInt not supported");
  }
})(lP);
const st = lP.Buffer, wu = "4.89.1";
let iy = !1, kl, fP, hP, hb, pP, mP, bP, gP, _P;
function dA(t, e = { auto: !1 }) {
  if (iy)
    throw new Error(`you must \`import 'openai/shims/${t.kind}'\` before importing anything else from openai`);
  if (kl)
    throw new Error(`can't \`import 'openai/shims/${t.kind}'\` after \`import 'openai/shims/${kl}'\``);
  iy = e.auto, kl = t.kind, fP = t.fetch, hP = t.FormData, hb = t.File, pP = t.ReadableStream, mP = t.getMultipartRequestOptions, bP = t.getDefaultAgent, gP = t.fileFromPath, _P = t.isFsReadStream;
}
let fA = class {
  constructor(e) {
    this.body = e;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};
function hA({ manuallyImported: t } = {}) {
  const e = t ? "You may need to use polyfills" : "Add one of these imports before your first `import  from 'openai'`:\n- `import 'openai/shims/node'` (if you're running on Node)\n- `import 'openai/shims/web'` (otherwise)\n";
  let n, a, r, i;
  try {
    n = fetch, a = Request, r = Response, i = Headers;
  } catch (s) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${s.message}. ${e}`);
  }
  return {
    kind: "web",
    fetch: n,
    Request: a,
    Response: r,
    Headers: i,
    FormData: (
      // @ts-ignore
      typeof FormData < "u" ? FormData : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`);
        }
      }
    ),
    Blob: typeof Blob < "u" ? Blob : class {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File < "u" ? File : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream < "u" ? ReadableStream : class {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`);
        }
      }
    ),
    getMultipartRequestOptions: async (s, u) => ({
      ...u,
      body: new fA(s)
    }),
    getDefaultAgent: (s) => {
    },
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (s) => !1
  };
}
kl || dA(hA(), { auto: !0 });
class le extends Error {
}
let on = class pb extends le {
  constructor(e, n, a, r) {
    super(`${pb.makeMessage(e, n, a)}`), this.status = e, this.headers = r, this.request_id = r?.["x-request-id"], this.error = n;
    const i = n;
    this.code = i?.code, this.param = i?.param, this.type = i?.type;
  }
  static makeMessage(e, n, a) {
    const r = n?.message ? typeof n.message == "string" ? n.message : JSON.stringify(n.message) : n ? JSON.stringify(n) : a;
    return e && r ? `${e} ${r}` : e ? `${e} status code (no body)` : r || "(no status code or body)";
  }
  static generate(e, n, a, r) {
    if (!e || !r)
      return new Gh({ message: a, cause: bb(n) });
    const i = n?.error;
    return e === 400 ? new yP(e, i, a, r) : e === 401 ? new vP(e, i, a, r) : e === 403 ? new wP(e, i, a, r) : e === 404 ? new SP(e, i, a, r) : e === 409 ? new OP(e, i, a, r) : e === 422 ? new jP(e, i, a, r) : e === 429 ? new PP(e, i, a, r) : e >= 500 ? new CP(e, i, a, r) : new pb(e, i, a, r);
  }
}, vn = class extends on {
  constructor({ message: e } = {}) {
    super(void 0, void 0, e || "Request was aborted.", void 0);
  }
}, Gh = class extends on {
  constructor({ message: e, cause: n }) {
    super(void 0, void 0, e || "Connection error.", void 0), n && (this.cause = n);
  }
}, Wh = class extends Gh {
  constructor({ message: e } = {}) {
    super({ message: e ?? "Request timed out." });
  }
}, yP = class extends on {
}, vP = class extends on {
}, wP = class extends on {
}, SP = class extends on {
}, OP = class extends on {
}, jP = class extends on {
}, PP = class extends on {
}, CP = class extends on {
};
class RP extends le {
  constructor() {
    super("Could not parse response content as the length limit was reached");
  }
}
class TP extends le {
  constructor() {
    super("Could not parse response content as the request was rejected by the content filter");
  }
}
var Wd = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, wo = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, pn;
let Xh = class {
  constructor() {
    pn.set(this, void 0), this.buffer = new Uint8Array(), Wd(this, pn, null, "f");
  }
  decode(e) {
    if (e == null)
      return [];
    const n = e instanceof ArrayBuffer ? new Uint8Array(e) : typeof e == "string" ? new TextEncoder().encode(e) : e;
    let a = new Uint8Array(this.buffer.length + n.length);
    a.set(this.buffer), a.set(n, this.buffer.length), this.buffer = a;
    const r = [];
    let i;
    for (; (i = pA(this.buffer, wo(this, pn, "f"))) != null; ) {
      if (i.carriage && wo(this, pn, "f") == null) {
        Wd(this, pn, i.index, "f");
        continue;
      }
      if (wo(this, pn, "f") != null && (i.index !== wo(this, pn, "f") + 1 || i.carriage)) {
        r.push(this.decodeText(this.buffer.slice(0, wo(this, pn, "f") - 1))), this.buffer = this.buffer.slice(wo(this, pn, "f")), Wd(this, pn, null, "f");
        continue;
      }
      const s = wo(this, pn, "f") !== null ? i.preceding - 1 : i.preceding, u = this.decodeText(this.buffer.slice(0, s));
      r.push(u), this.buffer = this.buffer.slice(i.index), Wd(this, pn, null, "f");
    }
    return r;
  }
  decodeText(e) {
    if (e == null)
      return "";
    if (typeof e == "string")
      return e;
    if (typeof st < "u") {
      if (e instanceof st)
        return e.toString();
      if (e instanceof Uint8Array)
        return st.from(e).toString();
      throw new le(`Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder < "u") {
      if (e instanceof Uint8Array || e instanceof ArrayBuffer)
        return this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8")), this.textDecoder.decode(e);
      throw new le(`Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new le("Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.");
  }
  flush() {
    return this.buffer.length ? this.decode(`
`) : [];
  }
};
pn = /* @__PURE__ */ new WeakMap();
Xh.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r"]);
Xh.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function pA(t, e) {
  for (let r = e ?? 0; r < t.length; r++) {
    if (t[r] === 10)
      return { preceding: r, index: r + 1, carriage: !1 };
    if (t[r] === 13)
      return { preceding: r, index: r + 1, carriage: !0 };
  }
  return null;
}
function mA(t) {
  for (let a = 0; a < t.length - 1; a++) {
    if (t[a] === 10 && t[a + 1] === 10 || t[a] === 13 && t[a + 1] === 13)
      return a + 2;
    if (t[a] === 13 && t[a + 1] === 10 && a + 3 < t.length && t[a + 2] === 13 && t[a + 3] === 10)
      return a + 4;
  }
  return -1;
}
function $P(t) {
  if (t[Symbol.asyncIterator])
    return t;
  const e = t.getReader();
  return {
    async next() {
      try {
        const n = await e.read();
        return n?.done && e.releaseLock(), n;
      } catch (n) {
        throw e.releaseLock(), n;
      }
    },
    async return() {
      const n = e.cancel();
      return e.releaseLock(), await n, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
let Hl = class jl {
  constructor(e, n) {
    this.iterator = e, this.controller = n;
  }
  static fromSSEResponse(e, n) {
    let a = !1;
    async function* r() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let i = !1;
      try {
        for await (const s of bA(e, n))
          if (!i) {
            if (s.data.startsWith("[DONE]")) {
              i = !0;
              continue;
            }
            if (s.event === null || s.event.startsWith("response.")) {
              let u;
              try {
                u = JSON.parse(s.data);
              } catch (d) {
                throw console.error("Could not parse message into JSON:", s.data), console.error("From chunk:", s.raw), d;
              }
              if (u && u.error)
                throw new on(void 0, u.error, void 0, void 0);
              yield u;
            } else {
              let u;
              try {
                u = JSON.parse(s.data);
              } catch (d) {
                throw console.error("Could not parse message into JSON:", s.data), console.error("From chunk:", s.raw), d;
              }
              if (s.event == "error")
                throw new on(void 0, u.error, u.message, void 0);
              yield { event: s.event, data: u };
            }
          }
        i = !0;
      } catch (s) {
        if (s instanceof Error && s.name === "AbortError")
          return;
        throw s;
      } finally {
        i || n.abort();
      }
    }
    return new jl(r, n);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(e, n) {
    let a = !1;
    async function* r() {
      const s = new Xh(), u = $P(e);
      for await (const d of u)
        for (const f of s.decode(d))
          yield f;
      for (const d of s.flush())
        yield d;
    }
    async function* i() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let s = !1;
      try {
        for await (const u of r())
          s || u && (yield JSON.parse(u));
        s = !0;
      } catch (u) {
        if (u instanceof Error && u.name === "AbortError")
          return;
        throw u;
      } finally {
        s || n.abort();
      }
    }
    return new jl(i, n);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const e = [], n = [], a = this.iterator(), r = (i) => ({
      next: () => {
        if (i.length === 0) {
          const s = a.next();
          e.push(s), n.push(s);
        }
        return i.shift();
      }
    });
    return [
      new jl(() => r(e), this.controller),
      new jl(() => r(n), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const e = this;
    let n;
    const a = new TextEncoder();
    return new pP({
      async start() {
        n = e[Symbol.asyncIterator]();
      },
      async pull(r) {
        try {
          const { value: i, done: s } = await n.next();
          if (s)
            return r.close();
          const u = a.encode(JSON.stringify(i) + `
`);
          r.enqueue(u);
        } catch (i) {
          r.error(i);
        }
      },
      async cancel() {
        await n.return?.();
      }
    });
  }
};
async function* bA(t, e) {
  if (!t.body)
    throw e.abort(), new le("Attempted to iterate over a response with no body");
  const n = new _A(), a = new Xh(), r = $P(t.body);
  for await (const i of gA(r))
    for (const s of a.decode(i)) {
      const u = n.decode(s);
      u && (yield u);
    }
  for (const i of a.flush()) {
    const s = n.decode(i);
    s && (yield s);
  }
}
async function* gA(t) {
  let e = new Uint8Array();
  for await (const n of t) {
    if (n == null)
      continue;
    const a = n instanceof ArrayBuffer ? new Uint8Array(n) : typeof n == "string" ? new TextEncoder().encode(n) : n;
    let r = new Uint8Array(e.length + a.length);
    r.set(e), r.set(a, e.length), e = r;
    let i;
    for (; (i = mA(e)) !== -1; )
      yield e.slice(0, i), e = e.slice(i);
  }
  e.length > 0 && (yield e);
}
let _A = class {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(e) {
    if (e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e) {
      if (!this.event && !this.data.length)
        return null;
      const i = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], i;
    }
    if (this.chunks.push(e), e.startsWith(":"))
      return null;
    let [n, a, r] = yA(e, ":");
    return r.startsWith(" ") && (r = r.substring(1)), n === "event" ? this.event = r : n === "data" && this.data.push(r), null;
  }
};
function yA(t, e) {
  const n = t.indexOf(e);
  return n !== -1 ? [t.substring(0, n), e, t.substring(n + e.length)] : [t, "", ""];
}
const MP = (t) => t != null && typeof t == "object" && typeof t.url == "string" && typeof t.blob == "function", AP = (t) => t != null && typeof t == "object" && typeof t.name == "string" && typeof t.lastModified == "number" && Qh(t), Qh = (t) => t != null && typeof t == "object" && typeof t.size == "number" && typeof t.type == "string" && typeof t.text == "function" && typeof t.slice == "function" && typeof t.arrayBuffer == "function", vA = (t) => AP(t) || MP(t) || _P(t);
async function EP(t, e, n) {
  if (t = await t, AP(t))
    return t;
  if (MP(t)) {
    const r = await t.blob();
    e || (e = new URL(t.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const i = Qh(r) ? [await r.arrayBuffer()] : [r];
    return new hb(i, e, n);
  }
  const a = await wA(t);
  if (e || (e = OA(t) ?? "unknown_file"), !n?.type) {
    const r = a[0]?.type;
    typeof r == "string" && (n = { ...n, type: r });
  }
  return new hb(a, e, n);
}
async function wA(t) {
  let e = [];
  if (typeof t == "string" || ArrayBuffer.isView(t) || // includes Uint8Array, Buffer, etc.
  t instanceof ArrayBuffer)
    e.push(t);
  else if (Qh(t))
    e.push(await t.arrayBuffer());
  else if (jA(t))
    for await (const n of t)
      e.push(n);
  else
    throw new Error(`Unexpected data type: ${typeof t}; constructor: ${t?.constructor?.name}; props: ${SA(t)}`);
  return e;
}
function SA(t) {
  return `[${Object.getOwnPropertyNames(t).map((n) => `"${n}"`).join(", ")}]`;
}
function OA(t) {
  return Bp(t.name) || Bp(t.filename) || // For fs.ReadStream
  Bp(t.path)?.split(/[\\/]/).pop();
}
const Bp = (t) => {
  if (typeof t == "string")
    return t;
  if (typeof st < "u" && t instanceof st)
    return String(t);
}, jA = (t) => t != null && typeof t == "object" && typeof t[Symbol.asyncIterator] == "function", sy = (t) => t && typeof t == "object" && t.body && t[Symbol.toStringTag] === "MultipartBody", Lu = async (t) => {
  const e = await PA(t.body);
  return mP(e, t);
}, PA = async (t) => {
  const e = new hP();
  return await Promise.all(Object.entries(t || {}).map(([n, a]) => mb(e, n, a))), e;
}, mb = async (t, e, n) => {
  if (n !== void 0) {
    if (n == null)
      throw new TypeError(`Received null for "${e}"; to pass null in FormData, you must use the string 'null'`);
    if (typeof n == "string" || typeof n == "number" || typeof n == "boolean")
      t.append(e, String(n));
    else if (vA(n)) {
      const a = await EP(n);
      t.append(e, a);
    } else if (Array.isArray(n))
      await Promise.all(n.map((a) => mb(t, e + "[]", a)));
    else if (typeof n == "object")
      await Promise.all(Object.entries(n).map(([a, r]) => mb(t, `${e}[${a}]`, r)));
    else
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${n} instead`);
  }
};
var CA = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, RA = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, Xd;
async function IP(t) {
  const { response: e } = t;
  if (t.options.stream)
    return Fu("response", e.status, e.url, e.headers, e.body), t.options.__streamClass ? t.options.__streamClass.fromSSEResponse(e, t.controller) : Hl.fromSSEResponse(e, t.controller);
  if (e.status === 204)
    return null;
  if (t.options.__binaryResponse)
    return e;
  const a = e.headers.get("content-type")?.split(";")[0]?.trim();
  if (a?.includes("application/json") || a?.endsWith("+json")) {
    const s = await e.json();
    return Fu("response", e.status, e.url, e.headers, s), NP(s, e);
  }
  const i = await e.text();
  return Fu("response", e.status, e.url, e.headers, i), i;
}
function NP(t, e) {
  return !t || typeof t != "object" || Array.isArray(t) ? t : Object.defineProperty(t, "_request_id", {
    value: e.headers.get("x-request-id"),
    enumerable: !1
  });
}
let FP = class kP extends Promise {
  constructor(e, n = IP) {
    super((a) => {
      a(null);
    }), this.responsePromise = e, this.parseResponse = n;
  }
  _thenUnwrap(e) {
    return new kP(this.responsePromise, async (n) => NP(e(await this.parseResponse(n), n), n.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((e) => e.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [e, n] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: e, response: n, request_id: n.headers.get("x-request-id") };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)), this.parsedPromise;
  }
  then(e, n) {
    return this.parse().then(e, n);
  }
  catch(e) {
    return this.parse().catch(e);
  }
  finally(e) {
    return this.parse().finally(e);
  }
}, TA = class {
  constructor({
    baseURL: e,
    maxRetries: n = 2,
    timeout: a = 6e5,
    // 10 minutes
    httpAgent: r,
    fetch: i
  }) {
    this.baseURL = e, this.maxRetries = xp("maxRetries", n), this.timeout = xp("timeout", a), this.httpAgent = r, this.fetch = i ?? fP;
  }
  authHeaders(e) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(e) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...NA(),
      ...this.authHeaders(e)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(e, n) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${qA()}`;
  }
  get(e, n) {
    return this.methodRequest("get", e, n);
  }
  post(e, n) {
    return this.methodRequest("post", e, n);
  }
  patch(e, n) {
    return this.methodRequest("patch", e, n);
  }
  put(e, n) {
    return this.methodRequest("put", e, n);
  }
  delete(e, n) {
    return this.methodRequest("delete", e, n);
  }
  methodRequest(e, n, a) {
    return this.request(Promise.resolve(a).then(async (r) => {
      const i = r && Qh(r?.body) ? new DataView(await r.body.arrayBuffer()) : r?.body instanceof DataView ? r.body : r?.body instanceof ArrayBuffer ? new DataView(r.body) : r && ArrayBuffer.isView(r?.body) ? new DataView(r.body.buffer) : r?.body;
      return { method: e, path: n, ...r, body: i };
    }));
  }
  getAPIList(e, n, a) {
    return this.requestAPIList(n, { method: "get", path: e, ...a });
  }
  calculateContentLength(e) {
    if (typeof e == "string") {
      if (typeof st < "u")
        return st.byteLength(e, "utf8").toString();
      if (typeof TextEncoder < "u")
        return new TextEncoder().encode(e).length.toString();
    } else if (ArrayBuffer.isView(e))
      return e.byteLength.toString();
    return null;
  }
  buildRequest(e, { retryCount: n = 0 } = {}) {
    e = { ...e };
    const { method: a, path: r, query: i, headers: s = {} } = e, u = ArrayBuffer.isView(e.body) || e.__binaryRequest && typeof e.body == "string" ? e.body : sy(e.body) ? e.body.body : e.body ? JSON.stringify(e.body, null, 2) : null, d = this.calculateContentLength(u), f = this.buildURL(r, i);
    "timeout" in e && xp("timeout", e.timeout), e.timeout = e.timeout ?? this.timeout;
    const o = e.httpAgent ?? this.httpAgent ?? bP(f), c = e.timeout + 1e3;
    typeof o?.options?.timeout == "number" && c > (o.options.timeout ?? 0) && (o.options.timeout = c), this.idempotencyHeader && a !== "get" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()), s[this.idempotencyHeader] = e.idempotencyKey);
    const h = this.buildHeaders({ options: e, headers: s, contentLength: d, retryCount: n });
    return { req: {
      method: a,
      ...u && { body: u },
      headers: h,
      ...o && { agent: o },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: e.signal ?? null
    }, url: f, timeout: e.timeout };
  }
  buildHeaders({ options: e, headers: n, contentLength: a, retryCount: r }) {
    const i = {};
    a && (i["content-length"] = a);
    const s = this.defaultHeaders(e);
    return ly(i, s), ly(i, n), sy(e.body) && kl !== "node" && delete i["content-type"], Yd(s, "x-stainless-retry-count") === void 0 && Yd(n, "x-stainless-retry-count") === void 0 && (i["x-stainless-retry-count"] = String(r)), Yd(s, "x-stainless-timeout") === void 0 && Yd(n, "x-stainless-timeout") === void 0 && e.timeout && (i["x-stainless-timeout"] = String(e.timeout)), this.validateHeaders(i, n), i;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(e) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(e, { url: n, options: a }) {
  }
  parseHeaders(e) {
    return e ? Symbol.iterator in e ? Object.fromEntries(Array.from(e).map((n) => [...n])) : { ...e } : {};
  }
  makeStatusError(e, n, a, r) {
    return on.generate(e, n, a, r);
  }
  request(e, n = null) {
    return new FP(this.makeRequest(e, n));
  }
  async makeRequest(e, n) {
    const a = await e, r = a.maxRetries ?? this.maxRetries;
    n == null && (n = r), await this.prepareOptions(a);
    const { req: i, url: s, timeout: u } = this.buildRequest(a, { retryCount: r - n });
    if (await this.prepareRequest(i, { url: s, options: a }), Fu("request", s, a, i.headers), a.signal?.aborted)
      throw new vn();
    const d = new AbortController(), f = await this.fetchWithTimeout(s, i, u, d).catch(bb);
    if (f instanceof Error) {
      if (a.signal?.aborted)
        throw new vn();
      if (n)
        return this.retryRequest(a, n);
      throw f.name === "AbortError" ? new Wh() : new Gh({ cause: f });
    }
    const o = MA(f.headers);
    if (!f.ok) {
      if (n && this.shouldRetry(f)) {
        const b = `retrying, ${n} attempts remaining`;
        return Fu(`response (error; ${b})`, f.status, s, o), this.retryRequest(a, n, o);
      }
      const c = await f.text().catch((b) => bb(b).message), h = FA(c), p = h ? void 0 : c;
      throw Fu(`response (error; ${n ? "(error; no more retries left)" : "(error; not retryable)"})`, f.status, s, o, p), this.makeStatusError(f.status, h, p, o);
    }
    return { response: f, options: a, controller: d };
  }
  requestAPIList(e, n) {
    const a = this.makeRequest(n, null);
    return new $A(this, a, e);
  }
  buildURL(e, n) {
    const a = DA(e) ? new URL(e) : new URL(this.baseURL + (this.baseURL.endsWith("/") && e.startsWith("/") ? e.slice(1) : e)), r = this.defaultQuery();
    return qP(r) || (n = { ...r, ...n }), typeof n == "object" && n && !Array.isArray(n) && (a.search = this.stringifyQuery(n)), a.toString();
  }
  stringifyQuery(e) {
    return Object.entries(e).filter(([n, a]) => typeof a < "u").map(([n, a]) => {
      if (typeof a == "string" || typeof a == "number" || typeof a == "boolean")
        return `${encodeURIComponent(n)}=${encodeURIComponent(a)}`;
      if (a === null)
        return `${encodeURIComponent(n)}=`;
      throw new le(`Cannot stringify type ${typeof a}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(e, n, a, r) {
    const { signal: i, ...s } = n || {};
    i && i.addEventListener("abort", () => r.abort());
    const u = setTimeout(() => r.abort(), a), d = {
      signal: r.signal,
      ...s
    };
    return d.method && (d.method = d.method.toUpperCase()), // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
    this.fetch.call(void 0, e, d).finally(() => {
      clearTimeout(u);
    });
  }
  shouldRetry(e) {
    const n = e.headers.get("x-should-retry");
    return n === "true" ? !0 : n === "false" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500;
  }
  async retryRequest(e, n, a) {
    let r;
    const i = a?.["retry-after-ms"];
    if (i) {
      const u = parseFloat(i);
      Number.isNaN(u) || (r = u);
    }
    const s = a?.["retry-after"];
    if (s && !r) {
      const u = parseFloat(s);
      Number.isNaN(u) ? r = Date.parse(s) - Date.now() : r = u * 1e3;
    }
    if (!(r && 0 <= r && r < 60 * 1e3)) {
      const u = e.maxRetries ?? this.maxRetries;
      r = this.calculateDefaultRetryTimeoutMillis(n, u);
    }
    return await Sd(r), this.makeRequest(e, n - 1);
  }
  calculateDefaultRetryTimeoutMillis(e, n) {
    const i = n - e, s = Math.min(0.5 * Math.pow(2, i), 8), u = 1 - Math.random() * 0.25;
    return s * u * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${wu}`;
  }
}, DP = class {
  constructor(e, n, a, r) {
    Xd.set(this, void 0), CA(this, Xd, e, "f"), this.options = r, this.response = n, this.body = a;
  }
  hasNextPage() {
    return this.getPaginatedItems().length ? this.nextPageInfo() != null : !1;
  }
  async getNextPage() {
    const e = this.nextPageInfo();
    if (!e)
      throw new le("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    const n = { ...this.options };
    if ("params" in e && typeof n.query == "object")
      n.query = { ...n.query, ...e.params };
    else if ("url" in e) {
      const a = [...Object.entries(n.query || {}), ...e.url.searchParams.entries()];
      for (const [r, i] of a)
        e.url.searchParams.set(r, i);
      n.query = void 0, n.path = e.url.toString();
    }
    return await RA(this, Xd, "f").requestAPIList(this.constructor, n);
  }
  async *iterPages() {
    let e = this;
    for (yield e; e.hasNextPage(); )
      e = await e.getNextPage(), yield e;
  }
  async *[(Xd = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const e of this.iterPages())
      for (const n of e.getPaginatedItems())
        yield n;
  }
}, $A = class extends FP {
  constructor(e, n, a) {
    super(n, async (r) => new a(e, r.response, await IP(r), r.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const e = await this;
    for await (const n of e)
      yield n;
  }
};
const MA = (t) => new Proxy(Object.fromEntries(
  // @ts-ignore
  t.entries()
), {
  get(e, n) {
    const a = n.toString();
    return e[a.toLowerCase()] || e[a];
  }
}), AA = {
  method: !0,
  path: !0,
  query: !0,
  body: !0,
  headers: !0,
  maxRetries: !0,
  stream: !0,
  timeout: !0,
  httpAgent: !0,
  signal: !0,
  idempotencyKey: !0,
  __metadata: !0,
  __binaryRequest: !0,
  __binaryResponse: !0,
  __streamClass: !0
}, Rt = (t) => typeof t == "object" && t !== null && !qP(t) && Object.keys(t).every((e) => JP(AA, e)), EA = () => {
  if (typeof Deno < "u" && Deno.build != null)
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": wu,
      "X-Stainless-OS": uy(Deno.build.os),
      "X-Stainless-Arch": oy(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": wu,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": pe.version
    };
  if (Object.prototype.toString.call(typeof pe < "u" ? pe : 0) === "[object process]")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": wu,
      "X-Stainless-OS": uy(pe.platform),
      "X-Stainless-Arch": oy(pe.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": pe.version
    };
  const t = IA();
  return t ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": wu,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${t.browser}`,
    "X-Stainless-Runtime-Version": t.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": wu,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function IA() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const t = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: e, pattern: n } of t) {
    const a = n.exec(navigator.userAgent);
    if (a) {
      const r = a[1] || 0, i = a[2] || 0, s = a[3] || 0;
      return { browser: e, version: `${r}.${i}.${s}` };
    }
  }
  return null;
}
const oy = (t) => t === "x32" ? "x32" : t === "x86_64" || t === "x64" ? "x64" : t === "arm" ? "arm" : t === "aarch64" || t === "arm64" ? "arm64" : t ? `other:${t}` : "unknown", uy = (t) => (t = t.toLowerCase(), t.includes("ios") ? "iOS" : t === "android" ? "Android" : t === "darwin" ? "MacOS" : t === "win32" ? "Windows" : t === "freebsd" ? "FreeBSD" : t === "openbsd" ? "OpenBSD" : t === "linux" ? "Linux" : t ? `Other:${t}` : "Unknown");
let cy;
const NA = () => cy ?? (cy = EA()), FA = (t) => {
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}, kA = /^[a-z][a-z0-9+.-]*:/i, DA = (t) => kA.test(t), Sd = (t) => new Promise((e) => setTimeout(e, t)), xp = (t, e) => {
  if (typeof e != "number" || !Number.isInteger(e))
    throw new le(`${t} must be an integer`);
  if (e < 0)
    throw new le(`${t} must be a positive integer`);
  return e;
}, bb = (t) => {
  if (t instanceof Error)
    return t;
  if (typeof t == "object" && t !== null)
    try {
      return new Error(JSON.stringify(t));
    } catch {
    }
  return new Error(t);
}, Qd = (t) => {
  if (typeof pe < "u")
    return pe.env?.[t]?.trim() ?? void 0;
  if (typeof Deno < "u")
    return Deno.env?.get?.(t)?.trim();
};
function qP(t) {
  if (!t)
    return !0;
  for (const e in t)
    return !1;
  return !0;
}
function JP(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function ly(t, e) {
  for (const n in e) {
    if (!JP(e, n))
      continue;
    const a = n.toLowerCase();
    if (!a)
      continue;
    const r = e[n];
    r === null ? delete t[a] : r !== void 0 && (t[a] = r);
  }
}
const dy = /* @__PURE__ */ new Set(["authorization", "api-key"]);
function Fu(t, ...e) {
  if (typeof pe < "u" && pe?.env?.DEBUG === "true") {
    const n = e.map((a) => {
      if (!a)
        return a;
      if (a.headers) {
        const i = { ...a, headers: { ...a.headers } };
        for (const s in a.headers)
          dy.has(s.toLowerCase()) && (i.headers[s] = "REDACTED");
        return i;
      }
      let r = null;
      for (const i in a)
        dy.has(i.toLowerCase()) && (r ?? (r = { ...a }), r[i] = "REDACTED");
      return r ?? a;
    });
    console.log(`OpenAI:DEBUG:${t}`, ...n);
  }
}
const qA = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
  const e = Math.random() * 16 | 0;
  return (t === "x" ? e : e & 3 | 8).toString(16);
}), JA = () => (
  // @ts-ignore
  typeof window < "u" && // @ts-ignore
  typeof window.document < "u" && // @ts-ignore
  typeof navigator < "u"
), LA = (t) => typeof t?.get == "function", Yd = (t, e) => {
  const n = e.toLowerCase();
  if (LA(t)) {
    const a = e[0]?.toUpperCase() + e.substring(1).replace(/([^\w])(\w)/g, (r, i, s) => i + s.toUpperCase());
    for (const r of [e, n, e.toUpperCase(), a]) {
      const i = t.get(r);
      if (i)
        return i;
    }
  }
  for (const [a, r] of Object.entries(t))
    if (a.toLowerCase() === n)
      return Array.isArray(r) ? (r.length <= 1 || console.warn(`Received ${r.length} entries for the ${e} header, using the first entry.`), r[0]) : r;
};
function Vp(t) {
  return t != null && typeof t == "object" && !Array.isArray(t);
}
let ig = class extends DP {
  constructor(e, n, a, r) {
    super(e, n, a, r), this.data = a.data || [], this.object = a.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
class ln extends DP {
  constructor(e, n, a, r) {
    super(e, n, a, r), this.data = a.data || [], this.has_more = a.has_more || !1;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const e = this.nextPageInfo();
    if (!e)
      return null;
    if ("params" in e)
      return e.params;
    const n = Object.fromEntries(e.url.searchParams);
    return Object.keys(n).length ? n : null;
  }
  nextPageInfo() {
    const e = this.getPaginatedItems();
    if (!e.length)
      return null;
    const n = e[e.length - 1]?.id;
    return n ? { params: { after: n } } : null;
  }
}
let Pe = class {
  constructor(e) {
    this._client = e;
  }
}, LP = class extends Pe {
  list(e, n = {}, a) {
    return Rt(n) ? this.list(e, {}, n) : this._client.getAPIList(`/chat/completions/${e}/messages`, UA, { query: n, ...a });
  }
}, Yh = class extends Pe {
  constructor() {
    super(...arguments), this.messages = new LP(this._client);
  }
  create(e, n) {
    return this._client.post("/chat/completions", { body: e, ...n, stream: e.stream ?? !1 });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   */
  retrieve(e, n) {
    return this._client.get(`/chat/completions/${e}`, n);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   */
  update(e, n, a) {
    return this._client.post(`/chat/completions/${e}`, { body: n, ...a });
  }
  list(e = {}, n) {
    return Rt(e) ? this.list({}, e) : this._client.getAPIList("/chat/completions", ep, { query: e, ...n });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   */
  del(e, n) {
    return this._client.delete(`/chat/completions/${e}`, n);
  }
};
class ep extends ln {
}
class UA extends ln {
}
Yh.ChatCompletionsPage = ep;
Yh.Messages = LP;
let tp = class extends Pe {
  constructor() {
    super(...arguments), this.completions = new Yh(this._client);
  }
};
tp.Completions = Yh;
tp.ChatCompletionsPage = ep;
class UP extends Pe {
  /**
   * Generates audio from the input text.
   */
  create(e, n) {
    return this._client.post("/audio/speech", {
      body: e,
      ...n,
      headers: { Accept: "application/octet-stream", ...n?.headers },
      __binaryResponse: !0
    });
  }
}
class BP extends Pe {
  create(e, n) {
    return this._client.post("/audio/transcriptions", Lu({ body: e, ...n, __metadata: { model: e.model } }));
  }
}
class xP extends Pe {
  create(e, n) {
    return this._client.post("/audio/translations", Lu({ body: e, ...n, __metadata: { model: e.model } }));
  }
}
class Od extends Pe {
  constructor() {
    super(...arguments), this.transcriptions = new BP(this._client), this.translations = new xP(this._client), this.speech = new UP(this._client);
  }
}
Od.Transcriptions = BP;
Od.Translations = xP;
Od.Speech = UP;
let sg = class extends Pe {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(e, n) {
    return this._client.post("/batches", { body: e, ...n });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(e, n) {
    return this._client.get(`/batches/${e}`, n);
  }
  list(e = {}, n) {
    return Rt(e) ? this.list({}, e) : this._client.getAPIList("/batches", og, { query: e, ...n });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(e, n) {
    return this._client.post(`/batches/${e}/cancel`, n);
  }
};
class og extends ln {
}
sg.BatchesPage = og;
class ug extends Pe {
  /**
   * Create an assistant with a model and instructions.
   */
  create(e, n) {
    return this._client.post("/assistants", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Retrieves an assistant.
   */
  retrieve(e, n) {
    return this._client.get(`/assistants/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Modifies an assistant.
   */
  update(e, n, a) {
    return this._client.post(`/assistants/${e}`, {
      body: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  list(e = {}, n) {
    return Rt(e) ? this.list({}, e) : this._client.getAPIList("/assistants", cg, {
      query: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Delete an assistant.
   */
  del(e, n) {
    return this._client.delete(`/assistants/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
}
class cg extends ln {
}
ug.AssistantsPage = cg;
function fy(t) {
  return typeof t.parse == "function";
}
const ku = (t) => t?.role === "assistant", VP = (t) => t?.role === "function", zP = (t) => t?.role === "tool";
var rr = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, Ye = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, gb, Zf, Kf, Pl, Cl, Hf, Rl, As, Tl, oh, uh, Su, ZP;
class lg {
  constructor() {
    gb.add(this), this.controller = new AbortController(), Zf.set(this, void 0), Kf.set(this, () => {
    }), Pl.set(this, () => {
    }), Cl.set(this, void 0), Hf.set(this, () => {
    }), Rl.set(this, () => {
    }), As.set(this, {}), Tl.set(this, !1), oh.set(this, !1), uh.set(this, !1), Su.set(this, !1), rr(this, Zf, new Promise((e, n) => {
      rr(this, Kf, e, "f"), rr(this, Pl, n, "f");
    }), "f"), rr(this, Cl, new Promise((e, n) => {
      rr(this, Hf, e, "f"), rr(this, Rl, n, "f");
    }), "f"), Ye(this, Zf, "f").catch(() => {
    }), Ye(this, Cl, "f").catch(() => {
    });
  }
  _run(e) {
    setTimeout(() => {
      e().then(() => {
        this._emitFinal(), this._emit("end");
      }, Ye(this, gb, "m", ZP).bind(this));
    }, 0);
  }
  _connected() {
    this.ended || (Ye(this, Kf, "f").call(this), this._emit("connect"));
  }
  get ended() {
    return Ye(this, Tl, "f");
  }
  get errored() {
    return Ye(this, oh, "f");
  }
  get aborted() {
    return Ye(this, uh, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(e, n) {
    return (Ye(this, As, "f")[e] || (Ye(this, As, "f")[e] = [])).push({ listener: n }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(e, n) {
    const a = Ye(this, As, "f")[e];
    if (!a)
      return this;
    const r = a.findIndex((i) => i.listener === n);
    return r >= 0 && a.splice(r, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(e, n) {
    return (Ye(this, As, "f")[e] || (Ye(this, As, "f")[e] = [])).push({ listener: n, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(e) {
    return new Promise((n, a) => {
      rr(this, Su, !0, "f"), e !== "error" && this.once("error", a), this.once(e, n);
    });
  }
  async done() {
    rr(this, Su, !0, "f"), await Ye(this, Cl, "f");
  }
  _emit(e, ...n) {
    if (Ye(this, Tl, "f"))
      return;
    e === "end" && (rr(this, Tl, !0, "f"), Ye(this, Hf, "f").call(this));
    const a = Ye(this, As, "f")[e];
    if (a && (Ye(this, As, "f")[e] = a.filter((r) => !r.once), a.forEach(({ listener: r }) => r(...n))), e === "abort") {
      const r = n[0];
      !Ye(this, Su, "f") && !a?.length && Promise.reject(r), Ye(this, Pl, "f").call(this, r), Ye(this, Rl, "f").call(this, r), this._emit("end");
      return;
    }
    if (e === "error") {
      const r = n[0];
      !Ye(this, Su, "f") && !a?.length && Promise.reject(r), Ye(this, Pl, "f").call(this, r), Ye(this, Rl, "f").call(this, r), this._emit("end");
    }
  }
  _emitFinal() {
  }
}
Zf = /* @__PURE__ */ new WeakMap(), Kf = /* @__PURE__ */ new WeakMap(), Pl = /* @__PURE__ */ new WeakMap(), Cl = /* @__PURE__ */ new WeakMap(), Hf = /* @__PURE__ */ new WeakMap(), Rl = /* @__PURE__ */ new WeakMap(), As = /* @__PURE__ */ new WeakMap(), Tl = /* @__PURE__ */ new WeakMap(), oh = /* @__PURE__ */ new WeakMap(), uh = /* @__PURE__ */ new WeakMap(), Su = /* @__PURE__ */ new WeakMap(), gb = /* @__PURE__ */ new WeakSet(), ZP = function(e) {
  if (rr(this, oh, !0, "f"), e instanceof Error && e.name === "AbortError" && (e = new vn()), e instanceof vn)
    return rr(this, uh, !0, "f"), this._emit("abort", e);
  if (e instanceof le)
    return this._emit("error", e);
  if (e instanceof Error) {
    const n = new le(e.message);
    return n.cause = e, this._emit("error", n);
  }
  return this._emit("error", new le(String(e)));
};
function BA(t, e) {
  const n = { ...t };
  return Object.defineProperties(n, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: !1
    },
    $parseRaw: {
      value: e,
      enumerable: !1
    }
  }), n;
}
function dg(t) {
  return t?.$brand === "auto-parseable-response-format";
}
function xA(t, { parser: e, callback: n }) {
  const a = { ...t };
  return Object.defineProperties(a, {
    $brand: {
      value: "auto-parseable-tool",
      enumerable: !1
    },
    $parseRaw: {
      value: e,
      enumerable: !1
    },
    $callback: {
      value: n,
      enumerable: !1
    }
  }), a;
}
function jd(t) {
  return t?.$brand === "auto-parseable-tool";
}
function VA(t, e) {
  return !e || !KP(e) ? {
    ...t,
    choices: t.choices.map((n) => ({
      ...n,
      message: {
        ...n.message,
        parsed: null,
        ...n.message.tool_calls ? {
          tool_calls: n.message.tool_calls
        } : void 0
      }
    }))
  } : fg(t, e);
}
function fg(t, e) {
  const n = t.choices.map((a) => {
    if (a.finish_reason === "length")
      throw new RP();
    if (a.finish_reason === "content_filter")
      throw new TP();
    return {
      ...a,
      message: {
        ...a.message,
        ...a.message.tool_calls ? {
          tool_calls: a.message.tool_calls?.map((r) => ZA(e, r)) ?? void 0
        } : void 0,
        parsed: a.message.content && !a.message.refusal ? zA(e, a.message.content) : null
      }
    };
  });
  return { ...t, choices: n };
}
function zA(t, e) {
  return t.response_format?.type !== "json_schema" ? null : t.response_format?.type === "json_schema" ? "$parseRaw" in t.response_format ? t.response_format.$parseRaw(e) : JSON.parse(e) : null;
}
function ZA(t, e) {
  const n = t.tools?.find((a) => a.function?.name === e.function.name);
  return {
    ...e,
    function: {
      ...e.function,
      parsed_arguments: jd(n) ? n.$parseRaw(e.function.arguments) : n?.function.strict ? JSON.parse(e.function.arguments) : null
    }
  };
}
function KA(t, e) {
  if (!t)
    return !1;
  const n = t.tools?.find((a) => a.function?.name === e.function.name);
  return jd(n) || n?.function.strict || !1;
}
function KP(t) {
  return dg(t.response_format) ? !0 : t.tools?.some((e) => jd(e) || e.type === "function" && e.function.strict === !0) ?? !1;
}
function HA(t) {
  for (const e of t ?? []) {
    if (e.type !== "function")
      throw new le(`Currently only \`function\` tool types support auto-parsing; Received \`${e.type}\``);
    if (e.function.strict !== !0)
      throw new le(`The \`${e.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
  }
}
var tn = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, Jt, _b, ch, yb, vb, wb, HP, Sb;
const hy = 10;
class GP extends lg {
  constructor() {
    super(...arguments), Jt.add(this), this._chatCompletions = [], this.messages = [];
  }
  _addChatCompletion(e) {
    this._chatCompletions.push(e), this._emit("chatCompletion", e);
    const n = e.choices[0]?.message;
    return n && this._addMessage(n), e;
  }
  _addMessage(e, n = !0) {
    if ("content" in e || (e.content = null), this.messages.push(e), n) {
      if (this._emit("message", e), (VP(e) || zP(e)) && e.content)
        this._emit("functionCallResult", e.content);
      else if (ku(e) && e.function_call)
        this._emit("functionCall", e.function_call);
      else if (ku(e) && e.tool_calls)
        for (const a of e.tool_calls)
          a.type === "function" && this._emit("functionCall", a.function);
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const e = this._chatCompletions[this._chatCompletions.length - 1];
    if (!e)
      throw new le("stream ended without producing a ChatCompletion");
    return e;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    return await this.done(), tn(this, Jt, "m", _b).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    return await this.done(), tn(this, Jt, "m", ch).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    return await this.done(), tn(this, Jt, "m", yb).call(this);
  }
  async finalFunctionCallResult() {
    return await this.done(), tn(this, Jt, "m", vb).call(this);
  }
  async totalUsage() {
    return await this.done(), tn(this, Jt, "m", wb).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const e = this._chatCompletions[this._chatCompletions.length - 1];
    e && this._emit("finalChatCompletion", e);
    const n = tn(this, Jt, "m", ch).call(this);
    n && this._emit("finalMessage", n);
    const a = tn(this, Jt, "m", _b).call(this);
    a && this._emit("finalContent", a);
    const r = tn(this, Jt, "m", yb).call(this);
    r && this._emit("finalFunctionCall", r);
    const i = tn(this, Jt, "m", vb).call(this);
    i != null && this._emit("finalFunctionCallResult", i), this._chatCompletions.some((s) => s.usage) && this._emit("totalUsage", tn(this, Jt, "m", wb).call(this));
  }
  async _createChatCompletion(e, n, a) {
    const r = a?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), tn(this, Jt, "m", HP).call(this, n);
    const i = await e.chat.completions.create({ ...n, stream: !1 }, { ...a, signal: this.controller.signal });
    return this._connected(), this._addChatCompletion(fg(i, n));
  }
  async _runChatCompletion(e, n, a) {
    for (const r of n.messages)
      this._addMessage(r, !1);
    return await this._createChatCompletion(e, n, a);
  }
  async _runFunctions(e, n, a) {
    const r = "function", { function_call: i = "auto", stream: s, ...u } = n, d = typeof i != "string" && i?.name, { maxChatCompletions: f = hy } = a || {}, o = {};
    for (const h of n.functions)
      o[h.name || h.function.name] = h;
    const c = n.functions.map((h) => ({
      name: h.name || h.function.name,
      parameters: h.parameters,
      description: h.description
    }));
    for (const h of n.messages)
      this._addMessage(h, !1);
    for (let h = 0; h < f; ++h) {
      const l = (await this._createChatCompletion(e, {
        ...u,
        function_call: i,
        functions: c,
        messages: [...this.messages]
      }, a)).choices[0]?.message;
      if (!l)
        throw new le("missing message in ChatCompletion response");
      if (!l.function_call)
        return;
      const { name: m, arguments: b } = l.function_call, g = o[m];
      if (g) {
        if (d && d !== m) {
          const C = `Invalid function_call: ${JSON.stringify(m)}. ${JSON.stringify(d)} requested. Please try again`;
          this._addMessage({ role: r, name: m, content: C });
          continue;
        }
      } else {
        const C = `Invalid function_call: ${JSON.stringify(m)}. Available options are: ${c.map((T) => JSON.stringify(T.name)).join(", ")}. Please try again`;
        this._addMessage({ role: r, name: m, content: C });
        continue;
      }
      let _;
      try {
        _ = fy(g) ? await g.parse(b) : b;
      } catch (C) {
        this._addMessage({
          role: r,
          name: m,
          content: C instanceof Error ? C.message : String(C)
        });
        continue;
      }
      const P = await g.function(_, this), R = tn(this, Jt, "m", Sb).call(this, P);
      if (this._addMessage({ role: r, name: m, content: R }), d)
        return;
    }
  }
  async _runTools(e, n, a) {
    const r = "tool", { tool_choice: i = "auto", stream: s, ...u } = n, d = typeof i != "string" && i?.function?.name, { maxChatCompletions: f = hy } = a || {}, o = n.tools.map((p) => {
      if (jd(p)) {
        if (!p.$callback)
          throw new le("Tool given to `.runTools()` that does not have an associated function");
        return {
          type: "function",
          function: {
            function: p.$callback,
            name: p.function.name,
            description: p.function.description || "",
            parameters: p.function.parameters,
            parse: p.$parseRaw,
            strict: !0
          }
        };
      }
      return p;
    }), c = {};
    for (const p of o)
      p.type === "function" && (c[p.function.name || p.function.function.name] = p.function);
    const h = "tools" in n ? o.map((p) => p.type === "function" ? {
      type: "function",
      function: {
        name: p.function.name || p.function.function.name,
        parameters: p.function.parameters,
        description: p.function.description,
        strict: p.function.strict
      }
    } : p) : void 0;
    for (const p of n.messages)
      this._addMessage(p, !1);
    for (let p = 0; p < f; ++p) {
      const m = (await this._createChatCompletion(e, {
        ...u,
        tool_choice: i,
        tools: h,
        messages: [...this.messages]
      }, a)).choices[0]?.message;
      if (!m)
        throw new le("missing message in ChatCompletion response");
      if (!m.tool_calls?.length)
        return;
      for (const b of m.tool_calls) {
        if (b.type !== "function")
          continue;
        const g = b.id, { name: _, arguments: P } = b.function, R = c[_];
        if (R) {
          if (d && d !== _) {
            const A = `Invalid tool_call: ${JSON.stringify(_)}. ${JSON.stringify(d)} requested. Please try again`;
            this._addMessage({ role: r, tool_call_id: g, content: A });
            continue;
          }
        } else {
          const A = `Invalid tool_call: ${JSON.stringify(_)}. Available options are: ${Object.keys(c).map((M) => JSON.stringify(M)).join(", ")}. Please try again`;
          this._addMessage({ role: r, tool_call_id: g, content: A });
          continue;
        }
        let C;
        try {
          C = fy(R) ? await R.parse(P) : P;
        } catch (A) {
          const M = A instanceof Error ? A.message : String(A);
          this._addMessage({ role: r, tool_call_id: g, content: M });
          continue;
        }
        const T = await R.function(C, this), O = tn(this, Jt, "m", Sb).call(this, T);
        if (this._addMessage({ role: r, tool_call_id: g, content: O }), d)
          return;
      }
    }
  }
}
Jt = /* @__PURE__ */ new WeakSet(), _b = function() {
  return tn(this, Jt, "m", ch).call(this).content ?? null;
}, ch = function() {
  let e = this.messages.length;
  for (; e-- > 0; ) {
    const n = this.messages[e];
    if (ku(n)) {
      const { function_call: a, ...r } = n, i = {
        ...r,
        content: n.content ?? null,
        refusal: n.refusal ?? null
      };
      return a && (i.function_call = a), i;
    }
  }
  throw new le("stream ended without producing a ChatCompletionMessage with role=assistant");
}, yb = function() {
  for (let e = this.messages.length - 1; e >= 0; e--) {
    const n = this.messages[e];
    if (ku(n) && n?.function_call)
      return n.function_call;
    if (ku(n) && n?.tool_calls?.length)
      return n.tool_calls.at(-1)?.function;
  }
}, vb = function() {
  for (let e = this.messages.length - 1; e >= 0; e--) {
    const n = this.messages[e];
    if (VP(n) && n.content != null || zP(n) && n.content != null && typeof n.content == "string" && this.messages.some((a) => a.role === "assistant" && a.tool_calls?.some((r) => r.type === "function" && r.id === n.tool_call_id)))
      return n.content;
  }
}, wb = function() {
  const e = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage: n } of this._chatCompletions)
    n && (e.completion_tokens += n.completion_tokens, e.prompt_tokens += n.prompt_tokens, e.total_tokens += n.total_tokens);
  return e;
}, HP = function(e) {
  if (e.n != null && e.n > 1)
    throw new le("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
}, Sb = function(e) {
  return typeof e == "string" ? e : e === void 0 ? "undefined" : JSON.stringify(e);
};
class Gl extends GP {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(e, n, a) {
    const r = new Gl(), i = {
      ...a,
      headers: { ...a?.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    return r._run(() => r._runFunctions(e, n, i)), r;
  }
  static runTools(e, n, a) {
    const r = new Gl(), i = {
      ...a,
      headers: { ...a?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return r._run(() => r._runTools(e, n, i)), r;
  }
  _addMessage(e, n = !0) {
    super._addMessage(e, n), ku(e) && e.content && this._emit("content", e.content);
  }
}
const WP = 1, XP = 2, QP = 4, YP = 8, eC = 16, tC = 32, nC = 64, rC = 128, aC = 256, iC = rC | aC, sC = eC | tC | iC | nC, oC = WP | XP | sC, uC = QP | YP, GA = oC | uC, Ot = {
  STR: WP,
  NUM: XP,
  ARR: QP,
  OBJ: YP,
  NULL: eC,
  BOOL: tC,
  NAN: nC,
  INFINITY: rC,
  MINUS_INFINITY: aC,
  INF: iC,
  SPECIAL: sC,
  ATOM: oC,
  COLLECTION: uC,
  ALL: GA
};
class WA extends Error {
}
class XA extends Error {
}
function QA(t, e = Ot.ALL) {
  if (typeof t != "string")
    throw new TypeError(`expecting str, got ${typeof t}`);
  if (!t.trim())
    throw new Error(`${t} is empty`);
  return YA(t.trim(), e);
}
const YA = (t, e) => {
  const n = t.length;
  let a = 0;
  const r = (h) => {
    throw new WA(`${h} at position ${a}`);
  }, i = (h) => {
    throw new XA(`${h} at position ${a}`);
  }, s = () => (c(), a >= n && r("Unexpected end of input"), t[a] === '"' ? u() : t[a] === "{" ? d() : t[a] === "[" ? f() : t.substring(a, a + 4) === "null" || Ot.NULL & e && n - a < 4 && "null".startsWith(t.substring(a)) ? (a += 4, null) : t.substring(a, a + 4) === "true" || Ot.BOOL & e && n - a < 4 && "true".startsWith(t.substring(a)) ? (a += 4, !0) : t.substring(a, a + 5) === "false" || Ot.BOOL & e && n - a < 5 && "false".startsWith(t.substring(a)) ? (a += 5, !1) : t.substring(a, a + 8) === "Infinity" || Ot.INFINITY & e && n - a < 8 && "Infinity".startsWith(t.substring(a)) ? (a += 8, 1 / 0) : t.substring(a, a + 9) === "-Infinity" || Ot.MINUS_INFINITY & e && 1 < n - a && n - a < 9 && "-Infinity".startsWith(t.substring(a)) ? (a += 9, -1 / 0) : t.substring(a, a + 3) === "NaN" || Ot.NAN & e && n - a < 3 && "NaN".startsWith(t.substring(a)) ? (a += 3, NaN) : o()), u = () => {
    const h = a;
    let p = !1;
    for (a++; a < n && (t[a] !== '"' || p && t[a - 1] === "\\"); )
      p = t[a] === "\\" ? !p : !1, a++;
    if (t.charAt(a) == '"')
      try {
        return JSON.parse(t.substring(h, ++a - Number(p)));
      } catch (l) {
        i(String(l));
      }
    else if (Ot.STR & e)
      try {
        return JSON.parse(t.substring(h, a - Number(p)) + '"');
      } catch {
        return JSON.parse(t.substring(h, t.lastIndexOf("\\")) + '"');
      }
    r("Unterminated string literal");
  }, d = () => {
    a++, c();
    const h = {};
    try {
      for (; t[a] !== "}"; ) {
        if (c(), a >= n && Ot.OBJ & e)
          return h;
        const p = u();
        c(), a++;
        try {
          const l = s();
          Object.defineProperty(h, p, { value: l, writable: !0, enumerable: !0, configurable: !0 });
        } catch (l) {
          if (Ot.OBJ & e)
            return h;
          throw l;
        }
        c(), t[a] === "," && a++;
      }
    } catch {
      if (Ot.OBJ & e)
        return h;
      r("Expected '}' at end of object");
    }
    return a++, h;
  }, f = () => {
    a++;
    const h = [];
    try {
      for (; t[a] !== "]"; )
        h.push(s()), c(), t[a] === "," && a++;
    } catch {
      if (Ot.ARR & e)
        return h;
      r("Expected ']' at end of array");
    }
    return a++, h;
  }, o = () => {
    if (a === 0) {
      t === "-" && Ot.NUM & e && r("Not sure what '-' is");
      try {
        return JSON.parse(t);
      } catch (p) {
        if (Ot.NUM & e)
          try {
            return t[t.length - 1] === "." ? JSON.parse(t.substring(0, t.lastIndexOf("."))) : JSON.parse(t.substring(0, t.lastIndexOf("e")));
          } catch {
          }
        i(String(p));
      }
    }
    const h = a;
    for (t[a] === "-" && a++; t[a] && !",]}".includes(t[a]); )
      a++;
    a == n && !(Ot.NUM & e) && r("Unterminated number literal");
    try {
      return JSON.parse(t.substring(h, a));
    } catch {
      t.substring(h, a) === "-" && Ot.NUM & e && r("Not sure what '-' is");
      try {
        return JSON.parse(t.substring(h, t.lastIndexOf("e")));
      } catch (l) {
        i(String(l));
      }
    }
  }, c = () => {
    for (; a < n && ` 
\r	`.includes(t[a]); )
      a++;
  };
  return s();
}, py = (t) => QA(t, Ot.ALL ^ Ot.NUM);
var ou = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, ze = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, dt, ga, uu, zs, zp, ef, Zp, Kp, Hp, tf, Gp, my;
class Wl extends GP {
  constructor(e) {
    super(), dt.add(this), ga.set(this, void 0), uu.set(this, void 0), zs.set(this, void 0), ou(this, ga, e, "f"), ou(this, uu, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return ze(this, zs, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(e) {
    const n = new Wl(null);
    return n._run(() => n._fromReadableStream(e)), n;
  }
  static createChatCompletion(e, n, a) {
    const r = new Wl(n);
    return r._run(() => r._runChatCompletion(e, { ...n, stream: !0 }, { ...a, headers: { ...a?.headers, "X-Stainless-Helper-Method": "stream" } })), r;
  }
  async _createChatCompletion(e, n, a) {
    const r = a?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), ze(this, dt, "m", zp).call(this);
    const i = await e.chat.completions.create({ ...n, stream: !0 }, { ...a, signal: this.controller.signal });
    this._connected();
    for await (const s of i)
      ze(this, dt, "m", Zp).call(this, s);
    if (i.controller.signal?.aborted)
      throw new vn();
    return this._addChatCompletion(ze(this, dt, "m", tf).call(this));
  }
  async _fromReadableStream(e, n) {
    const a = n?.signal;
    a && (a.aborted && this.controller.abort(), a.addEventListener("abort", () => this.controller.abort())), ze(this, dt, "m", zp).call(this), this._connected();
    const r = Hl.fromReadableStream(e, this.controller);
    let i;
    for await (const s of r)
      i && i !== s.id && this._addChatCompletion(ze(this, dt, "m", tf).call(this)), ze(this, dt, "m", Zp).call(this, s), i = s.id;
    if (r.controller.signal?.aborted)
      throw new vn();
    return this._addChatCompletion(ze(this, dt, "m", tf).call(this));
  }
  [(ga = /* @__PURE__ */ new WeakMap(), uu = /* @__PURE__ */ new WeakMap(), zs = /* @__PURE__ */ new WeakMap(), dt = /* @__PURE__ */ new WeakSet(), zp = function() {
    this.ended || ou(this, zs, void 0, "f");
  }, ef = function(n) {
    let a = ze(this, uu, "f")[n.index];
    return a || (a = {
      content_done: !1,
      refusal_done: !1,
      logprobs_content_done: !1,
      logprobs_refusal_done: !1,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    }, ze(this, uu, "f")[n.index] = a, a);
  }, Zp = function(n) {
    if (this.ended)
      return;
    const a = ze(this, dt, "m", my).call(this, n);
    this._emit("chunk", n, a);
    for (const r of n.choices) {
      const i = a.choices[r.index];
      r.delta.content != null && i.message?.role === "assistant" && i.message?.content && (this._emit("content", r.delta.content, i.message.content), this._emit("content.delta", {
        delta: r.delta.content,
        snapshot: i.message.content,
        parsed: i.message.parsed
      })), r.delta.refusal != null && i.message?.role === "assistant" && i.message?.refusal && this._emit("refusal.delta", {
        delta: r.delta.refusal,
        snapshot: i.message.refusal
      }), r.logprobs?.content != null && i.message?.role === "assistant" && this._emit("logprobs.content.delta", {
        content: r.logprobs?.content,
        snapshot: i.logprobs?.content ?? []
      }), r.logprobs?.refusal != null && i.message?.role === "assistant" && this._emit("logprobs.refusal.delta", {
        refusal: r.logprobs?.refusal,
        snapshot: i.logprobs?.refusal ?? []
      });
      const s = ze(this, dt, "m", ef).call(this, i);
      i.finish_reason && (ze(this, dt, "m", Hp).call(this, i), s.current_tool_call_index != null && ze(this, dt, "m", Kp).call(this, i, s.current_tool_call_index));
      for (const u of r.delta.tool_calls ?? [])
        s.current_tool_call_index !== u.index && (ze(this, dt, "m", Hp).call(this, i), s.current_tool_call_index != null && ze(this, dt, "m", Kp).call(this, i, s.current_tool_call_index)), s.current_tool_call_index = u.index;
      for (const u of r.delta.tool_calls ?? []) {
        const d = i.message.tool_calls?.[u.index];
        d?.type && d?.type === "function" && this._emit("tool_calls.function.arguments.delta", {
          name: d.function?.name,
          index: u.index,
          arguments: d.function.arguments,
          parsed_arguments: d.function.parsed_arguments,
          arguments_delta: u.function?.arguments ?? ""
        });
      }
    }
  }, Kp = function(n, a) {
    if (ze(this, dt, "m", ef).call(this, n).done_tool_calls.has(a))
      return;
    const i = n.message.tool_calls?.[a];
    if (!i)
      throw new Error("no tool call snapshot");
    if (!i.type)
      throw new Error("tool call snapshot missing `type`");
    if (i.type === "function") {
      const s = ze(this, ga, "f")?.tools?.find((u) => u.type === "function" && u.function.name === i.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: i.function.name,
        index: a,
        arguments: i.function.arguments,
        parsed_arguments: jd(s) ? s.$parseRaw(i.function.arguments) : s?.function.strict ? JSON.parse(i.function.arguments) : null
      });
    }
  }, Hp = function(n) {
    const a = ze(this, dt, "m", ef).call(this, n);
    if (n.message.content && !a.content_done) {
      a.content_done = !0;
      const r = ze(this, dt, "m", Gp).call(this);
      this._emit("content.done", {
        content: n.message.content,
        parsed: r ? r.$parseRaw(n.message.content) : null
      });
    }
    n.message.refusal && !a.refusal_done && (a.refusal_done = !0, this._emit("refusal.done", { refusal: n.message.refusal })), n.logprobs?.content && !a.logprobs_content_done && (a.logprobs_content_done = !0, this._emit("logprobs.content.done", { content: n.logprobs.content })), n.logprobs?.refusal && !a.logprobs_refusal_done && (a.logprobs_refusal_done = !0, this._emit("logprobs.refusal.done", { refusal: n.logprobs.refusal }));
  }, tf = function() {
    if (this.ended)
      throw new le("stream has ended, this shouldn't happen");
    const n = ze(this, zs, "f");
    if (!n)
      throw new le("request ended without sending any chunks");
    return ou(this, zs, void 0, "f"), ou(this, uu, [], "f"), eE(n, ze(this, ga, "f"));
  }, Gp = function() {
    const n = ze(this, ga, "f")?.response_format;
    return dg(n) ? n : null;
  }, my = function(n) {
    var a, r, i, s;
    let u = ze(this, zs, "f");
    const { choices: d, ...f } = n;
    u ? Object.assign(u, f) : u = ou(this, zs, {
      ...f,
      choices: []
    }, "f");
    for (const { delta: o, finish_reason: c, index: h, logprobs: p = null, ...l } of n.choices) {
      let m = u.choices[h];
      if (m || (m = u.choices[h] = { finish_reason: c, index: h, message: {}, logprobs: p, ...l }), p)
        if (!m.logprobs)
          m.logprobs = Object.assign({}, p);
        else {
          const { content: T, refusal: O, ...A } = p;
          Object.assign(m.logprobs, A), T && ((a = m.logprobs).content ?? (a.content = []), m.logprobs.content.push(...T)), O && ((r = m.logprobs).refusal ?? (r.refusal = []), m.logprobs.refusal.push(...O));
        }
      if (c && (m.finish_reason = c, ze(this, ga, "f") && KP(ze(this, ga, "f")))) {
        if (c === "length")
          throw new RP();
        if (c === "content_filter")
          throw new TP();
      }
      if (Object.assign(m, l), !o)
        continue;
      const { content: b, refusal: g, function_call: _, role: P, tool_calls: R, ...C } = o;
      if (Object.assign(m.message, C), g && (m.message.refusal = (m.message.refusal || "") + g), P && (m.message.role = P), _ && (m.message.function_call ? (_.name && (m.message.function_call.name = _.name), _.arguments && ((i = m.message.function_call).arguments ?? (i.arguments = ""), m.message.function_call.arguments += _.arguments)) : m.message.function_call = _), b && (m.message.content = (m.message.content || "") + b, !m.message.refusal && ze(this, dt, "m", Gp).call(this) && (m.message.parsed = py(m.message.content))), R) {
        m.message.tool_calls || (m.message.tool_calls = []);
        for (const { index: T, id: O, type: A, function: M, ...I } of R) {
          const N = (s = m.message.tool_calls)[T] ?? (s[T] = {});
          Object.assign(N, I), O && (N.id = O), A && (N.type = A), M && (N.function ?? (N.function = { name: M.name ?? "", arguments: "" })), M?.name && (N.function.name = M.name), M?.arguments && (N.function.arguments += M.arguments, KA(ze(this, ga, "f"), N) && (N.function.parsed_arguments = py(N.function.arguments)));
        }
      }
    }
    return u;
  }, Symbol.asyncIterator)]() {
    const e = [], n = [];
    let a = !1;
    return this.on("chunk", (r) => {
      const i = n.shift();
      i ? i.resolve(r) : e.push(r);
    }), this.on("end", () => {
      a = !0;
      for (const r of n)
        r.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), this.on("error", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : a ? { value: void 0, done: !0 } : new Promise((i, s) => n.push({ resolve: i, reject: s })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new Hl(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
function eE(t, e) {
  const { id: n, choices: a, created: r, model: i, system_fingerprint: s, ...u } = t, d = {
    ...u,
    id: n,
    choices: a.map(({ message: f, finish_reason: o, index: c, logprobs: h, ...p }) => {
      if (!o)
        throw new le(`missing finish_reason for choice ${c}`);
      const { content: l = null, function_call: m, tool_calls: b, ...g } = f, _ = f.role;
      if (!_)
        throw new le(`missing role for choice ${c}`);
      if (m) {
        const { arguments: P, name: R } = m;
        if (P == null)
          throw new le(`missing function_call.arguments for choice ${c}`);
        if (!R)
          throw new le(`missing function_call.name for choice ${c}`);
        return {
          ...p,
          message: {
            content: l,
            function_call: { arguments: P, name: R },
            role: _,
            refusal: f.refusal ?? null
          },
          finish_reason: o,
          index: c,
          logprobs: h
        };
      }
      return b ? {
        ...p,
        index: c,
        finish_reason: o,
        logprobs: h,
        message: {
          ...g,
          role: _,
          content: l,
          refusal: f.refusal ?? null,
          tool_calls: b.map((P, R) => {
            const { function: C, type: T, id: O, ...A } = P, { arguments: M, name: I, ...N } = C || {};
            if (O == null)
              throw new le(`missing choices[${c}].tool_calls[${R}].id
${nf(t)}`);
            if (T == null)
              throw new le(`missing choices[${c}].tool_calls[${R}].type
${nf(t)}`);
            if (I == null)
              throw new le(`missing choices[${c}].tool_calls[${R}].function.name
${nf(t)}`);
            if (M == null)
              throw new le(`missing choices[${c}].tool_calls[${R}].function.arguments
${nf(t)}`);
            return { ...A, id: O, type: T, function: { ...N, name: I, arguments: M } };
          })
        }
      } : {
        ...p,
        message: { ...g, content: l, role: _, refusal: f.refusal ?? null },
        finish_reason: o,
        index: c,
        logprobs: h
      };
    }),
    created: r,
    model: i,
    object: "chat.completion",
    ...s ? { system_fingerprint: s } : {}
  };
  return VA(d, e);
}
function nf(t) {
  return JSON.stringify(t);
}
class Du extends Wl {
  static fromReadableStream(e) {
    const n = new Du(null);
    return n._run(() => n._fromReadableStream(e)), n;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(e, n, a) {
    const r = new Du(null), i = {
      ...a,
      headers: { ...a?.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    return r._run(() => r._runFunctions(e, n, i)), r;
  }
  static runTools(e, n, a) {
    const r = new Du(
      // @ts-expect-error TODO these types are incompatible
      n
    ), i = {
      ...a,
      headers: { ...a?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return r._run(() => r._runTools(e, n, i)), r;
  }
}
let cC = class extends Pe {
  parse(e, n) {
    return HA(e.tools), this._client.chat.completions.create(e, {
      ...n,
      headers: {
        ...n?.headers,
        "X-Stainless-Helper-Method": "beta.chat.completions.parse"
      }
    })._thenUnwrap((a) => fg(a, e));
  }
  runFunctions(e, n) {
    return e.stream ? Du.runFunctions(this._client, e, n) : Gl.runFunctions(this._client, e, n);
  }
  runTools(e, n) {
    return e.stream ? Du.runTools(this._client, e, n) : Gl.runTools(this._client, e, n);
  }
  /**
   * Creates a chat completion stream
   */
  stream(e, n) {
    return Wl.createChatCompletion(this._client, e, n);
  }
}, Ob = class extends Pe {
  constructor() {
    super(...arguments), this.completions = new cC(this._client);
  }
};
(function(t) {
  t.Completions = cC;
})(Ob || (Ob = {}));
class lC extends Pe {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   */
  create(e, n) {
    return this._client.post("/realtime/sessions", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
}
class dC extends Pe {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   */
  create(e, n) {
    return this._client.post("/realtime/transcription_sessions", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
}
class np extends Pe {
  constructor() {
    super(...arguments), this.sessions = new lC(this._client), this.transcriptionSessions = new dC(this._client);
  }
}
np.Sessions = lC;
np.TranscriptionSessions = dC;
var se = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, hn = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, Mt, jb, ta, Gf, ar, No, Tu, Ao, lh, gn, Wf, Xf, Dl, $l, Ml, by, gy, _y, yy, vy, wy, Sy;
class ir extends lg {
  constructor() {
    super(...arguments), Mt.add(this), jb.set(this, []), ta.set(this, {}), Gf.set(this, {}), ar.set(this, void 0), No.set(this, void 0), Tu.set(this, void 0), Ao.set(this, void 0), lh.set(this, void 0), gn.set(this, void 0), Wf.set(this, void 0), Xf.set(this, void 0), Dl.set(this, void 0);
  }
  [(jb = /* @__PURE__ */ new WeakMap(), ta = /* @__PURE__ */ new WeakMap(), Gf = /* @__PURE__ */ new WeakMap(), ar = /* @__PURE__ */ new WeakMap(), No = /* @__PURE__ */ new WeakMap(), Tu = /* @__PURE__ */ new WeakMap(), Ao = /* @__PURE__ */ new WeakMap(), lh = /* @__PURE__ */ new WeakMap(), gn = /* @__PURE__ */ new WeakMap(), Wf = /* @__PURE__ */ new WeakMap(), Xf = /* @__PURE__ */ new WeakMap(), Dl = /* @__PURE__ */ new WeakMap(), Mt = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const e = [], n = [];
    let a = !1;
    return this.on("event", (r) => {
      const i = n.shift();
      i ? i.resolve(r) : e.push(r);
    }), this.on("end", () => {
      a = !0;
      for (const r of n)
        r.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), this.on("error", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : a ? { value: void 0, done: !0 } : new Promise((i, s) => n.push({ resolve: i, reject: s })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  static fromReadableStream(e) {
    const n = new ir();
    return n._run(() => n._fromReadableStream(e)), n;
  }
  async _fromReadableStream(e, n) {
    const a = n?.signal;
    a && (a.aborted && this.controller.abort(), a.addEventListener("abort", () => this.controller.abort())), this._connected();
    const r = Hl.fromReadableStream(e, this.controller);
    for await (const i of r)
      se(this, Mt, "m", $l).call(this, i);
    if (r.controller.signal?.aborted)
      throw new vn();
    return this._addRun(se(this, Mt, "m", Ml).call(this));
  }
  toReadableStream() {
    return new Hl(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
  static createToolAssistantStream(e, n, a, r, i) {
    const s = new ir();
    return s._run(() => s._runToolAssistantStream(e, n, a, r, {
      ...i,
      headers: { ...i?.headers, "X-Stainless-Helper-Method": "stream" }
    })), s;
  }
  async _createToolAssistantStream(e, n, a, r, i) {
    const s = i?.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort()));
    const u = { ...r, stream: !0 }, d = await e.submitToolOutputs(n, a, u, {
      ...i,
      signal: this.controller.signal
    });
    this._connected();
    for await (const f of d)
      se(this, Mt, "m", $l).call(this, f);
    if (d.controller.signal?.aborted)
      throw new vn();
    return this._addRun(se(this, Mt, "m", Ml).call(this));
  }
  static createThreadAssistantStream(e, n, a) {
    const r = new ir();
    return r._run(() => r._threadAssistantStream(e, n, {
      ...a,
      headers: { ...a?.headers, "X-Stainless-Helper-Method": "stream" }
    })), r;
  }
  static createAssistantStream(e, n, a, r) {
    const i = new ir();
    return i._run(() => i._runAssistantStream(e, n, a, {
      ...r,
      headers: { ...r?.headers, "X-Stainless-Helper-Method": "stream" }
    })), i;
  }
  currentEvent() {
    return se(this, Wf, "f");
  }
  currentRun() {
    return se(this, Xf, "f");
  }
  currentMessageSnapshot() {
    return se(this, ar, "f");
  }
  currentRunStepSnapshot() {
    return se(this, Dl, "f");
  }
  async finalRunSteps() {
    return await this.done(), Object.values(se(this, ta, "f"));
  }
  async finalMessages() {
    return await this.done(), Object.values(se(this, Gf, "f"));
  }
  async finalRun() {
    if (await this.done(), !se(this, No, "f"))
      throw Error("Final run was not received.");
    return se(this, No, "f");
  }
  async _createThreadAssistantStream(e, n, a) {
    const r = a?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort()));
    const i = { ...n, stream: !0 }, s = await e.createAndRun(i, { ...a, signal: this.controller.signal });
    this._connected();
    for await (const u of s)
      se(this, Mt, "m", $l).call(this, u);
    if (s.controller.signal?.aborted)
      throw new vn();
    return this._addRun(se(this, Mt, "m", Ml).call(this));
  }
  async _createAssistantStream(e, n, a, r) {
    const i = r?.signal;
    i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort()));
    const s = { ...a, stream: !0 }, u = await e.create(n, s, { ...r, signal: this.controller.signal });
    this._connected();
    for await (const d of u)
      se(this, Mt, "m", $l).call(this, d);
    if (u.controller.signal?.aborted)
      throw new vn();
    return this._addRun(se(this, Mt, "m", Ml).call(this));
  }
  static accumulateDelta(e, n) {
    for (const [a, r] of Object.entries(n)) {
      if (!e.hasOwnProperty(a)) {
        e[a] = r;
        continue;
      }
      let i = e[a];
      if (i == null) {
        e[a] = r;
        continue;
      }
      if (a === "index" || a === "type") {
        e[a] = r;
        continue;
      }
      if (typeof i == "string" && typeof r == "string")
        i += r;
      else if (typeof i == "number" && typeof r == "number")
        i += r;
      else if (Vp(i) && Vp(r))
        i = this.accumulateDelta(i, r);
      else if (Array.isArray(i) && Array.isArray(r)) {
        if (i.every((s) => typeof s == "string" || typeof s == "number")) {
          i.push(...r);
          continue;
        }
        for (const s of r) {
          if (!Vp(s))
            throw new Error(`Expected array delta entry to be an object but got: ${s}`);
          const u = s.index;
          if (u == null)
            throw console.error(s), new Error("Expected array delta entry to have an `index` property");
          if (typeof u != "number")
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${u}`);
          const d = i[u];
          d == null ? i.push(s) : i[u] = this.accumulateDelta(d, s);
        }
        continue;
      } else
        throw Error(`Unhandled record type: ${a}, deltaValue: ${r}, accValue: ${i}`);
      e[a] = i;
    }
    return e;
  }
  _addRun(e) {
    return e;
  }
  async _threadAssistantStream(e, n, a) {
    return await this._createThreadAssistantStream(n, e, a);
  }
  async _runAssistantStream(e, n, a, r) {
    return await this._createAssistantStream(n, e, a, r);
  }
  async _runToolAssistantStream(e, n, a, r, i) {
    return await this._createToolAssistantStream(a, e, n, r, i);
  }
}
$l = function(e) {
  if (!this.ended)
    switch (hn(this, Wf, e, "f"), se(this, Mt, "m", _y).call(this, e), e.event) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.incomplete":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        se(this, Mt, "m", Sy).call(this, e);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        se(this, Mt, "m", gy).call(this, e);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        se(this, Mt, "m", by).call(this, e);
        break;
      case "error":
        throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    }
}, Ml = function() {
  if (this.ended)
    throw new le("stream has ended, this shouldn't happen");
  if (!se(this, No, "f"))
    throw Error("Final run has not been received");
  return se(this, No, "f");
}, by = function(e) {
  const [n, a] = se(this, Mt, "m", vy).call(this, e, se(this, ar, "f"));
  hn(this, ar, n, "f"), se(this, Gf, "f")[n.id] = n;
  for (const r of a) {
    const i = n.content[r.index];
    i?.type == "text" && this._emit("textCreated", i.text);
  }
  switch (e.event) {
    case "thread.message.created":
      this._emit("messageCreated", e.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      if (this._emit("messageDelta", e.data.delta, n), e.data.delta.content)
        for (const r of e.data.delta.content) {
          if (r.type == "text" && r.text) {
            let i = r.text, s = n.content[r.index];
            if (s && s.type == "text")
              this._emit("textDelta", i, s.text);
            else
              throw Error("The snapshot associated with this text delta is not text or missing");
          }
          if (r.index != se(this, Tu, "f")) {
            if (se(this, Ao, "f"))
              switch (se(this, Ao, "f").type) {
                case "text":
                  this._emit("textDone", se(this, Ao, "f").text, se(this, ar, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", se(this, Ao, "f").image_file, se(this, ar, "f"));
                  break;
              }
            hn(this, Tu, r.index, "f");
          }
          hn(this, Ao, n.content[r.index], "f");
        }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (se(this, Tu, "f") !== void 0) {
        const r = e.data.content[se(this, Tu, "f")];
        if (r)
          switch (r.type) {
            case "image_file":
              this._emit("imageFileDone", r.image_file, se(this, ar, "f"));
              break;
            case "text":
              this._emit("textDone", r.text, se(this, ar, "f"));
              break;
          }
      }
      se(this, ar, "f") && this._emit("messageDone", e.data), hn(this, ar, void 0, "f");
  }
}, gy = function(e) {
  const n = se(this, Mt, "m", yy).call(this, e);
  switch (hn(this, Dl, n, "f"), e.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", e.data);
      break;
    case "thread.run.step.delta":
      const a = e.data.delta;
      if (a.step_details && a.step_details.type == "tool_calls" && a.step_details.tool_calls && n.step_details.type == "tool_calls")
        for (const i of a.step_details.tool_calls)
          i.index == se(this, lh, "f") ? this._emit("toolCallDelta", i, n.step_details.tool_calls[i.index]) : (se(this, gn, "f") && this._emit("toolCallDone", se(this, gn, "f")), hn(this, lh, i.index, "f"), hn(this, gn, n.step_details.tool_calls[i.index], "f"), se(this, gn, "f") && this._emit("toolCallCreated", se(this, gn, "f")));
      this._emit("runStepDelta", e.data.delta, n);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      hn(this, Dl, void 0, "f"), e.data.step_details.type == "tool_calls" && se(this, gn, "f") && (this._emit("toolCallDone", se(this, gn, "f")), hn(this, gn, void 0, "f")), this._emit("runStepDone", e.data, n);
      break;
  }
}, _y = function(e) {
  se(this, jb, "f").push(e), this._emit("event", e);
}, yy = function(e) {
  switch (e.event) {
    case "thread.run.step.created":
      return se(this, ta, "f")[e.data.id] = e.data, e.data;
    case "thread.run.step.delta":
      let n = se(this, ta, "f")[e.data.id];
      if (!n)
        throw Error("Received a RunStepDelta before creation of a snapshot");
      let a = e.data;
      if (a.delta) {
        const r = ir.accumulateDelta(n, a.delta);
        se(this, ta, "f")[e.data.id] = r;
      }
      return se(this, ta, "f")[e.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      se(this, ta, "f")[e.data.id] = e.data;
      break;
  }
  if (se(this, ta, "f")[e.data.id])
    return se(this, ta, "f")[e.data.id];
  throw new Error("No snapshot available");
}, vy = function(e, n) {
  let a = [];
  switch (e.event) {
    case "thread.message.created":
      return [e.data, a];
    case "thread.message.delta":
      if (!n)
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      let r = e.data;
      if (r.delta.content)
        for (const i of r.delta.content)
          if (i.index in n.content) {
            let s = n.content[i.index];
            n.content[i.index] = se(this, Mt, "m", wy).call(this, i, s);
          } else
            n.content[i.index] = i, a.push(i);
      return [n, a];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (n)
        return [n, a];
      throw Error("Received thread message event with no existing snapshot");
  }
  throw Error("Tried to accumulate a non-message event");
}, wy = function(e, n) {
  return ir.accumulateDelta(n, e);
}, Sy = function(e) {
  switch (hn(this, Xf, e.data, "f"), e.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
      hn(this, No, e.data, "f"), se(this, gn, "f") && (this._emit("toolCallDone", se(this, gn, "f")), hn(this, gn, void 0, "f"));
      break;
  }
};
let hg = class extends Pe {
  /**
   * Create a message.
   */
  create(e, n, a) {
    return this._client.post(`/threads/${e}/messages`, {
      body: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Retrieve a message.
   */
  retrieve(e, n, a) {
    return this._client.get(`/threads/${e}/messages/${n}`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Modifies a message.
   */
  update(e, n, a, r) {
    return this._client.post(`/threads/${e}/messages/${n}`, {
      body: a,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r?.headers }
    });
  }
  list(e, n = {}, a) {
    return Rt(n) ? this.list(e, {}, n) : this._client.getAPIList(`/threads/${e}/messages`, pg, {
      query: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Deletes a message.
   */
  del(e, n, a) {
    return this._client.delete(`/threads/${e}/messages/${n}`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
};
class pg extends ln {
}
hg.MessagesPage = pg;
class mg extends Pe {
  retrieve(e, n, a, r = {}, i) {
    return Rt(r) ? this.retrieve(e, n, a, {}, r) : this._client.get(`/threads/${e}/runs/${n}/steps/${a}`, {
      query: r,
      ...i,
      headers: { "OpenAI-Beta": "assistants=v2", ...i?.headers }
    });
  }
  list(e, n, a = {}, r) {
    return Rt(a) ? this.list(e, n, {}, a) : this._client.getAPIList(`/threads/${e}/runs/${n}/steps`, bg, {
      query: a,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r?.headers }
    });
  }
}
class bg extends ln {
}
mg.RunStepsPage = bg;
class Pd extends Pe {
  constructor() {
    super(...arguments), this.steps = new mg(this._client);
  }
  create(e, n, a) {
    const { include: r, ...i } = n;
    return this._client.post(`/threads/${e}/runs`, {
      query: { include: r },
      body: i,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers },
      stream: n.stream ?? !1
    });
  }
  /**
   * Retrieves a run.
   */
  retrieve(e, n, a) {
    return this._client.get(`/threads/${e}/runs/${n}`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Modifies a run.
   */
  update(e, n, a, r) {
    return this._client.post(`/threads/${e}/runs/${n}`, {
      body: a,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r?.headers }
    });
  }
  list(e, n = {}, a) {
    return Rt(n) ? this.list(e, {}, n) : this._client.getAPIList(`/threads/${e}/runs`, gg, {
      query: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   */
  cancel(e, n, a) {
    return this._client.post(`/threads/${e}/runs/${n}/cancel`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(e, n, a) {
    const r = await this.create(e, n, a);
    return await this.poll(e, r.id, a);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(e, n, a) {
    return ir.createAssistantStream(e, this._client.beta.threads.runs, n, a);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(e, n, a) {
    const r = { ...a?.headers, "X-Stainless-Poll-Helper": "true" };
    for (a?.pollIntervalMs && (r["X-Stainless-Custom-Poll-Interval"] = a.pollIntervalMs.toString()); ; ) {
      const { data: i, response: s } = await this.retrieve(e, n, {
        ...a,
        headers: { ...a?.headers, ...r }
      }).withResponse();
      switch (i.status) {
        //If we are in any sort of intermediate state we poll
        case "queued":
        case "in_progress":
        case "cancelling":
          let u = 5e3;
          if (a?.pollIntervalMs)
            u = a.pollIntervalMs;
          else {
            const d = s.headers.get("openai-poll-after-ms");
            if (d) {
              const f = parseInt(d);
              isNaN(f) || (u = f);
            }
          }
          await Sd(u);
          break;
        //We return the run in any terminal state.
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return i;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(e, n, a) {
    return ir.createAssistantStream(e, this._client.beta.threads.runs, n, a);
  }
  submitToolOutputs(e, n, a, r) {
    return this._client.post(`/threads/${e}/runs/${n}/submit_tool_outputs`, {
      body: a,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r?.headers },
      stream: a.stream ?? !1
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(e, n, a, r) {
    const i = await this.submitToolOutputs(e, n, a, r);
    return await this.poll(e, i.id, r);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(e, n, a, r) {
    return ir.createToolAssistantStream(e, n, this._client.beta.threads.runs, a, r);
  }
}
class gg extends ln {
}
Pd.RunsPage = gg;
Pd.Steps = mg;
Pd.RunStepsPage = bg;
class Ku extends Pe {
  constructor() {
    super(...arguments), this.runs = new Pd(this._client), this.messages = new hg(this._client);
  }
  create(e = {}, n) {
    return Rt(e) ? this.create({}, e) : this._client.post("/threads", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Retrieves a thread.
   */
  retrieve(e, n) {
    return this._client.get(`/threads/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Modifies a thread.
   */
  update(e, n, a) {
    return this._client.post(`/threads/${e}`, {
      body: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Delete a thread.
   */
  del(e, n) {
    return this._client.delete(`/threads/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  createAndRun(e, n) {
    return this._client.post("/threads/runs", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers },
      stream: e.stream ?? !1
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(e, n) {
    const a = await this.createAndRun(e, n);
    return await this.runs.poll(a.thread_id, a.id, n);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(e, n) {
    return ir.createThreadAssistantStream(e, this._client.beta.threads, n);
  }
}
Ku.Runs = Pd;
Ku.RunsPage = gg;
Ku.Messages = hg;
Ku.MessagesPage = pg;
let Hu = class extends Pe {
  constructor() {
    super(...arguments), this.realtime = new np(this._client), this.chat = new Ob(this._client), this.assistants = new ug(this._client), this.threads = new Ku(this._client);
  }
};
Hu.Realtime = np;
Hu.Assistants = ug;
Hu.AssistantsPage = cg;
Hu.Threads = Ku;
let fC = class extends Pe {
  create(e, n) {
    return this._client.post("/completions", { body: e, ...n, stream: e.stream ?? !1 });
  }
}, hC = class extends Pe {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(e, n) {
    return this._client.post("/embeddings", { body: e, ...n });
  }
}, _g = class extends Pe {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 100 GB.
   *
   * The Assistants API supports files up to 2 million tokens and of specific file
   * types. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
   * details.
   *
   * The Fine-tuning API only supports `.jsonl` files. The input also has certain
   * required formats for fine-tuning
   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   * models.
   *
   * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
   * has a specific required
   * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(e, n) {
    return this._client.post("/files", Lu({ body: e, ...n }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(e, n) {
    return this._client.get(`/files/${e}`, n);
  }
  list(e = {}, n) {
    return Rt(e) ? this.list({}, e) : this._client.getAPIList("/files", yg, { query: e, ...n });
  }
  /**
   * Delete a file.
   */
  del(e, n) {
    return this._client.delete(`/files/${e}`, n);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(e, n) {
    return this._client.get(`/files/${e}/content`, {
      ...n,
      headers: { Accept: "application/binary", ...n?.headers },
      __binaryResponse: !0
    });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(e, n) {
    return this._client.get(`/files/${e}/content`, n);
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(e, { pollInterval: n = 5e3, maxWait: a = 30 * 60 * 1e3 } = {}) {
    const r = /* @__PURE__ */ new Set(["processed", "error", "deleted"]), i = Date.now();
    let s = await this.retrieve(e);
    for (; !s.status || !r.has(s.status); )
      if (await Sd(n), s = await this.retrieve(e), Date.now() - i > a)
        throw new Wh({
          message: `Giving up on waiting for file ${e} to finish processing after ${a} milliseconds.`
        });
    return s;
  }
};
class yg extends ln {
}
_g.FileObjectsPage = yg;
class vg extends Pe {
  list(e, n = {}, a) {
    return Rt(n) ? this.list(e, {}, n) : this._client.getAPIList(`/fine_tuning/jobs/${e}/checkpoints`, wg, { query: n, ...a });
  }
}
class wg extends ln {
}
vg.FineTuningJobCheckpointsPage = wg;
class Gu extends Pe {
  constructor() {
    super(...arguments), this.checkpoints = new vg(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  create(e, n) {
    return this._client.post("/fine_tuning/jobs", { body: e, ...n });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  retrieve(e, n) {
    return this._client.get(`/fine_tuning/jobs/${e}`, n);
  }
  list(e = {}, n) {
    return Rt(e) ? this.list({}, e) : this._client.getAPIList("/fine_tuning/jobs", Sg, { query: e, ...n });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(e, n) {
    return this._client.post(`/fine_tuning/jobs/${e}/cancel`, n);
  }
  listEvents(e, n = {}, a) {
    return Rt(n) ? this.listEvents(e, {}, n) : this._client.getAPIList(`/fine_tuning/jobs/${e}/events`, Og, {
      query: n,
      ...a
    });
  }
}
class Sg extends ln {
}
class Og extends ln {
}
Gu.FineTuningJobsPage = Sg;
Gu.FineTuningJobEventsPage = Og;
Gu.Checkpoints = vg;
Gu.FineTuningJobCheckpointsPage = wg;
class Cd extends Pe {
  constructor() {
    super(...arguments), this.jobs = new Gu(this._client);
  }
}
Cd.Jobs = Gu;
Cd.FineTuningJobsPage = Sg;
Cd.FineTuningJobEventsPage = Og;
class pC extends Pe {
  /**
   * Creates a variation of a given image.
   */
  createVariation(e, n) {
    return this._client.post("/images/variations", Lu({ body: e, ...n }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(e, n) {
    return this._client.post("/images/edits", Lu({ body: e, ...n }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(e, n) {
    return this._client.post("/images/generations", { body: e, ...n });
  }
}
let jg = class extends Pe {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(e, n) {
    return this._client.get(`/models/${e}`, n);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(e) {
    return this._client.getAPIList("/models", Pg, e);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(e, n) {
    return this._client.delete(`/models/${e}`, n);
  }
};
class Pg extends ig {
}
jg.ModelsPage = Pg;
class mC extends Pe {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(e, n) {
    return this._client.post("/moderations", { body: e, ...n });
  }
}
function tE(t, e) {
  return !e || !rE(e) ? {
    ...t,
    output_parsed: null,
    output: t.output.map((n) => n.type === "function_call" ? {
      ...n,
      parsed_arguments: null
    } : n.type === "message" ? {
      ...n,
      content: n.content.map((a) => ({
        ...a,
        parsed: null
      }))
    } : n)
  } : bC(t, e);
}
function bC(t, e) {
  const n = t.output.map((r) => {
    if (r.type === "function_call")
      return {
        ...r,
        parsed_arguments: sE(e, r)
      };
    if (r.type === "message") {
      const i = r.content.map((s) => s.type === "output_text" ? {
        ...s,
        parsed: nE(e, s.text)
      } : s);
      return {
        ...r,
        content: i
      };
    }
    return r;
  }), a = Object.assign({}, t, { output: n });
  return Object.getOwnPropertyDescriptor(t, "output_text") || gC(a), Object.defineProperty(a, "output_parsed", {
    enumerable: !0,
    get() {
      for (const r of a.output)
        if (r.type === "message") {
          for (const i of r.content)
            if (i.type === "output_text" && i.parsed !== null)
              return i.parsed;
        }
      return null;
    }
  }), a;
}
function nE(t, e) {
  return t.text?.format?.type !== "json_schema" ? null : "$parseRaw" in t.text?.format ? (t.text?.format).$parseRaw(e) : JSON.parse(e);
}
function rE(t) {
  return !!dg(t.text?.format);
}
function aE(t) {
  return t?.$brand === "auto-parseable-tool";
}
function iE(t, e) {
  return t.find((n) => n.type === "function" && n.name === e);
}
function sE(t, e) {
  const n = iE(t.tools ?? [], e.name);
  return {
    ...e,
    ...e,
    parsed_arguments: aE(n) ? n.$parseRaw(e.arguments) : n?.strict ? JSON.parse(e.arguments) : null
  };
}
function gC(t) {
  const e = [];
  for (const n of t.output)
    if (n.type === "message")
      for (const a of n.content)
        a.type === "output_text" && e.push(a.text);
  t.output_text = e.join("");
}
class _C extends Pe {
  list(e, n = {}, a) {
    return Rt(n) ? this.list(e, {}, n) : this._client.getAPIList(`/responses/${e}/input_items`, uE, {
      query: n,
      ...a
    });
  }
}
var cu = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, Zs = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, lu, rf, Ks, af, Oy, jy, Py, Cy;
class Cg extends lg {
  constructor(e) {
    super(), lu.add(this), rf.set(this, void 0), Ks.set(this, void 0), af.set(this, void 0), cu(this, rf, e, "f");
  }
  static createResponse(e, n, a) {
    const r = new Cg(n);
    return r._run(() => r._createResponse(e, n, {
      ...a,
      headers: { ...a?.headers, "X-Stainless-Helper-Method": "stream" }
    })), r;
  }
  async _createResponse(e, n, a) {
    const r = a?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), Zs(this, lu, "m", Oy).call(this);
    const i = await e.responses.create({ ...n, stream: !0 }, { ...a, signal: this.controller.signal });
    this._connected();
    for await (const s of i)
      Zs(this, lu, "m", jy).call(this, s);
    if (i.controller.signal?.aborted)
      throw new vn();
    return Zs(this, lu, "m", Py).call(this);
  }
  [(rf = /* @__PURE__ */ new WeakMap(), Ks = /* @__PURE__ */ new WeakMap(), af = /* @__PURE__ */ new WeakMap(), lu = /* @__PURE__ */ new WeakSet(), Oy = function() {
    this.ended || cu(this, Ks, void 0, "f");
  }, jy = function(n) {
    if (this.ended)
      return;
    const a = Zs(this, lu, "m", Cy).call(this, n);
    switch (this._emit("event", n), n.type) {
      case "response.output_text.delta": {
        const r = a.output[n.output_index];
        if (!r)
          throw new le(`missing output at index ${n.output_index}`);
        if (r.type === "message") {
          const i = r.content[n.content_index];
          if (!i)
            throw new le(`missing content at index ${n.content_index}`);
          if (i.type !== "output_text")
            throw new le(`expected content to be 'output_text', got ${i.type}`);
          this._emit("response.output_text.delta", {
            ...n,
            snapshot: i.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const r = a.output[n.output_index];
        if (!r)
          throw new le(`missing output at index ${n.output_index}`);
        r.type === "function_call" && this._emit("response.function_call_arguments.delta", {
          ...n,
          snapshot: r.arguments
        });
        break;
      }
      default:
        this._emit(n.type, n);
        break;
    }
  }, Py = function() {
    if (this.ended)
      throw new le("stream has ended, this shouldn't happen");
    const n = Zs(this, Ks, "f");
    if (!n)
      throw new le("request ended without sending any events");
    cu(this, Ks, void 0, "f");
    const a = oE(n, Zs(this, rf, "f"));
    return cu(this, af, a, "f"), a;
  }, Cy = function(n) {
    let a = Zs(this, Ks, "f");
    if (!a) {
      if (n.type !== "response.created")
        throw new le(`When snapshot hasn't been set yet, expected 'response.created' event, got ${n.type}`);
      return a = cu(this, Ks, n.response, "f"), a;
    }
    switch (n.type) {
      case "response.output_item.added": {
        a.output.push(n.item);
        break;
      }
      case "response.content_part.added": {
        const r = a.output[n.output_index];
        if (!r)
          throw new le(`missing output at index ${n.output_index}`);
        r.type === "message" && r.content.push(n.part);
        break;
      }
      case "response.output_text.delta": {
        const r = a.output[n.output_index];
        if (!r)
          throw new le(`missing output at index ${n.output_index}`);
        if (r.type === "message") {
          const i = r.content[n.content_index];
          if (!i)
            throw new le(`missing content at index ${n.content_index}`);
          if (i.type !== "output_text")
            throw new le(`expected content to be 'output_text', got ${i.type}`);
          i.text += n.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const r = a.output[n.output_index];
        if (!r)
          throw new le(`missing output at index ${n.output_index}`);
        r.type === "function_call" && (r.arguments += n.delta);
        break;
      }
      case "response.completed": {
        cu(this, Ks, n.response, "f");
        break;
      }
    }
    return a;
  }, Symbol.asyncIterator)]() {
    const e = [], n = [];
    let a = !1;
    return this.on("event", (r) => {
      const i = n.shift();
      i ? i.resolve(r) : e.push(r);
    }), this.on("end", () => {
      a = !0;
      for (const r of n)
        r.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), this.on("error", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : a ? { value: void 0, done: !0 } : new Promise((i, s) => n.push({ resolve: i, reject: s })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const e = Zs(this, af, "f");
    if (!e)
      throw new le("stream ended without producing a ChatCompletion");
    return e;
  }
}
function oE(t, e) {
  return tE(t, e);
}
class Rg extends Pe {
  constructor() {
    super(...arguments), this.inputItems = new _C(this._client);
  }
  create(e, n) {
    return this._client.post("/responses", { body: e, ...n, stream: e.stream ?? !1 })._thenUnwrap((a) => ("object" in a && a.object === "response" && gC(a), a));
  }
  retrieve(e, n = {}, a) {
    return Rt(n) ? this.retrieve(e, {}, n) : this._client.get(`/responses/${e}`, { query: n, ...a });
  }
  /**
   * Deletes a model response with the given ID.
   */
  del(e, n) {
    return this._client.delete(`/responses/${e}`, {
      ...n,
      headers: { Accept: "*/*", ...n?.headers }
    });
  }
  parse(e, n) {
    return this._client.responses.create(e, n)._thenUnwrap((a) => bC(a, e));
  }
  /**
   * Creates a chat completion stream
   */
  stream(e, n) {
    return Cg.createResponse(this._client, e, n);
  }
}
class uE extends ln {
}
Rg.InputItems = _C;
class yC extends Pe {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(e, n, a) {
    return this._client.post(`/uploads/${e}/parts`, Lu({ body: n, ...a }));
  }
}
class Tg extends Pe {
  constructor() {
    super(...arguments), this.parts = new yC(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(e, n) {
    return this._client.post("/uploads", { body: e, ...n });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(e, n) {
    return this._client.post(`/uploads/${e}/cancel`, n);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(e, n, a) {
    return this._client.post(`/uploads/${e}/complete`, { body: n, ...a });
  }
}
Tg.Parts = yC;
const cE = async (t) => {
  const e = await Promise.allSettled(t), n = e.filter((r) => r.status === "rejected");
  if (n.length) {
    for (const r of n)
      console.error(r.reason);
    throw new Error(`${n.length} promise(s) failed - see the above errors`);
  }
  const a = [];
  for (const r of e)
    r.status === "fulfilled" && a.push(r.value);
  return a;
};
class rp extends Pe {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(e, n, a) {
    return this._client.post(`/vector_stores/${e}/files`, {
      body: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(e, n, a) {
    return this._client.get(`/vector_stores/${e}/files/${n}`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(e, n, a, r) {
    return this._client.post(`/vector_stores/${e}/files/${n}`, {
      body: a,
      ...r,
      headers: { "OpenAI-Beta": "assistants=v2", ...r?.headers }
    });
  }
  list(e, n = {}, a) {
    return Rt(n) ? this.list(e, {}, n) : this._client.getAPIList(`/vector_stores/${e}/files`, ap, {
      query: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  del(e, n, a) {
    return this._client.delete(`/vector_stores/${e}/files/${n}`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(e, n, a) {
    const r = await this.create(e, n, a);
    return await this.poll(e, r.id, a);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(e, n, a) {
    const r = { ...a?.headers, "X-Stainless-Poll-Helper": "true" };
    for (a?.pollIntervalMs && (r["X-Stainless-Custom-Poll-Interval"] = a.pollIntervalMs.toString()); ; ) {
      const i = await this.retrieve(e, n, {
        ...a,
        headers: r
      }).withResponse(), s = i.data;
      switch (s.status) {
        case "in_progress":
          let u = 5e3;
          if (a?.pollIntervalMs)
            u = a.pollIntervalMs;
          else {
            const d = i.response.headers.get("openai-poll-after-ms");
            if (d) {
              const f = parseInt(d);
              isNaN(f) || (u = f);
            }
          }
          await Sd(u);
          break;
        case "failed":
        case "completed":
          return s;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(e, n, a) {
    const r = await this._client.files.create({ file: n, purpose: "assistants" }, a);
    return this.create(e, { file_id: r.id }, a);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(e, n, a) {
    const r = await this.upload(e, n, a);
    return await this.poll(e, r.id, a);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(e, n, a) {
    return this._client.getAPIList(`/vector_stores/${e}/files/${n}/content`, $g, { ...a, headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers } });
  }
}
class ap extends ln {
}
class $g extends ig {
}
rp.VectorStoreFilesPage = ap;
rp.FileContentResponsesPage = $g;
class vC extends Pe {
  /**
   * Create a vector store file batch.
   */
  create(e, n, a) {
    return this._client.post(`/vector_stores/${e}/file_batches`, {
      body: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(e, n, a) {
    return this._client.get(`/vector_stores/${e}/file_batches/${n}`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(e, n, a) {
    return this._client.post(`/vector_stores/${e}/file_batches/${n}/cancel`, {
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(e, n, a) {
    const r = await this.create(e, n);
    return await this.poll(e, r.id, a);
  }
  listFiles(e, n, a = {}, r) {
    return Rt(a) ? this.listFiles(e, n, {}, a) : this._client.getAPIList(`/vector_stores/${e}/file_batches/${n}/files`, ap, { query: a, ...r, headers: { "OpenAI-Beta": "assistants=v2", ...r?.headers } });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(e, n, a) {
    const r = { ...a?.headers, "X-Stainless-Poll-Helper": "true" };
    for (a?.pollIntervalMs && (r["X-Stainless-Custom-Poll-Interval"] = a.pollIntervalMs.toString()); ; ) {
      const { data: i, response: s } = await this.retrieve(e, n, {
        ...a,
        headers: r
      }).withResponse();
      switch (i.status) {
        case "in_progress":
          let u = 5e3;
          if (a?.pollIntervalMs)
            u = a.pollIntervalMs;
          else {
            const d = s.headers.get("openai-poll-after-ms");
            if (d) {
              const f = parseInt(d);
              isNaN(f) || (u = f);
            }
          }
          await Sd(u);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return i;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(e, { files: n, fileIds: a = [] }, r) {
    if (n == null || n.length == 0)
      throw new Error("No `files` provided to process. If you've already uploaded files you should use `.createAndPoll()` instead");
    const i = r?.maxConcurrency ?? 5, s = Math.min(i, n.length), u = this._client, d = n.values(), f = [...a];
    async function o(h) {
      for (let p of h) {
        const l = await u.files.create({ file: p, purpose: "assistants" }, r);
        f.push(l.id);
      }
    }
    const c = Array(s).fill(d).map(o);
    return await cE(c), await this.createAndPoll(e, {
      file_ids: f
    });
  }
}
class mo extends Pe {
  constructor() {
    super(...arguments), this.files = new rp(this._client), this.fileBatches = new vC(this._client);
  }
  /**
   * Create a vector store.
   */
  create(e, n) {
    return this._client.post("/vector_stores", {
      body: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(e, n) {
    return this._client.get(`/vector_stores/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Modifies a vector store.
   */
  update(e, n, a) {
    return this._client.post(`/vector_stores/${e}`, {
      body: n,
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
  list(e = {}, n) {
    return Rt(e) ? this.list({}, e) : this._client.getAPIList("/vector_stores", Mg, {
      query: e,
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Delete a vector store.
   */
  del(e, n) {
    return this._client.delete(`/vector_stores/${e}`, {
      ...n,
      headers: { "OpenAI-Beta": "assistants=v2", ...n?.headers }
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(e, n, a) {
    return this._client.getAPIList(`/vector_stores/${e}/search`, Ag, {
      body: n,
      method: "post",
      ...a,
      headers: { "OpenAI-Beta": "assistants=v2", ...a?.headers }
    });
  }
}
class Mg extends ln {
}
class Ag extends ig {
}
mo.VectorStoresPage = Mg;
mo.VectorStoreSearchResponsesPage = Ag;
mo.Files = rp;
mo.VectorStoreFilesPage = ap;
mo.FileContentResponsesPage = $g;
mo.FileBatches = vC;
var wC;
let ge = class extends TA {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL: e = Qd("OPENAI_BASE_URL"), apiKey: n = Qd("OPENAI_API_KEY"), organization: a = Qd("OPENAI_ORG_ID") ?? null, project: r = Qd("OPENAI_PROJECT_ID") ?? null, ...i } = {}) {
    if (n === void 0)
      throw new le("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    const s = {
      apiKey: n,
      organization: a,
      project: r,
      ...i,
      baseURL: e || "https://api.openai.com/v1"
    };
    if (!s.dangerouslyAllowBrowser && JA())
      throw new le(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

https://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety
`);
    super({
      baseURL: s.baseURL,
      timeout: s.timeout ?? 6e5,
      httpAgent: s.httpAgent,
      maxRetries: s.maxRetries,
      fetch: s.fetch
    }), this.completions = new fC(this), this.chat = new tp(this), this.embeddings = new hC(this), this.files = new _g(this), this.images = new pC(this), this.audio = new Od(this), this.moderations = new mC(this), this.models = new jg(this), this.fineTuning = new Cd(this), this.vectorStores = new mo(this), this.beta = new Hu(this), this.batches = new sg(this), this.uploads = new Tg(this), this.responses = new Rg(this), this._options = s, this.apiKey = n, this.organization = a, this.project = r;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(e) {
    return {
      ...super.defaultHeaders(e),
      "OpenAI-Organization": this.organization,
      "OpenAI-Project": this.project,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(e) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
  stringifyQuery(e) {
    return nA(e, { arrayFormat: "brackets" });
  }
};
wC = ge;
ge.OpenAI = wC;
ge.DEFAULT_TIMEOUT = 6e5;
ge.OpenAIError = le;
ge.APIError = on;
ge.APIConnectionError = Gh;
ge.APIConnectionTimeoutError = Wh;
ge.APIUserAbortError = vn;
ge.NotFoundError = SP;
ge.ConflictError = OP;
ge.RateLimitError = PP;
ge.BadRequestError = yP;
ge.AuthenticationError = vP;
ge.InternalServerError = CP;
ge.PermissionDeniedError = wP;
ge.UnprocessableEntityError = jP;
ge.toFile = EP;
ge.fileFromPath = gP;
ge.Completions = fC;
ge.Chat = tp;
ge.ChatCompletionsPage = ep;
ge.Embeddings = hC;
ge.Files = _g;
ge.FileObjectsPage = yg;
ge.Images = pC;
ge.Audio = Od;
ge.Moderations = mC;
ge.Models = jg;
ge.ModelsPage = Pg;
ge.FineTuning = Cd;
ge.VectorStores = mo;
ge.VectorStoresPage = Mg;
ge.VectorStoreSearchResponsesPage = Ag;
ge.Beta = Hu;
ge.Batches = sg;
ge.BatchesPage = og;
ge.Uploads = Tg;
ge.Responses = Rg;
function Ry(t, e = Eg) {
  t = t.trim();
  const n = /```(json)?(.*)```/s.exec(t);
  return e(n ? n[2] : t);
}
function Eg(t) {
  if (typeof t > "u")
    return null;
  try {
    return JSON.parse(t);
  } catch {
  }
  let e = "";
  const n = [];
  let a = !1, r = !1;
  for (let i of t) {
    if (a)
      i === '"' && !r ? a = !1 : i === `
` && !r ? i = "\\n" : i === "\\" ? r = !r : r = !1;
    else if (i === '"')
      a = !0, r = !1;
    else if (i === "{")
      n.push("}");
    else if (i === "[")
      n.push("]");
    else if (i === "}" || i === "]")
      if (n && n[n.length - 1] === i)
        n.pop();
      else
        return null;
    e += i;
  }
  a && (e += '"');
  for (let i = n.length - 1; i >= 0; i -= 1)
    e += n[i];
  try {
    return JSON.parse(e);
  } catch {
    return null;
  }
}
function Rd(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Wp, Ty;
function lE() {
  return Ty || (Ty = 1, Wp = function(t, e) {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    return e = typeof e > "u" ? "_" : e, t.replace(/([a-z\d])([A-Z])/g, "$1" + e + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + e + "$2").toLowerCase();
  }), Wp;
}
var dE = /* @__PURE__ */ lE();
const fE = /* @__PURE__ */ Rd(dE);
function hE(t, e) {
  return e?.[t] || fE(t);
}
function pE(t, e, n) {
  const a = {};
  for (const r in t)
    Object.hasOwn(t, r) && (a[e(r, n)] = t[r]);
  return a;
}
function $y(t) {
  return Array.isArray(t) ? [...t] : { ...t };
}
function mE(t, e) {
  const n = $y(t);
  for (const [a, r] of Object.entries(e)) {
    const [i, ...s] = a.split(".").reverse();
    let u = n;
    for (const d of s.reverse()) {
      if (u[d] === void 0)
        break;
      u[d] = $y(u[d]), u = u[d];
    }
    u[i] !== void 0 && (u[i] = {
      lc: 1,
      type: "secret",
      id: [r]
    });
  }
  return n;
}
function SC(t) {
  const e = Object.getPrototypeOf(t);
  return typeof t.lc_name == "function" && (typeof e.lc_name != "function" || t.lc_name() !== e.lc_name()) ? t.lc_name() : t.name;
}
class pr {
  /**
   * The name of the serializable. Override to provide an alias or
   * to preserve the serialized module name in minified environments.
   *
   * Implemented as a static method to support loading logic.
   */
  static lc_name() {
    return this.name;
  }
  /**
   * The final serialized identifier for the module.
   */
  get lc_id() {
    return [
      ...this.lc_namespace,
      SC(this.constructor)
    ];
  }
  /**
   * A map of secrets, which will be omitted from serialization.
   * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
   * Values are the secret ids, which will be used when deserializing.
   */
  get lc_secrets() {
  }
  /**
   * A map of additional attributes to merge with constructor args.
   * Keys are the attribute names, e.g. "foo".
   * Values are the attribute values, which will be serialized.
   * These attributes need to be accepted by the constructor as arguments.
   */
  get lc_attributes() {
  }
  /**
   * A map of aliases for constructor args.
   * Keys are the attribute names, e.g. "foo".
   * Values are the alias that will replace the key in serialization.
   * This is used to eg. make argument names match Python.
   */
  get lc_aliases() {
  }
  /**
   * A manual list of keys that should be serialized.
   * If not overridden, all fields passed into the constructor will be serialized.
   */
  get lc_serializable_keys() {
  }
  constructor(e, ...n) {
    Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "lc_kwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.lc_serializable_keys !== void 0 ? this.lc_kwargs = Object.fromEntries(Object.entries(e || {}).filter(([a]) => this.lc_serializable_keys?.includes(a))) : this.lc_kwargs = e ?? {};
  }
  toJSON() {
    if (!this.lc_serializable)
      return this.toJSONNotImplemented();
    if (
      // eslint-disable-next-line no-instanceof/no-instanceof
      this.lc_kwargs instanceof pr || typeof this.lc_kwargs != "object" || Array.isArray(this.lc_kwargs)
    )
      return this.toJSONNotImplemented();
    const e = {}, n = {}, a = Object.keys(this.lc_kwargs).reduce((r, i) => (r[i] = i in this ? this[i] : this.lc_kwargs[i], r), {});
    for (let r = Object.getPrototypeOf(this); r; r = Object.getPrototypeOf(r))
      Object.assign(e, Reflect.get(r, "lc_aliases", this)), Object.assign(n, Reflect.get(r, "lc_secrets", this)), Object.assign(a, Reflect.get(r, "lc_attributes", this));
    return Object.keys(n).forEach((r) => {
      let i = this, s = a;
      const [u, ...d] = r.split(".").reverse();
      for (const f of d.reverse()) {
        if (!(f in i) || i[f] === void 0)
          return;
        (!(f in s) || s[f] === void 0) && (typeof i[f] == "object" && i[f] != null ? s[f] = {} : Array.isArray(i[f]) && (s[f] = [])), i = i[f], s = s[f];
      }
      u in i && i[u] !== void 0 && (s[u] = s[u] || i[u]);
    }), {
      lc: 1,
      type: "constructor",
      id: this.lc_id,
      kwargs: pE(Object.keys(n).length ? mE(a, n) : a, hE, e)
    };
  }
  toJSONNotImplemented() {
    return {
      lc: 1,
      type: "not_implemented",
      id: this.lc_id
    };
  }
}
function Wu(t, e) {
  return typeof t == "string" ? t === "" ? e : typeof e == "string" ? t + e : [{ type: "text", text: t }, ...e] : Array.isArray(e) ? ip(t, e) ?? [
    ...t,
    ...e
  ] : e === "" ? t : [...t, { type: "text", text: e }];
}
function bE(t, e) {
  return t === "error" || e === "error" ? "error" : "success";
}
function gE(t, e) {
  function n(a, r) {
    if (typeof a != "object" || a === null || a === void 0)
      return a;
    if (r >= e)
      return Array.isArray(a) ? "[Array]" : "[Object]";
    if (Array.isArray(a))
      return a.map((s) => n(s, r + 1));
    const i = {};
    for (const s of Object.keys(a))
      i[s] = n(a[s], r + 1);
    return i;
  }
  return JSON.stringify(n(t, 0), null, 2);
}
class sa extends pr {
  get lc_aliases() {
    return {
      additional_kwargs: "additional_kwargs",
      response_metadata: "response_metadata"
    };
  }
  /**
   * Get text content of the message.
   */
  get text() {
    return typeof this.content == "string" ? this.content : Array.isArray(this.content) ? this.content.map((e) => typeof e == "string" ? e : e.type === "text" ? e.text : "").join("") : "";
  }
  /** The type of the message. */
  getType() {
    return this._getType();
  }
  constructor(e, n) {
    typeof e == "string" && (e = {
      content: e,
      additional_kwargs: n,
      response_metadata: {}
    }), e.additional_kwargs || (e.additional_kwargs = {}), e.response_metadata || (e.response_metadata = {}), super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "messages"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "content", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "additional_kwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "response_metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = e.name, this.content = e.content, this.additional_kwargs = e.additional_kwargs, this.response_metadata = e.response_metadata, this.id = e.id;
  }
  toDict() {
    return {
      type: this._getType(),
      data: this.toJSON().kwargs
    };
  }
  static lc_name() {
    return "BaseMessage";
  }
  // Can't be protected for silly reasons
  get _printableFields() {
    return {
      id: this.id,
      content: this.content,
      name: this.name,
      additional_kwargs: this.additional_kwargs,
      response_metadata: this.response_metadata
    };
  }
  // this private method is used to update the ID for the runtime
  // value as well as in lc_kwargs for serialisation
  _updateId(e) {
    this.id = e, this.lc_kwargs.id = e;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.lc_name();
  }
  // Override the default behavior of console.log
  [Symbol.for("nodejs.util.inspect.custom")](e) {
    if (e === null)
      return this;
    const n = gE(this._printableFields, Math.max(4, e));
    return `${this.constructor.lc_name()} ${n}`;
  }
}
function Ht(t, e) {
  const n = { ...t };
  for (const [a, r] of Object.entries(e))
    if (n[a] == null)
      n[a] = r;
    else {
      if (r == null)
        continue;
      if (typeof n[a] != typeof r || Array.isArray(n[a]) !== Array.isArray(r))
        throw new Error(`field[${a}] already exists in the message chunk, but with a different type.`);
      if (typeof n[a] == "string") {
        if (a === "type")
          continue;
        n[a] += r;
      } else if (typeof n[a] == "object" && !Array.isArray(n[a]))
        n[a] = Ht(n[a], r);
      else if (Array.isArray(n[a]))
        n[a] = ip(n[a], r);
      else {
        if (n[a] === r)
          continue;
        console.warn(`field[${a}] already exists in this message chunk and value has unsupported type.`);
      }
    }
  return n;
}
function ip(t, e) {
  if (!(t === void 0 && e === void 0)) {
    if (t === void 0 || e === void 0)
      return t || e;
    {
      const n = [...t];
      for (const a of e)
        if (typeof a == "object" && "index" in a && typeof a.index == "number") {
          const r = n.findIndex((i) => i.index === a.index);
          r !== -1 ? n[r] = Ht(n[r], a) : n.push(a);
        } else {
          if (typeof a == "object" && "text" in a && a.text === "")
            continue;
          n.push(a);
        }
      return n;
    }
  }
}
function _E(t, e) {
  if (!t && !e)
    throw new Error("Cannot merge two undefined objects.");
  if (!t || !e)
    return t || e;
  if (typeof t != typeof e)
    throw new Error(`Cannot merge objects of different types.
Left ${typeof t}
Right ${typeof e}`);
  if (typeof t == "string" && typeof e == "string")
    return t + e;
  if (Array.isArray(t) && Array.isArray(e))
    return ip(t, e);
  if (typeof t == "object" && typeof e == "object")
    return Ht(t, e);
  if (t === e)
    return t;
  throw new Error(`Can not merge objects of different types.
Left ${t}
Right ${e}`);
}
class Xu extends sa {
}
function yE(t) {
  return typeof t.role == "string";
}
function nn(t) {
  return typeof t?._getType == "function";
}
function Pb(t) {
  return nn(t) && typeof t.concat == "function";
}
function vE(t) {
  return t != null && typeof t == "object" && "lc_direct_tool_output" in t && t.lc_direct_tool_output === !0;
}
class Cb extends sa {
  static lc_name() {
    return "ToolMessage";
  }
  get lc_aliases() {
    return { tool_call_id: "tool_call_id" };
  }
  constructor(e, n, a) {
    typeof e == "string" && (e = { content: e, name: a, tool_call_id: n }), super(e), Object.defineProperty(this, "lc_direct_tool_output", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tool_call_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "artifact", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.tool_call_id = e.tool_call_id, this.artifact = e.artifact, this.status = e.status;
  }
  _getType() {
    return "tool";
  }
  static isInstance(e) {
    return e._getType() === "tool";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
}
class sp extends Xu {
  constructor(e) {
    super(e), Object.defineProperty(this, "tool_call_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "artifact", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.tool_call_id = e.tool_call_id, this.artifact = e.artifact, this.status = e.status;
  }
  static lc_name() {
    return "ToolMessageChunk";
  }
  _getType() {
    return "tool";
  }
  concat(e) {
    return new sp({
      content: Wu(this.content, e.content),
      additional_kwargs: Ht(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Ht(this.response_metadata, e.response_metadata),
      artifact: _E(this.artifact, e.artifact),
      tool_call_id: this.tool_call_id,
      id: this.id ?? e.id,
      status: bE(this.status, e.status)
    });
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
}
function wE(t) {
  const e = [], n = [];
  for (const a of t)
    if (a.function) {
      const r = a.function.name;
      try {
        const i = JSON.parse(a.function.arguments), s = {
          name: r || "",
          args: i || {},
          id: a.id
        };
        e.push(s);
      } catch {
        n.push({
          name: r,
          args: a.function.arguments,
          id: a.id,
          error: "Malformed args."
        });
      }
    } else
      continue;
  return [e, n];
}
function SE(t) {
  return t._getType() === "tool";
}
class At extends sa {
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls"
    };
  }
  constructor(e, n) {
    let a;
    if (typeof e == "string")
      a = {
        content: e,
        tool_calls: [],
        invalid_tool_calls: [],
        additional_kwargs: n ?? {}
      };
    else {
      a = e;
      const r = a.additional_kwargs?.tool_calls, i = a.tool_calls;
      r != null && r.length > 0 && (i === void 0 || i.length === 0) && console.warn([
        "New LangChain packages are available that more efficiently handle",
        `tool calling.

Please upgrade your packages to versions that set`,
        "message tool calls. e.g., `yarn add @langchain/anthropic`,",
        "yarn add @langchain/openai`, etc."
      ].join(" "));
      try {
        if (r != null && i === void 0) {
          const [s, u] = wE(r);
          a.tool_calls = s ?? [], a.invalid_tool_calls = u ?? [];
        } else
          a.tool_calls = a.tool_calls ?? [], a.invalid_tool_calls = a.invalid_tool_calls ?? [];
      } catch {
        a.tool_calls = [], a.invalid_tool_calls = [];
      }
    }
    super(a), Object.defineProperty(this, "tool_calls", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "invalid_tool_calls", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "usage_metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), typeof a != "string" && (this.tool_calls = a.tool_calls ?? this.tool_calls, this.invalid_tool_calls = a.invalid_tool_calls ?? this.invalid_tool_calls), this.usage_metadata = a.usage_metadata;
  }
  static lc_name() {
    return "AIMessage";
  }
  _getType() {
    return "ai";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
}
function uo(t) {
  return t._getType() === "ai";
}
function My(t) {
  return t._getType() === "ai";
}
class We extends Xu {
  constructor(e) {
    let n;
    if (typeof e == "string")
      n = {
        content: e,
        tool_calls: [],
        invalid_tool_calls: [],
        tool_call_chunks: []
      };
    else if (e.tool_call_chunks === void 0)
      n = {
        ...e,
        tool_calls: e.tool_calls ?? [],
        invalid_tool_calls: [],
        tool_call_chunks: [],
        usage_metadata: e.usage_metadata !== void 0 ? e.usage_metadata : void 0
      };
    else {
      const a = [], r = [];
      for (const i of e.tool_call_chunks) {
        let s = {};
        try {
          if (s = Eg(i.args || "{}"), s === null || typeof s != "object" || Array.isArray(s))
            throw new Error("Malformed tool call chunk args.");
          a.push({
            name: i.name ?? "",
            args: s,
            id: i.id,
            type: "tool_call"
          });
        } catch {
          r.push({
            name: i.name,
            args: i.args,
            id: i.id,
            error: "Malformed args.",
            type: "invalid_tool_call"
          });
        }
      }
      n = {
        ...e,
        tool_calls: a,
        invalid_tool_calls: r,
        usage_metadata: e.usage_metadata !== void 0 ? e.usage_metadata : void 0
      };
    }
    super(n), Object.defineProperty(this, "tool_calls", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "invalid_tool_calls", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "tool_call_chunks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "usage_metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.tool_call_chunks = n.tool_call_chunks ?? this.tool_call_chunks, this.tool_calls = n.tool_calls ?? this.tool_calls, this.invalid_tool_calls = n.invalid_tool_calls ?? this.invalid_tool_calls, this.usage_metadata = n.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls",
      tool_call_chunks: "tool_call_chunks"
    };
  }
  static lc_name() {
    return "AIMessageChunk";
  }
  _getType() {
    return "ai";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      tool_call_chunks: this.tool_call_chunks,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  concat(e) {
    const n = {
      content: Wu(this.content, e.content),
      additional_kwargs: Ht(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Ht(this.response_metadata, e.response_metadata),
      tool_call_chunks: [],
      id: this.id ?? e.id
    };
    if (this.tool_call_chunks !== void 0 || e.tool_call_chunks !== void 0) {
      const a = ip(this.tool_call_chunks, e.tool_call_chunks);
      a !== void 0 && a.length > 0 && (n.tool_call_chunks = a);
    }
    if (this.usage_metadata !== void 0 || e.usage_metadata !== void 0) {
      const a = {
        ...(this.usage_metadata?.input_token_details?.audio !== void 0 || e.usage_metadata?.input_token_details?.audio !== void 0) && {
          audio: (this.usage_metadata?.input_token_details?.audio ?? 0) + (e.usage_metadata?.input_token_details?.audio ?? 0)
        },
        ...(this.usage_metadata?.input_token_details?.cache_read !== void 0 || e.usage_metadata?.input_token_details?.cache_read !== void 0) && {
          cache_read: (this.usage_metadata?.input_token_details?.cache_read ?? 0) + (e.usage_metadata?.input_token_details?.cache_read ?? 0)
        },
        ...(this.usage_metadata?.input_token_details?.cache_creation !== void 0 || e.usage_metadata?.input_token_details?.cache_creation !== void 0) && {
          cache_creation: (this.usage_metadata?.input_token_details?.cache_creation ?? 0) + (e.usage_metadata?.input_token_details?.cache_creation ?? 0)
        }
      }, r = {
        ...(this.usage_metadata?.output_token_details?.audio !== void 0 || e.usage_metadata?.output_token_details?.audio !== void 0) && {
          audio: (this.usage_metadata?.output_token_details?.audio ?? 0) + (e.usage_metadata?.output_token_details?.audio ?? 0)
        },
        ...(this.usage_metadata?.output_token_details?.reasoning !== void 0 || e.usage_metadata?.output_token_details?.reasoning !== void 0) && {
          reasoning: (this.usage_metadata?.output_token_details?.reasoning ?? 0) + (e.usage_metadata?.output_token_details?.reasoning ?? 0)
        }
      }, i = this.usage_metadata ?? {
        input_tokens: 0,
        output_tokens: 0,
        total_tokens: 0
      }, s = e.usage_metadata ?? {
        input_tokens: 0,
        output_tokens: 0,
        total_tokens: 0
      }, u = {
        input_tokens: i.input_tokens + s.input_tokens,
        output_tokens: i.output_tokens + s.output_tokens,
        total_tokens: i.total_tokens + s.total_tokens,
        // Do not include `input_token_details` / `output_token_details` keys in combined fields
        // unless their values are defined.
        ...Object.keys(a).length > 0 && {
          input_token_details: a
        },
        ...Object.keys(r).length > 0 && {
          output_token_details: r
        }
      };
      n.usage_metadata = u;
    }
    return new We(n);
  }
}
class Xo extends sa {
  static lc_name() {
    return "ChatMessage";
  }
  static _chatMessageClass() {
    return Xo;
  }
  constructor(e, n) {
    typeof e == "string" && (e = { content: e, role: n }), super(e), Object.defineProperty(this, "role", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.role = e.role;
  }
  _getType() {
    return "generic";
  }
  static isInstance(e) {
    return e._getType() === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
}
class Td extends Xu {
  static lc_name() {
    return "ChatMessageChunk";
  }
  constructor(e, n) {
    typeof e == "string" && (e = { content: e, role: n }), super(e), Object.defineProperty(this, "role", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.role = e.role;
  }
  _getType() {
    return "generic";
  }
  concat(e) {
    return new Td({
      content: Wu(this.content, e.content),
      additional_kwargs: Ht(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Ht(this.response_metadata, e.response_metadata),
      role: this.role,
      id: this.id ?? e.id
    });
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
}
class OE extends sa {
  static lc_name() {
    return "FunctionMessage";
  }
  constructor(e, n) {
    typeof e == "string" && (e = { content: e, name: n }), super(e);
  }
  _getType() {
    return "function";
  }
}
class $d extends Xu {
  static lc_name() {
    return "FunctionMessageChunk";
  }
  _getType() {
    return "function";
  }
  concat(e) {
    return new $d({
      content: Wu(this.content, e.content),
      additional_kwargs: Ht(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Ht(this.response_metadata, e.response_metadata),
      name: this.name ?? "",
      id: this.id ?? e.id
    });
  }
}
class mr extends sa {
  static lc_name() {
    return "HumanMessage";
  }
  _getType() {
    return "human";
  }
}
class Md extends Xu {
  static lc_name() {
    return "HumanMessageChunk";
  }
  _getType() {
    return "human";
  }
  concat(e) {
    return new Md({
      content: Wu(this.content, e.content),
      additional_kwargs: Ht(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Ht(this.response_metadata, e.response_metadata),
      id: this.id ?? e.id
    });
  }
}
class dh extends sa {
  static lc_name() {
    return "SystemMessage";
  }
  _getType() {
    return "system";
  }
}
class Xl extends Xu {
  static lc_name() {
    return "SystemMessageChunk";
  }
  _getType() {
    return "system";
  }
  concat(e) {
    return new Xl({
      content: Wu(this.content, e.content),
      additional_kwargs: Ht(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Ht(this.response_metadata, e.response_metadata),
      id: this.id ?? e.id
    });
  }
}
function op(t, e) {
  return t.lc_error_code = e, t.message = `${t.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${e}/
`, t;
}
function Ig(t) {
  return !!(t && typeof t == "object" && "type" in t && t.type === "tool_call");
}
class fh extends Error {
  constructor(e, n) {
    super(e), Object.defineProperty(this, "output", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.output = n;
  }
}
function jE(t) {
  return Ig(t) ? t : typeof t.id == "string" && t.type === "function" && typeof t.function == "object" && t.function !== null && "arguments" in t.function && typeof t.function.arguments == "string" && "name" in t.function && typeof t.function.name == "string" ? {
    id: t.id,
    args: JSON.parse(t.function.arguments),
    name: t.function.name,
    type: "tool_call"
  } : t;
}
function PE(t) {
  return typeof t == "object" && t != null && t.lc === 1 && Array.isArray(t.id) && t.kwargs != null && typeof t.kwargs == "object";
}
function Xp(t) {
  let e, n;
  if (PE(t)) {
    const a = t.id.at(-1);
    a === "HumanMessage" || a === "HumanMessageChunk" ? e = "user" : a === "AIMessage" || a === "AIMessageChunk" ? e = "assistant" : a === "SystemMessage" || a === "SystemMessageChunk" ? e = "system" : a === "FunctionMessage" || a === "FunctionMessageChunk" ? e = "function" : a === "ToolMessage" || a === "ToolMessageChunk" ? e = "tool" : e = "unknown", n = t.kwargs;
  } else {
    const { type: a, ...r } = t;
    e = a, n = r;
  }
  if (e === "human" || e === "user")
    return new mr(n);
  if (e === "ai" || e === "assistant") {
    const { tool_calls: a, ...r } = n;
    if (!Array.isArray(a))
      return new At(n);
    const i = a.map(jE);
    return new At({ ...r, tool_calls: i });
  } else {
    if (e === "system")
      return new dh(n);
    if (e === "developer")
      return new dh({
        ...n,
        additional_kwargs: {
          ...n.additional_kwargs,
          __openai_role__: "developer"
        }
      });
    if (e === "tool" && "tool_call_id" in n)
      return new Cb({
        ...n,
        content: n.content,
        tool_call_id: n.tool_call_id,
        name: n.name
      });
    throw op(new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(t, null, 2)}`), "MESSAGE_COERCION_FAILURE");
  }
}
function io(t) {
  if (typeof t == "string")
    return new mr(t);
  if (nn(t))
    return t;
  if (Array.isArray(t)) {
    const [e, n] = t;
    return Xp({ type: e, content: n });
  } else if (yE(t)) {
    const { role: e, ...n } = t;
    return Xp({ ...n, type: e });
  } else
    return Xp(t);
}
function so(t, e = "Human", n = "AI") {
  const a = [];
  for (const r of t) {
    let i;
    if (r._getType() === "human")
      i = e;
    else if (r._getType() === "ai")
      i = n;
    else if (r._getType() === "system")
      i = "System";
    else if (r._getType() === "function")
      i = "Function";
    else if (r._getType() === "tool")
      i = "Tool";
    else if (r._getType() === "generic")
      i = r.role;
    else
      throw new Error(`Got unsupported message type: ${r._getType()}`);
    const s = r.name ? `${r.name}, ` : "", u = typeof r.content == "string" ? r.content : JSON.stringify(r.content, null, 2);
    a.push(`${i}: ${s}${u}`);
  }
  return a.join(`
`);
}
function CE(t) {
  const e = t._getType();
  if (e === "human")
    return new Md({ ...t });
  if (e === "ai") {
    let n = {
      ...t
    };
    return "tool_calls" in n && (n = {
      ...n,
      tool_call_chunks: n.tool_calls?.map((a) => ({
        ...a,
        type: "tool_call_chunk",
        index: void 0,
        args: JSON.stringify(a.args)
      }))
    }), new We({ ...n });
  } else {
    if (e === "system")
      return new Xl({ ...t });
    if (e === "function")
      return new $d({ ...t });
    if (Xo.isInstance(t))
      return new Td({ ...t });
    throw new Error("Unknown message type.");
  }
}
var Re;
(function(t) {
  t.assertEqual = (r) => r;
  function e(r) {
  }
  t.assertIs = e;
  function n(r) {
    throw new Error();
  }
  t.assertNever = n, t.arrayToEnum = (r) => {
    const i = {};
    for (const s of r)
      i[s] = s;
    return i;
  }, t.getValidEnumValues = (r) => {
    const i = t.objectKeys(r).filter((u) => typeof r[r[u]] != "number"), s = {};
    for (const u of i)
      s[u] = r[u];
    return t.objectValues(s);
  }, t.objectValues = (r) => t.objectKeys(r).map(function(i) {
    return r[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (r) => Object.keys(r) : (r) => {
    const i = [];
    for (const s in r)
      Object.prototype.hasOwnProperty.call(r, s) && i.push(s);
    return i;
  }, t.find = (r, i) => {
    for (const s of r)
      if (i(s))
        return s;
  }, t.isInteger = typeof Number.isInteger == "function" ? (r) => Number.isInteger(r) : (r) => typeof r == "number" && isFinite(r) && Math.floor(r) === r;
  function a(r, i = " | ") {
    return r.map((s) => typeof s == "string" ? `'${s}'` : s).join(i);
  }
  t.joinValues = a, t.jsonStringifyReplacer = (r, i) => typeof i == "bigint" ? i.toString() : i;
})(Re || (Re = {}));
var Rb;
(function(t) {
  t.mergeShapes = (e, n) => ({
    ...e,
    ...n
    // second overwrites first
  });
})(Rb || (Rb = {}));
const te = Re.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Ns = (t) => {
  switch (typeof t) {
    case "undefined":
      return te.undefined;
    case "string":
      return te.string;
    case "number":
      return isNaN(t) ? te.nan : te.number;
    case "boolean":
      return te.boolean;
    case "function":
      return te.function;
    case "bigint":
      return te.bigint;
    case "symbol":
      return te.symbol;
    case "object":
      return Array.isArray(t) ? te.array : t === null ? te.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? te.promise : typeof Map < "u" && t instanceof Map ? te.map : typeof Set < "u" && t instanceof Set ? te.set : typeof Date < "u" && t instanceof Date ? te.date : te.object;
    default:
      return te.unknown;
  }
}, Y = Re.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), RE = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
let dr = class OC extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (a) => {
      this.issues = [...this.issues, a];
    }, this.addIssues = (a = []) => {
      this.issues = [...this.issues, ...a];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const n = e || function(i) {
      return i.message;
    }, a = { _errors: [] }, r = (i) => {
      for (const s of i.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(r);
        else if (s.code === "invalid_return_type")
          r(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          r(s.argumentsError);
        else if (s.path.length === 0)
          a._errors.push(n(s));
        else {
          let u = a, d = 0;
          for (; d < s.path.length; ) {
            const f = s.path[d];
            d === s.path.length - 1 ? (u[f] = u[f] || { _errors: [] }, u[f]._errors.push(n(s))) : u[f] = u[f] || { _errors: [] }, u = u[f], d++;
          }
        }
    };
    return r(this), a;
  }
  static assert(e) {
    if (!(e instanceof OC))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Re.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (n) => n.message) {
    const n = {}, a = [];
    for (const r of this.issues)
      r.path.length > 0 ? (n[r.path[0]] = n[r.path[0]] || [], n[r.path[0]].push(e(r))) : a.push(e(r));
    return { formErrors: a, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
};
dr.create = (t) => new dr(t);
const Uu = (t, e) => {
  let n;
  switch (t.code) {
    case Y.invalid_type:
      t.received === te.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
      break;
    case Y.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected, Re.jsonStringifyReplacer)}`;
      break;
    case Y.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${Re.joinValues(t.keys, ", ")}`;
      break;
    case Y.invalid_union:
      n = "Invalid input";
      break;
    case Y.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${Re.joinValues(t.options)}`;
      break;
    case Y.invalid_enum_value:
      n = `Invalid enum value. Expected ${Re.joinValues(t.options)}, received '${t.received}'`;
      break;
    case Y.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case Y.invalid_return_type:
      n = "Invalid function return type";
      break;
    case Y.invalid_date:
      n = "Invalid date";
      break;
    case Y.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (n = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : Re.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
      break;
    case Y.too_small:
      t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : n = "Invalid input";
      break;
    case Y.too_big:
      t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? n = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : n = "Invalid input";
      break;
    case Y.custom:
      n = "Invalid input";
      break;
    case Y.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case Y.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case Y.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = e.defaultError, Re.assertNever(t);
  }
  return { message: n };
};
let jC = Uu;
function TE(t) {
  jC = t;
}
function hh() {
  return jC;
}
const ph = (t) => {
  const { data: e, path: n, errorMaps: a, issueData: r } = t, i = [...n, ...r.path || []], s = {
    ...r,
    path: i
  };
  if (r.message !== void 0)
    return {
      ...r,
      path: i,
      message: r.message
    };
  let u = "";
  const d = a.filter((f) => !!f).slice().reverse();
  for (const f of d)
    u = f(s, { data: e, defaultError: u }).message;
  return {
    ...r,
    path: i,
    message: u
  };
}, $E = [];
function ee(t, e) {
  const n = hh(), a = ph({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      // contextual error map is first priority
      t.schemaErrorMap,
      // then schema-bound map if available
      n,
      // then global override map
      n === Uu ? void 0 : Uu
      // then global default map
    ].filter((r) => !!r)
  });
  t.common.issues.push(a);
}
class Lt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, n) {
    const a = [];
    for (const r of n) {
      if (r.status === "aborted")
        return fe;
      r.status === "dirty" && e.dirty(), a.push(r.value);
    }
    return { status: e.value, value: a };
  }
  static async mergeObjectAsync(e, n) {
    const a = [];
    for (const r of n) {
      const i = await r.key, s = await r.value;
      a.push({
        key: i,
        value: s
      });
    }
    return Lt.mergeObjectSync(e, a);
  }
  static mergeObjectSync(e, n) {
    const a = {};
    for (const r of n) {
      const { key: i, value: s } = r;
      if (i.status === "aborted" || s.status === "aborted")
        return fe;
      i.status === "dirty" && e.dirty(), s.status === "dirty" && e.dirty(), i.value !== "__proto__" && (typeof s.value < "u" || r.alwaysSet) && (a[i.value] = s.value);
    }
    return { status: e.value, value: a };
  }
}
const fe = Object.freeze({
  status: "aborted"
}), $u = (t) => ({ status: "dirty", value: t }), Gt = (t) => ({ status: "valid", value: t }), Tb = (t) => t.status === "aborted", $b = (t) => t.status === "dirty", Zo = (t) => t.status === "valid", Ql = (t) => typeof Promise < "u" && t instanceof Promise;
function mh(t, e, n, a) {
  if (typeof e == "function" ? t !== e || !0 : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e.get(t);
}
function PC(t, e, n, a, r) {
  if (typeof e == "function" ? t !== e || !0 : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return e.set(t, n), n;
}
var ae;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e?.message;
})(ae || (ae = {}));
var Al, El;
class la {
  constructor(e, n, a, r) {
    this._cachedPath = [], this.parent = e, this.data = n, this._path = a, this._key = r;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Ay = (t, e) => {
  if (Zo(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new dr(t.common.issues);
      return this._error = n, this._error;
    }
  };
};
function me(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: n, required_error: a, description: r } = t;
  if (e && (n || a))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: r } : { errorMap: (s, u) => {
    var d, f;
    const { message: o } = t;
    return s.code === "invalid_enum_value" ? { message: o ?? u.defaultError } : typeof u.data > "u" ? { message: (d = o ?? a) !== null && d !== void 0 ? d : u.defaultError } : s.code !== "invalid_type" ? { message: u.defaultError } : { message: (f = o ?? n) !== null && f !== void 0 ? f : u.defaultError };
  }, description: r };
}
class ye {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return Ns(e.data);
  }
  _getOrReturnCtx(e, n) {
    return n || {
      common: e.parent.common,
      data: e.data,
      parsedType: Ns(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new Lt(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: Ns(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (Ql(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n);
  }
  parse(e, n) {
    const a = this.safeParse(e, n);
    if (a.success)
      return a.data;
    throw a.error;
  }
  safeParse(e, n) {
    var a;
    const r = {
      common: {
        issues: [],
        async: (a = n?.async) !== null && a !== void 0 ? a : !1,
        contextualErrorMap: n?.errorMap
      },
      path: n?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Ns(e)
    }, i = this._parseSync({ data: e, path: r.path, parent: r });
    return Ay(r, i);
  }
  "~validate"(e) {
    var n, a;
    const r = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Ns(e)
    };
    if (!this["~standard"].async)
      try {
        const i = this._parseSync({ data: e, path: [], parent: r });
        return Zo(i) ? {
          value: i.value
        } : {
          issues: r.common.issues
        };
      } catch (i) {
        !((a = (n = i?.message) === null || n === void 0 ? void 0 : n.toLowerCase()) === null || a === void 0) && a.includes("encountered") && (this["~standard"].async = !0), r.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: e, path: [], parent: r }).then((i) => Zo(i) ? {
      value: i.value
    } : {
      issues: r.common.issues
    });
  }
  async parseAsync(e, n) {
    const a = await this.safeParseAsync(e, n);
    if (a.success)
      return a.data;
    throw a.error;
  }
  async safeParseAsync(e, n) {
    const a = {
      common: {
        issues: [],
        contextualErrorMap: n?.errorMap,
        async: !0
      },
      path: n?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Ns(e)
    }, r = this._parse({ data: e, path: a.path, parent: a }), i = await (Ql(r) ? r : Promise.resolve(r));
    return Ay(a, i);
  }
  refine(e, n) {
    const a = (r) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(r) : n;
    return this._refinement((r, i) => {
      const s = e(r), u = () => i.addIssue({
        code: Y.custom,
        ...a(r)
      });
      return typeof Promise < "u" && s instanceof Promise ? s.then((d) => d ? !0 : (u(), !1)) : s ? !0 : (u(), !1);
    });
  }
  refinement(e, n) {
    return this._refinement((a, r) => e(a) ? !0 : (r.addIssue(typeof n == "function" ? n(a, r) : n), !1));
  }
  _refinement(e) {
    return new br({
      schema: this,
      typeName: K.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (n) => this["~validate"](n)
    };
  }
  optional() {
    return hr.create(this, this._def);
  }
  nullable() {
    return ho.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return fr.create(this);
  }
  promise() {
    return xu.create(this, this._def);
  }
  or(e) {
    return nd.create([this, e], this._def);
  }
  and(e) {
    return rd.create(this, e, this._def);
  }
  transform(e) {
    return new br({
      ...me(this._def),
      schema: this,
      typeName: K.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const n = typeof e == "function" ? e : () => e;
    return new ud({
      ...me(this._def),
      innerType: this,
      defaultValue: n,
      typeName: K.ZodDefault
    });
  }
  brand() {
    return new Ng({
      typeName: K.ZodBranded,
      type: this,
      ...me(this._def)
    });
  }
  catch(e) {
    const n = typeof e == "function" ? e : () => e;
    return new cd({
      ...me(this._def),
      innerType: this,
      catchValue: n,
      typeName: K.ZodCatch
    });
  }
  describe(e) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Ad.create(this, e);
  }
  readonly() {
    return ld.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const ME = /^c[^\s-]{8,}$/i, AE = /^[0-9a-z]+$/, EE = /^[0-9A-HJKMNP-TV-Z]{26}$/i, IE = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, NE = /^[a-z0-9_-]{21}$/i, FE = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, kE = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, DE = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, qE = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let Qp;
const JE = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, LE = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, UE = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, BE = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, xE = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, VE = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, CC = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", zE = new RegExp(`^${CC}$`);
function RC(t) {
  let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`), e;
}
function ZE(t) {
  return new RegExp(`^${RC(t)}$`);
}
function TC(t) {
  let e = `${CC}T${RC(t)}`;
  const n = [];
  return n.push(t.local ? "Z?" : "Z"), t.offset && n.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${n.join("|")})`, new RegExp(`^${e}$`);
}
function KE(t, e) {
  return !!((e === "v4" || !e) && JE.test(t) || (e === "v6" || !e) && UE.test(t));
}
function HE(t, e) {
  if (!FE.test(t))
    return !1;
  try {
    const [n] = t.split("."), a = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "="), r = JSON.parse(atob(a));
    return !(typeof r != "object" || r === null || !r.typ || !r.alg || e && r.alg !== e);
  } catch {
    return !1;
  }
}
function GE(t, e) {
  return !!((e === "v4" || !e) && LE.test(t) || (e === "v6" || !e) && BE.test(t));
}
class sr extends ye {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== te.string) {
      const i = this._getOrReturnCtx(e);
      return ee(i, {
        code: Y.invalid_type,
        expected: te.string,
        received: i.parsedType
      }), fe;
    }
    const a = new Lt();
    let r;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (r = this._getOrReturnCtx(e, r), ee(r, {
          code: Y.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), a.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (r = this._getOrReturnCtx(e, r), ee(r, {
          code: Y.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), a.dirty());
      else if (i.kind === "length") {
        const s = e.data.length > i.value, u = e.data.length < i.value;
        (s || u) && (r = this._getOrReturnCtx(e, r), s ? ee(r, {
          code: Y.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : u && ee(r, {
          code: Y.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), a.dirty());
      } else if (i.kind === "email")
        DE.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "email",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "emoji")
        Qp || (Qp = new RegExp(qE, "u")), Qp.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "emoji",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "uuid")
        IE.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "uuid",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "nanoid")
        NE.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "nanoid",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "cuid")
        ME.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "cuid",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "cuid2")
        AE.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "cuid2",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "ulid")
        EE.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
          validation: "ulid",
          code: Y.invalid_string,
          message: i.message
        }), a.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          r = this._getOrReturnCtx(e, r), ee(r, {
            validation: "url",
            code: Y.invalid_string,
            message: i.message
          }), a.dirty();
        }
      else i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "regex",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.invalid_string,
        validation: { includes: i.value, position: i.position },
        message: i.message
      }), a.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.invalid_string,
        validation: { startsWith: i.value },
        message: i.message
      }), a.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.invalid_string,
        validation: { endsWith: i.value },
        message: i.message
      }), a.dirty()) : i.kind === "datetime" ? TC(i).test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.invalid_string,
        validation: "datetime",
        message: i.message
      }), a.dirty()) : i.kind === "date" ? zE.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.invalid_string,
        validation: "date",
        message: i.message
      }), a.dirty()) : i.kind === "time" ? ZE(i).test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.invalid_string,
        validation: "time",
        message: i.message
      }), a.dirty()) : i.kind === "duration" ? kE.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "duration",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty()) : i.kind === "ip" ? KE(e.data, i.version) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "ip",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty()) : i.kind === "jwt" ? HE(e.data, i.alg) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "jwt",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty()) : i.kind === "cidr" ? GE(e.data, i.version) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "cidr",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty()) : i.kind === "base64" ? xE.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "base64",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty()) : i.kind === "base64url" ? VE.test(e.data) || (r = this._getOrReturnCtx(e, r), ee(r, {
        validation: "base64url",
        code: Y.invalid_string,
        message: i.message
      }), a.dirty()) : Re.assertNever(i);
    return { status: a.value, value: e.data };
  }
  _regex(e, n, a) {
    return this.refinement((r) => e.test(r), {
      validation: n,
      code: Y.invalid_string,
      ...ae.errToObj(a)
    });
  }
  _addCheck(e) {
    return new sr({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...ae.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...ae.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...ae.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...ae.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...ae.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...ae.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...ae.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...ae.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...ae.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...ae.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...ae.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...ae.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...ae.errToObj(e) });
  }
  datetime(e) {
    var n, a;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      offset: (n = e?.offset) !== null && n !== void 0 ? n : !1,
      local: (a = e?.local) !== null && a !== void 0 ? a : !1,
      ...ae.errToObj(e?.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      ...ae.errToObj(e?.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...ae.errToObj(e) });
  }
  regex(e, n) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...ae.errToObj(n)
    });
  }
  includes(e, n) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: n?.position,
      ...ae.errToObj(n?.message)
    });
  }
  startsWith(e, n) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...ae.errToObj(n)
    });
  }
  endsWith(e, n) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...ae.errToObj(n)
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...ae.errToObj(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...ae.errToObj(n)
    });
  }
  length(e, n) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...ae.errToObj(n)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, ae.errToObj(e));
  }
  trim() {
    return new sr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new sr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new sr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
sr.create = (t) => {
  var e;
  return new sr({
    checks: [],
    typeName: K.ZodString,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...me(t)
  });
};
function WE(t, e) {
  const n = (t.toString().split(".")[1] || "").length, a = (e.toString().split(".")[1] || "").length, r = n > a ? n : a, i = parseInt(t.toFixed(r).replace(".", "")), s = parseInt(e.toFixed(r).replace(".", ""));
  return i % s / Math.pow(10, r);
}
class co extends ye {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== te.number) {
      const i = this._getOrReturnCtx(e);
      return ee(i, {
        code: Y.invalid_type,
        expected: te.number,
        received: i.parsedType
      }), fe;
    }
    let a;
    const r = new Lt();
    for (const i of this._def.checks)
      i.kind === "int" ? Re.isInteger(e.data) || (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), r.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), r.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), r.dirty()) : i.kind === "multipleOf" ? WE(e.data, i.value) !== 0 && (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), r.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.not_finite,
        message: i.message
      }), r.dirty()) : Re.assertNever(i);
    return { status: r.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, ae.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, ae.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, ae.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, ae.toString(n));
  }
  setLimit(e, n, a, r) {
    return new co({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: a,
          message: ae.toString(r)
        }
      ]
    });
  }
  _addCheck(e) {
    return new co({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: ae.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: ae.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: ae.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: ae.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: ae.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ae.toString(n)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: ae.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: ae.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: ae.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && Re.isInteger(e.value));
  }
  get isFinite() {
    let e = null, n = null;
    for (const a of this._def.checks) {
      if (a.kind === "finite" || a.kind === "int" || a.kind === "multipleOf")
        return !0;
      a.kind === "min" ? (n === null || a.value > n) && (n = a.value) : a.kind === "max" && (e === null || a.value < e) && (e = a.value);
    }
    return Number.isFinite(n) && Number.isFinite(e);
  }
}
co.create = (t) => new co({
  checks: [],
  typeName: K.ZodNumber,
  coerce: t?.coerce || !1,
  ...me(t)
});
class lo extends ye {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== te.bigint)
      return this._getInvalidInput(e);
    let a;
    const r = new Lt();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), r.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), r.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (a = this._getOrReturnCtx(e, a), ee(a, {
        code: Y.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), r.dirty()) : Re.assertNever(i);
    return { status: r.value, value: e.data };
  }
  _getInvalidInput(e) {
    const n = this._getOrReturnCtx(e);
    return ee(n, {
      code: Y.invalid_type,
      expected: te.bigint,
      received: n.parsedType
    }), fe;
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, ae.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, ae.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, ae.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, ae.toString(n));
  }
  setLimit(e, n, a, r) {
    return new lo({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: a,
          message: ae.toString(r)
        }
      ]
    });
  }
  _addCheck(e) {
    return new lo({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: ae.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: ae.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: ae.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: ae.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ae.toString(n)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
lo.create = (t) => {
  var e;
  return new lo({
    checks: [],
    typeName: K.ZodBigInt,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...me(t)
  });
};
class Yl extends ye {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== te.boolean) {
      const a = this._getOrReturnCtx(e);
      return ee(a, {
        code: Y.invalid_type,
        expected: te.boolean,
        received: a.parsedType
      }), fe;
    }
    return Gt(e.data);
  }
}
Yl.create = (t) => new Yl({
  typeName: K.ZodBoolean,
  coerce: t?.coerce || !1,
  ...me(t)
});
class Ko extends ye {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== te.date) {
      const i = this._getOrReturnCtx(e);
      return ee(i, {
        code: Y.invalid_type,
        expected: te.date,
        received: i.parsedType
      }), fe;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return ee(i, {
        code: Y.invalid_date
      }), fe;
    }
    const a = new Lt();
    let r;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), a.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (r = this._getOrReturnCtx(e, r), ee(r, {
        code: Y.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), a.dirty()) : Re.assertNever(i);
    return {
      status: a.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Ko({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: ae.toString(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: ae.toString(n)
    });
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
}
Ko.create = (t) => new Ko({
  checks: [],
  coerce: t?.coerce || !1,
  typeName: K.ZodDate,
  ...me(t)
});
class bh extends ye {
  _parse(e) {
    if (this._getType(e) !== te.symbol) {
      const a = this._getOrReturnCtx(e);
      return ee(a, {
        code: Y.invalid_type,
        expected: te.symbol,
        received: a.parsedType
      }), fe;
    }
    return Gt(e.data);
  }
}
bh.create = (t) => new bh({
  typeName: K.ZodSymbol,
  ...me(t)
});
class ed extends ye {
  _parse(e) {
    if (this._getType(e) !== te.undefined) {
      const a = this._getOrReturnCtx(e);
      return ee(a, {
        code: Y.invalid_type,
        expected: te.undefined,
        received: a.parsedType
      }), fe;
    }
    return Gt(e.data);
  }
}
ed.create = (t) => new ed({
  typeName: K.ZodUndefined,
  ...me(t)
});
class td extends ye {
  _parse(e) {
    if (this._getType(e) !== te.null) {
      const a = this._getOrReturnCtx(e);
      return ee(a, {
        code: Y.invalid_type,
        expected: te.null,
        received: a.parsedType
      }), fe;
    }
    return Gt(e.data);
  }
}
td.create = (t) => new td({
  typeName: K.ZodNull,
  ...me(t)
});
class Bu extends ye {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return Gt(e.data);
  }
}
Bu.create = (t) => new Bu({
  typeName: K.ZodAny,
  ...me(t)
});
class Do extends ye {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return Gt(e.data);
  }
}
Do.create = (t) => new Do({
  typeName: K.ZodUnknown,
  ...me(t)
});
class Us extends ye {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return ee(n, {
      code: Y.invalid_type,
      expected: te.never,
      received: n.parsedType
    }), fe;
  }
}
Us.create = (t) => new Us({
  typeName: K.ZodNever,
  ...me(t)
});
class gh extends ye {
  _parse(e) {
    if (this._getType(e) !== te.undefined) {
      const a = this._getOrReturnCtx(e);
      return ee(a, {
        code: Y.invalid_type,
        expected: te.void,
        received: a.parsedType
      }), fe;
    }
    return Gt(e.data);
  }
}
gh.create = (t) => new gh({
  typeName: K.ZodVoid,
  ...me(t)
});
class fr extends ye {
  _parse(e) {
    const { ctx: n, status: a } = this._processInputParams(e), r = this._def;
    if (n.parsedType !== te.array)
      return ee(n, {
        code: Y.invalid_type,
        expected: te.array,
        received: n.parsedType
      }), fe;
    if (r.exactLength !== null) {
      const s = n.data.length > r.exactLength.value, u = n.data.length < r.exactLength.value;
      (s || u) && (ee(n, {
        code: s ? Y.too_big : Y.too_small,
        minimum: u ? r.exactLength.value : void 0,
        maximum: s ? r.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: r.exactLength.message
      }), a.dirty());
    }
    if (r.minLength !== null && n.data.length < r.minLength.value && (ee(n, {
      code: Y.too_small,
      minimum: r.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: r.minLength.message
    }), a.dirty()), r.maxLength !== null && n.data.length > r.maxLength.value && (ee(n, {
      code: Y.too_big,
      maximum: r.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: r.maxLength.message
    }), a.dirty()), n.common.async)
      return Promise.all([...n.data].map((s, u) => r.type._parseAsync(new la(n, s, n.path, u)))).then((s) => Lt.mergeArray(a, s));
    const i = [...n.data].map((s, u) => r.type._parseSync(new la(n, s, n.path, u)));
    return Lt.mergeArray(a, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, n) {
    return new fr({
      ...this._def,
      minLength: { value: e, message: ae.toString(n) }
    });
  }
  max(e, n) {
    return new fr({
      ...this._def,
      maxLength: { value: e, message: ae.toString(n) }
    });
  }
  length(e, n) {
    return new fr({
      ...this._def,
      exactLength: { value: e, message: ae.toString(n) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
fr.create = (t, e) => new fr({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: K.ZodArray,
  ...me(e)
});
function Ou(t) {
  if (t instanceof et) {
    const e = {};
    for (const n in t.shape) {
      const a = t.shape[n];
      e[n] = hr.create(Ou(a));
    }
    return new et({
      ...t._def,
      shape: () => e
    });
  } else return t instanceof fr ? new fr({
    ...t._def,
    type: Ou(t.element)
  }) : t instanceof hr ? hr.create(Ou(t.unwrap())) : t instanceof ho ? ho.create(Ou(t.unwrap())) : t instanceof da ? da.create(t.items.map((e) => Ou(e))) : t;
}
class et extends ye {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), n = Re.objectKeys(e);
    return this._cached = { shape: e, keys: n };
  }
  _parse(e) {
    if (this._getType(e) !== te.object) {
      const f = this._getOrReturnCtx(e);
      return ee(f, {
        code: Y.invalid_type,
        expected: te.object,
        received: f.parsedType
      }), fe;
    }
    const { status: a, ctx: r } = this._processInputParams(e), { shape: i, keys: s } = this._getCached(), u = [];
    if (!(this._def.catchall instanceof Us && this._def.unknownKeys === "strip"))
      for (const f in r.data)
        s.includes(f) || u.push(f);
    const d = [];
    for (const f of s) {
      const o = i[f], c = r.data[f];
      d.push({
        key: { status: "valid", value: f },
        value: o._parse(new la(r, c, r.path, f)),
        alwaysSet: f in r.data
      });
    }
    if (this._def.catchall instanceof Us) {
      const f = this._def.unknownKeys;
      if (f === "passthrough")
        for (const o of u)
          d.push({
            key: { status: "valid", value: o },
            value: { status: "valid", value: r.data[o] }
          });
      else if (f === "strict")
        u.length > 0 && (ee(r, {
          code: Y.unrecognized_keys,
          keys: u
        }), a.dirty());
      else if (f !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const f = this._def.catchall;
      for (const o of u) {
        const c = r.data[o];
        d.push({
          key: { status: "valid", value: o },
          value: f._parse(
            new la(r, c, r.path, o)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: o in r.data
        });
      }
    }
    return r.common.async ? Promise.resolve().then(async () => {
      const f = [];
      for (const o of d) {
        const c = await o.key, h = await o.value;
        f.push({
          key: c,
          value: h,
          alwaysSet: o.alwaysSet
        });
      }
      return f;
    }).then((f) => Lt.mergeObjectSync(a, f)) : Lt.mergeObjectSync(a, d);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return new et({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (n, a) => {
          var r, i, s, u;
          const d = (s = (i = (r = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(r, n, a).message) !== null && s !== void 0 ? s : a.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (u = ae.errToObj(e).message) !== null && u !== void 0 ? u : d
          } : {
            message: d
          };
        }
      } : {}
    });
  }
  strip() {
    return new et({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new et({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new et({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new et({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: K.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, n) {
    return this.augment({ [e]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new et({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const n = {};
    return Re.objectKeys(e).forEach((a) => {
      e[a] && this.shape[a] && (n[a] = this.shape[a]);
    }), new et({
      ...this._def,
      shape: () => n
    });
  }
  omit(e) {
    const n = {};
    return Re.objectKeys(this.shape).forEach((a) => {
      e[a] || (n[a] = this.shape[a]);
    }), new et({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Ou(this);
  }
  partial(e) {
    const n = {};
    return Re.objectKeys(this.shape).forEach((a) => {
      const r = this.shape[a];
      e && !e[a] ? n[a] = r : n[a] = r.optional();
    }), new et({
      ...this._def,
      shape: () => n
    });
  }
  required(e) {
    const n = {};
    return Re.objectKeys(this.shape).forEach((a) => {
      if (e && !e[a])
        n[a] = this.shape[a];
      else {
        let i = this.shape[a];
        for (; i instanceof hr; )
          i = i._def.innerType;
        n[a] = i;
      }
    }), new et({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return $C(Re.objectKeys(this.shape));
  }
}
et.create = (t, e) => new et({
  shape: () => t,
  unknownKeys: "strip",
  catchall: Us.create(),
  typeName: K.ZodObject,
  ...me(e)
});
et.strictCreate = (t, e) => new et({
  shape: () => t,
  unknownKeys: "strict",
  catchall: Us.create(),
  typeName: K.ZodObject,
  ...me(e)
});
et.lazycreate = (t, e) => new et({
  shape: t,
  unknownKeys: "strip",
  catchall: Us.create(),
  typeName: K.ZodObject,
  ...me(e)
});
class nd extends ye {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), a = this._def.options;
    function r(i) {
      for (const u of i)
        if (u.result.status === "valid")
          return u.result;
      for (const u of i)
        if (u.result.status === "dirty")
          return n.common.issues.push(...u.ctx.common.issues), u.result;
      const s = i.map((u) => new dr(u.ctx.common.issues));
      return ee(n, {
        code: Y.invalid_union,
        unionErrors: s
      }), fe;
    }
    if (n.common.async)
      return Promise.all(a.map(async (i) => {
        const s = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: n.data,
            path: n.path,
            parent: s
          }),
          ctx: s
        };
      })).then(r);
    {
      let i;
      const s = [];
      for (const d of a) {
        const f = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, o = d._parseSync({
          data: n.data,
          path: n.path,
          parent: f
        });
        if (o.status === "valid")
          return o;
        o.status === "dirty" && !i && (i = { result: o, ctx: f }), f.common.issues.length && s.push(f.common.issues);
      }
      if (i)
        return n.common.issues.push(...i.ctx.common.issues), i.result;
      const u = s.map((d) => new dr(d));
      return ee(n, {
        code: Y.invalid_union,
        unionErrors: u
      }), fe;
    }
  }
  get options() {
    return this._def.options;
  }
}
nd.create = (t, e) => new nd({
  options: t,
  typeName: K.ZodUnion,
  ...me(e)
});
const Es = (t) => t instanceof id ? Es(t.schema) : t instanceof br ? Es(t.innerType()) : t instanceof sd ? [t.value] : t instanceof fo ? t.options : t instanceof od ? Re.objectValues(t.enum) : t instanceof ud ? Es(t._def.innerType) : t instanceof ed ? [void 0] : t instanceof td ? [null] : t instanceof hr ? [void 0, ...Es(t.unwrap())] : t instanceof ho ? [null, ...Es(t.unwrap())] : t instanceof Ng || t instanceof ld ? Es(t.unwrap()) : t instanceof cd ? Es(t._def.innerType) : [];
class up extends ye {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== te.object)
      return ee(n, {
        code: Y.invalid_type,
        expected: te.object,
        received: n.parsedType
      }), fe;
    const a = this.discriminator, r = n.data[a], i = this.optionsMap.get(r);
    return i ? n.common.async ? i._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : i._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (ee(n, {
      code: Y.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [a]
    }), fe);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, n, a) {
    const r = /* @__PURE__ */ new Map();
    for (const i of n) {
      const s = Es(i.shape[e]);
      if (!s.length)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const u of s) {
        if (r.has(u))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(u)}`);
        r.set(u, i);
      }
    }
    return new up({
      typeName: K.ZodDiscriminatedUnion,
      discriminator: e,
      options: n,
      optionsMap: r,
      ...me(a)
    });
  }
}
function Mb(t, e) {
  const n = Ns(t), a = Ns(e);
  if (t === e)
    return { valid: !0, data: t };
  if (n === te.object && a === te.object) {
    const r = Re.objectKeys(e), i = Re.objectKeys(t).filter((u) => r.indexOf(u) !== -1), s = { ...t, ...e };
    for (const u of i) {
      const d = Mb(t[u], e[u]);
      if (!d.valid)
        return { valid: !1 };
      s[u] = d.data;
    }
    return { valid: !0, data: s };
  } else if (n === te.array && a === te.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const r = [];
    for (let i = 0; i < t.length; i++) {
      const s = t[i], u = e[i], d = Mb(s, u);
      if (!d.valid)
        return { valid: !1 };
      r.push(d.data);
    }
    return { valid: !0, data: r };
  } else return n === te.date && a === te.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class rd extends ye {
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e), r = (i, s) => {
      if (Tb(i) || Tb(s))
        return fe;
      const u = Mb(i.value, s.value);
      return u.valid ? (($b(i) || $b(s)) && n.dirty(), { status: n.value, value: u.data }) : (ee(a, {
        code: Y.invalid_intersection_types
      }), fe);
    };
    return a.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: a.data,
        path: a.path,
        parent: a
      }),
      this._def.right._parseAsync({
        data: a.data,
        path: a.path,
        parent: a
      })
    ]).then(([i, s]) => r(i, s)) : r(this._def.left._parseSync({
      data: a.data,
      path: a.path,
      parent: a
    }), this._def.right._parseSync({
      data: a.data,
      path: a.path,
      parent: a
    }));
  }
}
rd.create = (t, e, n) => new rd({
  left: t,
  right: e,
  typeName: K.ZodIntersection,
  ...me(n)
});
class da extends ye {
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e);
    if (a.parsedType !== te.array)
      return ee(a, {
        code: Y.invalid_type,
        expected: te.array,
        received: a.parsedType
      }), fe;
    if (a.data.length < this._def.items.length)
      return ee(a, {
        code: Y.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), fe;
    !this._def.rest && a.data.length > this._def.items.length && (ee(a, {
      code: Y.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const i = [...a.data].map((s, u) => {
      const d = this._def.items[u] || this._def.rest;
      return d ? d._parse(new la(a, s, a.path, u)) : null;
    }).filter((s) => !!s);
    return a.common.async ? Promise.all(i).then((s) => Lt.mergeArray(n, s)) : Lt.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new da({
      ...this._def,
      rest: e
    });
  }
}
da.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new da({
    items: t,
    typeName: K.ZodTuple,
    rest: null,
    ...me(e)
  });
};
class ad extends ye {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e);
    if (a.parsedType !== te.object)
      return ee(a, {
        code: Y.invalid_type,
        expected: te.object,
        received: a.parsedType
      }), fe;
    const r = [], i = this._def.keyType, s = this._def.valueType;
    for (const u in a.data)
      r.push({
        key: i._parse(new la(a, u, a.path, u)),
        value: s._parse(new la(a, a.data[u], a.path, u)),
        alwaysSet: u in a.data
      });
    return a.common.async ? Lt.mergeObjectAsync(n, r) : Lt.mergeObjectSync(n, r);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, n, a) {
    return n instanceof ye ? new ad({
      keyType: e,
      valueType: n,
      typeName: K.ZodRecord,
      ...me(a)
    }) : new ad({
      keyType: sr.create(),
      valueType: e,
      typeName: K.ZodRecord,
      ...me(n)
    });
  }
}
class _h extends ye {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e);
    if (a.parsedType !== te.map)
      return ee(a, {
        code: Y.invalid_type,
        expected: te.map,
        received: a.parsedType
      }), fe;
    const r = this._def.keyType, i = this._def.valueType, s = [...a.data.entries()].map(([u, d], f) => ({
      key: r._parse(new la(a, u, a.path, [f, "key"])),
      value: i._parse(new la(a, d, a.path, [f, "value"]))
    }));
    if (a.common.async) {
      const u = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const d of s) {
          const f = await d.key, o = await d.value;
          if (f.status === "aborted" || o.status === "aborted")
            return fe;
          (f.status === "dirty" || o.status === "dirty") && n.dirty(), u.set(f.value, o.value);
        }
        return { status: n.value, value: u };
      });
    } else {
      const u = /* @__PURE__ */ new Map();
      for (const d of s) {
        const f = d.key, o = d.value;
        if (f.status === "aborted" || o.status === "aborted")
          return fe;
        (f.status === "dirty" || o.status === "dirty") && n.dirty(), u.set(f.value, o.value);
      }
      return { status: n.value, value: u };
    }
  }
}
_h.create = (t, e, n) => new _h({
  valueType: e,
  keyType: t,
  typeName: K.ZodMap,
  ...me(n)
});
class Ho extends ye {
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e);
    if (a.parsedType !== te.set)
      return ee(a, {
        code: Y.invalid_type,
        expected: te.set,
        received: a.parsedType
      }), fe;
    const r = this._def;
    r.minSize !== null && a.data.size < r.minSize.value && (ee(a, {
      code: Y.too_small,
      minimum: r.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: r.minSize.message
    }), n.dirty()), r.maxSize !== null && a.data.size > r.maxSize.value && (ee(a, {
      code: Y.too_big,
      maximum: r.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: r.maxSize.message
    }), n.dirty());
    const i = this._def.valueType;
    function s(d) {
      const f = /* @__PURE__ */ new Set();
      for (const o of d) {
        if (o.status === "aborted")
          return fe;
        o.status === "dirty" && n.dirty(), f.add(o.value);
      }
      return { status: n.value, value: f };
    }
    const u = [...a.data.values()].map((d, f) => i._parse(new la(a, d, a.path, f)));
    return a.common.async ? Promise.all(u).then((d) => s(d)) : s(u);
  }
  min(e, n) {
    return new Ho({
      ...this._def,
      minSize: { value: e, message: ae.toString(n) }
    });
  }
  max(e, n) {
    return new Ho({
      ...this._def,
      maxSize: { value: e, message: ae.toString(n) }
    });
  }
  size(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Ho.create = (t, e) => new Ho({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: K.ZodSet,
  ...me(e)
});
class qu extends ye {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== te.function)
      return ee(n, {
        code: Y.invalid_type,
        expected: te.function,
        received: n.parsedType
      }), fe;
    function a(u, d) {
      return ph({
        data: u,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          hh(),
          Uu
        ].filter((f) => !!f),
        issueData: {
          code: Y.invalid_arguments,
          argumentsError: d
        }
      });
    }
    function r(u, d) {
      return ph({
        data: u,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          hh(),
          Uu
        ].filter((f) => !!f),
        issueData: {
          code: Y.invalid_return_type,
          returnTypeError: d
        }
      });
    }
    const i = { errorMap: n.common.contextualErrorMap }, s = n.data;
    if (this._def.returns instanceof xu) {
      const u = this;
      return Gt(async function(...d) {
        const f = new dr([]), o = await u._def.args.parseAsync(d, i).catch((p) => {
          throw f.addIssue(a(d, p)), f;
        }), c = await Reflect.apply(s, this, o);
        return await u._def.returns._def.type.parseAsync(c, i).catch((p) => {
          throw f.addIssue(r(c, p)), f;
        });
      });
    } else {
      const u = this;
      return Gt(function(...d) {
        const f = u._def.args.safeParse(d, i);
        if (!f.success)
          throw new dr([a(d, f.error)]);
        const o = Reflect.apply(s, this, f.data), c = u._def.returns.safeParse(o, i);
        if (!c.success)
          throw new dr([r(o, c.error)]);
        return c.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new qu({
      ...this._def,
      args: da.create(e).rest(Do.create())
    });
  }
  returns(e) {
    return new qu({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, n, a) {
    return new qu({
      args: e || da.create([]).rest(Do.create()),
      returns: n || Do.create(),
      typeName: K.ZodFunction,
      ...me(a)
    });
  }
}
class id extends ye {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
id.create = (t, e) => new id({
  getter: t,
  typeName: K.ZodLazy,
  ...me(e)
});
class sd extends ye {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return ee(n, {
        received: n.data,
        code: Y.invalid_literal,
        expected: this._def.value
      }), fe;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
sd.create = (t, e) => new sd({
  value: t,
  typeName: K.ZodLiteral,
  ...me(e)
});
function $C(t, e) {
  return new fo({
    values: t,
    typeName: K.ZodEnum,
    ...me(e)
  });
}
class fo extends ye {
  constructor() {
    super(...arguments), Al.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e), a = this._def.values;
      return ee(n, {
        expected: Re.joinValues(a),
        received: n.parsedType,
        code: Y.invalid_type
      }), fe;
    }
    if (mh(this, Al) || PC(this, Al, new Set(this._def.values)), !mh(this, Al).has(e.data)) {
      const n = this._getOrReturnCtx(e), a = this._def.values;
      return ee(n, {
        received: n.data,
        code: Y.invalid_enum_value,
        options: a
      }), fe;
    }
    return Gt(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Values() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  extract(e, n = this._def) {
    return fo.create(e, {
      ...this._def,
      ...n
    });
  }
  exclude(e, n = this._def) {
    return fo.create(this.options.filter((a) => !e.includes(a)), {
      ...this._def,
      ...n
    });
  }
}
Al = /* @__PURE__ */ new WeakMap();
fo.create = $C;
class od extends ye {
  constructor() {
    super(...arguments), El.set(this, void 0);
  }
  _parse(e) {
    const n = Re.getValidEnumValues(this._def.values), a = this._getOrReturnCtx(e);
    if (a.parsedType !== te.string && a.parsedType !== te.number) {
      const r = Re.objectValues(n);
      return ee(a, {
        expected: Re.joinValues(r),
        received: a.parsedType,
        code: Y.invalid_type
      }), fe;
    }
    if (mh(this, El) || PC(this, El, new Set(Re.getValidEnumValues(this._def.values))), !mh(this, El).has(e.data)) {
      const r = Re.objectValues(n);
      return ee(a, {
        received: a.data,
        code: Y.invalid_enum_value,
        options: r
      }), fe;
    }
    return Gt(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
El = /* @__PURE__ */ new WeakMap();
od.create = (t, e) => new od({
  values: t,
  typeName: K.ZodNativeEnum,
  ...me(e)
});
class xu extends ye {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== te.promise && n.common.async === !1)
      return ee(n, {
        code: Y.invalid_type,
        expected: te.promise,
        received: n.parsedType
      }), fe;
    const a = n.parsedType === te.promise ? n.data : Promise.resolve(n.data);
    return Gt(a.then((r) => this._def.type.parseAsync(r, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
xu.create = (t, e) => new xu({
  type: t,
  typeName: K.ZodPromise,
  ...me(e)
});
class br extends ye {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === K.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e), r = this._def.effect || null, i = {
      addIssue: (s) => {
        ee(a, s), s.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return a.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), r.type === "preprocess") {
      const s = r.transform(a.data, i);
      if (a.common.async)
        return Promise.resolve(s).then(async (u) => {
          if (n.value === "aborted")
            return fe;
          const d = await this._def.schema._parseAsync({
            data: u,
            path: a.path,
            parent: a
          });
          return d.status === "aborted" ? fe : d.status === "dirty" || n.value === "dirty" ? $u(d.value) : d;
        });
      {
        if (n.value === "aborted")
          return fe;
        const u = this._def.schema._parseSync({
          data: s,
          path: a.path,
          parent: a
        });
        return u.status === "aborted" ? fe : u.status === "dirty" || n.value === "dirty" ? $u(u.value) : u;
      }
    }
    if (r.type === "refinement") {
      const s = (u) => {
        const d = r.refinement(u, i);
        if (a.common.async)
          return Promise.resolve(d);
        if (d instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return u;
      };
      if (a.common.async === !1) {
        const u = this._def.schema._parseSync({
          data: a.data,
          path: a.path,
          parent: a
        });
        return u.status === "aborted" ? fe : (u.status === "dirty" && n.dirty(), s(u.value), { status: n.value, value: u.value });
      } else
        return this._def.schema._parseAsync({ data: a.data, path: a.path, parent: a }).then((u) => u.status === "aborted" ? fe : (u.status === "dirty" && n.dirty(), s(u.value).then(() => ({ status: n.value, value: u.value }))));
    }
    if (r.type === "transform")
      if (a.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: a.data,
          path: a.path,
          parent: a
        });
        if (!Zo(s))
          return s;
        const u = r.transform(s.value, i);
        if (u instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: u };
      } else
        return this._def.schema._parseAsync({ data: a.data, path: a.path, parent: a }).then((s) => Zo(s) ? Promise.resolve(r.transform(s.value, i)).then((u) => ({ status: n.value, value: u })) : s);
    Re.assertNever(r);
  }
}
br.create = (t, e, n) => new br({
  schema: t,
  typeName: K.ZodEffects,
  effect: e,
  ...me(n)
});
br.createWithPreprocess = (t, e, n) => new br({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: K.ZodEffects,
  ...me(n)
});
class hr extends ye {
  _parse(e) {
    return this._getType(e) === te.undefined ? Gt(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
hr.create = (t, e) => new hr({
  innerType: t,
  typeName: K.ZodOptional,
  ...me(e)
});
class ho extends ye {
  _parse(e) {
    return this._getType(e) === te.null ? Gt(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ho.create = (t, e) => new ho({
  innerType: t,
  typeName: K.ZodNullable,
  ...me(e)
});
class ud extends ye {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    let a = n.data;
    return n.parsedType === te.undefined && (a = this._def.defaultValue()), this._def.innerType._parse({
      data: a,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ud.create = (t, e) => new ud({
  innerType: t,
  typeName: K.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...me(e)
});
class cd extends ye {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), a = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, r = this._def.innerType._parse({
      data: a.data,
      path: a.path,
      parent: {
        ...a
      }
    });
    return Ql(r) ? r.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new dr(a.common.issues);
        },
        input: a.data
      })
    })) : {
      status: "valid",
      value: r.status === "valid" ? r.value : this._def.catchValue({
        get error() {
          return new dr(a.common.issues);
        },
        input: a.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
cd.create = (t, e) => new cd({
  innerType: t,
  typeName: K.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...me(e)
});
class yh extends ye {
  _parse(e) {
    if (this._getType(e) !== te.nan) {
      const a = this._getOrReturnCtx(e);
      return ee(a, {
        code: Y.invalid_type,
        expected: te.nan,
        received: a.parsedType
      }), fe;
    }
    return { status: "valid", value: e.data };
  }
}
yh.create = (t) => new yh({
  typeName: K.ZodNaN,
  ...me(t)
});
const XE = Symbol("zod_brand");
class Ng extends ye {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), a = n.data;
    return this._def.type._parse({
      data: a,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Ad extends ye {
  _parse(e) {
    const { status: n, ctx: a } = this._processInputParams(e);
    if (a.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: a.data,
          path: a.path,
          parent: a
        });
        return i.status === "aborted" ? fe : i.status === "dirty" ? (n.dirty(), $u(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: a.path,
          parent: a
        });
      })();
    {
      const r = this._def.in._parseSync({
        data: a.data,
        path: a.path,
        parent: a
      });
      return r.status === "aborted" ? fe : r.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: r.value
      }) : this._def.out._parseSync({
        data: r.value,
        path: a.path,
        parent: a
      });
    }
  }
  static create(e, n) {
    return new Ad({
      in: e,
      out: n,
      typeName: K.ZodPipeline
    });
  }
}
class ld extends ye {
  _parse(e) {
    const n = this._def.innerType._parse(e), a = (r) => (Zo(r) && (r.value = Object.freeze(r.value)), r);
    return Ql(n) ? n.then((r) => a(r)) : a(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ld.create = (t, e) => new ld({
  innerType: t,
  typeName: K.ZodReadonly,
  ...me(e)
});
function Ey(t, e) {
  const n = typeof t == "function" ? t(e) : typeof t == "string" ? { message: t } : t;
  return typeof n == "string" ? { message: n } : n;
}
function MC(t, e = {}, n) {
  return t ? Bu.create().superRefine((a, r) => {
    var i, s;
    const u = t(a);
    if (u instanceof Promise)
      return u.then((d) => {
        var f, o;
        if (!d) {
          const c = Ey(e, a), h = (o = (f = c.fatal) !== null && f !== void 0 ? f : n) !== null && o !== void 0 ? o : !0;
          r.addIssue({ code: "custom", ...c, fatal: h });
        }
      });
    if (!u) {
      const d = Ey(e, a), f = (s = (i = d.fatal) !== null && i !== void 0 ? i : n) !== null && s !== void 0 ? s : !0;
      r.addIssue({ code: "custom", ...d, fatal: f });
    }
  }) : Bu.create();
}
const QE = {
  object: et.lazycreate
};
var K;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(K || (K = {}));
const YE = (t, e = {
  message: `Input not instance of ${t.name}`
}) => MC((n) => n instanceof t, e), AC = sr.create, EC = co.create, eI = yh.create, tI = lo.create, IC = Yl.create, nI = Ko.create, rI = bh.create, aI = ed.create, iI = td.create, sI = Bu.create, oI = Do.create, uI = Us.create, cI = gh.create, lI = fr.create, dI = et.create, fI = et.strictCreate, hI = nd.create, pI = up.create, mI = rd.create, bI = da.create, gI = ad.create, _I = _h.create, yI = Ho.create, vI = qu.create, wI = id.create, SI = sd.create, OI = fo.create, jI = od.create, PI = xu.create, Iy = br.create, CI = hr.create, RI = ho.create, TI = br.createWithPreprocess, $I = Ad.create, MI = () => AC().optional(), AI = () => EC().optional(), EI = () => IC().optional(), II = {
  string: (t) => sr.create({ ...t, coerce: !0 }),
  number: (t) => co.create({ ...t, coerce: !0 }),
  boolean: (t) => Yl.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => lo.create({ ...t, coerce: !0 }),
  date: (t) => Ko.create({ ...t, coerce: !0 })
}, NI = fe;
var wn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Uu,
  setErrorMap: TE,
  getErrorMap: hh,
  makeIssue: ph,
  EMPTY_PATH: $E,
  addIssueToContext: ee,
  ParseStatus: Lt,
  INVALID: fe,
  DIRTY: $u,
  OK: Gt,
  isAborted: Tb,
  isDirty: $b,
  isValid: Zo,
  isAsync: Ql,
  get util() {
    return Re;
  },
  get objectUtil() {
    return Rb;
  },
  ZodParsedType: te,
  getParsedType: Ns,
  ZodType: ye,
  datetimeRegex: TC,
  ZodString: sr,
  ZodNumber: co,
  ZodBigInt: lo,
  ZodBoolean: Yl,
  ZodDate: Ko,
  ZodSymbol: bh,
  ZodUndefined: ed,
  ZodNull: td,
  ZodAny: Bu,
  ZodUnknown: Do,
  ZodNever: Us,
  ZodVoid: gh,
  ZodArray: fr,
  ZodObject: et,
  ZodUnion: nd,
  ZodDiscriminatedUnion: up,
  ZodIntersection: rd,
  ZodTuple: da,
  ZodRecord: ad,
  ZodMap: _h,
  ZodSet: Ho,
  ZodFunction: qu,
  ZodLazy: id,
  ZodLiteral: sd,
  ZodEnum: fo,
  ZodNativeEnum: od,
  ZodPromise: xu,
  ZodEffects: br,
  ZodTransformer: br,
  ZodOptional: hr,
  ZodNullable: ho,
  ZodDefault: ud,
  ZodCatch: cd,
  ZodNaN: yh,
  BRAND: XE,
  ZodBranded: Ng,
  ZodPipeline: Ad,
  ZodReadonly: ld,
  custom: MC,
  Schema: ye,
  ZodSchema: ye,
  late: QE,
  get ZodFirstPartyTypeKind() {
    return K;
  },
  coerce: II,
  any: sI,
  array: lI,
  bigint: tI,
  boolean: IC,
  date: nI,
  discriminatedUnion: pI,
  effect: Iy,
  enum: OI,
  function: vI,
  instanceof: YE,
  intersection: mI,
  lazy: wI,
  literal: SI,
  map: _I,
  nan: eI,
  nativeEnum: jI,
  never: uI,
  null: iI,
  nullable: RI,
  number: EC,
  object: dI,
  oboolean: EI,
  onumber: AI,
  optional: CI,
  ostring: MI,
  pipeline: $I,
  preprocess: TI,
  promise: PI,
  record: gI,
  set: yI,
  strictObject: fI,
  string: AC,
  symbol: rI,
  transformer: Iy,
  tuple: bI,
  undefined: aI,
  union: hI,
  unknown: oI,
  void: cI,
  NEVER: NI,
  ZodIssueCode: Y,
  quotelessJson: RE,
  ZodError: dr
}), lc = { exports: {} }, Yp = {}, em, Ny;
function FI() {
  if (Ny) return em;
  Ny = 1;
  function t(e, n) {
    typeof n == "boolean" && (n = { forever: n }), this._originalTimeouts = JSON.parse(JSON.stringify(e)), this._timeouts = e, this._options = n || {}, this._maxRetryTime = n && n.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
  }
  return em = t, t.prototype.reset = function() {
    this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
  }, t.prototype.stop = function() {
    this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null;
  }, t.prototype.retry = function(e) {
    if (this._timeout && clearTimeout(this._timeout), !e)
      return !1;
    var n = (/* @__PURE__ */ new Date()).getTime();
    if (e && n - this._operationStart >= this._maxRetryTime)
      return this._errors.push(e), this._errors.unshift(new Error("RetryOperation timeout occurred")), !1;
    this._errors.push(e);
    var a = this._timeouts.shift();
    if (a === void 0)
      if (this._cachedTimeouts)
        this._errors.splice(0, this._errors.length - 1), a = this._cachedTimeouts.slice(-1);
      else
        return !1;
    var r = this;
    return this._timer = setTimeout(function() {
      r._attempts++, r._operationTimeoutCb && (r._timeout = setTimeout(function() {
        r._operationTimeoutCb(r._attempts);
      }, r._operationTimeout), r._options.unref && r._timeout.unref()), r._fn(r._attempts);
    }, a), this._options.unref && this._timer.unref(), !0;
  }, t.prototype.attempt = function(e, n) {
    this._fn = e, n && (n.timeout && (this._operationTimeout = n.timeout), n.cb && (this._operationTimeoutCb = n.cb));
    var a = this;
    this._operationTimeoutCb && (this._timeout = setTimeout(function() {
      a._operationTimeoutCb();
    }, a._operationTimeout)), this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
  }, t.prototype.try = function(e) {
    console.log("Using RetryOperation.try() is deprecated"), this.attempt(e);
  }, t.prototype.start = function(e) {
    console.log("Using RetryOperation.start() is deprecated"), this.attempt(e);
  }, t.prototype.start = t.prototype.try, t.prototype.errors = function() {
    return this._errors;
  }, t.prototype.attempts = function() {
    return this._attempts;
  }, t.prototype.mainError = function() {
    if (this._errors.length === 0)
      return null;
    for (var e = {}, n = null, a = 0, r = 0; r < this._errors.length; r++) {
      var i = this._errors[r], s = i.message, u = (e[s] || 0) + 1;
      e[s] = u, u >= a && (n = i, a = u);
    }
    return n;
  }, em;
}
var Fy;
function kI() {
  return Fy || (Fy = 1, function(t) {
    var e = /* @__PURE__ */ FI();
    t.operation = function(n) {
      var a = t.timeouts(n);
      return new e(a, {
        forever: n && (n.forever || n.retries === 1 / 0),
        unref: n && n.unref,
        maxRetryTime: n && n.maxRetryTime
      });
    }, t.timeouts = function(n) {
      if (n instanceof Array)
        return [].concat(n);
      var a = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: 1 / 0,
        randomize: !1
      };
      for (var r in n)
        a[r] = n[r];
      if (a.minTimeout > a.maxTimeout)
        throw new Error("minTimeout is greater than maxTimeout");
      for (var i = [], s = 0; s < a.retries; s++)
        i.push(this.createTimeout(s, a));
      return n && n.forever && !i.length && i.push(this.createTimeout(s, a)), i.sort(function(u, d) {
        return u - d;
      }), i;
    }, t.createTimeout = function(n, a) {
      var r = a.randomize ? Math.random() + 1 : 1, i = Math.round(r * Math.max(a.minTimeout, 1) * Math.pow(a.factor, n));
      return i = Math.min(i, a.maxTimeout), i;
    }, t.wrap = function(n, a, r) {
      if (a instanceof Array && (r = a, a = null), !r) {
        r = [];
        for (var i in n)
          typeof n[i] == "function" && r.push(i);
      }
      for (var s = 0; s < r.length; s++) {
        var u = r[s], d = n[u];
        n[u] = function(o) {
          var c = t.operation(a), h = Array.prototype.slice.call(arguments, 1), p = h.pop();
          h.push(function(l) {
            c.retry(l) || (l && (arguments[0] = c.mainError()), p.apply(this, arguments));
          }), c.attempt(function() {
            o.apply(n, h);
          });
        }.bind(n, d), n[u].options = a;
      }
    };
  }(Yp)), Yp;
}
var tm, ky;
function DI() {
  return ky || (ky = 1, tm = /* @__PURE__ */ kI()), tm;
}
var Dy;
function qI() {
  if (Dy) return lc.exports;
  Dy = 1;
  const t = /* @__PURE__ */ DI(), e = [
    "Failed to fetch",
    // Chrome
    "NetworkError when attempting to fetch resource.",
    // Firefox
    "The Internet connection appears to be offline.",
    // Safari
    "Network request failed"
    // `cross-fetch`
  ];
  class n extends Error {
    constructor(u) {
      super(), u instanceof Error ? (this.originalError = u, { message: u } = u) : (this.originalError = new Error(u), this.originalError.stack = this.stack), this.name = "AbortError", this.message = u;
    }
  }
  const a = (s, u, d) => {
    const f = d.retries - (u - 1);
    return s.attemptNumber = u, s.retriesLeft = f, s;
  }, r = (s) => e.includes(s), i = (s, u) => new Promise((d, f) => {
    u = {
      onFailedAttempt: () => {
      },
      retries: 10,
      ...u
    };
    const o = t.operation(u);
    o.attempt(async (c) => {
      try {
        d(await s(c));
      } catch (h) {
        if (!(h instanceof Error)) {
          f(new TypeError(`Non-error was thrown: "${h}". You should only throw errors.`));
          return;
        }
        if (h instanceof n)
          o.stop(), f(h.originalError);
        else if (h instanceof TypeError && !r(h.message))
          o.stop(), f(h);
        else {
          a(h, c, u);
          try {
            await u.onFailedAttempt(h);
          } catch (p) {
            f(p);
            return;
          }
          o.retry(h) || f(o.mainError());
        }
      }
    });
  });
  return lc.exports = i, lc.exports.default = i, lc.exports.AbortError = n, lc.exports;
}
var JI = /* @__PURE__ */ qI();
const vh = /* @__PURE__ */ Rd(JI), LI = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function qs(t) {
  return typeof t == "string" && LI.test(t);
}
function NC(t) {
  if (!qs(t))
    throw TypeError("Invalid UUID");
  var e, n = new Uint8Array(16);
  return n[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24, n[1] = e >>> 16 & 255, n[2] = e >>> 8 & 255, n[3] = e & 255, n[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8, n[5] = e & 255, n[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8, n[7] = e & 255, n[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8, n[9] = e & 255, n[10] = (e = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255, n[11] = e / 4294967296 & 255, n[12] = e >>> 24 & 255, n[13] = e >>> 16 & 255, n[14] = e >>> 8 & 255, n[15] = e & 255, n;
}
var $t = [];
for (var nm = 0; nm < 256; ++nm)
  $t.push((nm + 256).toString(16).slice(1));
function Ed(t, e = 0) {
  return ($t[t[e + 0]] + $t[t[e + 1]] + $t[t[e + 2]] + $t[t[e + 3]] + "-" + $t[t[e + 4]] + $t[t[e + 5]] + "-" + $t[t[e + 6]] + $t[t[e + 7]] + "-" + $t[t[e + 8]] + $t[t[e + 9]] + "-" + $t[t[e + 10]] + $t[t[e + 11]] + $t[t[e + 12]] + $t[t[e + 13]] + $t[t[e + 14]] + $t[t[e + 15]]).toLowerCase();
}
var sf, UI = new Uint8Array(16);
function FC() {
  if (!sf && (sf = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !sf))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return sf(UI);
}
var rm, of, am = 0, im = 0;
function BI(t, e, n) {
  var a = 0, r = e || new Array(16);
  t = t || {};
  var i = t.node, s = t.clockseq;
  if (t._v6 || (i || (i = rm), s == null && (s = of)), i == null || s == null) {
    var u = t.random || (t.rng || FC)();
    i == null && (i = [u[0], u[1], u[2], u[3], u[4], u[5]], !rm && !t._v6 && (i[0] |= 1, rm = i)), s == null && (s = (u[6] << 8 | u[7]) & 16383, of === void 0 && !t._v6 && (of = s));
  }
  var d = t.msecs !== void 0 ? t.msecs : Date.now(), f = t.nsecs !== void 0 ? t.nsecs : im + 1, o = d - am + (f - im) / 1e4;
  if (o < 0 && t.clockseq === void 0 && (s = s + 1 & 16383), (o < 0 || d > am) && t.nsecs === void 0 && (f = 0), f >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  am = d, im = f, of = s, d += 122192928e5;
  var c = ((d & 268435455) * 1e4 + f) % 4294967296;
  r[a++] = c >>> 24 & 255, r[a++] = c >>> 16 & 255, r[a++] = c >>> 8 & 255, r[a++] = c & 255;
  var h = d / 4294967296 * 1e4 & 268435455;
  r[a++] = h >>> 8 & 255, r[a++] = h & 255, r[a++] = h >>> 24 & 15 | 16, r[a++] = h >>> 16 & 255, r[a++] = s >>> 8 | 128, r[a++] = s & 255;
  for (var p = 0; p < 6; ++p)
    r[a + p] = i[p];
  return e || Ed(r);
}
function xI(t) {
  var e = typeof t == "string" ? NC(t) : t, n = VI(e);
  return typeof t == "string" ? Ed(n) : n;
}
function VI(t, e = !1) {
  return Uint8Array.of((t[6] & 15) << 4 | t[7] >> 4 & 15, (t[7] & 15) << 4 | (t[4] & 240) >> 4, (t[4] & 15) << 4 | (t[5] & 240) >> 4, (t[5] & 15) << 4 | (t[0] & 240) >> 4, (t[0] & 15) << 4 | (t[1] & 240) >> 4, (t[1] & 15) << 4 | (t[2] & 240) >> 4, 96 | t[2] & 15, t[3], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
}
function zI(t) {
  t = unescape(encodeURIComponent(t));
  for (var e = [], n = 0; n < t.length; ++n)
    e.push(t.charCodeAt(n));
  return e;
}
var ZI = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", KI = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function HI(t, e, n) {
  function a(r, i, s, u) {
    var d;
    if (typeof r == "string" && (r = zI(r)), typeof i == "string" && (i = NC(i)), ((d = i) === null || d === void 0 ? void 0 : d.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var f = new Uint8Array(16 + r.length);
    if (f.set(i), f.set(r, i.length), f = n(f), f[6] = f[6] & 15 | e, f[8] = f[8] & 63 | 128, s) {
      u = u || 0;
      for (var o = 0; o < 16; ++o)
        s[u + o] = f[o];
      return s;
    }
    return Ed(f);
  }
  try {
    a.name = t;
  } catch {
  }
  return a.DNS = ZI, a.URL = KI, a;
}
var GI = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const qy = {
  randomUUID: GI
};
function jt(t, e, n) {
  if (qy.randomUUID && !t)
    return qy.randomUUID();
  t = t || {};
  var a = t.random || (t.rng || FC)();
  return a[6] = a[6] & 15 | 64, a[8] = a[8] & 63 | 128, Ed(a);
}
function WI(t, e, n, a) {
  switch (t) {
    case 0:
      return e & n ^ ~e & a;
    case 1:
      return e ^ n ^ a;
    case 2:
      return e & n ^ e & a ^ n & a;
    case 3:
      return e ^ n ^ a;
  }
}
function sm(t, e) {
  return t << e | t >>> 32 - e;
}
function XI(t) {
  var e = [1518500249, 1859775393, 2400959708, 3395469782], n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof t == "string") {
    var a = unescape(encodeURIComponent(t));
    t = [];
    for (var r = 0; r < a.length; ++r)
      t.push(a.charCodeAt(r));
  } else Array.isArray(t) || (t = Array.prototype.slice.call(t));
  t.push(128);
  for (var i = t.length / 4 + 2, s = Math.ceil(i / 16), u = new Array(s), d = 0; d < s; ++d) {
    for (var f = new Uint32Array(16), o = 0; o < 16; ++o)
      f[o] = t[d * 64 + o * 4] << 24 | t[d * 64 + o * 4 + 1] << 16 | t[d * 64 + o * 4 + 2] << 8 | t[d * 64 + o * 4 + 3];
    u[d] = f;
  }
  u[s - 1][14] = (t.length - 1) * 8 / Math.pow(2, 32), u[s - 1][14] = Math.floor(u[s - 1][14]), u[s - 1][15] = (t.length - 1) * 8 & 4294967295;
  for (var c = 0; c < s; ++c) {
    for (var h = new Uint32Array(80), p = 0; p < 16; ++p)
      h[p] = u[c][p];
    for (var l = 16; l < 80; ++l)
      h[l] = sm(h[l - 3] ^ h[l - 8] ^ h[l - 14] ^ h[l - 16], 1);
    for (var m = n[0], b = n[1], g = n[2], _ = n[3], P = n[4], R = 0; R < 80; ++R) {
      var C = Math.floor(R / 20), T = sm(m, 5) + WI(C, b, g, _) + P + e[C] + h[R] >>> 0;
      P = _, _ = g, g = sm(b, 30) >>> 0, b = m, m = T;
    }
    n[0] = n[0] + m >>> 0, n[1] = n[1] + b >>> 0, n[2] = n[2] + g >>> 0, n[3] = n[3] + _ >>> 0, n[4] = n[4] + P >>> 0;
  }
  return [n[0] >> 24 & 255, n[0] >> 16 & 255, n[0] >> 8 & 255, n[0] & 255, n[1] >> 24 & 255, n[1] >> 16 & 255, n[1] >> 8 & 255, n[1] & 255, n[2] >> 24 & 255, n[2] >> 16 & 255, n[2] >> 8 & 255, n[2] & 255, n[3] >> 24 & 255, n[3] >> 16 & 255, n[3] >> 8 & 255, n[3] & 255, n[4] >> 24 & 255, n[4] >> 16 & 255, n[4] >> 8 & 255, n[4] & 255];
}
var QI = HI("v5", 80, XI);
function Jy(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t, r).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Ly(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Jy(Object(n), !0).forEach(function(a) {
      YI(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Jy(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function YI(t, e, n) {
  return (e = e1(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function e1(t) {
  var e = t1(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
function t1(t, e) {
  if (typeof t != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var a = n.call(t, e);
    if (typeof a != "object") return a;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function n1(t = {}, e, n = 0) {
  var a = BI(Ly(Ly({}, t), {}, {
    _v6: !0
  }), new Uint8Array(16));
  return a = xI(a), Ed(a);
}
var uf = {}, om = { exports: {} }, Uy;
function r1() {
  return Uy || (Uy = 1, function(t) {
    var e = Object.prototype.hasOwnProperty, n = "~";
    function a() {
    }
    Object.create && (a.prototype = /* @__PURE__ */ Object.create(null), new a().__proto__ || (n = !1));
    function r(d, f, o) {
      this.fn = d, this.context = f, this.once = o || !1;
    }
    function i(d, f, o, c, h) {
      if (typeof o != "function")
        throw new TypeError("The listener must be a function");
      var p = new r(o, c || d, h), l = n ? n + f : f;
      return d._events[l] ? d._events[l].fn ? d._events[l] = [d._events[l], p] : d._events[l].push(p) : (d._events[l] = p, d._eventsCount++), d;
    }
    function s(d, f) {
      --d._eventsCount === 0 ? d._events = new a() : delete d._events[f];
    }
    function u() {
      this._events = new a(), this._eventsCount = 0;
    }
    u.prototype.eventNames = function() {
      var f = [], o, c;
      if (this._eventsCount === 0) return f;
      for (c in o = this._events)
        e.call(o, c) && f.push(n ? c.slice(1) : c);
      return Object.getOwnPropertySymbols ? f.concat(Object.getOwnPropertySymbols(o)) : f;
    }, u.prototype.listeners = function(f) {
      var o = n ? n + f : f, c = this._events[o];
      if (!c) return [];
      if (c.fn) return [c.fn];
      for (var h = 0, p = c.length, l = new Array(p); h < p; h++)
        l[h] = c[h].fn;
      return l;
    }, u.prototype.listenerCount = function(f) {
      var o = n ? n + f : f, c = this._events[o];
      return c ? c.fn ? 1 : c.length : 0;
    }, u.prototype.emit = function(f, o, c, h, p, l) {
      var m = n ? n + f : f;
      if (!this._events[m]) return !1;
      var b = this._events[m], g = arguments.length, _, P;
      if (b.fn) {
        switch (b.once && this.removeListener(f, b.fn, void 0, !0), g) {
          case 1:
            return b.fn.call(b.context), !0;
          case 2:
            return b.fn.call(b.context, o), !0;
          case 3:
            return b.fn.call(b.context, o, c), !0;
          case 4:
            return b.fn.call(b.context, o, c, h), !0;
          case 5:
            return b.fn.call(b.context, o, c, h, p), !0;
          case 6:
            return b.fn.call(b.context, o, c, h, p, l), !0;
        }
        for (P = 1, _ = new Array(g - 1); P < g; P++)
          _[P - 1] = arguments[P];
        b.fn.apply(b.context, _);
      } else {
        var R = b.length, C;
        for (P = 0; P < R; P++)
          switch (b[P].once && this.removeListener(f, b[P].fn, void 0, !0), g) {
            case 1:
              b[P].fn.call(b[P].context);
              break;
            case 2:
              b[P].fn.call(b[P].context, o);
              break;
            case 3:
              b[P].fn.call(b[P].context, o, c);
              break;
            case 4:
              b[P].fn.call(b[P].context, o, c, h);
              break;
            default:
              if (!_) for (C = 1, _ = new Array(g - 1); C < g; C++)
                _[C - 1] = arguments[C];
              b[P].fn.apply(b[P].context, _);
          }
      }
      return !0;
    }, u.prototype.on = function(f, o, c) {
      return i(this, f, o, c, !1);
    }, u.prototype.once = function(f, o, c) {
      return i(this, f, o, c, !0);
    }, u.prototype.removeListener = function(f, o, c, h) {
      var p = n ? n + f : f;
      if (!this._events[p]) return this;
      if (!o)
        return s(this, p), this;
      var l = this._events[p];
      if (l.fn)
        l.fn === o && (!h || l.once) && (!c || l.context === c) && s(this, p);
      else {
        for (var m = 0, b = [], g = l.length; m < g; m++)
          (l[m].fn !== o || h && !l[m].once || c && l[m].context !== c) && b.push(l[m]);
        b.length ? this._events[p] = b.length === 1 ? b[0] : b : s(this, p);
      }
      return this;
    }, u.prototype.removeAllListeners = function(f) {
      var o;
      return f ? (o = n ? n + f : f, this._events[o] && s(this, o)) : (this._events = new a(), this._eventsCount = 0), this;
    }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = n, u.EventEmitter = u, t.exports = u;
  }(om)), om.exports;
}
var dc = { exports: {} }, um, By;
function a1() {
  return By || (By = 1, um = (t, e) => (e = e || (() => {
  }), t.then(
    (n) => new Promise((a) => {
      a(e());
    }).then(() => n),
    (n) => new Promise((a) => {
      a(e());
    }).then(() => {
      throw n;
    })
  ))), um;
}
var xy;
function i1() {
  if (xy) return dc.exports;
  xy = 1;
  const t = /* @__PURE__ */ a1();
  class e extends Error {
    constructor(r) {
      super(r), this.name = "TimeoutError";
    }
  }
  const n = (a, r, i) => new Promise((s, u) => {
    if (typeof r != "number" || r < 0)
      throw new TypeError("Expected `milliseconds` to be a positive number");
    if (r === 1 / 0) {
      s(a);
      return;
    }
    const d = setTimeout(() => {
      if (typeof i == "function") {
        try {
          s(i());
        } catch (c) {
          u(c);
        }
        return;
      }
      const f = typeof i == "string" ? i : `Promise timed out after ${r} milliseconds`, o = i instanceof Error ? i : new e(f);
      typeof a.cancel == "function" && a.cancel(), u(o);
    }, r);
    t(
      // eslint-disable-next-line promise/prefer-await-to-then
      a.then(s, u),
      () => {
        clearTimeout(d);
      }
    );
  });
  return dc.exports = n, dc.exports.default = n, dc.exports.TimeoutError = e, dc.exports;
}
var cf = {}, lf = {}, Vy;
function s1() {
  if (Vy) return lf;
  Vy = 1, Object.defineProperty(lf, "__esModule", { value: !0 });
  function t(e, n, a) {
    let r = 0, i = e.length;
    for (; i > 0; ) {
      const s = i / 2 | 0;
      let u = r + s;
      a(e[u], n) <= 0 ? (r = ++u, i -= s + 1) : i = s;
    }
    return r;
  }
  return lf.default = t, lf;
}
var zy;
function o1() {
  if (zy) return cf;
  zy = 1, Object.defineProperty(cf, "__esModule", { value: !0 });
  const t = /* @__PURE__ */ s1();
  class e {
    constructor() {
      this._queue = [];
    }
    enqueue(a, r) {
      r = Object.assign({ priority: 0 }, r);
      const i = {
        priority: r.priority,
        run: a
      };
      if (this.size && this._queue[this.size - 1].priority >= r.priority) {
        this._queue.push(i);
        return;
      }
      const s = t.default(this._queue, i, (u, d) => d.priority - u.priority);
      this._queue.splice(s, 0, i);
    }
    dequeue() {
      const a = this._queue.shift();
      return a?.run;
    }
    filter(a) {
      return this._queue.filter((r) => r.priority === a.priority).map((r) => r.run);
    }
    get size() {
      return this._queue.length;
    }
  }
  return cf.default = e, cf;
}
var Zy;
function u1() {
  if (Zy) return uf;
  Zy = 1, Object.defineProperty(uf, "__esModule", { value: !0 });
  const t = /* @__PURE__ */ r1(), e = /* @__PURE__ */ i1(), n = /* @__PURE__ */ o1(), a = () => {
  }, r = new e.TimeoutError();
  class i extends t {
    constructor(u) {
      var d, f, o, c;
      if (super(), this._intervalCount = 0, this._intervalEnd = 0, this._pendingCount = 0, this._resolveEmpty = a, this._resolveIdle = a, u = Object.assign({ carryoverConcurrencyCount: !1, intervalCap: 1 / 0, interval: 0, concurrency: 1 / 0, autoStart: !0, queueClass: n.default }, u), !(typeof u.intervalCap == "number" && u.intervalCap >= 1))
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(f = (d = u.intervalCap) === null || d === void 0 ? void 0 : d.toString()) !== null && f !== void 0 ? f : ""}\` (${typeof u.intervalCap})`);
      if (u.interval === void 0 || !(Number.isFinite(u.interval) && u.interval >= 0))
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(c = (o = u.interval) === null || o === void 0 ? void 0 : o.toString()) !== null && c !== void 0 ? c : ""}\` (${typeof u.interval})`);
      this._carryoverConcurrencyCount = u.carryoverConcurrencyCount, this._isIntervalIgnored = u.intervalCap === 1 / 0 || u.interval === 0, this._intervalCap = u.intervalCap, this._interval = u.interval, this._queue = new u.queueClass(), this._queueClass = u.queueClass, this.concurrency = u.concurrency, this._timeout = u.timeout, this._throwOnTimeout = u.throwOnTimeout === !0, this._isPaused = u.autoStart === !1;
    }
    get _doesIntervalAllowAnother() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
    get _doesConcurrentAllowAnother() {
      return this._pendingCount < this._concurrency;
    }
    _next() {
      this._pendingCount--, this._tryToStartAnother(), this.emit("next");
    }
    _resolvePromises() {
      this._resolveEmpty(), this._resolveEmpty = a, this._pendingCount === 0 && (this._resolveIdle(), this._resolveIdle = a, this.emit("idle"));
    }
    _onResumeInterval() {
      this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0;
    }
    _isIntervalPaused() {
      const u = Date.now();
      if (this._intervalId === void 0) {
        const d = this._intervalEnd - u;
        if (d < 0)
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        else
          return this._timeoutId === void 0 && (this._timeoutId = setTimeout(() => {
            this._onResumeInterval();
          }, d)), !0;
      }
      return !1;
    }
    _tryToStartAnother() {
      if (this._queue.size === 0)
        return this._intervalId && clearInterval(this._intervalId), this._intervalId = void 0, this._resolvePromises(), !1;
      if (!this._isPaused) {
        const u = !this._isIntervalPaused();
        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          const d = this._queue.dequeue();
          return d ? (this.emit("active"), d(), u && this._initializeIntervalIfNeeded(), !0) : !1;
        }
      }
      return !1;
    }
    _initializeIntervalIfNeeded() {
      this._isIntervalIgnored || this._intervalId !== void 0 || (this._intervalId = setInterval(() => {
        this._onInterval();
      }, this._interval), this._intervalEnd = Date.now() + this._interval);
    }
    _onInterval() {
      this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId && (clearInterval(this._intervalId), this._intervalId = void 0), this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
    _processQueue() {
      for (; this._tryToStartAnother(); )
        ;
    }
    get concurrency() {
      return this._concurrency;
    }
    set concurrency(u) {
      if (!(typeof u == "number" && u >= 1))
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${u}\` (${typeof u})`);
      this._concurrency = u, this._processQueue();
    }
    /**
    Adds a sync or async task to the queue. Always returns a promise.
    */
    async add(u, d = {}) {
      return new Promise((f, o) => {
        const c = async () => {
          this._pendingCount++, this._intervalCount++;
          try {
            const h = this._timeout === void 0 && d.timeout === void 0 ? u() : e.default(Promise.resolve(u()), d.timeout === void 0 ? this._timeout : d.timeout, () => {
              (d.throwOnTimeout === void 0 ? this._throwOnTimeout : d.throwOnTimeout) && o(r);
            });
            f(await h);
          } catch (h) {
            o(h);
          }
          this._next();
        };
        this._queue.enqueue(c, d), this._tryToStartAnother(), this.emit("add");
      });
    }
    /**
    	    Same as `.add()`, but accepts an array of sync or async functions.
    
    	    @returns A promise that resolves when all functions are resolved.
    	    */
    async addAll(u, d) {
      return Promise.all(u.map(async (f) => this.add(f, d)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
      return this._isPaused ? (this._isPaused = !1, this._processQueue(), this) : this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
      this._isPaused = !0;
    }
    /**
    Clear the queue.
    */
    clear() {
      this._queue = new this._queueClass();
    }
    /**
    	    Can be called multiple times. Useful if you for example add additional items at a later time.
    
    	    @returns A promise that settles when the queue becomes empty.
    	    */
    async onEmpty() {
      if (this._queue.size !== 0)
        return new Promise((u) => {
          const d = this._resolveEmpty;
          this._resolveEmpty = () => {
            d(), u();
          };
        });
    }
    /**
    	    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
    
    	    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    	    */
    async onIdle() {
      if (!(this._pendingCount === 0 && this._queue.size === 0))
        return new Promise((u) => {
          const d = this._resolveIdle;
          this._resolveIdle = () => {
            d(), u();
          };
        });
    }
    /**
    Size of the queue.
    */
    get size() {
      return this._queue.size;
    }
    /**
    	    Size of the queue, filtered by the given options.
    
    	    For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    	    */
    sizeBy(u) {
      return this._queue.filter(u).length;
    }
    /**
    Number of pending promises.
    */
    get pending() {
      return this._pendingCount;
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
      return this._isPaused;
    }
    get timeout() {
      return this._timeout;
    }
    /**
    Set the timeout for future operations.
    */
    set timeout(u) {
      this._timeout = u;
    }
  }
  return uf.default = i, uf;
}
var c1 = /* @__PURE__ */ u1();
const Js = /* @__PURE__ */ Rd(c1), l1 = (...t) => fetch(...t), d1 = Symbol.for("ls:fetch_implementation"), oe = () => globalThis[d1] ?? l1, f1 = [
  400,
  // Bad Request
  401,
  // Unauthorized
  403,
  // Forbidden
  404,
  // Not Found
  405,
  // Method Not Allowed
  406,
  // Not Acceptable
  407,
  // Proxy Authentication Required
  408
  // Request Timeout
], h1 = [
  409
  // Conflict
];
let Ky = class {
  constructor(e) {
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxRetries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onFailedResponseHook", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxConcurrency = e.maxConcurrency ?? 1 / 0, this.maxRetries = e.maxRetries ?? 6, "default" in Js ? this.queue = new Js.default({
      concurrency: this.maxConcurrency
    }) : this.queue = new Js({ concurrency: this.maxConcurrency }), this.onFailedResponseHook = e?.onFailedResponseHook;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(e, ...n) {
    const a = this.onFailedResponseHook;
    return this.queue.add(() => vh(() => e(...n).catch((r) => {
      throw r instanceof Error ? r : new Error(r);
    }), {
      async onFailedAttempt(r) {
        if (r.message.startsWith("Cancel") || r.message.startsWith("TimeoutError") || r.message.startsWith("AbortError") || r?.code === "ECONNABORTED")
          throw r;
        const i = r?.response, s = i?.status;
        if (s) {
          if (f1.includes(+s))
            throw r;
          if (h1.includes(+s))
            return;
          a && await a(i);
        }
      },
      // If needed we can change some of the defaults here,
      // but they're quite sensible.
      retries: this.maxRetries,
      randomize: !0
    }), { throwOnTimeout: !0 });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(e, n, ...a) {
    return e.signal ? Promise.race([
      this.call(n, ...a),
      new Promise((r, i) => {
        e.signal?.addEventListener("abort", () => {
          i(new Error("AbortError"));
        });
      })
    ]) : this.call(n, ...a);
  }
  fetch(...e) {
    return this.call(() => oe()(...e).then((n) => n.ok ? n : Promise.reject(n)));
  }
};
function Hy(t) {
  return typeof t?._getType == "function";
}
function Gy(t) {
  const e = {
    type: t._getType(),
    data: { content: t.content }
  };
  return t?.additional_kwargs && Object.keys(t.additional_kwargs).length > 0 && (e.data.additional_kwargs = { ...t.additional_kwargs }), e;
}
function be(t, e) {
  if (!qs(t)) {
    const n = e !== void 0 ? `Invalid UUID for ${e}: ${t}` : `Invalid UUID: ${t}`;
    throw new Error(n);
  }
  return t;
}
const Wy = {};
function kC(t) {
  Wy[t] || (console.warn(t), Wy[t] = !0);
}
function Hs(t) {
  if (!t || t.split("/").length > 2 || t.startsWith("/") || t.endsWith("/") || t.split(":").length > 2)
    throw new Error(`Invalid identifier format: ${t}`);
  const [e, n] = t.split(":"), a = n || "latest";
  if (e.includes("/")) {
    const [r, i] = e.split("/", 2);
    if (!r || !i)
      throw new Error(`Invalid identifier format: ${t}`);
    return [r, i, a];
  } else {
    if (!e)
      throw new Error(`Invalid identifier format: ${t}`);
    return ["-", e, a];
  }
}
class p1 extends Error {
  constructor(e) {
    super(e), this.name = "LangSmithConflictError";
  }
}
async function Se(t, e, n) {
  let a;
  if (t.ok) {
    n && (a = await t.text());
    return;
  }
  a = await t.text();
  const r = `Failed to ${e}. Received status [${t.status}]: ${t.statusText}. Server response: ${a}`;
  throw t.status === 409 ? new p1(r) : new Error(r);
}
var Xy = "[...]", m1 = { result: "[Circular]" }, wh = [], Mu = [];
const b1 = new TextEncoder();
function g1() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function df(t) {
  return b1.encode(t);
}
function mn(t, e, n, a) {
  try {
    const r = JSON.stringify(t, e, n);
    return df(r);
  } catch (r) {
    if (!r.message?.includes("Converting circular structure to JSON"))
      return console.warn("[WARNING]: LangSmith received unserializable value."), df("[Unserializable]");
    console.warn("[WARNING]: LangSmith received circular JSON. This will decrease tracer performance."), typeof a > "u" && (a = g1()), Ab(t, "", 0, [], void 0, 0, a);
    let i;
    try {
      Mu.length === 0 ? i = JSON.stringify(t, e, n) : i = JSON.stringify(t, _1(e), n);
    } catch {
      return df("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; wh.length !== 0; ) {
        const s = wh.pop();
        s.length === 4 ? Object.defineProperty(s[0], s[1], s[3]) : s[0][s[1]] = s[2];
      }
    }
    return df(i);
  }
}
function cm(t, e, n, a) {
  var r = Object.getOwnPropertyDescriptor(a, n);
  r.get !== void 0 ? r.configurable ? (Object.defineProperty(a, n, { value: t }), wh.push([a, n, e, r])) : Mu.push([e, n, t]) : (a[n] = t, wh.push([a, n, e]));
}
function Ab(t, e, n, a, r, i, s) {
  i += 1;
  var u;
  if (typeof t == "object" && t !== null) {
    for (u = 0; u < a.length; u++)
      if (a[u] === t) {
        cm(m1, t, e, r);
        return;
      }
    if (typeof s.depthLimit < "u" && i > s.depthLimit) {
      cm(Xy, t, e, r);
      return;
    }
    if (typeof s.edgesLimit < "u" && n + 1 > s.edgesLimit) {
      cm(Xy, t, e, r);
      return;
    }
    if (a.push(t), Array.isArray(t))
      for (u = 0; u < t.length; u++)
        Ab(t[u], u, u, a, t, i, s);
    else {
      var d = Object.keys(t);
      for (u = 0; u < d.length; u++) {
        var f = d[u];
        Ab(t[f], f, u, a, t, i, s);
      }
    }
    a.pop();
  }
}
function _1(t) {
  return t = typeof t < "u" ? t : function(e, n) {
    return n;
  }, function(e, n) {
    if (Mu.length > 0)
      for (var a = 0; a < Mu.length; a++) {
        var r = Mu[a];
        if (r[1] === e && r[0] === n) {
          n = r[2], Mu.splice(a, 1);
          break;
        }
      }
    return t.call(this, e, n);
  };
}
function Qy(t) {
  const e = JC(), n = E1(), a = t.extra ?? {}, r = a.metadata;
  return t.extra = {
    ...a,
    runtime: {
      ...e,
      ...a?.runtime
    },
    metadata: {
      ...n,
      ...n.revision_id || t.revision_id ? { revision_id: t.revision_id ?? n.revision_id } : {},
      ...r
    }
  }, t;
}
const y1 = (t) => {
  const e = t?.toString() ?? no("TRACING_SAMPLING_RATE");
  if (e === void 0)
    return;
  const n = parseFloat(e);
  if (n < 0 || n > 1)
    throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${n}`);
  return n;
}, v1 = (t) => {
  const n = t.replace("http://", "").replace("https://", "").split("/")[0].split(":")[0];
  return n === "localhost" || n === "127.0.0.1" || n === "::1";
};
async function w1(t) {
  const e = [];
  for await (const n of t)
    e.push(n);
  return e;
}
function lm(t) {
  if (t !== void 0)
    return t.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
const S1 = async (t) => {
  if (t?.status === 429) {
    const e = parseInt(t.headers.get("retry-after") ?? "30", 10) * 1e3;
    if (e > 0)
      return await new Promise((n) => setTimeout(n, e)), !0;
  }
  return !1;
};
function Yy(t) {
  return typeof t == "number" ? Number(t.toFixed(4)) : t;
}
class O1 {
  constructor() {
    Object.defineProperty(this, "items", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "sizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  peek() {
    return this.items[0];
  }
  push(e) {
    let n;
    const a = new Promise((i) => {
      n = i;
    }), r = mn(e.item).length;
    return this.items.push({
      action: e.action,
      payload: e.item,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      itemPromiseResolve: n,
      itemPromise: a,
      size: r
    }), this.sizeBytes += r, a;
  }
  pop(e) {
    if (e < 1)
      throw new Error("Number of bytes to pop off may not be less than 1.");
    const n = [];
    let a = 0;
    for (; a + (this.peek()?.size ?? 0) < e && this.items.length > 0; ) {
      const r = this.items.shift();
      r && (n.push(r), a += r.size, this.sizeBytes -= r.size);
    }
    if (n.length === 0 && this.items.length > 0) {
      const r = this.items.shift();
      n.push(r), a += r.size, this.sizeBytes -= r.size;
    }
    return [
      n.map((r) => ({ action: r.action, item: r.payload })),
      () => n.forEach((r) => r.itemPromiseResolve())
    ];
  }
}
const j1 = 20971520, P1 = 2500;
class dd {
  constructor(e = {}) {
    Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "webUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchIngestCaller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "timeout_ms", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tenantId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "hideInputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "hideOutputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tracingSampleRate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "filteredPostUuids", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "autoBatchTracing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "autoBatchQueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new O1()
    }), Object.defineProperty(this, "autoBatchTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "autoBatchAggregationDelayMs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 250
    }), Object.defineProperty(this, "batchSizeBytesLimit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fetchOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "blockOnRootRunFinalization", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: qo("LANGSMITH_TRACING_BACKGROUND") === "false"
    }), Object.defineProperty(this, "traceBatchConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5
    }), Object.defineProperty(this, "_serverInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_getServerInfoPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "manualFlushMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
    const n = dd.getDefaultClientConfig();
    if (this.tracingSampleRate = y1(e.tracingSamplingRate), this.apiUrl = lm(e.apiUrl ?? n.apiUrl) ?? "", this.apiUrl.endsWith("/") && (this.apiUrl = this.apiUrl.slice(0, -1)), this.apiKey = lm(e.apiKey ?? n.apiKey), this.webUrl = lm(e.webUrl ?? n.webUrl), this.webUrl?.endsWith("/") && (this.webUrl = this.webUrl.slice(0, -1)), this.timeout_ms = e.timeout_ms ?? 9e4, this.caller = new Ky(e.callerOptions ?? {}), this.traceBatchConcurrency = e.traceBatchConcurrency ?? this.traceBatchConcurrency, this.traceBatchConcurrency < 1)
      throw new Error("Trace batch concurrency must be positive.");
    this.batchIngestCaller = new Ky({
      maxRetries: 2,
      maxConcurrency: this.traceBatchConcurrency,
      ...e.callerOptions ?? {},
      onFailedResponseHook: S1
    }), this.hideInputs = e.hideInputs ?? e.anonymizer ?? n.hideInputs, this.hideOutputs = e.hideOutputs ?? e.anonymizer ?? n.hideOutputs, this.autoBatchTracing = e.autoBatchTracing ?? this.autoBatchTracing, this.blockOnRootRunFinalization = e.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization, this.batchSizeBytesLimit = e.batchSizeBytesLimit, this.fetchOptions = e.fetchOptions || {}, this.manualFlushMode = e.manualFlushMode ?? this.manualFlushMode;
  }
  static getDefaultClientConfig() {
    const e = no("API_KEY"), n = no("ENDPOINT") ?? "https://api.smith.langchain.com", a = no("HIDE_INPUTS") === "true", r = no("HIDE_OUTPUTS") === "true";
    return {
      apiUrl: n,
      apiKey: e,
      webUrl: void 0,
      hideInputs: a,
      hideOutputs: r
    };
  }
  getHostUrl() {
    return this.webUrl ? this.webUrl : v1(this.apiUrl) ? (this.webUrl = "http://localhost:3000", this.webUrl) : this.apiUrl.endsWith("/api/v1") ? (this.webUrl = this.apiUrl.replace("/api/v1", ""), this.webUrl) : this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api") ? (this.webUrl = this.apiUrl.replace("/api", ""), this.webUrl) : this.apiUrl.split(".", 1)[0].includes("dev") ? (this.webUrl = "https://dev.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("eu") ? (this.webUrl = "https://eu.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("beta") ? (this.webUrl = "https://beta.smith.langchain.com", this.webUrl) : (this.webUrl = "https://smith.langchain.com", this.webUrl);
  }
  get headers() {
    const e = {
      "User-Agent": `langsmith-js/${DC}`
    };
    return this.apiKey && (e["x-api-key"] = `${this.apiKey}`), e;
  }
  processInputs(e) {
    return this.hideInputs === !1 ? e : this.hideInputs === !0 ? {} : typeof this.hideInputs == "function" ? this.hideInputs(e) : e;
  }
  processOutputs(e) {
    return this.hideOutputs === !1 ? e : this.hideOutputs === !0 ? {} : typeof this.hideOutputs == "function" ? this.hideOutputs(e) : e;
  }
  prepareRunCreateOrUpdateInputs(e) {
    const n = { ...e };
    return n.inputs !== void 0 && (n.inputs = this.processInputs(n.inputs)), n.outputs !== void 0 && (n.outputs = this.processOutputs(n.outputs)), n;
  }
  async _getResponse(e, n) {
    const a = n?.toString() ?? "", r = `${this.apiUrl}${e}?${a}`, i = await this.caller.call(oe(), r, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(i, `Failed to fetch ${e}`), i;
  }
  async _get(e, n) {
    return (await this._getResponse(e, n)).json();
  }
  async *_getPaginated(e, n = new URLSearchParams(), a) {
    let r = Number(n.get("offset")) || 0;
    const i = Number(n.get("limit")) || 100;
    for (; ; ) {
      n.set("offset", String(r)), n.set("limit", String(i));
      const s = `${this.apiUrl}${e}?${n}`, u = await this.caller.call(oe(), s, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await Se(u, `Failed to fetch ${e}`);
      const d = a ? a(await u.json()) : await u.json();
      if (d.length === 0 || (yield d, d.length < i))
        break;
      r += d.length;
    }
  }
  async *_getCursorPaginatedList(e, n = null, a = "POST", r = "runs") {
    const i = n ? { ...n } : {};
    for (; ; ) {
      const u = await (await this.caller.call(oe(), `${this.apiUrl}${e}`, {
        method: a,
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: JSON.stringify(i)
      })).json();
      if (!u || !u[r])
        break;
      yield u[r];
      const d = u.cursors;
      if (!d || !d.next)
        break;
      i.cursor = d.next;
    }
  }
  // Allows mocking for tests
  _shouldSample() {
    return this.tracingSampleRate === void 0 ? !0 : Math.random() < this.tracingSampleRate;
  }
  _filterForSampling(e, n = !1) {
    if (this.tracingSampleRate === void 0)
      return e;
    if (n) {
      const a = [];
      for (const r of e)
        this.filteredPostUuids.has(r.id) ? this.filteredPostUuids.delete(r.id) : a.push(r);
      return a;
    } else {
      const a = [];
      for (const r of e) {
        const i = r.trace_id ?? r.id;
        this.filteredPostUuids.has(i) || (r.id === i ? this._shouldSample() ? a.push(r) : this.filteredPostUuids.add(i) : a.push(r));
      }
      return a;
    }
  }
  async _getBatchSizeLimitBytes() {
    const e = await this._ensureServerInfo();
    return this.batchSizeBytesLimit ?? e.batch_ingest_config?.size_limit_bytes ?? j1;
  }
  async _getMultiPartSupport() {
    return (await this._ensureServerInfo()).instance_flags?.dataset_examples_multipart_enabled ?? !1;
  }
  drainAutoBatchQueue(e) {
    const n = [];
    for (; this.autoBatchQueue.items.length > 0; ) {
      const [a, r] = this.autoBatchQueue.pop(e);
      if (!a.length) {
        r();
        break;
      }
      const i = this._processBatch(a, r).catch(console.error);
      n.push(i);
    }
    return Promise.all(n);
  }
  async _processBatch(e, n) {
    if (!e.length) {
      n();
      return;
    }
    try {
      const a = {
        runCreates: e.filter((i) => i.action === "create").map((i) => i.item),
        runUpdates: e.filter((i) => i.action === "update").map((i) => i.item)
      };
      (await this._ensureServerInfo())?.batch_ingest_config?.use_multipart_endpoint ? await this.multipartIngestRuns(a) : await this.batchIngestRuns(a);
    } finally {
      n();
    }
  }
  async processRunOperation(e) {
    clearTimeout(this.autoBatchTimeout), this.autoBatchTimeout = void 0, e.action === "create" && (e.item = Qy(e.item));
    const n = this.autoBatchQueue.push(e);
    if (this.manualFlushMode)
      return n;
    const a = await this._getBatchSizeLimitBytes();
    return this.autoBatchQueue.sizeBytes > a && this.drainAutoBatchQueue(a), this.autoBatchQueue.items.length > 0 && (this.autoBatchTimeout = setTimeout(() => {
      this.autoBatchTimeout = void 0, this.drainAutoBatchQueue(a);
    }, this.autoBatchAggregationDelayMs)), n;
  }
  async _getServerInfo() {
    const e = await oe()(`${this.apiUrl}/info`, {
      method: "GET",
      headers: { Accept: "application/json" },
      signal: AbortSignal.timeout(P1),
      ...this.fetchOptions
    });
    return await Se(e, "get server info"), e.json();
  }
  async _ensureServerInfo() {
    return this._getServerInfoPromise === void 0 && (this._getServerInfoPromise = (async () => {
      if (this._serverInfo === void 0)
        try {
          this._serverInfo = await this._getServerInfo();
        } catch {
          console.warn("[WARNING]: LangSmith failed to fetch info on supported operations. Falling back to batch operations and default limits.");
        }
      return this._serverInfo ?? {};
    })()), this._getServerInfoPromise.then((e) => (this._serverInfo === void 0 && (this._getServerInfoPromise = void 0), e));
  }
  async _getSettings() {
    return this.settings || (this.settings = this._get("/settings")), await this.settings;
  }
  /**
   * Flushes current queued traces.
   */
  async flush() {
    const e = await this._getBatchSizeLimitBytes();
    await this.drainAutoBatchQueue(e);
  }
  async createRun(e) {
    if (!this._filterForSampling([e]).length)
      return;
    const n = { ...this.headers, "Content-Type": "application/json" }, a = e.project_name;
    delete e.project_name;
    const r = this.prepareRunCreateOrUpdateInputs({
      session_name: a,
      ...e,
      start_time: e.start_time ?? Date.now()
    });
    if (this.autoBatchTracing && r.trace_id !== void 0 && r.dotted_order !== void 0) {
      this.processRunOperation({
        action: "create",
        item: r
      }).catch(console.error);
      return;
    }
    const i = Qy(r), s = await this.caller.call(oe(), `${this.apiUrl}/runs`, {
      method: "POST",
      headers: n,
      body: mn(i),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(s, "create run", !0);
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async batchIngestRuns({ runCreates: e, runUpdates: n }) {
    if (e === void 0 && n === void 0)
      return;
    let a = e?.map((u) => this.prepareRunCreateOrUpdateInputs(u)) ?? [], r = n?.map((u) => this.prepareRunCreateOrUpdateInputs(u)) ?? [];
    if (a.length > 0 && r.length > 0) {
      const u = a.reduce((f, o) => (o.id && (f[o.id] = o), f), {}), d = [];
      for (const f of r)
        f.id !== void 0 && u[f.id] ? u[f.id] = {
          ...u[f.id],
          ...f
        } : d.push(f);
      a = Object.values(u), r = d;
    }
    const i = {
      post: a,
      patch: r
    };
    if (!i.post.length && !i.patch.length)
      return;
    const s = {
      post: [],
      patch: []
    };
    for (const u of ["post", "patch"]) {
      const d = u, f = i[d].reverse();
      let o = f.pop();
      for (; o !== void 0; )
        s[d].push(o), o = f.pop();
    }
    (s.post.length > 0 || s.patch.length > 0) && await this._postBatchIngestRuns(mn(s));
  }
  async _postBatchIngestRuns(e) {
    const n = {
      ...this.headers,
      "Content-Type": "application/json",
      Accept: "application/json"
    }, a = await this.batchIngestCaller.call(oe(), `${this.apiUrl}/runs/batch`, {
      method: "POST",
      headers: n,
      body: e,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(a, "batch create run", !0);
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async multipartIngestRuns({ runCreates: e, runUpdates: n }) {
    if (e === void 0 && n === void 0)
      return;
    const a = {};
    let r = [];
    for (const o of e ?? []) {
      const c = this.prepareRunCreateOrUpdateInputs(o);
      c.id !== void 0 && c.attachments !== void 0 && (a[c.id] = c.attachments), delete c.attachments, r.push(c);
    }
    let i = [];
    for (const o of n ?? [])
      i.push(this.prepareRunCreateOrUpdateInputs(o));
    if (r.find((o) => o.trace_id === void 0 || o.dotted_order === void 0) !== void 0)
      throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run');
    if (i.find((o) => o.trace_id === void 0 || o.dotted_order === void 0) !== void 0)
      throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run');
    if (r.length > 0 && i.length > 0) {
      const o = r.reduce((h, p) => (p.id && (h[p.id] = p), h), {}), c = [];
      for (const h of i)
        h.id !== void 0 && o[h.id] ? o[h.id] = {
          ...o[h.id],
          ...h
        } : c.push(h);
      r = Object.values(o), i = c;
    }
    if (r.length === 0 && i.length === 0)
      return;
    const d = [], f = [];
    for (const [o, c] of [
      ["post", r],
      ["patch", i]
    ])
      for (const h of c) {
        const { inputs: p, outputs: l, events: m, attachments: b, ...g } = h, _ = { inputs: p, outputs: l, events: m }, P = mn(g);
        f.push({
          name: `${o}.${g.id}`,
          payload: new Blob([P], {
            type: `application/json; length=${P.length}`
            // encoding=gzip
          })
        });
        for (const [R, C] of Object.entries(_)) {
          if (C === void 0)
            continue;
          const T = mn(C);
          f.push({
            name: `${o}.${g.id}.${R}`,
            payload: new Blob([T], {
              type: `application/json; length=${T.length}`
            })
          });
        }
        if (g.id !== void 0) {
          const R = a[g.id];
          if (R) {
            delete a[g.id];
            for (const [C, T] of Object.entries(R)) {
              let O, A;
              if (Array.isArray(T) ? [O, A] = T : (O = T.mimeType, A = T.data), C.includes(".")) {
                console.warn(`Skipping attachment '${C}' for run ${g.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                continue;
              }
              f.push({
                name: `attachment.${g.id}.${C}`,
                payload: new Blob([A], {
                  type: `${O}; length=${A.byteLength}`
                })
              });
            }
          }
        }
        d.push(`trace=${g.trace_id},id=${g.id}`);
      }
    await this._sendMultipartRequest(f, d.join("; "));
  }
  async _sendMultipartRequest(e, n) {
    try {
      const a = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2), r = [];
      for (const d of e)
        r.push(new Blob([`--${a}\r
`])), r.push(new Blob([
          `Content-Disposition: form-data; name="${d.name}"\r
`,
          `Content-Type: ${d.payload.type}\r
\r
`
        ])), r.push(d.payload), r.push(new Blob([`\r
`]));
      r.push(new Blob([`--${a}--\r
`]));
      const s = await new Blob(r).arrayBuffer(), u = await this.batchIngestCaller.call(oe(), `${this.apiUrl}/runs/multipart`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": `multipart/form-data; boundary=${a}`
        },
        body: s,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await Se(u, "ingest multipart runs", !0);
    } catch (a) {
      console.warn(`${a.message.trim()}

Context: ${n}`);
    }
  }
  async updateRun(e, n) {
    be(e), n.inputs && (n.inputs = this.processInputs(n.inputs)), n.outputs && (n.outputs = this.processOutputs(n.outputs));
    const a = { ...n, id: e };
    if (!this._filterForSampling([a], !0).length)
      return;
    if (this.autoBatchTracing && a.trace_id !== void 0 && a.dotted_order !== void 0) {
      if (n.end_time !== void 0 && a.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
        await this.processRunOperation({ action: "update", item: a }).catch(console.error);
        return;
      } else
        this.processRunOperation({ action: "update", item: a }).catch(console.error);
      return;
    }
    const r = { ...this.headers, "Content-Type": "application/json" }, i = await this.caller.call(oe(), `${this.apiUrl}/runs/${e}`, {
      method: "PATCH",
      headers: r,
      body: mn(n),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(i, "update run", !0);
  }
  async readRun(e, { loadChildRuns: n } = { loadChildRuns: !1 }) {
    be(e);
    let a = await this._get(`/runs/${e}`);
    return n && a.child_run_ids && (a = await this._loadChildRuns(a)), a;
  }
  async getRunUrl({ runId: e, run: n, projectOpts: a }) {
    if (n !== void 0) {
      let r;
      n.session_id ? r = n.session_id : a?.projectName ? r = (await this.readProject({ projectName: a?.projectName })).id : a?.projectId ? r = a?.projectId : r = (await this.readProject({
        projectName: no("PROJECT") || "default"
      })).id;
      const i = await this._getTenantId();
      return `${this.getHostUrl()}/o/${i}/projects/p/${r}/r/${n.id}?poll=true`;
    } else if (e !== void 0) {
      const r = await this.readRun(e);
      if (!r.app_path)
        throw new Error(`Run ${e} has no app_path`);
      return `${this.getHostUrl()}${r.app_path}`;
    } else
      throw new Error("Must provide either runId or run");
  }
  async _loadChildRuns(e) {
    const n = await w1(this.listRuns({ id: e.child_run_ids })), a = {}, r = {};
    n.sort((i, s) => (i?.dotted_order ?? "").localeCompare(s?.dotted_order ?? ""));
    for (const i of n) {
      if (i.parent_run_id === null || i.parent_run_id === void 0)
        throw new Error(`Child run ${i.id} has no parent`);
      i.parent_run_id in a || (a[i.parent_run_id] = []), a[i.parent_run_id].push(i), r[i.id] = i;
    }
    e.child_runs = a[e.id] || [];
    for (const i in a)
      i !== e.id && (r[i].child_runs = a[i]);
    return e;
  }
  /**
   * List runs from the LangSmith server.
   * @param projectId - The ID of the project to filter by.
   * @param projectName - The name of the project to filter by.
   * @param parentRunId - The ID of the parent run to filter by.
   * @param traceId - The ID of the trace to filter by.
   * @param referenceExampleId - The ID of the reference example to filter by.
   * @param startTime - The start time to filter by.
   * @param isRoot - Indicates whether to only return root runs.
   * @param runType - The run type to filter by.
   * @param error - Indicates whether to filter by error runs.
   * @param id - The ID of the run to filter by.
   * @param query - The query string to filter by.
   * @param filter - The filter string to apply to the run spans.
   * @param traceFilter - The filter string to apply on the root run of the trace.
   * @param treeFilter - The filter string to apply on other runs in the trace.
   * @param limit - The maximum number of runs to retrieve.
   * @returns {AsyncIterable<Run>} - The runs.
   *
   * @example
   * // List all runs in a project
   * const projectRuns = client.listRuns({ projectName: "<your_project>" });
   *
   * @example
   * // List LLM and Chat runs in the last 24 hours
   * const todaysLLMRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
   *   run_type: "llm",
   * });
   *
   * @example
   * // List traces in a project
   * const rootRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   execution_order: 1,
   * });
   *
   * @example
   * // List runs without errors
   * const correctRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   error: false,
   * });
   *
   * @example
   * // List runs by run ID
   * const runIds = [
   *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
   *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
   * ];
   * const selectedRuns = client.listRuns({ run_ids: runIds });
   *
   * @example
   * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
   * const chainRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
   * });
   *
   * @example
   * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
   * const goodExtractorRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'eq(name, "extractor")',
   *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
   * });
   *
   * @example
   * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
   * const complexRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
   * });
   *
   * @example
   * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
   * const taggedRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
   * });
   */
  async *listRuns(e) {
    const { projectId: n, projectName: a, parentRunId: r, traceId: i, referenceExampleId: s, startTime: u, executionOrder: d, isRoot: f, runType: o, error: c, id: h, query: p, filter: l, traceFilter: m, treeFilter: b, limit: g, select: _ } = e;
    let P = [];
    if (n && (P = Array.isArray(n) ? n : [n]), a) {
      const O = Array.isArray(a) ? a : [a], A = await Promise.all(O.map((M) => this.readProject({ projectName: M }).then((I) => I.id)));
      P.push(...A);
    }
    const R = [
      "app_path",
      "child_run_ids",
      "completion_cost",
      "completion_tokens",
      "dotted_order",
      "end_time",
      "error",
      "events",
      "extra",
      "feedback_stats",
      "first_token_time",
      "id",
      "inputs",
      "name",
      "outputs",
      "parent_run_id",
      "parent_run_ids",
      "prompt_cost",
      "prompt_tokens",
      "reference_example_id",
      "run_type",
      "session_id",
      "start_time",
      "status",
      "tags",
      "total_cost",
      "total_tokens",
      "trace_id"
    ], C = {
      session: P.length ? P : null,
      run_type: o,
      reference_example: s,
      query: p,
      filter: l,
      trace_filter: m,
      tree_filter: b,
      execution_order: d,
      parent_run: r,
      start_time: u ? u.toISOString() : null,
      error: c,
      id: h,
      limit: g,
      trace: i,
      select: _ || R,
      is_root: f
    };
    let T = 0;
    for await (const O of this._getCursorPaginatedList("/runs/query", C))
      if (g) {
        if (T >= g)
          break;
        if (O.length + T > g) {
          yield* O.slice(0, g - T);
          break;
        }
        T += O.length, yield* O;
      } else
        yield* O;
  }
  async getRunStats({ id: e, trace: n, parentRun: a, runType: r, projectNames: i, projectIds: s, referenceExampleIds: u, startTime: d, endTime: f, error: o, query: c, filter: h, traceFilter: p, treeFilter: l, isRoot: m, dataSourceType: b }) {
    let g = s || [];
    i && (g = [
      ...s || [],
      ...await Promise.all(i.map((T) => this.readProject({ projectName: T }).then((O) => O.id)))
    ]);
    const P = Object.fromEntries(Object.entries({
      id: e,
      trace: n,
      parent_run: a,
      run_type: r,
      session: g,
      reference_example: u,
      start_time: d,
      end_time: f,
      error: o,
      query: c,
      filter: h,
      trace_filter: p,
      tree_filter: l,
      is_root: m,
      data_source_type: b
    }).filter(([T, O]) => O !== void 0));
    return await (await this.caller.call(oe(), `${this.apiUrl}/runs/stats`, {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify(P),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
  }
  async shareRun(e, { shareId: n } = {}) {
    const a = {
      run_id: e,
      share_token: n || jt()
    };
    be(e);
    const i = await (await this.caller.call(oe(), `${this.apiUrl}/runs/${e}/share`, {
      method: "PUT",
      headers: this.headers,
      body: JSON.stringify(a),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
    if (i === null || !("share_token" in i))
      throw new Error("Invalid response from server");
    return `${this.getHostUrl()}/public/${i.share_token}/r`;
  }
  async unshareRun(e) {
    be(e);
    const n = await this.caller.call(oe(), `${this.apiUrl}/runs/${e}/share`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(n, "unshare run", !0);
  }
  async readRunSharedLink(e) {
    be(e);
    const a = await (await this.caller.call(oe(), `${this.apiUrl}/runs/${e}/share`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
    if (!(a === null || !("share_token" in a)))
      return `${this.getHostUrl()}/public/${a.share_token}/r`;
  }
  async listSharedRuns(e, { runIds: n } = {}) {
    const a = new URLSearchParams({
      share_token: e
    });
    if (n !== void 0)
      for (const s of n)
        a.append("id", s);
    return be(e), await (await this.caller.call(oe(), `${this.apiUrl}/public/${e}/runs${a}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
  }
  async readDatasetSharedSchema(e, n) {
    if (!e && !n)
      throw new Error("Either datasetId or datasetName must be given");
    e || (e = (await this.readDataset({ datasetName: n })).id), be(e);
    const r = await (await this.caller.call(oe(), `${this.apiUrl}/datasets/${e}/share`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
    return r.url = `${this.getHostUrl()}/public/${r.share_token}/d`, r;
  }
  async shareDataset(e, n) {
    if (!e && !n)
      throw new Error("Either datasetId or datasetName must be given");
    e || (e = (await this.readDataset({ datasetName: n })).id);
    const a = {
      dataset_id: e
    };
    be(e);
    const i = await (await this.caller.call(oe(), `${this.apiUrl}/datasets/${e}/share`, {
      method: "PUT",
      headers: this.headers,
      body: JSON.stringify(a),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
    return i.url = `${this.getHostUrl()}/public/${i.share_token}/d`, i;
  }
  async unshareDataset(e) {
    be(e);
    const n = await this.caller.call(oe(), `${this.apiUrl}/datasets/${e}/share`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(n, "unshare dataset", !0);
  }
  async readSharedDataset(e) {
    return be(e), await (await this.caller.call(oe(), `${this.apiUrl}/public/${e}/datasets`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
  }
  /**
   * Get shared examples.
   *
   * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
   * @param {Object} [options] Additional options for listing the examples.
   * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
   * @returns {Promise<Example[]>} The shared examples.
   */
  async listSharedExamples(e, n) {
    const a = {};
    n?.exampleIds && (a.id = n.exampleIds);
    const r = new URLSearchParams();
    Object.entries(a).forEach(([u, d]) => {
      Array.isArray(d) ? d.forEach((f) => r.append(u, f)) : r.append(u, d);
    });
    const i = await this.caller.call(oe(), `${this.apiUrl}/public/${e}/examples?${r.toString()}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    }), s = await i.json();
    if (!i.ok)
      throw "detail" in s ? new Error(`Failed to list shared examples.
Status: ${i.status}
Message: ${s.detail.join(`
`)}`) : new Error(`Failed to list shared examples: ${i.status} ${i.statusText}`);
    return s.map((u) => ({
      ...u,
      _hostUrl: this.getHostUrl()
    }));
  }
  async createProject({ projectName: e, description: n = null, metadata: a = null, upsert: r = !1, projectExtra: i = null, referenceDatasetId: s = null }) {
    const u = r ? "?upsert=true" : "", d = `${this.apiUrl}/sessions${u}`, f = i || {};
    a && (f.metadata = a);
    const o = {
      name: e,
      extra: f,
      description: n
    };
    s !== null && (o.reference_dataset_id = s);
    const c = await this.caller.call(oe(), d, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(o),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(c, "create project"), await c.json();
  }
  async updateProject(e, { name: n = null, description: a = null, metadata: r = null, projectExtra: i = null, endTime: s = null }) {
    const u = `${this.apiUrl}/sessions/${e}`;
    let d = i;
    r && (d = { ...d || {}, metadata: r });
    const f = {
      name: n,
      extra: d,
      description: a,
      end_time: s ? new Date(s).toISOString() : null
    }, o = await this.caller.call(oe(), u, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(f),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(o, "update project"), await o.json();
  }
  async hasProject({ projectId: e, projectName: n }) {
    let a = "/sessions";
    const r = new URLSearchParams();
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    if (e !== void 0)
      be(e), a += `/${e}`;
    else if (n !== void 0)
      r.append("name", n);
    else
      throw new Error("Must provide projectName or projectId");
    const i = await this.caller.call(oe(), `${this.apiUrl}${a}?${r}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    try {
      const s = await i.json();
      return i.ok ? Array.isArray(s) ? s.length > 0 : !0 : !1;
    } catch {
      return !1;
    }
  }
  async readProject({ projectId: e, projectName: n, includeStats: a }) {
    let r = "/sessions";
    const i = new URLSearchParams();
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    if (e !== void 0)
      be(e), r += `/${e}`;
    else if (n !== void 0)
      i.append("name", n);
    else
      throw new Error("Must provide projectName or projectId");
    a !== void 0 && i.append("include_stats", a.toString());
    const s = await this._get(r, i);
    let u;
    if (Array.isArray(s)) {
      if (s.length === 0)
        throw new Error(`Project[id=${e}, name=${n}] not found`);
      u = s[0];
    } else
      u = s;
    return u;
  }
  async getProjectUrl({ projectId: e, projectName: n }) {
    if (e === void 0 && n === void 0)
      throw new Error("Must provide either projectName or projectId");
    const a = await this.readProject({ projectId: e, projectName: n }), r = await this._getTenantId();
    return `${this.getHostUrl()}/o/${r}/projects/p/${a.id}`;
  }
  async getDatasetUrl({ datasetId: e, datasetName: n }) {
    if (e === void 0 && n === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    const a = await this.readDataset({ datasetId: e, datasetName: n }), r = await this._getTenantId();
    return `${this.getHostUrl()}/o/${r}/datasets/${a.id}`;
  }
  async _getTenantId() {
    if (this._tenantId !== null)
      return this._tenantId;
    const e = new URLSearchParams({ limit: "1" });
    for await (const n of this._getPaginated("/sessions", e))
      return this._tenantId = n[0].tenant_id, n[0].tenant_id;
    throw new Error("No projects found to resolve tenant.");
  }
  async *listProjects({ projectIds: e, name: n, nameContains: a, referenceDatasetId: r, referenceDatasetName: i, referenceFree: s, metadata: u } = {}) {
    const d = new URLSearchParams();
    if (e !== void 0)
      for (const f of e)
        d.append("id", f);
    if (n !== void 0 && d.append("name", n), a !== void 0 && d.append("name_contains", a), r !== void 0)
      d.append("reference_dataset", r);
    else if (i !== void 0) {
      const f = await this.readDataset({
        datasetName: i
      });
      d.append("reference_dataset", f.id);
    }
    s !== void 0 && d.append("reference_free", s.toString()), u !== void 0 && d.append("metadata", JSON.stringify(u));
    for await (const f of this._getPaginated("/sessions", d))
      yield* f;
  }
  async deleteProject({ projectId: e, projectName: n }) {
    let a;
    if (e === void 0 && n === void 0)
      throw new Error("Must provide projectName or projectId");
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    e === void 0 ? a = (await this.readProject({ projectName: n })).id : a = e, be(a);
    const r = await this.caller.call(oe(), `${this.apiUrl}/sessions/${a}`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(r, `delete session ${a} (${n})`, !0);
  }
  async uploadCsv({ csvFile: e, fileName: n, inputKeys: a, outputKeys: r, description: i, dataType: s, name: u }) {
    const d = `${this.apiUrl}/datasets/upload`, f = new FormData();
    f.append("file", e, n), a.forEach((h) => {
      f.append("input_keys", h);
    }), r.forEach((h) => {
      f.append("output_keys", h);
    }), i && f.append("description", i), s && f.append("data_type", s), u && f.append("name", u);
    const o = await this.caller.call(oe(), d, {
      method: "POST",
      headers: this.headers,
      body: f,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(o, "upload CSV"), await o.json();
  }
  async createDataset(e, { description: n, dataType: a, inputsSchema: r, outputsSchema: i, metadata: s } = {}) {
    const u = {
      name: e,
      description: n,
      extra: s ? { metadata: s } : void 0
    };
    a && (u.data_type = a), r && (u.inputs_schema_definition = r), i && (u.outputs_schema_definition = i);
    const d = await this.caller.call(oe(), `${this.apiUrl}/datasets`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(u),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(d, "create dataset"), await d.json();
  }
  async readDataset({ datasetId: e, datasetName: n }) {
    let a = "/datasets";
    const r = new URLSearchParams({ limit: "1" });
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (e !== void 0)
      be(e), a += `/${e}`;
    else if (n !== void 0)
      r.append("name", n);
    else
      throw new Error("Must provide datasetName or datasetId");
    const i = await this._get(a, r);
    let s;
    if (Array.isArray(i)) {
      if (i.length === 0)
        throw new Error(`Dataset[id=${e}, name=${n}] not found`);
      s = i[0];
    } else
      s = i;
    return s;
  }
  async hasDataset({ datasetId: e, datasetName: n }) {
    try {
      return await this.readDataset({ datasetId: e, datasetName: n }), !0;
    } catch (a) {
      if (
        // eslint-disable-next-line no-instanceof/no-instanceof
        a instanceof Error && a.message.toLocaleLowerCase().includes("not found")
      )
        return !1;
      throw a;
    }
  }
  async diffDatasetVersions({ datasetId: e, datasetName: n, fromVersion: a, toVersion: r }) {
    let i = e;
    if (i === void 0 && n === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (i !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    i === void 0 && (i = (await this.readDataset({ datasetName: n })).id);
    const s = new URLSearchParams({
      from_version: typeof a == "string" ? a : a.toISOString(),
      to_version: typeof r == "string" ? r : r.toISOString()
    });
    return await this._get(`/datasets/${i}/versions/diff`, s);
  }
  async readDatasetOpenaiFinetuning({ datasetId: e, datasetName: n }) {
    const a = "/datasets";
    if (e === void 0) if (n !== void 0)
      e = (await this.readDataset({ datasetName: n })).id;
    else
      throw new Error("Must provide either datasetName or datasetId");
    return (await (await this._getResponse(`${a}/${e}/openai_ft`)).text()).trim().split(`
`).map((u) => JSON.parse(u));
  }
  async *listDatasets({ limit: e = 100, offset: n = 0, datasetIds: a, datasetName: r, datasetNameContains: i, metadata: s } = {}) {
    const u = "/datasets", d = new URLSearchParams({
      limit: e.toString(),
      offset: n.toString()
    });
    if (a !== void 0)
      for (const f of a)
        d.append("id", f);
    r !== void 0 && d.append("name", r), i !== void 0 && d.append("name_contains", i), s !== void 0 && d.append("metadata", JSON.stringify(s));
    for await (const f of this._getPaginated(u, d))
      yield* f;
  }
  /**
   * Update a dataset
   * @param props The dataset details to update
   * @returns The updated dataset
   */
  async updateDataset(e) {
    const { datasetId: n, datasetName: a, ...r } = e;
    if (!n && !a)
      throw new Error("Must provide either datasetName or datasetId");
    const i = n ?? (await this.readDataset({ datasetName: a })).id;
    be(i);
    const s = await this.caller.call(oe(), `${this.apiUrl}/datasets/${i}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(r),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(s, "update dataset"), await s.json();
  }
  /**
   * Updates a tag on a dataset.
   *
   * If the tag is already assigned to a different version of this dataset,
   * the tag will be moved to the new version. The as_of parameter is used to
   * determine which version of the dataset to apply the new tags to.
   *
   * It must be an exact version of the dataset to succeed. You can
   * use the "readDatasetVersion" method to find the exact version
   * to apply the tags to.
   * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
   * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
   * @param params.asOf The timestamp of the dataset to apply the new tags to.
   * @param params.tag The new tag to apply to the dataset.
   */
  async updateDatasetTag(e) {
    const { datasetId: n, datasetName: a, asOf: r, tag: i } = e;
    if (!n && !a)
      throw new Error("Must provide either datasetName or datasetId");
    const s = n ?? (await this.readDataset({ datasetName: a })).id;
    be(s);
    const u = await this.caller.call(oe(), `${this.apiUrl}/datasets/${s}/tags`, {
      method: "PUT",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify({
        as_of: typeof r == "string" ? r : r.toISOString(),
        tag: i
      }),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(u, "update dataset tags");
  }
  async deleteDataset({ datasetId: e, datasetName: n }) {
    let a = "/datasets", r = e;
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (n !== void 0 && (r = (await this.readDataset({ datasetName: n })).id), r !== void 0)
      be(r), a += `/${r}`;
    else
      throw new Error("Must provide datasetName or datasetId");
    const i = await this.caller.call(oe(), this.apiUrl + a, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(i, `delete ${a}`), await i.json();
  }
  async indexDataset({ datasetId: e, datasetName: n, tag: a }) {
    let r = e;
    if (!r && !n)
      throw new Error("Must provide either datasetName or datasetId");
    if (r && n)
      throw new Error("Must provide either datasetName or datasetId, not both");
    r || (r = (await this.readDataset({ datasetName: n })).id), be(r);
    const i = {
      tag: a
    }, s = await this.caller.call(oe(), `${this.apiUrl}/datasets/${r}/index`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(i),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(s, "index dataset"), await s.json();
  }
  /**
   * Lets you run a similarity search query on a dataset.
   *
   * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
   *
   * @param inputs      The input on which to run the similarity search. Must have the
   *                    same schema as the dataset.
   *
   * @param datasetId   The dataset to search for similar examples.
   *
   * @param limit       The maximum number of examples to return. Will return the top `limit` most
   *                    similar examples in order of most similar to least similar. If no similar
   *                    examples are found, random examples will be returned.
   *
   * @param filter      A filter string to apply to the search. Only examples will be returned that
   *                    match the filter string. Some examples of filters
   *
   *                    - eq(metadata.mykey, "value")
   *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
   *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
   *
   * @returns           A list of similar examples.
   *
   *
   * @example
   * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
   * inputs = {"text": "How many people live in Berlin?"}
   * limit = 5
   * examples = await client.similarExamples(inputs, dataset_id, limit)
   */
  async similarExamples(e, n, a, { filter: r } = {}) {
    const i = {
      limit: a,
      inputs: e
    };
    r !== void 0 && (i.filter = r), be(n);
    const s = await this.caller.call(oe(), `${this.apiUrl}/datasets/${n}/search`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(i),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(s, "fetch similar examples"), (await s.json()).examples;
  }
  async createExample(e, n, a) {
    if (ev(e) && (n !== void 0 || a !== void 0))
      throw new Error("Cannot provide outputs or options when using ExampleCreate object");
    let r = n ? a?.datasetId : e.dataset_id;
    const i = n ? a?.datasetName : e.dataset_name;
    if (r === void 0 && i === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (r !== void 0 && i !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    r === void 0 && (r = (await this.readDataset({ datasetName: i })).id);
    const s = (n ? a?.createdAt : e.created_at) || /* @__PURE__ */ new Date();
    let u;
    ev(e) ? u = e : u = {
      inputs: e,
      outputs: n,
      created_at: s?.toISOString(),
      id: a?.exampleId,
      metadata: a?.metadata,
      split: a?.split,
      source_run_id: a?.sourceRunId,
      use_source_run_io: a?.useSourceRunIO,
      use_source_run_attachments: a?.useSourceRunAttachments,
      attachments: a?.attachments
    };
    const d = await this._uploadExamplesMultipart(r, [u]);
    return await this.readExample(d.example_ids?.[0] ?? jt());
  }
  async createExamples(e) {
    if (Array.isArray(e)) {
      if (e.length === 0)
        return [];
      const _ = e;
      let P = _[0].dataset_id;
      const R = _[0].dataset_name;
      if (P === void 0 && R === void 0)
        throw new Error("Must provide either datasetName or datasetId");
      if (P !== void 0 && R !== void 0)
        throw new Error("Must provide either datasetName or datasetId, not both");
      P === void 0 && (P = (await this.readDataset({ datasetName: R })).id);
      const C = await this._uploadExamplesMultipart(P, _);
      return await Promise.all(C.example_ids.map((O) => this.readExample(O)));
    }
    const { inputs: n, outputs: a, metadata: r, splits: i, sourceRunIds: s, useSourceRunIOs: u, useSourceRunAttachments: d, attachments: f, exampleIds: o, datasetId: c, datasetName: h } = e;
    if (n === void 0)
      throw new Error("Must provide inputs when using legacy parameters");
    let p = c;
    const l = h;
    if (p === void 0 && l === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (p !== void 0 && l !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    p === void 0 && (p = (await this.readDataset({ datasetName: l })).id);
    const m = n.map((_, P) => ({
      dataset_id: p,
      inputs: _,
      outputs: a?.[P],
      metadata: r?.[P],
      split: i?.[P],
      id: o?.[P],
      attachments: f?.[P],
      source_run_id: s?.[P],
      use_source_run_io: u?.[P],
      use_source_run_attachments: d?.[P]
    })), b = await this._uploadExamplesMultipart(p, m);
    return await Promise.all(b.example_ids.map((_) => this.readExample(_)));
  }
  async createLLMExample(e, n, a) {
    return this.createExample({ input: e }, { output: n }, a);
  }
  async createChatExample(e, n, a) {
    const r = e.map((s) => Hy(s) ? Gy(s) : s), i = Hy(n) ? Gy(n) : n;
    return this.createExample({ input: r }, { output: i }, a);
  }
  async readExample(e) {
    be(e);
    const n = `/examples/${e}`, a = await this._get(n), { attachment_urls: r, ...i } = a, s = i;
    return r && (s.attachments = Object.entries(r).reduce((u, [d, f]) => (u[d.slice(11)] = {
      presigned_url: f.presigned_url,
      mime_type: f.mime_type
    }, u), {})), s;
  }
  async *listExamples({ datasetId: e, datasetName: n, exampleIds: a, asOf: r, splits: i, inlineS3Urls: s, metadata: u, limit: d, offset: f, filter: o, includeAttachments: c } = {}) {
    let h;
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (e !== void 0)
      h = e;
    else if (n !== void 0)
      h = (await this.readDataset({ datasetName: n })).id;
    else
      throw new Error("Must provide a datasetName or datasetId");
    const p = new URLSearchParams({ dataset: h }), l = r ? typeof r == "string" ? r : r?.toISOString() : void 0;
    l && p.append("as_of", l);
    const m = s ?? !0;
    if (p.append("inline_s3_urls", m.toString()), a !== void 0)
      for (const g of a)
        p.append("id", g);
    if (i !== void 0)
      for (const g of i)
        p.append("splits", g);
    if (u !== void 0) {
      const g = JSON.stringify(u);
      p.append("metadata", g);
    }
    d !== void 0 && p.append("limit", d.toString()), f !== void 0 && p.append("offset", f.toString()), o !== void 0 && p.append("filter", o), c === !0 && ["attachment_urls", "outputs", "metadata"].forEach((g) => p.append("select", g));
    let b = 0;
    for await (const g of this._getPaginated("/examples", p)) {
      for (const _ of g) {
        const { attachment_urls: P, ...R } = _, C = R;
        P && (C.attachments = Object.entries(P).reduce((T, [O, A]) => (T[O.slice(11)] = {
          presigned_url: A.presigned_url,
          mime_type: A.mime_type || void 0
        }, T), {})), yield C, b++;
      }
      if (d !== void 0 && b >= d)
        break;
    }
  }
  async deleteExample(e) {
    be(e);
    const n = `/examples/${e}`, a = await this.caller.call(oe(), this.apiUrl + n, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(a, `delete ${n}`), await a.json();
  }
  async updateExample(e, n) {
    let a;
    n ? a = e : a = e.id, be(a);
    let r;
    n ? r = { id: a, ...n } : r = e;
    let i;
    return r.dataset_id !== void 0 ? i = r.dataset_id : i = (await this.readExample(a)).dataset_id, this._updateExamplesMultipart(i, [r]);
  }
  async updateExamples(e) {
    let n;
    return e[0].dataset_id === void 0 ? n = (await this.readExample(e[0].id)).dataset_id : n = e[0].dataset_id, this._updateExamplesMultipart(n, e);
  }
  /**
   * Get dataset version by closest date or exact tag.
   *
   * Use this to resolve the nearest version to a given timestamp or for a given tag.
   *
   * @param options The options for getting the dataset version
   * @param options.datasetId The ID of the dataset
   * @param options.datasetName The name of the dataset
   * @param options.asOf The timestamp of the dataset to retrieve
   * @param options.tag The tag of the dataset to retrieve
   * @returns The dataset version
   */
  async readDatasetVersion({ datasetId: e, datasetName: n, asOf: a, tag: r }) {
    let i;
    if (e ? i = e : i = (await this.readDataset({ datasetName: n })).id, be(i), a && r || !a && !r)
      throw new Error("Exactly one of asOf and tag must be specified.");
    const s = new URLSearchParams();
    a !== void 0 && s.append("as_of", typeof a == "string" ? a : a.toISOString()), r !== void 0 && s.append("tag", r);
    const u = await this.caller.call(oe(), `${this.apiUrl}/datasets/${i}/version?${s.toString()}`, {
      method: "GET",
      headers: { ...this.headers },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(u, "read dataset version"), await u.json();
  }
  async listDatasetSplits({ datasetId: e, datasetName: n, asOf: a }) {
    let r;
    if (e === void 0 && n === void 0)
      throw new Error("Must provide dataset name or ID");
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    e === void 0 ? r = (await this.readDataset({ datasetName: n })).id : r = e, be(r);
    const i = new URLSearchParams(), s = a ? typeof a == "string" ? a : a?.toISOString() : void 0;
    return s && i.append("as_of", s), await this._get(`/datasets/${r}/splits`, i);
  }
  async updateDatasetSplits({ datasetId: e, datasetName: n, splitName: a, exampleIds: r, remove: i = !1 }) {
    let s;
    if (e === void 0 && n === void 0)
      throw new Error("Must provide dataset name or ID");
    if (e !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    e === void 0 ? s = (await this.readDataset({ datasetName: n })).id : s = e, be(s);
    const u = {
      split_name: a,
      examples: r.map((f) => (be(f), f)),
      remove: i
    }, d = await this.caller.call(oe(), `${this.apiUrl}/datasets/${s}/splits`, {
      method: "PUT",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(u),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(d, "update dataset splits", !0);
  }
  /**
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.
   */
  async evaluateRun(e, n, { sourceInfo: a, loadChildRuns: r, referenceExample: i } = { loadChildRuns: !1 }) {
    kC("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
    let s;
    if (typeof e == "string")
      s = await this.readRun(e, { loadChildRuns: r });
    else if (typeof e == "object" && "id" in e)
      s = e;
    else
      throw new Error(`Invalid run type: ${typeof e}`);
    s.reference_example_id !== null && s.reference_example_id !== void 0 && (i = await this.readExample(s.reference_example_id));
    const u = await n.evaluateRun(s, i), [d, f] = await this._logEvaluationFeedback(u, s, a);
    return f[0];
  }
  async createFeedback(e, n, { score: a, value: r, correction: i, comment: s, sourceInfo: u, feedbackSourceType: d = "api", sourceRunId: f, feedbackId: o, feedbackConfig: c, projectId: h, comparativeExperimentId: p }) {
    if (!e && !h)
      throw new Error("One of runId or projectId must be provided");
    if (e && h)
      throw new Error("Only one of runId or projectId can be provided");
    const l = {
      type: d ?? "api",
      metadata: u ?? {}
    };
    f !== void 0 && l?.metadata !== void 0 && !l.metadata.__run && (l.metadata.__run = { run_id: f }), l?.metadata !== void 0 && l.metadata.__run?.run_id !== void 0 && be(l.metadata.__run.run_id);
    const m = {
      id: o ?? jt(),
      run_id: e,
      key: n,
      score: Yy(a),
      value: r,
      correction: i,
      comment: s,
      feedback_source: l,
      comparative_experiment_id: p,
      feedbackConfig: c,
      session_id: h
    }, b = `${this.apiUrl}/feedback`, g = await this.caller.call(oe(), b, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(m),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(g, "create feedback", !0), m;
  }
  async updateFeedback(e, { score: n, value: a, correction: r, comment: i }) {
    const s = {};
    n != null && (s.score = Yy(n)), a != null && (s.value = a), r != null && (s.correction = r), i != null && (s.comment = i), be(e);
    const u = await this.caller.call(oe(), `${this.apiUrl}/feedback/${e}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(s),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(u, "update feedback", !0);
  }
  async readFeedback(e) {
    be(e);
    const n = `/feedback/${e}`;
    return await this._get(n);
  }
  async deleteFeedback(e) {
    be(e);
    const n = `/feedback/${e}`, a = await this.caller.call(oe(), this.apiUrl + n, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(a, `delete ${n}`), await a.json();
  }
  async *listFeedback({ runIds: e, feedbackKeys: n, feedbackSourceTypes: a } = {}) {
    const r = new URLSearchParams();
    if (e && r.append("run", e.join(",")), n)
      for (const i of n)
        r.append("key", i);
    if (a)
      for (const i of a)
        r.append("source", i);
    for await (const i of this._getPaginated("/feedback", r))
      yield* i;
  }
  /**
   * Creates a presigned feedback token and URL.
   *
   * The token can be used to authorize feedback metrics without
   * needing an API key. This is useful for giving browser-based
   * applications the ability to submit feedback without needing
   * to expose an API key.
   *
   * @param runId The ID of the run.
   * @param feedbackKey The feedback key.
   * @param options Additional options for the token.
   * @param options.expiration The expiration time for the token.
   *
   * @returns A promise that resolves to a FeedbackIngestToken.
   */
  async createPresignedFeedbackToken(e, n, { expiration: a, feedbackConfig: r } = {}) {
    const i = {
      run_id: e,
      feedback_key: n,
      feedback_config: r
    };
    return a ? typeof a == "string" ? i.expires_at = a : (a?.hours || a?.minutes || a?.days) && (i.expires_in = a) : i.expires_in = {
      hours: 3
    }, await (await this.caller.call(oe(), `${this.apiUrl}/feedback/tokens`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(i),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
  }
  async createComparativeExperiment({ name: e, experimentIds: n, referenceDatasetId: a, createdAt: r, description: i, metadata: s, id: u }) {
    if (n.length === 0)
      throw new Error("At least one experiment is required");
    if (a || (a = (await this.readProject({
      projectId: n[0]
    })).reference_dataset_id), !a == null)
      throw new Error("A reference dataset is required");
    const d = {
      id: u,
      name: e,
      experiment_ids: n,
      reference_dataset_id: a,
      description: i,
      created_at: (r ?? /* @__PURE__ */ new Date())?.toISOString(),
      extra: {}
    };
    return s && (d.extra.metadata = s), await (await this.caller.call(oe(), `${this.apiUrl}/datasets/comparative`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(d),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
  }
  /**
   * Retrieves a list of presigned feedback tokens for a given run ID.
   * @param runId The ID of the run.
   * @returns An async iterable of FeedbackIngestToken objects.
   */
  async *listPresignedFeedbackTokens(e) {
    be(e);
    const n = new URLSearchParams({ run_id: e });
    for await (const a of this._getPaginated("/feedback/tokens", n))
      yield* a;
  }
  _selectEvalResults(e) {
    let n;
    return "results" in e ? n = e.results : Array.isArray(e) ? n = e : n = [e], n;
  }
  async _logEvaluationFeedback(e, n, a) {
    const r = this._selectEvalResults(e), i = [];
    for (const s of r) {
      let u = a || {};
      s.evaluatorInfo && (u = { ...s.evaluatorInfo, ...u });
      let d = null;
      s.targetRunId ? d = s.targetRunId : n && (d = n.id), i.push(await this.createFeedback(d, s.key, {
        score: s.score,
        value: s.value,
        comment: s.comment,
        correction: s.correction,
        sourceInfo: u,
        sourceRunId: s.sourceRunId,
        feedbackConfig: s.feedbackConfig,
        feedbackSourceType: "model"
      }));
    }
    return [r, i];
  }
  async logEvaluationFeedback(e, n, a) {
    const [r] = await this._logEvaluationFeedback(e, n, a);
    return r;
  }
  /**
   * API for managing annotation queues
   */
  /**
   * List the annotation queues on the LangSmith API.
   * @param options - The options for listing annotation queues
   * @param options.queueIds - The IDs of the queues to filter by
   * @param options.name - The name of the queue to filter by
   * @param options.nameContains - The substring that the queue name should contain
   * @param options.limit - The maximum number of queues to return
   * @returns An iterator of AnnotationQueue objects
   */
  async *listAnnotationQueues(e = {}) {
    const { queueIds: n, name: a, nameContains: r, limit: i } = e, s = new URLSearchParams();
    n && n.forEach((d, f) => {
      be(d, `queueIds[${f}]`), s.append("ids", d);
    }), a && s.append("name", a), r && s.append("name_contains", r), s.append("limit", (i !== void 0 ? Math.min(i, 100) : 100).toString());
    let u = 0;
    for await (const d of this._getPaginated("/annotation-queues", s))
      if (yield* d, u++, i !== void 0 && u >= i)
        break;
  }
  /**
   * Create an annotation queue on the LangSmith API.
   * @param options - The options for creating an annotation queue
   * @param options.name - The name of the annotation queue
   * @param options.description - The description of the annotation queue
   * @param options.queueId - The ID of the annotation queue
   * @returns The created AnnotationQueue object
   */
  async createAnnotationQueue(e) {
    const { name: n, description: a, queueId: r } = e, i = {
      name: n,
      description: a,
      id: r || jt()
    }, s = await this.caller.call(oe(), `${this.apiUrl}/annotation-queues`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(Object.fromEntries(Object.entries(i).filter(([d, f]) => f !== void 0))),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(s, "create annotation queue"), await s.json();
  }
  /**
   * Read an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to read
   * @returns The AnnotationQueue object
   */
  async readAnnotationQueue(e) {
    const n = await this.listAnnotationQueues({
      queueIds: [e]
    }).next();
    if (n.done)
      throw new Error(`Annotation queue with ID ${e} not found`);
    return n.value;
  }
  /**
   * Update an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to update
   * @param options - The options for updating the annotation queue
   * @param options.name - The new name for the annotation queue
   * @param options.description - The new description for the annotation queue
   */
  async updateAnnotationQueue(e, n) {
    const { name: a, description: r } = n, i = await this.caller.call(oe(), `${this.apiUrl}/annotation-queues/${be(e, "queueId")}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify({ name: a, description: r }),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(i, "update annotation queue");
  }
  /**
   * Delete an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to delete
   */
  async deleteAnnotationQueue(e) {
    const n = await this.caller.call(oe(), `${this.apiUrl}/annotation-queues/${be(e, "queueId")}`, {
      method: "DELETE",
      headers: { ...this.headers, Accept: "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(n, "delete annotation queue");
  }
  /**
   * Add runs to an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue
   * @param runIds - The IDs of the runs to be added to the annotation queue
   */
  async addRunsToAnnotationQueue(e, n) {
    const a = await this.caller.call(oe(), `${this.apiUrl}/annotation-queues/${be(e, "queueId")}/runs`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(n.map((r, i) => be(r, `runIds[${i}]`).toString())),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(a, "add runs to annotation queue");
  }
  /**
   * Get a run from an annotation queue at the specified index.
   * @param queueId - The ID of the annotation queue
   * @param index - The index of the run to retrieve
   * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
   * @throws {Error} If the run is not found at the given index or for other API-related errors
   */
  async getRunFromAnnotationQueue(e, n) {
    const a = `/annotation-queues/${be(e, "queueId")}/run`, r = await this.caller.call(oe(), `${this.apiUrl}${a}/${n}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(r, "get run from annotation queue"), await r.json();
  }
  /**
   * Delete a run from an an annotation queue.
   * @param queueId - The ID of the annotation queue to delete the run from
   * @param queueRunId - The ID of the run to delete from the annotation queue
   */
  async deleteRunFromAnnotationQueue(e, n) {
    const a = await this.caller.call(oe(), `${this.apiUrl}/annotation-queues/${be(e, "queueId")}/runs/${be(n, "queueRunId")}`, {
      method: "DELETE",
      headers: { ...this.headers, Accept: "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(a, "delete run from annotation queue");
  }
  /**
   * Get the size of an annotation queue.
   * @param queueId - The ID of the annotation queue
   */
  async getSizeFromAnnotationQueue(e) {
    const n = await this.caller.call(oe(), `${this.apiUrl}/annotation-queues/${be(e, "queueId")}/size`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(n, "get size from annotation queue"), await n.json();
  }
  async _currentTenantIsOwner(e) {
    const n = await this._getSettings();
    return e == "-" || n.tenant_handle === e;
  }
  async _ownerConflictError(e, n) {
    const a = await this._getSettings();
    return new Error(`Cannot ${e} for another tenant.

      Current tenant: ${a.tenant_handle}

      Requested tenant: ${n}`);
  }
  async _getLatestCommitHash(e) {
    const n = await this.caller.call(oe(), `${this.apiUrl}/commits/${e}/?limit=1&offset=0`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    }), a = await n.json();
    if (!n.ok) {
      const r = typeof a.detail == "string" ? a.detail : JSON.stringify(a.detail), i = new Error(`Error ${n.status}: ${n.statusText}
${r}`);
      throw i.statusCode = n.status, i;
    }
    if (a.commits.length !== 0)
      return a.commits[0].commit_hash;
  }
  async _likeOrUnlikePrompt(e, n) {
    const [a, r, i] = Hs(e), s = await this.caller.call(oe(), `${this.apiUrl}/likes/${a}/${r}`, {
      method: "POST",
      body: JSON.stringify({ like: n }),
      headers: { ...this.headers, "Content-Type": "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(s, `${n ? "like" : "unlike"} prompt`), await s.json();
  }
  async _getPromptUrl(e) {
    const [n, a, r] = Hs(e);
    if (await this._currentTenantIsOwner(n)) {
      const i = await this._getSettings();
      return r !== "latest" ? `${this.getHostUrl()}/prompts/${a}/${r.substring(0, 8)}?organizationId=${i.id}` : `${this.getHostUrl()}/prompts/${a}?organizationId=${i.id}`;
    } else
      return r !== "latest" ? `${this.getHostUrl()}/hub/${n}/${a}/${r.substring(0, 8)}` : `${this.getHostUrl()}/hub/${n}/${a}`;
  }
  async promptExists(e) {
    return !!await this.getPrompt(e);
  }
  async likePrompt(e) {
    return this._likeOrUnlikePrompt(e, !0);
  }
  async unlikePrompt(e) {
    return this._likeOrUnlikePrompt(e, !1);
  }
  async *listCommits(e) {
    for await (const n of this._getPaginated(`/commits/${e}/`, new URLSearchParams(), (a) => a.commits))
      yield* n;
  }
  async *listPrompts(e) {
    const n = new URLSearchParams();
    n.append("sort_field", e?.sortField ?? "updated_at"), n.append("sort_direction", "desc"), n.append("is_archived", (!!e?.isArchived).toString()), e?.isPublic !== void 0 && n.append("is_public", e.isPublic.toString()), e?.query && n.append("query", e.query);
    for await (const a of this._getPaginated("/repos", n, (r) => r.repos))
      yield* a;
  }
  async getPrompt(e) {
    const [n, a, r] = Hs(e), i = await this.caller.call(oe(), `${this.apiUrl}/repos/${n}/${a}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    if (i.status === 404)
      return null;
    await Se(i, "get prompt");
    const s = await i.json();
    return s.repo ? s.repo : null;
  }
  async createPrompt(e, n) {
    const a = await this._getSettings();
    if (n?.isPublic && !a.tenant_handle)
      throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle. 
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
    const [r, i, s] = Hs(e);
    if (!await this._currentTenantIsOwner(r))
      throw await this._ownerConflictError("create a prompt", r);
    const u = {
      repo_handle: i,
      ...n?.description && { description: n.description },
      ...n?.readme && { readme: n.readme },
      ...n?.tags && { tags: n.tags },
      is_public: !!n?.isPublic
    }, d = await this.caller.call(oe(), `${this.apiUrl}/repos/`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(u),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(d, "create prompt");
    const { repo: f } = await d.json();
    return f;
  }
  async createCommit(e, n, a) {
    if (!await this.promptExists(e))
      throw new Error("Prompt does not exist, you must create it first.");
    const [r, i, s] = Hs(e), u = a?.parentCommitHash === "latest" || !a?.parentCommitHash ? await this._getLatestCommitHash(`${r}/${i}`) : a?.parentCommitHash, d = {
      manifest: JSON.parse(JSON.stringify(n)),
      parent_commit: u
    }, f = await this.caller.call(oe(), `${this.apiUrl}/commits/${r}/${i}`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(d),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(f, "create commit");
    const o = await f.json();
    return this._getPromptUrl(`${r}/${i}${o.commit_hash ? `:${o.commit_hash}` : ""}`);
  }
  /**
   * Update examples with attachments using multipart form data.
   * @param updates List of ExampleUpdateWithAttachments objects to upsert
   * @returns Promise with the update response
   */
  async updateExamplesMultipart(e, n = []) {
    return this._updateExamplesMultipart(e, n);
  }
  async _updateExamplesMultipart(e, n = []) {
    if (!await this._getMultiPartSupport())
      throw new Error("Your LangSmith version does not allow using the multipart examples endpoint, please update to the latest version.");
    const a = new FormData();
    for (const u of n) {
      const d = u.id, f = {
        ...u.metadata && { metadata: u.metadata },
        ...u.split && { split: u.split }
      }, o = mn(f), c = new Blob([o], {
        type: "application/json"
      });
      if (a.append(d, c), u.inputs) {
        const h = mn(u.inputs), p = new Blob([h], {
          type: "application/json"
        });
        a.append(`${d}.inputs`, p);
      }
      if (u.outputs) {
        const h = mn(u.outputs), p = new Blob([h], {
          type: "application/json"
        });
        a.append(`${d}.outputs`, p);
      }
      if (u.attachments)
        for (const [h, p] of Object.entries(u.attachments)) {
          let l, m;
          Array.isArray(p) ? [l, m] = p : (l = p.mimeType, m = p.data);
          const b = new Blob([m], {
            type: `${l}; length=${m.byteLength}`
          });
          a.append(`${d}.attachment.${h}`, b);
        }
      if (u.attachments_operations) {
        const h = mn(u.attachments_operations), p = new Blob([h], {
          type: "application/json"
        });
        a.append(`${d}.attachments_operations`, p);
      }
    }
    const r = e ?? n[0]?.dataset_id;
    return await (await this.caller.call(oe(), `${this.apiUrl}/v1/platform/datasets/${r}/examples`, {
      method: "PATCH",
      headers: this.headers,
      body: a
    })).json();
  }
  /**
   * Upload examples with attachments using multipart form data.
   * @param uploads List of ExampleUploadWithAttachments objects to upload
   * @returns Promise with the upload response
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead
   */
  async uploadExamplesMultipart(e, n = []) {
    return this._uploadExamplesMultipart(e, n);
  }
  async _uploadExamplesMultipart(e, n = []) {
    if (!await this._getMultiPartSupport())
      throw new Error("Your LangSmith version does not allow using the multipart examples endpoint, please update to the latest version.");
    const a = new FormData();
    for (const s of n) {
      const u = (s.id ?? jt()).toString(), d = {
        created_at: s.created_at,
        ...s.metadata && { metadata: s.metadata },
        ...s.split && { split: s.split },
        ...s.source_run_id && { source_run_id: s.source_run_id },
        ...s.use_source_run_io && {
          use_source_run_io: s.use_source_run_io
        },
        ...s.use_source_run_attachments && {
          use_source_run_attachments: s.use_source_run_attachments
        }
      }, f = mn(d), o = new Blob([f], {
        type: "application/json"
      });
      if (a.append(u, o), s.inputs) {
        const c = mn(s.inputs), h = new Blob([c], {
          type: "application/json"
        });
        a.append(`${u}.inputs`, h);
      }
      if (s.outputs) {
        const c = mn(s.outputs), h = new Blob([c], {
          type: "application/json"
        });
        a.append(`${u}.outputs`, h);
      }
      if (s.attachments)
        for (const [c, h] of Object.entries(s.attachments)) {
          let p, l;
          Array.isArray(h) ? [p, l] = h : (p = h.mimeType, l = h.data);
          const m = new Blob([l], {
            type: `${p}; length=${l.byteLength}`
          });
          a.append(`${u}.attachment.${c}`, m);
        }
    }
    return await (await this.caller.call(oe(), `${this.apiUrl}/v1/platform/datasets/${e}/examples`, {
      method: "POST",
      headers: this.headers,
      body: a
    })).json();
  }
  async updatePrompt(e, n) {
    if (!await this.promptExists(e))
      throw new Error("Prompt does not exist, you must create it first.");
    const [a, r] = Hs(e);
    if (!await this._currentTenantIsOwner(a))
      throw await this._ownerConflictError("update a prompt", a);
    const i = {};
    if (n?.description !== void 0 && (i.description = n.description), n?.readme !== void 0 && (i.readme = n.readme), n?.tags !== void 0 && (i.tags = n.tags), n?.isPublic !== void 0 && (i.is_public = n.isPublic), n?.isArchived !== void 0 && (i.is_archived = n.isArchived), Object.keys(i).length === 0)
      throw new Error("No valid update options provided");
    const s = await this.caller.call(oe(), `${this.apiUrl}/repos/${a}/${r}`, {
      method: "PATCH",
      body: JSON.stringify(i),
      headers: {
        ...this.headers,
        "Content-Type": "application/json"
      },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await Se(s, "update prompt"), s.json();
  }
  async deletePrompt(e) {
    if (!await this.promptExists(e))
      throw new Error("Prompt does not exist, you must create it first.");
    const [n, a, r] = Hs(e);
    if (!await this._currentTenantIsOwner(n))
      throw await this._ownerConflictError("delete a prompt", n);
    return await (await this.caller.call(oe(), `${this.apiUrl}/repos/${n}/${a}`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    })).json();
  }
  async pullPromptCommit(e, n) {
    const [a, r, i] = Hs(e), s = await this.caller.call(oe(), `${this.apiUrl}/commits/${a}/${r}/${i}${n?.includeModel ? "?include_model=true" : ""}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await Se(s, "pull prompt commit");
    const u = await s.json();
    return {
      owner: a,
      repo: r,
      commit_hash: u.commit_hash,
      manifest: u.manifest,
      examples: u.examples
    };
  }
  /**
   * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
   * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
   * @private
   */
  async _pullPrompt(e, n) {
    const a = await this.pullPromptCommit(e, {
      includeModel: n?.includeModel
    });
    return JSON.stringify(a.manifest);
  }
  async pushPrompt(e, n) {
    return await this.promptExists(e) ? n && Object.keys(n).some((r) => r !== "object") && await this.updatePrompt(e, {
      description: n?.description,
      readme: n?.readme,
      tags: n?.tags,
      isPublic: n?.isPublic
    }) : await this.createPrompt(e, {
      description: n?.description,
      readme: n?.readme,
      tags: n?.tags,
      isPublic: n?.isPublic
    }), n?.object ? await this.createCommit(e, n?.object, {
      parentCommitHash: n?.parentCommitHash
    }) : await this._getPromptUrl(e);
  }
  /**
     * Clone a public dataset to your own langsmith tenant.
     * This operation is idempotent. If you already have a dataset with the given name,
     * this function will do nothing.
  
     * @param {string} tokenOrUrl The token of the public dataset to clone.
     * @param {Object} [options] Additional options for cloning the dataset.
     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
     * @returns {Promise<void>}
     */
  async clonePublicDataset(e, n = {}) {
    const { sourceApiUrl: a = this.apiUrl, datasetName: r } = n, [i, s] = this.parseTokenOrUrl(e, a), u = new dd({
      apiUrl: i,
      // Placeholder API key not needed anymore in most cases, but
      // some private deployments may have API key-based rate limiting
      // that would cause this to fail if we provide no value.
      apiKey: "placeholder"
    }), d = await u.readSharedDataset(s), f = r || d.name;
    try {
      if (await this.hasDataset({ datasetId: f })) {
        console.log(`Dataset ${f} already exists in your tenant. Skipping.`);
        return;
      }
    } catch {
    }
    const o = await u.listSharedExamples(s), c = await this.createDataset(f, {
      description: d.description,
      dataType: d.data_type || "kv",
      inputsSchema: d.inputs_schema_definition ?? void 0,
      outputsSchema: d.outputs_schema_definition ?? void 0
    });
    try {
      await this.createExamples({
        inputs: o.map((h) => h.inputs),
        outputs: o.flatMap((h) => h.outputs ? [h.outputs] : []),
        datasetId: c.id
      });
    } catch (h) {
      throw console.error(`An error occurred while creating dataset ${f}. You should delete it manually.`), h;
    }
  }
  parseTokenOrUrl(e, n, a = 2, r = "dataset") {
    try {
      return be(e), [n, e];
    } catch {
    }
    try {
      const s = new URL(e).pathname.split("/").filter((u) => u !== "");
      if (s.length >= a) {
        const u = s[s.length - a];
        return [n, u];
      } else
        throw new Error(`Invalid public ${r} URL: ${e}`);
    } catch {
      throw new Error(`Invalid public ${r} URL or token: ${e}`);
    }
  }
  /**
   * Awaits all pending trace batches. Useful for environments where
   * you need to be sure that all tracing requests finish before execution ends,
   * such as serverless environments.
   *
   * @example
   * ```
   * import { Client } from "langsmith";
   *
   * const client = new Client();
   *
   * try {
   *   // Tracing happens here
   *   ...
   * } finally {
   *   await client.awaitPendingTraceBatches();
   * }
   * ```
   *
   * @returns A promise that resolves once all currently pending traces have sent.
   */
  awaitPendingTraceBatches() {
    return this.manualFlushMode ? (console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches."), Promise.resolve()) : Promise.all([
      ...this.autoBatchQueue.items.map(({ itemPromise: e }) => e),
      this.batchIngestCaller.queue.onIdle()
    ]);
  }
}
function ev(t) {
  return "dataset_id" in t || "dataset_name" in t;
}
const DC = "0.3.15";
var C1 = {};
let _a;
const R1 = () => typeof window < "u" && typeof window.document < "u", T1 = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", $1 = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), qC = () => typeof Deno < "u", M1 = () => typeof pe < "u" && typeof C1 < "u" && !0 && !qC(), A1 = () => _a || (R1() ? _a = "browser" : M1() ? _a = "node" : T1() ? _a = "webworker" : $1() ? _a = "jsdom" : qC() ? _a = "deno" : _a = "other", _a);
let dm;
function JC() {
  if (dm === void 0) {
    const t = A1(), e = N1();
    dm = {
      library: "langsmith",
      runtime: t,
      sdk: "langsmith-js",
      sdk_version: DC,
      ...e
    };
  }
  return dm;
}
function E1() {
  const t = I1() || {}, e = {}, n = [
    "LANGCHAIN_API_KEY",
    "LANGCHAIN_ENDPOINT",
    "LANGCHAIN_TRACING_V2",
    "LANGCHAIN_PROJECT",
    "LANGCHAIN_SESSION",
    "LANGSMITH_API_KEY",
    "LANGSMITH_ENDPOINT",
    "LANGSMITH_TRACING_V2",
    "LANGSMITH_PROJECT",
    "LANGSMITH_SESSION"
  ];
  for (const [a, r] of Object.entries(t))
    (a.startsWith("LANGCHAIN_") || a.startsWith("LANGSMITH_")) && typeof r == "string" && !n.includes(a) && !a.toLowerCase().includes("key") && !a.toLowerCase().includes("secret") && !a.toLowerCase().includes("token") && (a === "LANGCHAIN_REVISION_ID" ? e.revision_id = r : e[a] = r);
  return e;
}
function I1() {
  try {
    return typeof pe < "u" && pe.env ? Object.entries(pe.env).reduce((t, [e, n]) => (t[e] = String(n), t), {}) : void 0;
  } catch {
    return;
  }
}
function qo(t) {
  try {
    return typeof pe < "u" ? (
      // eslint-disable-next-line no-process-env
      pe.env?.[t]
    ) : void 0;
  } catch {
    return;
  }
}
function no(t) {
  return qo(`LANGSMITH_${t}`) || qo(`LANGCHAIN_${t}`);
}
let fm;
function N1() {
  if (fm !== void 0)
    return fm;
  const t = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT"
  ], e = {};
  for (const n of t) {
    const a = qo(n);
    a !== void 0 && (e[n] = a);
  }
  return fm = e, e;
}
const F1 = (t) => !!["TRACING_V2", "TRACING"].find((n) => no(n) === "true"), hm = Symbol.for("lc:context_variables");
function k1(t) {
  return t.replace(/[-:.]/g, "");
}
function D1(t, e, n = 1) {
  const a = n.toFixed(0).slice(0, 3).padStart(3, "0");
  return k1(`${new Date(t).toISOString().slice(0, -1)}${a}Z`) + e;
}
class Sh {
  constructor(e, n) {
    Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.metadata = e, this.tags = n;
  }
  static fromHeader(e) {
    const n = e.split(",");
    let a = {}, r = [];
    for (const i of n) {
      const [s, u] = i.split("="), d = decodeURIComponent(u);
      s === "langsmith-metadata" ? a = JSON.parse(d) : s === "langsmith-tags" && (r = d.split(","));
    }
    return new Sh(a, r);
  }
  toHeader() {
    const e = [];
    return this.metadata && Object.keys(this.metadata).length > 0 && e.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`), this.tags && this.tags.length > 0 && e.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`), e.join(",");
  }
}
class _n {
  constructor(e) {
    if (Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "run_type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "project_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "parent_run", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "child_runs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "start_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "end_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "extra", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "error", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serialized", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reference_example_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "trace_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dotted_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tracingEnabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "execution_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "child_execution_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "attachments", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), LC(e)) {
      Object.assign(this, { ...e });
      return;
    }
    const n = _n.getDefaultConfig(), { metadata: a, ...r } = e, i = r.client ?? _n.getSharedClient(), s = {
      ...a,
      ...r?.extra?.metadata
    };
    if (r.extra = { ...r.extra, metadata: s }, Object.assign(this, { ...n, ...r, client: i }), this.trace_id || (this.parent_run ? this.trace_id = this.parent_run.trace_id ?? this.id : this.trace_id = this.id), this.execution_order ??= 1, this.child_execution_order ??= 1, !this.dotted_order) {
      const u = D1(this.start_time, this.id, this.execution_order);
      this.parent_run ? this.dotted_order = this.parent_run.dotted_order + "." + u : this.dotted_order = u;
    }
  }
  static getDefaultConfig() {
    return {
      id: jt(),
      run_type: "chain",
      project_name: no("PROJECT") ?? qo("LANGCHAIN_SESSION") ?? // TODO: Deprecate
      "default",
      child_runs: [],
      api_url: qo("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
      api_key: qo("LANGCHAIN_API_KEY"),
      caller_options: {},
      start_time: Date.now(),
      serialized: {},
      inputs: {},
      extra: {}
    };
  }
  static getSharedClient() {
    return _n.sharedClient || (_n.sharedClient = new dd()), _n.sharedClient;
  }
  createChild(e) {
    const n = this.child_execution_order + 1, a = new _n({
      ...e,
      parent_run: this,
      project_name: this.project_name,
      client: this.client,
      tracingEnabled: this.tracingEnabled,
      execution_order: n,
      child_execution_order: n
    });
    hm in this && (a[hm] = this[hm]);
    const r = Symbol.for("lc:child_config"), i = e.extra?.[r] ?? this.extra[r];
    if (J1(i)) {
      const d = { ...i }, f = q1(d.callbacks) ? d.callbacks.copy?.() : void 0;
      f && (Object.assign(f, { _parentRunId: a.id }), f.handlers?.find(UC)?.updateFromRunTree?.(a), d.callbacks = f), a.extra[r] = d;
    }
    const s = /* @__PURE__ */ new Set();
    let u = this;
    for (; u != null && !s.has(u.id); )
      s.add(u.id), u.child_execution_order = Math.max(u.child_execution_order, n), u = u.parent_run;
    return this.child_runs.push(a), a;
  }
  async end(e, n, a = Date.now(), r) {
    this.outputs = this.outputs ?? e, this.error = this.error ?? n, this.end_time = this.end_time ?? a, r && Object.keys(r).length > 0 && (this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...r } } : { metadata: r });
  }
  _convertToCreate(e, n, a = !0) {
    const r = e.extra ?? {};
    if (r.runtime || (r.runtime = {}), n)
      for (const [d, f] of Object.entries(n))
        r.runtime[d] || (r.runtime[d] = f);
    let i, s;
    return a ? (s = e.parent_run?.id, i = []) : (i = e.child_runs.map((d) => this._convertToCreate(d, n, a)), s = void 0), {
      id: e.id,
      name: e.name,
      start_time: e.start_time,
      end_time: e.end_time,
      run_type: e.run_type,
      reference_example_id: e.reference_example_id,
      extra: r,
      serialized: e.serialized,
      error: e.error,
      inputs: e.inputs,
      outputs: e.outputs,
      session_name: e.project_name,
      child_runs: i,
      parent_run_id: s,
      trace_id: e.trace_id,
      dotted_order: e.dotted_order,
      tags: e.tags,
      attachments: e.attachments
    };
  }
  async postRun(e = !0) {
    try {
      const n = JC(), a = await this._convertToCreate(this, n, !0);
      if (await this.client.createRun(a), !e) {
        kC("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
        for (const r of this.child_runs)
          await r.postRun(!1);
      }
    } catch (n) {
      console.error(`Error in postRun for run ${this.id}:`, n);
    }
  }
  async patchRun() {
    try {
      const e = {
        end_time: this.end_time,
        error: this.error,
        inputs: this.inputs,
        outputs: this.outputs,
        parent_run_id: this.parent_run?.id,
        reference_example_id: this.reference_example_id,
        extra: this.extra,
        events: this.events,
        dotted_order: this.dotted_order,
        trace_id: this.trace_id,
        tags: this.tags,
        attachments: this.attachments
      };
      await this.client.updateRun(this.id, e);
    } catch (e) {
      console.error(`Error in patchRun for run ${this.id}`, e);
    }
  }
  toJSON() {
    return this._convertToCreate(this, void 0, !1);
  }
  /**
   * Add an event to the run tree.
   * @param event - A single event or string to add
   */
  addEvent(e) {
    this.events || (this.events = []), typeof e == "string" ? this.events.push({
      name: "event",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      message: e
    }) : this.events.push({
      ...e,
      time: e.time ?? (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  static fromRunnableConfig(e, n) {
    const a = e?.callbacks;
    let r, i, s, u = F1();
    if (a) {
      const f = a?.getParentRunId?.() ?? "", o = a?.handlers?.find((c) => c?.name == "langchain_tracer");
      r = o?.getRun?.(f), i = o?.projectName, s = o?.client, u = u || !!o;
    }
    return r ? new _n({
      name: r.name,
      id: r.id,
      trace_id: r.trace_id,
      dotted_order: r.dotted_order,
      client: s,
      tracingEnabled: u,
      project_name: i,
      tags: [
        ...new Set((r?.tags ?? []).concat(e?.tags ?? []))
      ],
      extra: {
        metadata: {
          ...r?.extra?.metadata,
          ...e?.metadata
        }
      }
    }).createChild(n) : new _n({
      ...n,
      client: s,
      tracingEnabled: u,
      project_name: i
    });
  }
  static fromDottedOrder(e) {
    return this.fromHeaders({ "langsmith-trace": e });
  }
  static fromHeaders(e, n) {
    const a = "get" in e && typeof e.get == "function" ? {
      "langsmith-trace": e.get("langsmith-trace"),
      baggage: e.get("baggage")
    } : e, r = a["langsmith-trace"];
    if (!r || typeof r != "string")
      return;
    const i = r.trim(), s = i.split(".").map((f) => {
      const [o, c] = f.split("Z");
      return { strTime: o, time: Date.parse(o + "Z"), uuid: c };
    }), u = s[0].uuid, d = {
      ...n,
      name: n?.name ?? "parent",
      run_type: n?.run_type ?? "chain",
      start_time: n?.start_time ?? Date.now(),
      id: s.at(-1)?.uuid,
      trace_id: u,
      dotted_order: i
    };
    if (a.baggage && typeof a.baggage == "string") {
      const f = Sh.fromHeader(a.baggage);
      d.metadata = f.metadata, d.tags = f.tags;
    }
    return new _n(d);
  }
  toHeaders(e) {
    const n = {
      "langsmith-trace": this.dotted_order,
      baggage: new Sh(this.extra?.metadata, this.tags).toHeader()
    };
    if (e)
      for (const [a, r] of Object.entries(n))
        e.set(a, r);
    return n;
  }
}
Object.defineProperty(_n, "sharedClient", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: null
});
function LC(t) {
  return t !== void 0 && typeof t.createChild == "function" && typeof t.postRun == "function";
}
function UC(t) {
  return typeof t == "object" && t != null && typeof t.name == "string" && t.name === "langchain_tracer";
}
function tv(t) {
  return Array.isArray(t) && t.some((e) => UC(e));
}
function q1(t) {
  return typeof t == "object" && t != null && Array.isArray(t.handlers);
}
function J1(t) {
  return t !== void 0 && typeof t.callbacks == "object" && // Callback manager with a langchain tracer
  (tv(t.callbacks?.handlers) || // Or it's an array with a LangChainTracerLike object within it
  tv(t.callbacks));
}
let L1 = class {
  getStore() {
  }
  run(e, n) {
    return n();
  }
};
const pm = Symbol.for("ls:tracing_async_local_storage"), U1 = new L1();
let B1 = class {
  getInstance() {
    return globalThis[pm] ?? U1;
  }
  initializeGlobalInstance(e) {
    globalThis[pm] === void 0 && (globalThis[pm] = e);
  }
};
const x1 = new B1(), V1 = () => {
  const t = x1.getInstance().getStore();
  if (!LC(t))
    throw new Error([
      "Could not get the current run tree.",
      "",
      "Please make sure you are calling this method within a traceable function and that tracing is enabled."
    ].join(`
`));
  return t;
};
function Fg(t) {
  return typeof t == "function" && "langsmith:traceable" in t;
}
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
const z1 = Object.prototype.hasOwnProperty;
function Eb(t, e) {
  return z1.call(t, e);
}
function Ib(t) {
  if (Array.isArray(t)) {
    const n = new Array(t.length);
    for (let a = 0; a < n.length; a++)
      n[a] = "" + a;
    return n;
  }
  if (Object.keys)
    return Object.keys(t);
  let e = [];
  for (let n in t)
    Eb(t, n) && e.push(n);
  return e;
}
function ra(t) {
  switch (typeof t) {
    case "object":
      return JSON.parse(JSON.stringify(t));
    //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
    case "undefined":
      return null;
    //this is how JSON.stringify behaves for array items
    default:
      return t;
  }
}
function Nb(t) {
  let e = 0;
  const n = t.length;
  let a;
  for (; e < n; ) {
    if (a = t.charCodeAt(e), a >= 48 && a <= 57) {
      e++;
      continue;
    }
    return !1;
  }
  return !0;
}
function du(t) {
  return t.indexOf("/") === -1 && t.indexOf("~") === -1 ? t : t.replace(/~/g, "~0").replace(/\//g, "~1");
}
function Z1(t) {
  return t.replace(/~1/g, "/").replace(/~0/g, "~");
}
function Fb(t) {
  if (t === void 0)
    return !0;
  if (t) {
    if (Array.isArray(t)) {
      for (let n = 0, a = t.length; n < a; n++)
        if (Fb(t[n]))
          return !0;
    } else if (typeof t == "object") {
      const n = Ib(t), a = n.length;
      for (var e = 0; e < a; e++)
        if (Fb(t[n[e]]))
          return !0;
    }
  }
  return !1;
}
function nv(t, e) {
  const n = [t];
  for (const a in e) {
    const r = typeof e[a] == "object" ? JSON.stringify(e[a], null, 2) : e[a];
    typeof r < "u" && n.push(`${a}: ${r}`);
  }
  return n.join(`
`);
}
class K1 extends Error {
  constructor(e, n, a, r, i) {
    super(nv(e, { name: n, index: a, operation: r, tree: i })), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "index", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    }), Object.defineProperty(this, "operation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "tree", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.setPrototypeOf(this, new.target.prototype), this.message = nv(e, {
      name: n,
      index: a,
      operation: r,
      tree: i
    });
  }
}
const ct = K1, Au = {
  add: function(t, e, n) {
    return t[e] = this.value, { newDocument: n };
  },
  remove: function(t, e, n) {
    var a = t[e];
    return delete t[e], { newDocument: n, removed: a };
  },
  replace: function(t, e, n) {
    var a = t[e];
    return t[e] = this.value, { newDocument: n, removed: a };
  },
  move: function(t, e, n) {
    let a = kb(n, this.path);
    a && (a = ra(a));
    const r = ql(n, {
      op: "remove",
      path: this.from
    }).removed;
    return ql(n, {
      op: "add",
      path: this.path,
      value: r
    }), { newDocument: n, removed: a };
  },
  copy: function(t, e, n) {
    const a = kb(n, this.from);
    return ql(n, {
      op: "add",
      path: this.path,
      value: ra(a)
    }), { newDocument: n };
  },
  test: function(t, e, n) {
    return { newDocument: n, test: jh(t[e], this.value) };
  },
  _get: function(t, e, n) {
    return this.value = t[e], { newDocument: n };
  }
};
var H1 = {
  add: function(t, e, n) {
    return Nb(e) ? t.splice(e, 0, this.value) : t[e] = this.value, { newDocument: n, index: e };
  },
  remove: function(t, e, n) {
    var a = t.splice(e, 1);
    return { newDocument: n, removed: a[0] };
  },
  replace: function(t, e, n) {
    var a = t[e];
    return t[e] = this.value, { newDocument: n, removed: a };
  },
  move: Au.move,
  copy: Au.copy,
  test: Au.test,
  _get: Au._get
};
function kb(t, e) {
  if (e == "")
    return t;
  var n = { op: "_get", path: e };
  return ql(t, n), n.value;
}
function ql(t, e, n = !1, a = !0, r = !0, i = 0) {
  if (n && (typeof n == "function" ? n(e, 0, t, e.path) : Db(e, 0)), e.path === "") {
    let s = { newDocument: t };
    if (e.op === "add")
      return s.newDocument = e.value, s;
    if (e.op === "replace")
      return s.newDocument = e.value, s.removed = t, s;
    if (e.op === "move" || e.op === "copy")
      return s.newDocument = kb(t, e.from), e.op === "move" && (s.removed = t), s;
    if (e.op === "test") {
      if (s.test = jh(t, e.value), s.test === !1)
        throw new ct("Test operation failed", "TEST_OPERATION_FAILED", i, e, t);
      return s.newDocument = t, s;
    } else {
      if (e.op === "remove")
        return s.removed = t, s.newDocument = null, s;
      if (e.op === "_get")
        return e.value = t, s;
      if (n)
        throw new ct("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", i, e, t);
      return s;
    }
  } else {
    a || (t = ra(t));
    const u = (e.path || "").split("/");
    let d = t, f = 1, o = u.length, c, h, p;
    for (typeof n == "function" ? p = n : p = Db; ; ) {
      if (h = u[f], h && h.indexOf("~") != -1 && (h = Z1(h)), r && (h == "__proto__" || h == "prototype" && f > 0 && u[f - 1] == "constructor"))
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (n && c === void 0 && (d[h] === void 0 ? c = u.slice(0, f).join("/") : f == o - 1 && (c = e.path), c !== void 0 && p(e, 0, t, c)), f++, Array.isArray(d)) {
        if (h === "-")
          h = d.length;
        else {
          if (n && !Nb(h))
            throw new ct("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", i, e, t);
          Nb(h) && (h = ~~h);
        }
        if (f >= o) {
          if (n && e.op === "add" && h > d.length)
            throw new ct("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", i, e, t);
          const l = H1[e.op].call(e, d, h, t);
          if (l.test === !1)
            throw new ct("Test operation failed", "TEST_OPERATION_FAILED", i, e, t);
          return l;
        }
      } else if (f >= o) {
        const l = Au[e.op].call(e, d, h, t);
        if (l.test === !1)
          throw new ct("Test operation failed", "TEST_OPERATION_FAILED", i, e, t);
        return l;
      }
      if (d = d[h], n && f < o && (!d || typeof d != "object"))
        throw new ct("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", i, e, t);
    }
  }
}
function Oh(t, e, n, a = !0, r = !0) {
  if (n && !Array.isArray(e))
    throw new ct("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  a || (t = ra(t));
  const i = new Array(e.length);
  for (let s = 0, u = e.length; s < u; s++)
    i[s] = ql(t, e[s], n, !0, r, s), t = i[s].newDocument;
  return i.newDocument = t, i;
}
function Db(t, e, n, a) {
  if (typeof t != "object" || t === null || Array.isArray(t))
    throw new ct("Operation is not an object", "OPERATION_NOT_AN_OBJECT", e, t, n);
  if (Au[t.op]) {
    if (typeof t.path != "string")
      throw new ct("Operation `path` property is not a string", "OPERATION_PATH_INVALID", e, t, n);
    if (t.path.indexOf("/") !== 0 && t.path.length > 0)
      throw new ct('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", e, t, n);
    if ((t.op === "move" || t.op === "copy") && typeof t.from != "string")
      throw new ct("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", e, t, n);
    if ((t.op === "add" || t.op === "replace" || t.op === "test") && t.value === void 0)
      throw new ct("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", e, t, n);
    if ((t.op === "add" || t.op === "replace" || t.op === "test") && Fb(t.value))
      throw new ct("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", e, t, n);
    if (n) {
      if (t.op == "add") {
        var r = t.path.split("/").length, i = a.split("/").length;
        if (r !== i + 1 && r !== i)
          throw new ct("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", e, t, n);
      } else if (t.op === "replace" || t.op === "remove" || t.op === "_get") {
        if (t.path !== a)
          throw new ct("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", e, t, n);
      } else if (t.op === "move" || t.op === "copy") {
        var s = {
          op: "_get",
          path: t.from,
          value: void 0
        }, u = G1([s], n);
        if (u && u.name === "OPERATION_PATH_UNRESOLVABLE")
          throw new ct("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", e, t, n);
      }
    }
  } else throw new ct("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", e, t, n);
}
function G1(t, e, n) {
  try {
    if (!Array.isArray(t))
      throw new ct("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (e)
      Oh(ra(e), ra(t), n || !0);
    else {
      n = n || Db;
      for (var a = 0; a < t.length; a++)
        n(t[a], a, e, void 0);
    }
  } catch (r) {
    if (r instanceof ct)
      return r;
    throw r;
  }
}
function jh(t, e) {
  if (t === e)
    return !0;
  if (t && e && typeof t == "object" && typeof e == "object") {
    var n = Array.isArray(t), a = Array.isArray(e), r, i, s;
    if (n && a) {
      if (i = t.length, i != e.length)
        return !1;
      for (r = i; r-- !== 0; )
        if (!jh(t[r], e[r]))
          return !1;
      return !0;
    }
    if (n != a)
      return !1;
    var u = Object.keys(t);
    if (i = u.length, i !== Object.keys(e).length)
      return !1;
    for (r = i; r-- !== 0; )
      if (!e.hasOwnProperty(u[r]))
        return !1;
    for (r = i; r-- !== 0; )
      if (s = u[r], !jh(t[s], e[s]))
        return !1;
    return !0;
  }
  return t !== t && e !== e;
}
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2013-2021 Joachim Wester
 * MIT license
 */
function BC(t, e, n, a, r) {
  if (e !== t) {
    typeof e.toJSON == "function" && (e = e.toJSON());
    for (var i = Ib(e), s = Ib(t), u = !1, d = s.length - 1; d >= 0; d--) {
      var f = s[d], o = t[f];
      if (Eb(e, f) && !(e[f] === void 0 && o !== void 0 && Array.isArray(e) === !1)) {
        var c = e[f];
        typeof o == "object" && o != null && typeof c == "object" && c != null && Array.isArray(o) === Array.isArray(c) ? BC(o, c, n, a + "/" + du(f), r) : o !== c && (r && n.push({
          op: "test",
          path: a + "/" + du(f),
          value: ra(o)
        }), n.push({
          op: "replace",
          path: a + "/" + du(f),
          value: ra(c)
        }));
      } else Array.isArray(t) === Array.isArray(e) ? (r && n.push({
        op: "test",
        path: a + "/" + du(f),
        value: ra(o)
      }), n.push({
        op: "remove",
        path: a + "/" + du(f)
      }), u = !0) : (r && n.push({ op: "test", path: a, value: t }), n.push({ op: "replace", path: a, value: e }));
    }
    if (!(!u && i.length == s.length))
      for (var d = 0; d < i.length; d++) {
        var f = i[d];
        !Eb(t, f) && e[f] !== void 0 && n.push({
          op: "add",
          path: a + "/" + du(f),
          value: ra(e[f])
        });
      }
  }
}
function W1(t, e, n = !1) {
  var a = [];
  return BC(t, e, a, "", n), a;
}
var X1 = {};
const Q1 = () => typeof window < "u" && typeof window.document < "u", Y1 = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", eN = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), kg = () => typeof Deno < "u", tN = () => typeof pe < "u" && typeof X1 < "u" && !0 && !kg(), nN = () => {
  let t;
  return Q1() ? t = "browser" : tN() ? t = "node" : Y1() ? t = "webworker" : eN() ? t = "jsdom" : kg() ? t = "deno" : t = "other", t;
};
let mm;
async function rN() {
  return mm === void 0 && (mm = {
    library: "langchain-js",
    runtime: nN()
  }), mm;
}
function _t(t) {
  try {
    return typeof pe < "u" ? pe.env?.[t] : kg() ? Deno?.env.get(t) : void 0;
  } catch {
    return;
  }
}
class aN {
}
function xC(t) {
  return "lc_prefer_streaming" in t && t.lc_prefer_streaming;
}
class Qu extends aN {
  get lc_namespace() {
    return ["langchain_core", "callbacks", this.name];
  }
  get lc_secrets() {
  }
  get lc_attributes() {
  }
  get lc_aliases() {
  }
  get lc_serializable_keys() {
  }
  /**
   * The name of the serializable. Override to provide an alias or
   * to preserve the serialized module name in minified environments.
   *
   * Implemented as a static method to support loading logic.
   */
  static lc_name() {
    return this.name;
  }
  /**
   * The final serialized identifier for the module.
   */
  get lc_id() {
    return [
      ...this.lc_namespace,
      SC(this.constructor)
    ];
  }
  constructor(e) {
    super(), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "lc_kwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ignoreLLM", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "ignoreChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "ignoreAgent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "ignoreRetriever", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "ignoreCustomEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "raiseError", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "awaitHandlers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: _t("LANGCHAIN_CALLBACKS_BACKGROUND") === "false"
    }), this.lc_kwargs = e || {}, e && (this.ignoreLLM = e.ignoreLLM ?? this.ignoreLLM, this.ignoreChain = e.ignoreChain ?? this.ignoreChain, this.ignoreAgent = e.ignoreAgent ?? this.ignoreAgent, this.ignoreRetriever = e.ignoreRetriever ?? this.ignoreRetriever, this.ignoreCustomEvent = e.ignoreCustomEvent ?? this.ignoreCustomEvent, this.raiseError = e.raiseError ?? this.raiseError, this.awaitHandlers = this.raiseError || (e._awaitHandler ?? this.awaitHandlers));
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return pr.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return pr.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods(e) {
    class n extends Qu {
      constructor() {
        super(), Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: jt()
        }), Object.assign(this, e);
      }
    }
    return new n();
  }
}
const iN = (t) => {
  const e = t;
  return e !== void 0 && typeof e.copy == "function" && typeof e.name == "string" && typeof e.awaitHandlers == "boolean";
};
function bm(t, e) {
  return t && !Array.isArray(t) && typeof t == "object" ? t : { [e]: t };
}
function sN(t) {
  return t.replace(/[-:.]/g, "");
}
function oN(t, e, n) {
  const a = n.toFixed(0).slice(0, 3).padStart(3, "0");
  return sN(`${new Date(t).toISOString().slice(0, -1)}${a}Z`) + e;
}
function fc(t) {
  return typeof t._addRunToRunMap == "function";
}
class Id extends Qu {
  constructor(e) {
    super(...arguments), Object.defineProperty(this, "runMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
  }
  copy() {
    return this;
  }
  stringifyError(e) {
    return e instanceof Error ? e.message + (e?.stack ? `

${e.stack}` : "") : typeof e == "string" ? e : `${e}`;
  }
  _addChildRun(e, n) {
    e.child_runs.push(n);
  }
  _addRunToRunMap(e) {
    const n = oN(e.start_time, e.id, e.execution_order), a = { ...e };
    if (a.parent_run_id !== void 0) {
      const r = this.runMap.get(a.parent_run_id);
      r && (this._addChildRun(r, a), r.child_execution_order = Math.max(r.child_execution_order, a.child_execution_order), a.trace_id = r.trace_id, r.dotted_order !== void 0 && (a.dotted_order = [
        r.dotted_order,
        n
      ].join(".")));
    } else
      a.trace_id = a.id, a.dotted_order = n;
    return this.runMap.set(a.id, a), a;
  }
  async _endTrace(e) {
    const n = e.parent_run_id !== void 0 && this.runMap.get(e.parent_run_id);
    n ? n.child_execution_order = Math.max(n.child_execution_order, e.child_execution_order) : await this.persistRun(e), this.runMap.delete(e.id), await this.onRunUpdate?.(e);
  }
  _getExecutionOrder(e) {
    const n = e !== void 0 && this.runMap.get(e);
    return n ? n.child_execution_order + 1 : 1;
  }
  /**
   * Create and add a run to the run map for LLM start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForLLMStart(e, n, a, r, i, s, u, d) {
    const f = this._getExecutionOrder(r), o = Date.now(), c = u ? { ...i, metadata: u } : i, h = {
      id: a,
      name: d ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: o,
      serialized: e,
      events: [
        {
          name: "start",
          time: new Date(o).toISOString()
        }
      ],
      inputs: { prompts: n },
      execution_order: f,
      child_runs: [],
      child_execution_order: f,
      run_type: "llm",
      extra: c ?? {},
      tags: s || []
    };
    return this._addRunToRunMap(h);
  }
  async handleLLMStart(e, n, a, r, i, s, u, d) {
    const f = this.runMap.get(a) ?? this._createRunForLLMStart(e, n, a, r, i, s, u, d);
    return await this.onRunCreate?.(f), await this.onLLMStart?.(f), f;
  }
  /**
   * Create and add a run to the run map for chat model start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForChatModelStart(e, n, a, r, i, s, u, d) {
    const f = this._getExecutionOrder(r), o = Date.now(), c = u ? { ...i, metadata: u } : i, h = {
      id: a,
      name: d ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: o,
      serialized: e,
      events: [
        {
          name: "start",
          time: new Date(o).toISOString()
        }
      ],
      inputs: { messages: n },
      execution_order: f,
      child_runs: [],
      child_execution_order: f,
      run_type: "llm",
      extra: c ?? {},
      tags: s || []
    };
    return this._addRunToRunMap(h);
  }
  async handleChatModelStart(e, n, a, r, i, s, u, d) {
    const f = this.runMap.get(a) ?? this._createRunForChatModelStart(e, n, a, r, i, s, u, d);
    return await this.onRunCreate?.(f), await this.onLLMStart?.(f), f;
  }
  async handleLLMEnd(e, n, a, r, i) {
    const s = this.runMap.get(n);
    if (!s || s?.run_type !== "llm")
      throw new Error("No LLM run to end.");
    return s.end_time = Date.now(), s.outputs = e, s.events.push({
      name: "end",
      time: new Date(s.end_time).toISOString()
    }), s.extra = { ...s.extra, ...i }, await this.onLLMEnd?.(s), await this._endTrace(s), s;
  }
  async handleLLMError(e, n, a, r, i) {
    const s = this.runMap.get(n);
    if (!s || s?.run_type !== "llm")
      throw new Error("No LLM run to end.");
    return s.end_time = Date.now(), s.error = this.stringifyError(e), s.events.push({
      name: "error",
      time: new Date(s.end_time).toISOString()
    }), s.extra = { ...s.extra, ...i }, await this.onLLMError?.(s), await this._endTrace(s), s;
  }
  /**
   * Create and add a run to the run map for chain start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForChainStart(e, n, a, r, i, s, u, d) {
    const f = this._getExecutionOrder(r), o = Date.now(), c = {
      id: a,
      name: d ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: o,
      serialized: e,
      events: [
        {
          name: "start",
          time: new Date(o).toISOString()
        }
      ],
      inputs: n,
      execution_order: f,
      child_execution_order: f,
      run_type: u ?? "chain",
      child_runs: [],
      extra: s ? { metadata: s } : {},
      tags: i || []
    };
    return this._addRunToRunMap(c);
  }
  async handleChainStart(e, n, a, r, i, s, u, d) {
    const f = this.runMap.get(a) ?? this._createRunForChainStart(e, n, a, r, i, s, u, d);
    return await this.onRunCreate?.(f), await this.onChainStart?.(f), f;
  }
  async handleChainEnd(e, n, a, r, i) {
    const s = this.runMap.get(n);
    if (!s)
      throw new Error("No chain run to end.");
    return s.end_time = Date.now(), s.outputs = bm(e, "output"), s.events.push({
      name: "end",
      time: new Date(s.end_time).toISOString()
    }), i?.inputs !== void 0 && (s.inputs = bm(i.inputs, "input")), await this.onChainEnd?.(s), await this._endTrace(s), s;
  }
  async handleChainError(e, n, a, r, i) {
    const s = this.runMap.get(n);
    if (!s)
      throw new Error("No chain run to end.");
    return s.end_time = Date.now(), s.error = this.stringifyError(e), s.events.push({
      name: "error",
      time: new Date(s.end_time).toISOString()
    }), i?.inputs !== void 0 && (s.inputs = bm(i.inputs, "input")), await this.onChainError?.(s), await this._endTrace(s), s;
  }
  /**
   * Create and add a run to the run map for tool start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForToolStart(e, n, a, r, i, s, u) {
    const d = this._getExecutionOrder(r), f = Date.now(), o = {
      id: a,
      name: u ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: f,
      serialized: e,
      events: [
        {
          name: "start",
          time: new Date(f).toISOString()
        }
      ],
      inputs: { input: n },
      execution_order: d,
      child_execution_order: d,
      run_type: "tool",
      child_runs: [],
      extra: s ? { metadata: s } : {},
      tags: i || []
    };
    return this._addRunToRunMap(o);
  }
  async handleToolStart(e, n, a, r, i, s, u) {
    const d = this.runMap.get(a) ?? this._createRunForToolStart(e, n, a, r, i, s, u);
    return await this.onRunCreate?.(d), await this.onToolStart?.(d), d;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleToolEnd(e, n) {
    const a = this.runMap.get(n);
    if (!a || a?.run_type !== "tool")
      throw new Error("No tool run to end");
    return a.end_time = Date.now(), a.outputs = { output: e }, a.events.push({
      name: "end",
      time: new Date(a.end_time).toISOString()
    }), await this.onToolEnd?.(a), await this._endTrace(a), a;
  }
  async handleToolError(e, n) {
    const a = this.runMap.get(n);
    if (!a || a?.run_type !== "tool")
      throw new Error("No tool run to end");
    return a.end_time = Date.now(), a.error = this.stringifyError(e), a.events.push({
      name: "error",
      time: new Date(a.end_time).toISOString()
    }), await this.onToolError?.(a), await this._endTrace(a), a;
  }
  async handleAgentAction(e, n) {
    const a = this.runMap.get(n);
    if (!a || a?.run_type !== "chain")
      return;
    const r = a;
    r.actions = r.actions || [], r.actions.push(e), r.events.push({
      name: "agent_action",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action: e }
    }), await this.onAgentAction?.(a);
  }
  async handleAgentEnd(e, n) {
    const a = this.runMap.get(n);
    !a || a?.run_type !== "chain" || (a.events.push({
      name: "agent_end",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action: e }
    }), await this.onAgentEnd?.(a));
  }
  /**
   * Create and add a run to the run map for retriever start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForRetrieverStart(e, n, a, r, i, s, u) {
    const d = this._getExecutionOrder(r), f = Date.now(), o = {
      id: a,
      name: u ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: f,
      serialized: e,
      events: [
        {
          name: "start",
          time: new Date(f).toISOString()
        }
      ],
      inputs: { query: n },
      execution_order: d,
      child_execution_order: d,
      run_type: "retriever",
      child_runs: [],
      extra: s ? { metadata: s } : {},
      tags: i || []
    };
    return this._addRunToRunMap(o);
  }
  async handleRetrieverStart(e, n, a, r, i, s, u) {
    const d = this.runMap.get(a) ?? this._createRunForRetrieverStart(e, n, a, r, i, s, u);
    return await this.onRunCreate?.(d), await this.onRetrieverStart?.(d), d;
  }
  async handleRetrieverEnd(e, n) {
    const a = this.runMap.get(n);
    if (!a || a?.run_type !== "retriever")
      throw new Error("No retriever run to end");
    return a.end_time = Date.now(), a.outputs = { documents: e }, a.events.push({
      name: "end",
      time: new Date(a.end_time).toISOString()
    }), await this.onRetrieverEnd?.(a), await this._endTrace(a), a;
  }
  async handleRetrieverError(e, n) {
    const a = this.runMap.get(n);
    if (!a || a?.run_type !== "retriever")
      throw new Error("No retriever run to end");
    return a.end_time = Date.now(), a.error = this.stringifyError(e), a.events.push({
      name: "error",
      time: new Date(a.end_time).toISOString()
    }), await this.onRetrieverError?.(a), await this._endTrace(a), a;
  }
  async handleText(e, n) {
    const a = this.runMap.get(n);
    !a || a?.run_type !== "chain" || (a.events.push({
      name: "text",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { text: e }
    }), await this.onText?.(a));
  }
  async handleLLMNewToken(e, n, a, r, i, s) {
    const u = this.runMap.get(a);
    if (!u || u?.run_type !== "llm")
      throw new Error('Invalid "runId" provided to "handleLLMNewToken" callback.');
    return u.events.push({
      name: "new_token",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { token: e, idx: n, chunk: s?.chunk }
    }), await this.onLLMNewToken?.(u, e, { chunk: s?.chunk }), u;
  }
}
var gm = { exports: {} }, rv;
function uN() {
  return rv || (rv = 1, function(t) {
    const n = (i = 0) => (s) => `\x1B[${38 + i};5;${s}m`, a = (i = 0) => (s, u, d) => `\x1B[${38 + i};2;${s};${u};${d}m`;
    function r() {
      const i = /* @__PURE__ */ new Map(), s = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      s.color.gray = s.color.blackBright, s.bgColor.bgGray = s.bgColor.bgBlackBright, s.color.grey = s.color.blackBright, s.bgColor.bgGrey = s.bgColor.bgBlackBright;
      for (const [u, d] of Object.entries(s)) {
        for (const [f, o] of Object.entries(d))
          s[f] = {
            open: `\x1B[${o[0]}m`,
            close: `\x1B[${o[1]}m`
          }, d[f] = s[f], i.set(o[0], o[1]);
        Object.defineProperty(s, u, {
          value: d,
          enumerable: !1
        });
      }
      return Object.defineProperty(s, "codes", {
        value: i,
        enumerable: !1
      }), s.color.close = "\x1B[39m", s.bgColor.close = "\x1B[49m", s.color.ansi256 = n(), s.color.ansi16m = a(), s.bgColor.ansi256 = n(10), s.bgColor.ansi16m = a(10), Object.defineProperties(s, {
        rgbToAnsi256: {
          value: (u, d, f) => u === d && d === f ? u < 8 ? 16 : u > 248 ? 231 : Math.round((u - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(u / 255 * 5) + 6 * Math.round(d / 255 * 5) + Math.round(f / 255 * 5),
          enumerable: !1
        },
        hexToRgb: {
          value: (u) => {
            const d = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(u.toString(16));
            if (!d)
              return [0, 0, 0];
            let { colorString: f } = d.groups;
            f.length === 3 && (f = f.split("").map((c) => c + c).join(""));
            const o = Number.parseInt(f, 16);
            return [
              o >> 16 & 255,
              o >> 8 & 255,
              o & 255
            ];
          },
          enumerable: !1
        },
        hexToAnsi256: {
          value: (u) => s.rgbToAnsi256(...s.hexToRgb(u)),
          enumerable: !1
        }
      }), s;
    }
    Object.defineProperty(t, "exports", {
      enumerable: !0,
      get: r
    });
  }(gm)), gm.exports;
}
var cN = /* @__PURE__ */ uN();
const VC = /* @__PURE__ */ Rd(cN);
function Vt(t, e) {
  return `${t.open}${e}${t.close}`;
}
function Nn(t, e) {
  try {
    return JSON.stringify(t, null, 2);
  } catch {
    return e;
  }
}
function av(t) {
  return typeof t == "string" ? t.trim() : t == null ? t : Nn(t, t.toString());
}
function Gs(t) {
  if (!t.end_time)
    return "";
  const e = t.end_time - t.start_time;
  return e < 1e3 ? `${e}ms` : `${(e / 1e3).toFixed(2)}s`;
}
const { color: en } = VC;
class iv extends Id {
  constructor() {
    super(...arguments), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "console_callback_handler"
    });
  }
  /**
   * Method used to persist the run. In this case, it simply returns a
   * resolved promise as there's no persistence logic.
   * @param _run The run to persist.
   * @returns A resolved promise.
   */
  persistRun(e) {
    return Promise.resolve();
  }
  // utility methods
  /**
   * Method used to get all the parent runs of a given run.
   * @param run The run whose parents are to be retrieved.
   * @returns An array of parent runs.
   */
  getParents(e) {
    const n = [];
    let a = e;
    for (; a.parent_run_id; ) {
      const r = this.runMap.get(a.parent_run_id);
      if (r)
        n.push(r), a = r;
      else
        break;
    }
    return n;
  }
  /**
   * Method used to get a string representation of the run's lineage, which
   * is used in logging.
   * @param run The run whose lineage is to be retrieved.
   * @returns A string representation of the run's lineage.
   */
  getBreadcrumbs(e) {
    const a = [...this.getParents(e).reverse(), e].map((r, i, s) => {
      const u = `${r.execution_order}:${r.run_type}:${r.name}`;
      return i === s.length - 1 ? Vt(VC.bold, u) : u;
    }).join(" > ");
    return Vt(en.grey, a);
  }
  // logging methods
  /**
   * Method used to log the start of a chain run.
   * @param run The chain run that has started.
   * @returns void
   */
  onChainStart(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Vt(en.green, "[chain/start]")} [${n}] Entering Chain run with input: ${Nn(e.inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of a chain run.
   * @param run The chain run that has ended.
   * @returns void
   */
  onChainEnd(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Vt(en.cyan, "[chain/end]")} [${n}] [${Gs(e)}] Exiting Chain run with output: ${Nn(e.outputs, "[outputs]")}`);
  }
  /**
   * Method used to log any errors of a chain run.
   * @param run The chain run that has errored.
   * @returns void
   */
  onChainError(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Vt(en.red, "[chain/error]")} [${n}] [${Gs(e)}] Chain run errored with error: ${Nn(e.error, "[error]")}`);
  }
  /**
   * Method used to log the start of an LLM run.
   * @param run The LLM run that has started.
   * @returns void
   */
  onLLMStart(e) {
    const n = this.getBreadcrumbs(e), a = "prompts" in e.inputs ? { prompts: e.inputs.prompts.map((r) => r.trim()) } : e.inputs;
    console.log(`${Vt(en.green, "[llm/start]")} [${n}] Entering LLM run with input: ${Nn(a, "[inputs]")}`);
  }
  /**
   * Method used to log the end of an LLM run.
   * @param run The LLM run that has ended.
   * @returns void
   */
  onLLMEnd(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Vt(en.cyan, "[llm/end]")} [${n}] [${Gs(e)}] Exiting LLM run with output: ${Nn(e.outputs, "[response]")}`);
  }
  /**
   * Method used to log any errors of an LLM run.
   * @param run The LLM run that has errored.
   * @returns void
   */
  onLLMError(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Vt(en.red, "[llm/error]")} [${n}] [${Gs(e)}] LLM run errored with error: ${Nn(e.error, "[error]")}`);
  }
  /**
   * Method used to log the start of a tool run.
   * @param run The tool run that has started.
   * @returns void
   */
  onToolStart(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Vt(en.green, "[tool/start]")} [${n}] Entering Tool run with input: "${av(e.inputs.input)}"`);
  }
  /**
   * Method used to log the end of a tool run.
   * @param run The tool run that has ended.
   * @returns void
   */
  onToolEnd(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Vt(en.cyan, "[tool/end]")} [${n}] [${Gs(e)}] Exiting Tool run with output: "${av(e.outputs?.output)}"`);
  }
  /**
   * Method used to log any errors of a tool run.
   * @param run The tool run that has errored.
   * @returns void
   */
  onToolError(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Vt(en.red, "[tool/error]")} [${n}] [${Gs(e)}] Tool run errored with error: ${Nn(e.error, "[error]")}`);
  }
  /**
   * Method used to log the start of a retriever run.
   * @param run The retriever run that has started.
   * @returns void
   */
  onRetrieverStart(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Vt(en.green, "[retriever/start]")} [${n}] Entering Retriever run with input: ${Nn(e.inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of a retriever run.
   * @param run The retriever run that has ended.
   * @returns void
   */
  onRetrieverEnd(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Vt(en.cyan, "[retriever/end]")} [${n}] [${Gs(e)}] Exiting Retriever run with output: ${Nn(e.outputs, "[outputs]")}`);
  }
  /**
   * Method used to log any errors of a retriever run.
   * @param run The retriever run that has errored.
   * @returns void
   */
  onRetrieverError(e) {
    const n = this.getBreadcrumbs(e);
    console.log(`${Vt(en.red, "[retriever/error]")} [${n}] [${Gs(e)}] Retriever run errored with error: ${Nn(e.error, "[error]")}`);
  }
  /**
   * Method used to log the action selected by the agent.
   * @param run The run in which the agent action occurred.
   * @returns void
   */
  onAgentAction(e) {
    const n = e, a = this.getBreadcrumbs(e);
    console.log(`${Vt(en.blue, "[agent/action]")} [${a}] Agent selected action: ${Nn(n.actions[n.actions.length - 1], "[action]")}`);
  }
}
let _m;
const lN = () => {
  if (_m === void 0) {
    const t = _t("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? {
      // LangSmith has its own backgrounding system
      blockOnRootRunFinalization: !0
    } : {};
    _m = new dd(t);
  }
  return _m;
};
class Jl extends Id {
  constructor(e = {}) {
    super(e), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "langchain_tracer"
    }), Object.defineProperty(this, "projectName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "exampleId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { exampleId: n, projectName: a, client: r } = e;
    this.projectName = a ?? _t("LANGCHAIN_PROJECT") ?? _t("LANGCHAIN_SESSION"), this.exampleId = n, this.client = r ?? lN();
    const i = Jl.getTraceableRunTree();
    i && this.updateFromRunTree(i);
  }
  async _convertToCreate(e, n = void 0) {
    return {
      ...e,
      extra: {
        ...e.extra,
        runtime: await rN()
      },
      child_runs: void 0,
      session_name: this.projectName,
      reference_example_id: e.parent_run_id ? void 0 : n
    };
  }
  async persistRun(e) {
  }
  async onRunCreate(e) {
    const n = await this._convertToCreate(e, this.exampleId);
    await this.client.createRun(n);
  }
  async onRunUpdate(e) {
    const n = {
      end_time: e.end_time,
      error: e.error,
      outputs: e.outputs,
      events: e.events,
      inputs: e.inputs,
      trace_id: e.trace_id,
      dotted_order: e.dotted_order,
      parent_run_id: e.parent_run_id,
      extra: e.extra
    };
    await this.client.updateRun(e.id, n);
  }
  getRun(e) {
    return this.runMap.get(e);
  }
  updateFromRunTree(e) {
    let n = e;
    const a = /* @__PURE__ */ new Set();
    for (; n.parent_run && !(a.has(n.id) || (a.add(n.id), !n.parent_run)); )
      n = n.parent_run;
    a.clear();
    const r = [n];
    for (; r.length > 0; ) {
      const i = r.shift();
      !i || a.has(i.id) || (a.add(i.id), this.runMap.set(i.id, i), i.child_runs && r.push(...i.child_runs));
    }
    this.client = e.client ?? this.client, this.projectName = e.project_name ?? this.projectName, this.exampleId = e.reference_example_id ?? this.exampleId;
  }
  convertToRunTree(e) {
    const n = {}, a = [];
    for (const [r, i] of this.runMap) {
      const s = new _n({
        ...i,
        child_runs: [],
        parent_run: void 0,
        // inherited properties
        client: this.client,
        project_name: this.projectName,
        reference_example_id: this.exampleId,
        tracingEnabled: !0
      });
      n[r] = s, a.push([r, i.dotted_order]);
    }
    a.sort((r, i) => !r[1] || !i[1] ? 0 : r[1].localeCompare(i[1]));
    for (const [r] of a) {
      const i = this.runMap.get(r), s = n[r];
      if (!(!i || !s) && i.parent_run_id) {
        const u = n[i.parent_run_id];
        u && (u.child_runs.push(s), s.parent_run = u);
      }
    }
    return n[e];
  }
  static getTraceableRunTree() {
    try {
      return V1();
    } catch {
      return;
    }
  }
}
const zC = Symbol.for("ls:tracing_async_local_storage"), Qf = Symbol.for("lc:context_variables"), dN = (t) => {
  globalThis[zC] = t;
}, fd = () => globalThis[zC];
let Ll;
function fN() {
  const t = "default" in Js ? Js.default : Js;
  return new t({
    autoStart: !0,
    concurrency: 1
  });
}
function hN() {
  return typeof Ll > "u" && (Ll = fN()), Ll;
}
async function bt(t, e) {
  if (e === !0) {
    const n = fd();
    n !== void 0 ? await n.run(void 0, async () => t()) : await t();
  } else
    Ll = hN(), Ll.add(async () => {
      const n = fd();
      n !== void 0 ? await n.run(void 0, async () => t()) : await t();
    });
}
const pN = (t) => !![
  "LANGSMITH_TRACING_V2",
  "LANGCHAIN_TRACING_V2",
  "LANGSMITH_TRACING",
  "LANGCHAIN_TRACING"
].find((n) => _t(n) === "true");
function ZC(t) {
  const e = fd();
  return e === void 0 ? void 0 : e.getStore()?.[Qf]?.[t];
}
const mN = Symbol("lc:configure_hooks"), bN = () => ZC(mN) || [];
function cp(t) {
  return t ? Array.isArray(t) || "name" in t ? { callbacks: t } : t : {};
}
class gN {
  setHandler(e) {
    return this.setHandlers([e]);
  }
}
class lp {
  constructor(e, n, a, r, i, s, u, d) {
    Object.defineProperty(this, "runId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "handlers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "inheritableHandlers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "inheritableTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "inheritableMetadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: u
    }), Object.defineProperty(this, "_parentRunId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: d
    });
  }
  get parentRunId() {
    return this._parentRunId;
  }
  async handleText(e) {
    await Promise.all(this.handlers.map((n) => bt(async () => {
      try {
        await n.handleText?.(e, this.runId, this._parentRunId, this.tags);
      } catch (a) {
        if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleText: ${a}`), n.raiseError)
          throw a;
      }
    }, n.awaitHandlers)));
  }
  async handleCustomEvent(e, n, a, r, i) {
    await Promise.all(this.handlers.map((s) => bt(async () => {
      try {
        await s.handleCustomEvent?.(e, n, this.runId, this.tags, this.metadata);
      } catch (u) {
        if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleCustomEvent: ${u}`), s.raiseError)
          throw u;
      }
    }, s.awaitHandlers)));
  }
}
class _N extends lp {
  getChild(e) {
    const n = new it(this.runId);
    return n.setHandlers(this.inheritableHandlers), n.addTags(this.inheritableTags), n.addMetadata(this.inheritableMetadata), e && n.addTags([e], !1), n;
  }
  async handleRetrieverEnd(e) {
    await Promise.all(this.handlers.map((n) => bt(async () => {
      if (!n.ignoreRetriever)
        try {
          await n.handleRetrieverEnd?.(e, this.runId, this._parentRunId, this.tags);
        } catch (a) {
          if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleRetriever`), n.raiseError)
            throw a;
        }
    }, n.awaitHandlers)));
  }
  async handleRetrieverError(e) {
    await Promise.all(this.handlers.map((n) => bt(async () => {
      if (!n.ignoreRetriever)
        try {
          await n.handleRetrieverError?.(e, this.runId, this._parentRunId, this.tags);
        } catch (a) {
          if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleRetrieverError: ${a}`), n.raiseError)
            throw e;
        }
    }, n.awaitHandlers)));
  }
}
class sv extends lp {
  async handleLLMNewToken(e, n, a, r, i, s) {
    await Promise.all(this.handlers.map((u) => bt(async () => {
      if (!u.ignoreLLM)
        try {
          await u.handleLLMNewToken?.(e, n ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, s);
        } catch (d) {
          if ((u.raiseError ? console.error : console.warn)(`Error in handler ${u.constructor.name}, handleLLMNewToken: ${d}`), u.raiseError)
            throw d;
        }
    }, u.awaitHandlers)));
  }
  async handleLLMError(e, n, a, r, i) {
    await Promise.all(this.handlers.map((s) => bt(async () => {
      if (!s.ignoreLLM)
        try {
          await s.handleLLMError?.(e, this.runId, this._parentRunId, this.tags, i);
        } catch (u) {
          if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleLLMError: ${u}`), s.raiseError)
            throw u;
        }
    }, s.awaitHandlers)));
  }
  async handleLLMEnd(e, n, a, r, i) {
    await Promise.all(this.handlers.map((s) => bt(async () => {
      if (!s.ignoreLLM)
        try {
          await s.handleLLMEnd?.(e, this.runId, this._parentRunId, this.tags, i);
        } catch (u) {
          if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleLLMEnd: ${u}`), s.raiseError)
            throw u;
        }
    }, s.awaitHandlers)));
  }
}
class yN extends lp {
  getChild(e) {
    const n = new it(this.runId);
    return n.setHandlers(this.inheritableHandlers), n.addTags(this.inheritableTags), n.addMetadata(this.inheritableMetadata), e && n.addTags([e], !1), n;
  }
  async handleChainError(e, n, a, r, i) {
    await Promise.all(this.handlers.map((s) => bt(async () => {
      if (!s.ignoreChain)
        try {
          await s.handleChainError?.(e, this.runId, this._parentRunId, this.tags, i);
        } catch (u) {
          if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleChainError: ${u}`), s.raiseError)
            throw u;
        }
    }, s.awaitHandlers)));
  }
  async handleChainEnd(e, n, a, r, i) {
    await Promise.all(this.handlers.map((s) => bt(async () => {
      if (!s.ignoreChain)
        try {
          await s.handleChainEnd?.(e, this.runId, this._parentRunId, this.tags, i);
        } catch (u) {
          if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleChainEnd: ${u}`), s.raiseError)
            throw u;
        }
    }, s.awaitHandlers)));
  }
  async handleAgentAction(e) {
    await Promise.all(this.handlers.map((n) => bt(async () => {
      if (!n.ignoreAgent)
        try {
          await n.handleAgentAction?.(e, this.runId, this._parentRunId, this.tags);
        } catch (a) {
          if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleAgentAction: ${a}`), n.raiseError)
            throw a;
        }
    }, n.awaitHandlers)));
  }
  async handleAgentEnd(e) {
    await Promise.all(this.handlers.map((n) => bt(async () => {
      if (!n.ignoreAgent)
        try {
          await n.handleAgentEnd?.(e, this.runId, this._parentRunId, this.tags);
        } catch (a) {
          if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleAgentEnd: ${a}`), n.raiseError)
            throw a;
        }
    }, n.awaitHandlers)));
  }
}
class vN extends lp {
  getChild(e) {
    const n = new it(this.runId);
    return n.setHandlers(this.inheritableHandlers), n.addTags(this.inheritableTags), n.addMetadata(this.inheritableMetadata), e && n.addTags([e], !1), n;
  }
  async handleToolError(e) {
    await Promise.all(this.handlers.map((n) => bt(async () => {
      if (!n.ignoreAgent)
        try {
          await n.handleToolError?.(e, this.runId, this._parentRunId, this.tags);
        } catch (a) {
          if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleToolError: ${a}`), n.raiseError)
            throw a;
        }
    }, n.awaitHandlers)));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleToolEnd(e) {
    await Promise.all(this.handlers.map((n) => bt(async () => {
      if (!n.ignoreAgent)
        try {
          await n.handleToolEnd?.(e, this.runId, this._parentRunId, this.tags);
        } catch (a) {
          if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleToolEnd: ${a}`), n.raiseError)
            throw a;
        }
    }, n.awaitHandlers)));
  }
}
class it extends gN {
  constructor(e, n) {
    super(), Object.defineProperty(this, "handlers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "inheritableHandlers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "inheritableTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "inheritableMetadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "callback_manager"
    }), Object.defineProperty(this, "_parentRunId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.handlers = n?.handlers ?? this.handlers, this.inheritableHandlers = n?.inheritableHandlers ?? this.inheritableHandlers, this.tags = n?.tags ?? this.tags, this.inheritableTags = n?.inheritableTags ?? this.inheritableTags, this.metadata = n?.metadata ?? this.metadata, this.inheritableMetadata = n?.inheritableMetadata ?? this.inheritableMetadata, this._parentRunId = e;
  }
  /**
   * Gets the parent run ID, if any.
   *
   * @returns The parent run ID.
   */
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(e, n, a = void 0, r = void 0, i = void 0, s = void 0, u = void 0, d = void 0) {
    return Promise.all(n.map(async (f, o) => {
      const c = o === 0 && a ? a : jt();
      return await Promise.all(this.handlers.map((h) => {
        if (!h.ignoreLLM)
          return fc(h) && h._createRunForLLMStart(e, [f], c, this._parentRunId, i, this.tags, this.metadata, d), bt(async () => {
            try {
              await h.handleLLMStart?.(e, [f], c, this._parentRunId, i, this.tags, this.metadata, d);
            } catch (p) {
              if ((h.raiseError ? console.error : console.warn)(`Error in handler ${h.constructor.name}, handleLLMStart: ${p}`), h.raiseError)
                throw p;
            }
          }, h.awaitHandlers);
      })), new sv(c, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(e, n, a = void 0, r = void 0, i = void 0, s = void 0, u = void 0, d = void 0) {
    return Promise.all(n.map(async (f, o) => {
      const c = o === 0 && a ? a : jt();
      return await Promise.all(this.handlers.map((h) => {
        if (!h.ignoreLLM)
          return fc(h) && h._createRunForChatModelStart(e, [f], c, this._parentRunId, i, this.tags, this.metadata, d), bt(async () => {
            try {
              if (h.handleChatModelStart)
                await h.handleChatModelStart?.(e, [f], c, this._parentRunId, i, this.tags, this.metadata, d);
              else if (h.handleLLMStart) {
                const p = so(f);
                await h.handleLLMStart?.(e, [p], c, this._parentRunId, i, this.tags, this.metadata, d);
              }
            } catch (p) {
              if ((h.raiseError ? console.error : console.warn)(`Error in handler ${h.constructor.name}, handleLLMStart: ${p}`), h.raiseError)
                throw p;
            }
          }, h.awaitHandlers);
      })), new sv(c, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(e, n, a = jt(), r = void 0, i = void 0, s = void 0, u = void 0) {
    return await Promise.all(this.handlers.map((d) => {
      if (!d.ignoreChain)
        return fc(d) && d._createRunForChainStart(e, n, a, this._parentRunId, this.tags, this.metadata, r, u), bt(async () => {
          try {
            await d.handleChainStart?.(e, n, a, this._parentRunId, this.tags, this.metadata, r, u);
          } catch (f) {
            if ((d.raiseError ? console.error : console.warn)(`Error in handler ${d.constructor.name}, handleChainStart: ${f}`), d.raiseError)
              throw f;
          }
        }, d.awaitHandlers);
    })), new yN(a, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(e, n, a = jt(), r = void 0, i = void 0, s = void 0, u = void 0) {
    return await Promise.all(this.handlers.map((d) => {
      if (!d.ignoreAgent)
        return fc(d) && d._createRunForToolStart(e, n, a, this._parentRunId, this.tags, this.metadata, u), bt(async () => {
          try {
            await d.handleToolStart?.(e, n, a, this._parentRunId, this.tags, this.metadata, u);
          } catch (f) {
            if ((d.raiseError ? console.error : console.warn)(`Error in handler ${d.constructor.name}, handleToolStart: ${f}`), d.raiseError)
              throw f;
          }
        }, d.awaitHandlers);
    })), new vN(a, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(e, n, a = jt(), r = void 0, i = void 0, s = void 0, u = void 0) {
    return await Promise.all(this.handlers.map((d) => {
      if (!d.ignoreRetriever)
        return fc(d) && d._createRunForRetrieverStart(e, n, a, this._parentRunId, this.tags, this.metadata, u), bt(async () => {
          try {
            await d.handleRetrieverStart?.(e, n, a, this._parentRunId, this.tags, this.metadata, u);
          } catch (f) {
            if ((d.raiseError ? console.error : console.warn)(`Error in handler ${d.constructor.name}, handleRetrieverStart: ${f}`), d.raiseError)
              throw f;
          }
        }, d.awaitHandlers);
    })), new _N(a, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleCustomEvent(e, n, a, r, i) {
    await Promise.all(this.handlers.map((s) => bt(async () => {
      if (!s.ignoreCustomEvent)
        try {
          await s.handleCustomEvent?.(e, n, a, this.tags, this.metadata);
        } catch (u) {
          if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleCustomEvent: ${u}`), s.raiseError)
            throw u;
        }
    }, s.awaitHandlers)));
  }
  addHandler(e, n = !0) {
    this.handlers.push(e), n && this.inheritableHandlers.push(e);
  }
  removeHandler(e) {
    this.handlers = this.handlers.filter((n) => n !== e), this.inheritableHandlers = this.inheritableHandlers.filter((n) => n !== e);
  }
  setHandlers(e, n = !0) {
    this.handlers = [], this.inheritableHandlers = [];
    for (const a of e)
      this.addHandler(a, n);
  }
  addTags(e, n = !0) {
    this.removeTags(e), this.tags.push(...e), n && this.inheritableTags.push(...e);
  }
  removeTags(e) {
    this.tags = this.tags.filter((n) => !e.includes(n)), this.inheritableTags = this.inheritableTags.filter((n) => !e.includes(n));
  }
  addMetadata(e, n = !0) {
    this.metadata = { ...this.metadata, ...e }, n && (this.inheritableMetadata = { ...this.inheritableMetadata, ...e });
  }
  removeMetadata(e) {
    for (const n of Object.keys(e))
      delete this.metadata[n], delete this.inheritableMetadata[n];
  }
  copy(e = [], n = !0) {
    const a = new it(this._parentRunId);
    for (const r of this.handlers) {
      const i = this.inheritableHandlers.includes(r);
      a.addHandler(r, i);
    }
    for (const r of this.tags) {
      const i = this.inheritableTags.includes(r);
      a.addTags([r], i);
    }
    for (const r of Object.keys(this.metadata)) {
      const i = Object.keys(this.inheritableMetadata).includes(r);
      a.addMetadata({ [r]: this.metadata[r] }, i);
    }
    for (const r of e)
      // Prevent multiple copies of console_callback_handler
      a.handlers.filter((i) => i.name === "console_callback_handler").some((i) => i.name === r.name) || a.addHandler(r, n);
    return a;
  }
  static fromHandlers(e) {
    class n extends Qu {
      constructor() {
        super(), Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: jt()
        }), Object.assign(this, e);
      }
    }
    const a = new this();
    return a.addHandler(new n()), a;
  }
  static configure(e, n, a, r, i, s, u) {
    return this._configureSync(e, n, a, r, i, s, u);
  }
  // TODO: Deprecate async method in favor of this one.
  static _configureSync(e, n, a, r, i, s, u) {
    let d;
    (e || n) && (Array.isArray(e) || !e ? (d = new it(), d.setHandlers(e?.map(Ph) ?? [], !0)) : d = e, d = d.copy(Array.isArray(n) ? n.map(Ph) : n?.handlers, !1));
    const f = _t("LANGCHAIN_VERBOSE") === "true" || u?.verbose, o = Jl.getTraceableRunTree()?.tracingEnabled || pN(), c = o || (_t("LANGCHAIN_TRACING") ?? !1);
    if (f || c) {
      if (d || (d = new it()), f && !d.handlers.some((h) => h.name === iv.prototype.name)) {
        const h = new iv();
        d.addHandler(h, !0);
      }
      if (c && !d.handlers.some((h) => h.name === "langchain_tracer") && o) {
        const h = new Jl();
        d.addHandler(h, !0), d._parentRunId = Jl.getTraceableRunTree()?.id ?? d._parentRunId;
      }
    }
    for (const { contextVar: h, inheritable: p = !0, handlerClass: l, envVar: m } of bN()) {
      const b = m && _t(m) === "true" && l;
      let g;
      const _ = h !== void 0 ? ZC(h) : void 0;
      _ && iN(_) ? g = _ : b && (g = new l({})), g !== void 0 && (d || (d = new it()), d.handlers.some((P) => P.name === g.name) || d.addHandler(g, p));
    }
    return (a || r) && d && (d.addTags(a ?? []), d.addTags(r ?? [], !1)), (i || s) && d && (d.addMetadata(i ?? {}), d.addMetadata(s ?? {}, !1)), d;
  }
}
function Ph(t) {
  return "name" in t ? t : Qu.fromMethods(t);
}
class wN {
  getStore() {
  }
  run(e, n) {
    return n();
  }
  enterWith(e) {
  }
}
const SN = new wN(), ov = Symbol.for("lc:child_config");
class ON {
  getInstance() {
    return fd() ?? SN;
  }
  getRunnableConfig() {
    return this.getInstance().getStore()?.extra?.[ov];
  }
  runWithConfig(e, n, a) {
    const r = it._configureSync(e?.callbacks, void 0, e?.tags, void 0, e?.metadata), i = this.getInstance(), s = i.getStore(), u = r?.getParentRunId(), d = r?.handlers?.find((o) => o?.name === "langchain_tracer");
    let f;
    return d && u ? f = d.convertToRunTree(u) : a || (f = new _n({
      name: "<runnable_lambda>",
      tracingEnabled: !1
    })), f && (f.extra = { ...f.extra, [ov]: e }), s !== void 0 && s[Qf] !== void 0 && (f === void 0 && (f = {}), f[Qf] = s[Qf]), i.run(f, n);
  }
  initializeGlobalInstance(e) {
    fd() === void 0 && dN(e);
  }
}
const Ln = new ON(), ym = 25;
async function Un(t) {
  return it._configureSync(t?.callbacks, void 0, t?.tags, void 0, t?.metadata);
}
function aa(...t) {
  const e = {};
  for (const n of t.filter((a) => !!a))
    for (const a of Object.keys(n))
      if (a === "metadata")
        e[a] = { ...e[a], ...n[a] };
      else if (a === "tags") {
        const r = e[a] ?? [];
        e[a] = [...new Set(r.concat(n[a] ?? []))];
      } else if (a === "configurable")
        e[a] = { ...e[a], ...n[a] };
      else if (a === "timeout")
        e.timeout === void 0 ? e.timeout = n.timeout : n.timeout !== void 0 && (e.timeout = Math.min(e.timeout, n.timeout));
      else if (a === "signal")
        e.signal === void 0 ? e.signal = n.signal : n.signal !== void 0 && ("any" in AbortSignal ? e.signal = AbortSignal.any([
          e.signal,
          n.signal
        ]) : e.signal = n.signal);
      else if (a === "callbacks") {
        const r = e.callbacks, i = n.callbacks;
        if (Array.isArray(i))
          if (!r)
            e.callbacks = i;
          else if (Array.isArray(r))
            e.callbacks = r.concat(i);
          else {
            const s = r.copy();
            for (const u of i)
              s.addHandler(Ph(u), !0);
            e.callbacks = s;
          }
        else if (i)
          if (!r)
            e.callbacks = i;
          else if (Array.isArray(r)) {
            const s = i.copy();
            for (const u of r)
              s.addHandler(Ph(u), !0);
            e.callbacks = s;
          } else
            e.callbacks = new it(i._parentRunId, {
              handlers: r.handlers.concat(i.handlers),
              inheritableHandlers: r.inheritableHandlers.concat(i.inheritableHandlers),
              tags: Array.from(new Set(r.tags.concat(i.tags))),
              inheritableTags: Array.from(new Set(r.inheritableTags.concat(i.inheritableTags))),
              metadata: {
                ...r.metadata,
                ...i.metadata
              }
            });
      } else {
        const r = a;
        e[r] = n[r] ?? e[r];
      }
  return e;
}
const jN = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
function Ce(t) {
  const e = Ln.getRunnableConfig();
  let n = {
    tags: [],
    metadata: {},
    recursionLimit: 25,
    runId: void 0
  };
  if (e) {
    const { runId: a, runName: r, ...i } = e;
    n = Object.entries(i).reduce(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (s, [u, d]) => (d !== void 0 && (s[u] = d), s),
      n
    );
  }
  if (t && (n = Object.entries(t).reduce(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (a, [r, i]) => (i !== void 0 && (a[r] = i), a),
    n
  )), n?.configurable)
    for (const a of Object.keys(n.configurable))
      jN.has(typeof n.configurable[a]) && !n.metadata?.[a] && (n.metadata || (n.metadata = {}), n.metadata[a] = n.configurable[a]);
  if (n.timeout !== void 0) {
    if (n.timeout <= 0)
      throw new Error("Timeout must be a positive number");
    const a = AbortSignal.timeout(n.timeout);
    n.signal !== void 0 ? "any" in AbortSignal && (n.signal = AbortSignal.any([n.signal, a])) : n.signal = a, delete n.timeout;
  }
  return n;
}
function Qe(t = {}, { callbacks: e, maxConcurrency: n, recursionLimit: a, runName: r, configurable: i, runId: s } = {}) {
  const u = Ce(t);
  return e !== void 0 && (delete u.runName, u.callbacks = e), a !== void 0 && (u.recursionLimit = a), n !== void 0 && (u.maxConcurrency = n), r !== void 0 && (u.runName = r), i !== void 0 && (u.configurable = { ...u.configurable, ...i }), s !== void 0 && delete u.runId, u;
}
function Vu(t) {
  return t ? {
    configurable: t.configurable,
    recursionLimit: t.recursionLimit,
    callbacks: t.callbacks,
    tags: t.tags,
    metadata: t.metadata,
    maxConcurrency: t.maxConcurrency,
    timeout: t.timeout,
    signal: t.signal
  } : void 0;
}
async function po(t, e) {
  if (e === void 0)
    return t;
  let n;
  return Promise.race([
    t.catch((a) => {
      if (!e?.aborted)
        throw a;
    }),
    new Promise((a, r) => {
      n = () => {
        r(new Error("Aborted"));
      }, e.addEventListener("abort", n), e.aborted && r(new Error("Aborted"));
    })
  ]).finally(() => e.removeEventListener("abort", n));
}
class un extends ReadableStream {
  constructor() {
    super(...arguments), Object.defineProperty(this, "reader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  ensureReader() {
    this.reader || (this.reader = this.getReader());
  }
  async next() {
    this.ensureReader();
    try {
      const e = await this.reader.read();
      return e.done ? (this.reader.releaseLock(), {
        done: !0,
        value: void 0
      }) : {
        done: !1,
        value: e.value
      };
    } catch (e) {
      throw this.reader.releaseLock(), e;
    }
  }
  async return() {
    if (this.ensureReader(), this.locked) {
      const e = this.reader.cancel();
      this.reader.releaseLock(), await e;
    }
    return { done: !0, value: void 0 };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async throw(e) {
    if (this.ensureReader(), this.locked) {
      const n = this.reader.cancel();
      this.reader.releaseLock(), await n;
    }
    throw e;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore Not present in Node 18 types, required in latest Node 22
  async [Symbol.asyncDispose]() {
    await this.return();
  }
  static fromReadableStream(e) {
    const n = e.getReader();
    return new un({
      start(a) {
        return r();
        function r() {
          return n.read().then(({ done: i, value: s }) => {
            if (i) {
              a.close();
              return;
            }
            return a.enqueue(s), r();
          });
        }
      },
      cancel() {
        n.releaseLock();
      }
    });
  }
  static fromAsyncGenerator(e) {
    return new un({
      async pull(n) {
        const { value: a, done: r } = await e.next();
        r && n.close(), n.enqueue(a);
      },
      async cancel(n) {
        await e.return(n);
      }
    });
  }
}
function KC(t, e = 2) {
  const n = Array.from({ length: e }, () => []);
  return n.map(async function* (r) {
    for (; ; )
      if (r.length === 0) {
        const i = await t.next();
        for (const s of n)
          s.push(i);
      } else {
        if (r[0].done)
          return;
        yield r.shift().value;
      }
  });
}
function an(t, e) {
  if (Array.isArray(t) && Array.isArray(e))
    return t.concat(e);
  if (typeof t == "string" && typeof e == "string")
    return t + e;
  if (typeof t == "number" && typeof e == "number")
    return t + e;
  if (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    "concat" in t && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof t.concat == "function"
  )
    return t.concat(e);
  if (typeof t == "object" && typeof e == "object") {
    const n = { ...t };
    for (const [a, r] of Object.entries(e))
      a in n && !Array.isArray(n[a]) ? n[a] = an(n[a], r) : n[a] = r;
    return n;
  } else
    throw new Error(`Cannot concat ${typeof t} and ${typeof e}`);
}
class Yu {
  constructor(e) {
    Object.defineProperty(this, "generator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "setup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "firstResult", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "firstResultUsed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.generator = e.generator, this.config = e.config, this.signal = e.signal ?? this.config?.signal, this.setup = new Promise((n, a) => {
      Ln.runWithConfig(Vu(e.config), async () => {
        this.firstResult = e.generator.next(), e.startSetup ? this.firstResult.then(e.startSetup).then(n, a) : this.firstResult.then((r) => n(void 0), a);
      }, !0);
    });
  }
  async next(...e) {
    return this.signal?.throwIfAborted(), this.firstResultUsed ? Ln.runWithConfig(Vu(this.config), this.signal ? async () => po(this.generator.next(...e), this.signal) : async () => this.generator.next(...e), !0) : (this.firstResultUsed = !0, this.firstResult);
  }
  async return(e) {
    return this.generator.return(e);
  }
  async throw(e) {
    return this.generator.throw(e);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore Not present in Node 18 types, required in latest Node 22
  async [Symbol.asyncDispose]() {
    await this.return();
  }
}
async function PN(t, e, n, a, ...r) {
  const i = new Yu({
    generator: e,
    startSetup: n,
    signal: a
  }), s = await i.setup;
  return { output: t(i, s, ...r), setup: s };
}
class eo {
  constructor(e) {
    Object.defineProperty(this, "ops", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.ops = e.ops ?? [];
  }
  concat(e) {
    const n = this.ops.concat(e.ops), a = Oh({}, n);
    return new hd({
      ops: n,
      state: a[a.length - 1].newDocument
    });
  }
}
class hd extends eo {
  constructor(e) {
    super(e), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.state = e.state;
  }
  concat(e) {
    const n = this.ops.concat(e.ops), a = Oh(this.state, e.ops);
    return new hd({ ops: n, state: a[a.length - 1].newDocument });
  }
  static fromRunLogPatch(e) {
    const n = Oh({}, e.ops);
    return new hd({
      ops: e.ops,
      state: n[n.length - 1].newDocument
    });
  }
}
const CN = (t) => t.name === "log_stream_tracer";
async function uv(t, e) {
  if (e === "original")
    throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  const { inputs: n } = t;
  if (["retriever", "llm", "prompt"].includes(t.run_type))
    return n;
  if (!(Object.keys(n).length === 1 && n?.input === ""))
    return n.input;
}
async function cv(t, e) {
  const { outputs: n } = t;
  return e === "original" || ["retriever", "llm", "prompt"].includes(t.run_type) ? n : n !== void 0 && Object.keys(n).length === 1 && n?.output !== void 0 ? n.output : n;
}
function RN(t) {
  return t !== void 0 && t.message !== void 0;
}
class lv extends Id {
  constructor(e) {
    super({ _awaitHandler: !0, ...e }), Object.defineProperty(this, "autoClose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "includeNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "includeTypes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "includeTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeTypes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_schemaFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "original"
    }), Object.defineProperty(this, "rootId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "keyMapByRunId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "counterMapByRunName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "transformStream", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "writer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "receiveStream", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "log_stream_tracer"
    }), Object.defineProperty(this, "lc_prefer_streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.autoClose = e?.autoClose ?? !0, this.includeNames = e?.includeNames, this.includeTypes = e?.includeTypes, this.includeTags = e?.includeTags, this.excludeNames = e?.excludeNames, this.excludeTypes = e?.excludeTypes, this.excludeTags = e?.excludeTags, this._schemaFormat = e?._schemaFormat ?? this._schemaFormat, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = un.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(e) {
  }
  _includeRun(e) {
    if (e.id === this.rootId)
      return !1;
    const n = e.tags ?? [];
    let a = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    return this.includeNames !== void 0 && (a = a || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (a = a || this.includeTypes.includes(e.run_type)), this.includeTags !== void 0 && (a = a || n.find((r) => this.includeTags?.includes(r)) !== void 0), this.excludeNames !== void 0 && (a = a && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (a = a && !this.excludeTypes.includes(e.run_type)), this.excludeTags !== void 0 && (a = a && n.every((r) => !this.excludeTags?.includes(r))), a;
  }
  async *tapOutputIterable(e, n) {
    for await (const a of n) {
      if (e !== this.rootId) {
        const r = this.keyMapByRunId[e];
        r && await this.writer.write(new eo({
          ops: [
            {
              op: "add",
              path: `/logs/${r}/streamed_output/-`,
              value: a
            }
          ]
        }));
      }
      yield a;
    }
  }
  async onRunCreate(e) {
    if (this.rootId === void 0 && (this.rootId = e.id, await this.writer.write(new eo({
      ops: [
        {
          op: "replace",
          path: "",
          value: {
            id: e.id,
            name: e.name,
            type: e.run_type,
            streamed_output: [],
            final_output: void 0,
            logs: {}
          }
        }
      ]
    }))), !this._includeRun(e))
      return;
    this.counterMapByRunName[e.name] === void 0 && (this.counterMapByRunName[e.name] = 0), this.counterMapByRunName[e.name] += 1;
    const n = this.counterMapByRunName[e.name];
    this.keyMapByRunId[e.id] = n === 1 ? e.name : `${e.name}:${n}`;
    const a = {
      id: e.id,
      name: e.name,
      type: e.run_type,
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      start_time: new Date(e.start_time).toISOString(),
      streamed_output: [],
      streamed_output_str: [],
      final_output: void 0,
      end_time: void 0
    };
    this._schemaFormat === "streaming_events" && (a.inputs = await uv(e, this._schemaFormat)), await this.writer.write(new eo({
      ops: [
        {
          op: "add",
          path: `/logs/${this.keyMapByRunId[e.id]}`,
          value: a
        }
      ]
    }));
  }
  async onRunUpdate(e) {
    try {
      const n = this.keyMapByRunId[e.id];
      if (n === void 0)
        return;
      const a = [];
      this._schemaFormat === "streaming_events" && a.push({
        op: "replace",
        path: `/logs/${n}/inputs`,
        value: await uv(e, this._schemaFormat)
      }), a.push({
        op: "add",
        path: `/logs/${n}/final_output`,
        value: await cv(e, this._schemaFormat)
      }), e.end_time !== void 0 && a.push({
        op: "add",
        path: `/logs/${n}/end_time`,
        value: new Date(e.end_time).toISOString()
      });
      const r = new eo({ ops: a });
      await this.writer.write(r);
    } finally {
      if (e.id === this.rootId) {
        const n = new eo({
          ops: [
            {
              op: "replace",
              path: "/final_output",
              value: await cv(e, this._schemaFormat)
            }
          ]
        });
        await this.writer.write(n), this.autoClose && await this.writer.close();
      }
    }
  }
  async onLLMNewToken(e, n, a) {
    const r = this.keyMapByRunId[e.id];
    if (r === void 0)
      return;
    const i = e.inputs.messages !== void 0;
    let s;
    i ? RN(a?.chunk) ? s = a?.chunk : s = new We({
      id: `run-${e.id}`,
      content: n
    }) : s = n;
    const u = new eo({
      ops: [
        {
          op: "add",
          path: `/logs/${r}/streamed_output_str/-`,
          value: n
        },
        {
          op: "add",
          path: `/logs/${r}/streamed_output/-`,
          value: s
        }
      ]
    });
    await this.writer.write(u);
  }
}
const pd = "__run";
class fa {
  constructor(e) {
    Object.defineProperty(this, "text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "generationInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.text = e.text, this.generationInfo = e.generationInfo;
  }
  concat(e) {
    return new fa({
      text: this.text + e.text,
      generationInfo: {
        ...this.generationInfo,
        ...e.generationInfo
      }
    });
  }
}
class On extends fa {
  constructor(e) {
    super(e), Object.defineProperty(this, "message", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.message = e.message;
  }
  concat(e) {
    return new On({
      text: this.text + e.text,
      generationInfo: {
        ...this.generationInfo,
        ...e.generationInfo
      },
      message: this.message.concat(e.message)
    });
  }
}
function ff({ name: t, serialized: e }) {
  return t !== void 0 ? t : e?.name !== void 0 ? e.name : e?.id !== void 0 && Array.isArray(e?.id) ? e.id[e.id.length - 1] : "Unnamed";
}
const TN = (t) => t.name === "event_stream_tracer";
class $N extends Id {
  constructor(e) {
    super({ _awaitHandler: !0, ...e }), Object.defineProperty(this, "autoClose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "includeNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "includeTypes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "includeTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeTypes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "runInfoMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "tappedPromises", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "transformStream", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "writer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "receiveStream", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "event_stream_tracer"
    }), Object.defineProperty(this, "lc_prefer_streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.autoClose = e?.autoClose ?? !0, this.includeNames = e?.includeNames, this.includeTypes = e?.includeTypes, this.includeTags = e?.includeTags, this.excludeNames = e?.excludeNames, this.excludeTypes = e?.excludeTypes, this.excludeTags = e?.excludeTags, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = un.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(e) {
  }
  _includeRun(e) {
    const n = e.tags ?? [];
    let a = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    return this.includeNames !== void 0 && (a = a || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (a = a || this.includeTypes.includes(e.runType)), this.includeTags !== void 0 && (a = a || n.find((r) => this.includeTags?.includes(r)) !== void 0), this.excludeNames !== void 0 && (a = a && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (a = a && !this.excludeTypes.includes(e.runType)), this.excludeTags !== void 0 && (a = a && n.every((r) => !this.excludeTags?.includes(r))), a;
  }
  async *tapOutputIterable(e, n) {
    const a = await n.next();
    if (a.done)
      return;
    const r = this.runInfoMap.get(e);
    if (r === void 0) {
      yield a.value;
      return;
    }
    function i(u, d) {
      return u === "llm" && typeof d == "string" ? new fa({ text: d }) : d;
    }
    let s = this.tappedPromises.get(e);
    if (s === void 0) {
      let u;
      s = new Promise((d) => {
        u = d;
      }), this.tappedPromises.set(e, s);
      try {
        const d = {
          event: `on_${r.runType}_stream`,
          run_id: e,
          name: r.name,
          tags: r.tags,
          metadata: r.metadata,
          data: {}
        };
        await this.send({
          ...d,
          data: {
            chunk: i(r.runType, a.value)
          }
        }, r), yield a.value;
        for await (const f of n)
          r.runType !== "tool" && r.runType !== "retriever" && await this.send({
            ...d,
            data: {
              chunk: i(r.runType, f)
            }
          }, r), yield f;
      } finally {
        u();
      }
    } else {
      yield a.value;
      for await (const u of n)
        yield u;
    }
  }
  async send(e, n) {
    this._includeRun(n) && await this.writer.write(e);
  }
  async sendEndEvent(e, n) {
    const a = this.tappedPromises.get(e.run_id);
    a !== void 0 ? a.then(() => {
      this.send(e, n);
    }) : await this.send(e, n);
  }
  async onLLMStart(e) {
    const n = ff(e), a = e.inputs.messages !== void 0 ? "chat_model" : "llm", r = {
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      name: n,
      runType: a,
      inputs: e.inputs
    };
    this.runInfoMap.set(e.id, r);
    const i = `on_${a}_start`;
    await this.send({
      event: i,
      data: {
        input: e.inputs
      },
      name: n,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: e.extra?.metadata ?? {}
    }, r);
  }
  async onLLMNewToken(e, n, a) {
    const r = this.runInfoMap.get(e.id);
    let i, s;
    if (r === void 0)
      throw new Error(`onLLMNewToken: Run ID ${e.id} not found in run map.`);
    if (this.runInfoMap.size !== 1) {
      if (r.runType === "chat_model")
        s = "on_chat_model_stream", a?.chunk === void 0 ? i = new We({ content: n, id: `run-${e.id}` }) : i = a.chunk.message;
      else if (r.runType === "llm")
        s = "on_llm_stream", a?.chunk === void 0 ? i = new fa({ text: n }) : i = a.chunk;
      else
        throw new Error(`Unexpected run type ${r.runType}`);
      await this.send({
        event: s,
        data: {
          chunk: i
        },
        run_id: e.id,
        name: r.name,
        tags: r.tags,
        metadata: r.metadata
      }, r);
    }
  }
  async onLLMEnd(e) {
    const n = this.runInfoMap.get(e.id);
    this.runInfoMap.delete(e.id);
    let a;
    if (n === void 0)
      throw new Error(`onLLMEnd: Run ID ${e.id} not found in run map.`);
    const r = e.outputs?.generations;
    let i;
    if (n.runType === "chat_model") {
      for (const s of r ?? []) {
        if (i !== void 0)
          break;
        i = s[0]?.message;
      }
      a = "on_chat_model_end";
    } else if (n.runType === "llm")
      i = {
        generations: r?.map((s) => s.map((u) => ({
          text: u.text,
          generationInfo: u.generationInfo
        }))),
        llmOutput: e.outputs?.llmOutput ?? {}
      }, a = "on_llm_end";
    else
      throw new Error(`onLLMEnd: Unexpected run type: ${n.runType}`);
    await this.sendEndEvent({
      event: a,
      data: {
        output: i,
        input: n.inputs
      },
      run_id: e.id,
      name: n.name,
      tags: n.tags,
      metadata: n.metadata
    }, n);
  }
  async onChainStart(e) {
    const n = ff(e), a = e.run_type ?? "chain", r = {
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      name: n,
      runType: e.run_type
    };
    let i = {};
    e.inputs.input === "" && Object.keys(e.inputs).length === 1 ? (i = {}, r.inputs = {}) : e.inputs.input !== void 0 ? (i.input = e.inputs.input, r.inputs = e.inputs.input) : (i.input = e.inputs, r.inputs = e.inputs), this.runInfoMap.set(e.id, r), await this.send({
      event: `on_${a}_start`,
      data: i,
      name: n,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: e.extra?.metadata ?? {}
    }, r);
  }
  async onChainEnd(e) {
    const n = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), n === void 0)
      throw new Error(`onChainEnd: Run ID ${e.id} not found in run map.`);
    const a = `on_${e.run_type}_end`, r = e.inputs ?? n.inputs ?? {}, s = {
      output: e.outputs?.output ?? e.outputs,
      input: r
    };
    r.input && Object.keys(r).length === 1 && (s.input = r.input, n.inputs = r.input), await this.sendEndEvent({
      event: a,
      data: s,
      run_id: e.id,
      name: n.name,
      tags: n.tags,
      metadata: n.metadata ?? {}
    }, n);
  }
  async onToolStart(e) {
    const n = ff(e), a = {
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      name: n,
      runType: "tool",
      inputs: e.inputs ?? {}
    };
    this.runInfoMap.set(e.id, a), await this.send({
      event: "on_tool_start",
      data: {
        input: e.inputs ?? {}
      },
      name: n,
      run_id: e.id,
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {}
    }, a);
  }
  async onToolEnd(e) {
    const n = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), n === void 0)
      throw new Error(`onToolEnd: Run ID ${e.id} not found in run map.`);
    if (n.inputs === void 0)
      throw new Error(`onToolEnd: Run ID ${e.id} is a tool call, and is expected to have traced inputs.`);
    const a = e.outputs?.output === void 0 ? e.outputs : e.outputs.output;
    await this.sendEndEvent({
      event: "on_tool_end",
      data: {
        output: a,
        input: n.inputs
      },
      run_id: e.id,
      name: n.name,
      tags: n.tags,
      metadata: n.metadata
    }, n);
  }
  async onRetrieverStart(e) {
    const n = ff(e), r = {
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      name: n,
      runType: "retriever",
      inputs: {
        query: e.inputs.query
      }
    };
    this.runInfoMap.set(e.id, r), await this.send({
      event: "on_retriever_start",
      data: {
        input: {
          query: e.inputs.query
        }
      },
      name: n,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: e.extra?.metadata ?? {}
    }, r);
  }
  async onRetrieverEnd(e) {
    const n = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), n === void 0)
      throw new Error(`onRetrieverEnd: Run ID ${e.id} not found in run map.`);
    await this.sendEndEvent({
      event: "on_retriever_end",
      data: {
        output: e.outputs?.documents ?? e.outputs,
        input: n.inputs
      },
      run_id: e.id,
      name: n.name,
      tags: n.tags,
      metadata: n.metadata
    }, n);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleCustomEvent(e, n, a) {
    const r = this.runInfoMap.get(a);
    if (r === void 0)
      throw new Error(`handleCustomEvent: Run ID ${a} not found in run map.`);
    await this.send({
      event: "on_custom_event",
      run_id: a,
      name: e,
      tags: r.tags,
      metadata: r.metadata,
      data: n
    }, r);
  }
  async finish() {
    const e = [...this.tappedPromises.values()];
    Promise.all(e).finally(() => {
      this.writer.close();
    });
  }
}
const MN = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  409
  // Conflict
], AN = (t) => {
  if (t.message.startsWith("Cancel") || t.message.startsWith("AbortError") || t.name === "AbortError" || t?.code === "ECONNABORTED")
    throw t;
  const e = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    t?.response?.status ?? t?.status
  );
  if (e && MN.includes(+e))
    throw t;
  if (t?.error?.code === "insufficient_quota") {
    const n = new Error(t?.message);
    throw n.name = "InsufficientQuotaError", n;
  }
};
class Qo {
  constructor(e) {
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxRetries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onFailedAttempt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxConcurrency = e.maxConcurrency ?? 1 / 0, this.maxRetries = e.maxRetries ?? 6, this.onFailedAttempt = e.onFailedAttempt ?? AN;
    const n = "default" in Js ? Js.default : Js;
    this.queue = new n({ concurrency: this.maxConcurrency });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(e, ...n) {
    return this.queue.add(() => vh(() => e(...n).catch((a) => {
      throw a instanceof Error ? a : new Error(a);
    }), {
      onFailedAttempt: this.onFailedAttempt,
      retries: this.maxRetries,
      randomize: !0
      // If needed we can change some of the defaults here,
      // but they're quite sensible.
    }), { throwOnTimeout: !0 });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(e, n, ...a) {
    return e.signal ? Promise.race([
      this.call(n, ...a),
      new Promise((r, i) => {
        e.signal?.addEventListener("abort", () => {
          i(new Error("AbortError"));
        });
      })
    ]) : this.call(n, ...a);
  }
  fetch(...e) {
    return this.call(() => fetch(...e).then((n) => n.ok ? n : Promise.reject(n)));
  }
}
class HC extends Id {
  constructor({ config: e, onStart: n, onEnd: a, onError: r }) {
    super({ _awaitHandler: !0 }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RootListenersTracer"
    }), Object.defineProperty(this, "rootId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "argOnStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "argOnEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "argOnError", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.config = e, this.argOnStart = n, this.argOnEnd = a, this.argOnError = r;
  }
  /**
   * This is a legacy method only called once for an entire run tree
   * therefore not useful here
   * @param {Run} _ Not used
   */
  persistRun(e) {
    return Promise.resolve();
  }
  async onRunCreate(e) {
    this.rootId || (this.rootId = e.id, this.argOnStart && await this.argOnStart(e, this.config));
  }
  async onRunUpdate(e) {
    e.id === this.rootId && (e.error ? this.argOnError && await this.argOnError(e, this.config) : this.argOnEnd && await this.argOnEnd(e, this.config));
  }
}
function Dg(t) {
  return t ? t.lc_runnable : !1;
}
class EN {
  constructor(e) {
    Object.defineProperty(this, "includeNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "includeTypes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "includeTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeTypes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.includeNames = e.includeNames, this.includeTypes = e.includeTypes, this.includeTags = e.includeTags, this.excludeNames = e.excludeNames, this.excludeTypes = e.excludeTypes, this.excludeTags = e.excludeTags;
  }
  includeEvent(e, n) {
    let a = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
    const r = e.tags ?? [];
    return this.includeNames !== void 0 && (a = a || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (a = a || this.includeTypes.includes(n)), this.includeTags !== void 0 && (a = a || r.some((i) => this.includeTags?.includes(i))), this.excludeNames !== void 0 && (a = a && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (a = a && !this.excludeTypes.includes(n)), this.excludeTags !== void 0 && (a = a && r.every((i) => !this.excludeTags?.includes(i))), a;
  }
}
const IN = Symbol("Let zodToJsonSchema decide on which parser to use"), dv = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, NN = (t) => typeof t == "string" ? {
  ...dv,
  name: t
} : {
  ...dv,
  ...t
}, FN = (t) => {
  const e = NN(t), n = e.name !== void 0 ? [...e.basePath, e.definitionPath, e.name] : e.basePath;
  return {
    ...e,
    currentPath: n,
    propertyPath: void 0,
    seen: new Map(Object.entries(e.definitions).map(([a, r]) => [
      r._def,
      {
        def: r._def,
        path: [...e.basePath, e.definitionPath, a],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function GC(t, e, n, a) {
  a?.errorMessages && n && (t.errorMessage = {
    ...t.errorMessage,
    [e]: n
  });
}
function Ue(t, e, n, a, r) {
  t[e] = n, GC(t, e, a, r);
}
function kN() {
  return {};
}
function DN(t, e) {
  const n = {
    type: "array"
  };
  return t.type?._def && t.type?._def?.typeName !== K.ZodAny && (n.items = Ie(t.type._def, {
    ...e,
    currentPath: [...e.currentPath, "items"]
  })), t.minLength && Ue(n, "minItems", t.minLength.value, t.minLength.message, e), t.maxLength && Ue(n, "maxItems", t.maxLength.value, t.maxLength.message, e), t.exactLength && (Ue(n, "minItems", t.exactLength.value, t.exactLength.message, e), Ue(n, "maxItems", t.exactLength.value, t.exactLength.message, e)), n;
}
function qN(t, e) {
  const n = {
    type: "integer",
    format: "int64"
  };
  if (!t.checks)
    return n;
  for (const a of t.checks)
    switch (a.kind) {
      case "min":
        e.target === "jsonSchema7" ? a.inclusive ? Ue(n, "minimum", a.value, a.message, e) : Ue(n, "exclusiveMinimum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMinimum = !0), Ue(n, "minimum", a.value, a.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? a.inclusive ? Ue(n, "maximum", a.value, a.message, e) : Ue(n, "exclusiveMaximum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMaximum = !0), Ue(n, "maximum", a.value, a.message, e));
        break;
      case "multipleOf":
        Ue(n, "multipleOf", a.value, a.message, e);
        break;
    }
  return n;
}
function JN() {
  return {
    type: "boolean"
  };
}
function WC(t, e) {
  return Ie(t.type._def, e);
}
const LN = (t, e) => Ie(t.innerType._def, e);
function XC(t, e, n) {
  const a = n ?? e.dateStrategy;
  if (Array.isArray(a))
    return {
      anyOf: a.map((r, i) => XC(t, e, r))
    };
  switch (a) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return UN(t, e);
  }
}
const UN = (t, e) => {
  const n = {
    type: "integer",
    format: "unix-time"
  };
  if (e.target === "openApi3")
    return n;
  for (const a of t.checks)
    switch (a.kind) {
      case "min":
        Ue(
          n,
          "minimum",
          a.value,
          // This is in milliseconds
          a.message,
          e
        );
        break;
      case "max":
        Ue(
          n,
          "maximum",
          a.value,
          // This is in milliseconds
          a.message,
          e
        );
        break;
    }
  return n;
};
function BN(t, e) {
  return {
    ...Ie(t.innerType._def, e),
    default: t.defaultValue()
  };
}
function xN(t, e) {
  return e.effectStrategy === "input" ? Ie(t.schema._def, e) : {};
}
function VN(t) {
  return {
    type: "string",
    enum: Array.from(t.values)
  };
}
const zN = (t) => "type" in t && t.type === "string" ? !1 : "allOf" in t;
function ZN(t, e) {
  const n = [
    Ie(t.left._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "0"]
    }),
    Ie(t.right._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "1"]
    })
  ].filter((i) => !!i);
  let a = e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const r = [];
  return n.forEach((i) => {
    if (zN(i))
      r.push(...i.allOf), i.unevaluatedProperties === void 0 && (a = void 0);
    else {
      let s = i;
      if ("additionalProperties" in i && i.additionalProperties === !1) {
        const { additionalProperties: u, ...d } = i;
        s = d;
      } else
        a = void 0;
      r.push(s);
    }
  }), r.length ? {
    allOf: r,
    ...a
  } : void 0;
}
function KN(t, e) {
  const n = typeof t.value;
  return n !== "bigint" && n !== "number" && n !== "boolean" && n !== "string" ? {
    type: Array.isArray(t.value) ? "array" : "object"
  } : e.target === "openApi3" ? {
    type: n === "bigint" ? "integer" : n,
    enum: [t.value]
  } : {
    type: n === "bigint" ? "integer" : n,
    const: t.value
  };
}
let vm;
const Hn = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (vm === void 0 && (vm = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), vm),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function QC(t, e) {
  const n = {
    type: "string"
  };
  if (t.checks)
    for (const a of t.checks)
      switch (a.kind) {
        case "min":
          Ue(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, a.value) : a.value, a.message, e);
          break;
        case "max":
          Ue(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, a.value) : a.value, a.message, e);
          break;
        case "email":
          switch (e.emailStrategy) {
            case "format:email":
              Gn(n, "email", a.message, e);
              break;
            case "format:idn-email":
              Gn(n, "idn-email", a.message, e);
              break;
            case "pattern:zod":
              zt(n, Hn.email, a.message, e);
              break;
          }
          break;
        case "url":
          Gn(n, "uri", a.message, e);
          break;
        case "uuid":
          Gn(n, "uuid", a.message, e);
          break;
        case "regex":
          zt(n, a.regex, a.message, e);
          break;
        case "cuid":
          zt(n, Hn.cuid, a.message, e);
          break;
        case "cuid2":
          zt(n, Hn.cuid2, a.message, e);
          break;
        case "startsWith":
          zt(n, RegExp(`^${wm(a.value, e)}`), a.message, e);
          break;
        case "endsWith":
          zt(n, RegExp(`${wm(a.value, e)}$`), a.message, e);
          break;
        case "datetime":
          Gn(n, "date-time", a.message, e);
          break;
        case "date":
          Gn(n, "date", a.message, e);
          break;
        case "time":
          Gn(n, "time", a.message, e);
          break;
        case "duration":
          Gn(n, "duration", a.message, e);
          break;
        case "length":
          Ue(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, a.value) : a.value, a.message, e), Ue(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, a.value) : a.value, a.message, e);
          break;
        case "includes": {
          zt(n, RegExp(wm(a.value, e)), a.message, e);
          break;
        }
        case "ip": {
          a.version !== "v6" && Gn(n, "ipv4", a.message, e), a.version !== "v4" && Gn(n, "ipv6", a.message, e);
          break;
        }
        case "base64url":
          zt(n, Hn.base64url, a.message, e);
          break;
        case "jwt":
          zt(n, Hn.jwt, a.message, e);
          break;
        case "cidr": {
          a.version !== "v6" && zt(n, Hn.ipv4Cidr, a.message, e), a.version !== "v4" && zt(n, Hn.ipv6Cidr, a.message, e);
          break;
        }
        case "emoji":
          zt(n, Hn.emoji(), a.message, e);
          break;
        case "ulid": {
          zt(n, Hn.ulid, a.message, e);
          break;
        }
        case "base64": {
          switch (e.base64Strategy) {
            case "format:binary": {
              Gn(n, "binary", a.message, e);
              break;
            }
            case "contentEncoding:base64": {
              Ue(n, "contentEncoding", "base64", a.message, e);
              break;
            }
            case "pattern:zod": {
              zt(n, Hn.base64, a.message, e);
              break;
            }
          }
          break;
        }
        case "nanoid":
          zt(n, Hn.nanoid, a.message, e);
      }
  return n;
}
function wm(t, e) {
  return e.patternStrategy === "escape" ? GN(t) : t;
}
const HN = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function GN(t) {
  let e = "";
  for (let n = 0; n < t.length; n++)
    HN.has(t[n]) || (e += "\\"), e += t[n];
  return e;
}
function Gn(t, e, n, a) {
  t.format || t.anyOf?.some((r) => r.format) ? (t.anyOf || (t.anyOf = []), t.format && (t.anyOf.push({
    format: t.format,
    ...t.errorMessage && a.errorMessages && {
      errorMessage: { format: t.errorMessage.format }
    }
  }), delete t.format, t.errorMessage && (delete t.errorMessage.format, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.anyOf.push({
    format: e,
    ...n && a.errorMessages && { errorMessage: { format: n } }
  })) : Ue(t, "format", e, n, a);
}
function zt(t, e, n, a) {
  t.pattern || t.allOf?.some((r) => r.pattern) ? (t.allOf || (t.allOf = []), t.pattern && (t.allOf.push({
    pattern: t.pattern,
    ...t.errorMessage && a.errorMessages && {
      errorMessage: { pattern: t.errorMessage.pattern }
    }
  }), delete t.pattern, t.errorMessage && (delete t.errorMessage.pattern, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.allOf.push({
    pattern: fv(e, a),
    ...n && a.errorMessages && { errorMessage: { pattern: n } }
  })) : Ue(t, "pattern", fv(e, a), n, a);
}
function fv(t, e) {
  if (!e.applyRegexFlags || !t.flags)
    return t.source;
  const n = {
    i: t.flags.includes("i"),
    m: t.flags.includes("m"),
    s: t.flags.includes("s")
    // `.` matches newlines
  }, a = n.i ? t.source.toLowerCase() : t.source;
  let r = "", i = !1, s = !1, u = !1;
  for (let d = 0; d < a.length; d++) {
    if (i) {
      r += a[d], i = !1;
      continue;
    }
    if (n.i) {
      if (s) {
        if (a[d].match(/[a-z]/)) {
          u ? (r += a[d], r += `${a[d - 2]}-${a[d]}`.toUpperCase(), u = !1) : a[d + 1] === "-" && a[d + 2]?.match(/[a-z]/) ? (r += a[d], u = !0) : r += `${a[d]}${a[d].toUpperCase()}`;
          continue;
        }
      } else if (a[d].match(/[a-z]/)) {
        r += `[${a[d]}${a[d].toUpperCase()}]`;
        continue;
      }
    }
    if (n.m) {
      if (a[d] === "^") {
        r += `(^|(?<=[\r
]))`;
        continue;
      } else if (a[d] === "$") {
        r += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (n.s && a[d] === ".") {
      r += s ? `${a[d]}\r
` : `[${a[d]}\r
]`;
      continue;
    }
    r += a[d], a[d] === "\\" ? i = !0 : s && a[d] === "]" ? s = !1 : !s && a[d] === "[" && (s = !0);
  }
  try {
    new RegExp(r);
  } catch {
    return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), t.source;
  }
  return r;
}
function YC(t, e) {
  if (e.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."), e.target === "openApi3" && t.keyType?._def.typeName === K.ZodEnum)
    return {
      type: "object",
      required: t.keyType._def.values,
      properties: t.keyType._def.values.reduce((a, r) => ({
        ...a,
        [r]: Ie(t.valueType._def, {
          ...e,
          currentPath: [...e.currentPath, "properties", r]
        }) ?? {}
      }), {}),
      additionalProperties: e.rejectedAdditionalProperties
    };
  const n = {
    type: "object",
    additionalProperties: Ie(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    }) ?? e.allowedAdditionalProperties
  };
  if (e.target === "openApi3")
    return n;
  if (t.keyType?._def.typeName === K.ZodString && t.keyType._def.checks?.length) {
    const { type: a, ...r } = QC(t.keyType._def, e);
    return {
      ...n,
      propertyNames: r
    };
  } else {
    if (t.keyType?._def.typeName === K.ZodEnum)
      return {
        ...n,
        propertyNames: {
          enum: t.keyType._def.values
        }
      };
    if (t.keyType?._def.typeName === K.ZodBranded && t.keyType._def.type._def.typeName === K.ZodString && t.keyType._def.type._def.checks?.length) {
      const { type: a, ...r } = WC(t.keyType._def, e);
      return {
        ...n,
        propertyNames: r
      };
    }
  }
  return n;
}
function WN(t, e) {
  if (e.mapStrategy === "record")
    return YC(t, e);
  const n = Ie(t.keyType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "0"]
  }) || {}, a = Ie(t.valueType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, a],
      minItems: 2,
      maxItems: 2
    }
  };
}
function XN(t) {
  const e = t.values, a = Object.keys(t.values).filter((i) => typeof e[e[i]] != "number").map((i) => e[i]), r = Array.from(new Set(a.map((i) => typeof i)));
  return {
    type: r.length === 1 ? r[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: a
  };
}
function QN() {
  return {
    not: {}
  };
}
function YN(t) {
  return t.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const Ch = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function eF(t, e) {
  if (e.target === "openApi3")
    return hv(t, e);
  const n = t.options instanceof Map ? Array.from(t.options.values()) : t.options;
  if (n.every((a) => a._def.typeName in Ch && (!a._def.checks || !a._def.checks.length))) {
    const a = n.reduce((r, i) => {
      const s = Ch[i._def.typeName];
      return s && !r.includes(s) ? [...r, s] : r;
    }, []);
    return {
      type: a.length > 1 ? a : a[0]
    };
  } else if (n.every((a) => a._def.typeName === "ZodLiteral" && !a.description)) {
    const a = n.reduce((r, i) => {
      const s = typeof i._def.value;
      switch (s) {
        case "string":
        case "number":
        case "boolean":
          return [...r, s];
        case "bigint":
          return [...r, "integer"];
        case "object":
          if (i._def.value === null)
            return [...r, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return r;
      }
    }, []);
    if (a.length === n.length) {
      const r = a.filter((i, s, u) => u.indexOf(i) === s);
      return {
        type: r.length > 1 ? r : r[0],
        enum: n.reduce((i, s) => i.includes(s._def.value) ? i : [...i, s._def.value], [])
      };
    }
  } else if (n.every((a) => a._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce((a, r) => [
        ...a,
        ...r._def.values.filter((i) => !a.includes(i))
      ], [])
    };
  return hv(t, e);
}
const hv = (t, e) => {
  const n = (t.options instanceof Map ? Array.from(t.options.values()) : t.options).map((a, r) => Ie(a._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", `${r}`]
  })).filter((a) => !!a && (!e.strictUnions || typeof a == "object" && Object.keys(a).length > 0));
  return n.length ? { anyOf: n } : void 0;
};
function tF(t, e) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(t.innerType._def.typeName) && (!t.innerType._def.checks || !t.innerType._def.checks.length))
    return e.target === "openApi3" ? {
      type: Ch[t.innerType._def.typeName],
      nullable: !0
    } : {
      type: [
        Ch[t.innerType._def.typeName],
        "null"
      ]
    };
  if (e.target === "openApi3") {
    const a = Ie(t.innerType._def, {
      ...e,
      currentPath: [...e.currentPath]
    });
    return a && "$ref" in a ? { allOf: [a], nullable: !0 } : a && { ...a, nullable: !0 };
  }
  const n = Ie(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "0"]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function nF(t, e) {
  const n = {
    type: "number"
  };
  if (!t.checks)
    return n;
  for (const a of t.checks)
    switch (a.kind) {
      case "int":
        n.type = "integer", GC(n, "type", a.message, e);
        break;
      case "min":
        e.target === "jsonSchema7" ? a.inclusive ? Ue(n, "minimum", a.value, a.message, e) : Ue(n, "exclusiveMinimum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMinimum = !0), Ue(n, "minimum", a.value, a.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? a.inclusive ? Ue(n, "maximum", a.value, a.message, e) : Ue(n, "exclusiveMaximum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMaximum = !0), Ue(n, "maximum", a.value, a.message, e));
        break;
      case "multipleOf":
        Ue(n, "multipleOf", a.value, a.message, e);
        break;
    }
  return n;
}
function rF(t, e) {
  const n = e.target === "openAi", a = {
    type: "object",
    properties: {}
  }, r = [], i = t.shape();
  for (const u in i) {
    let d = i[u];
    if (d === void 0 || d._def === void 0)
      continue;
    let f = iF(d);
    f && n && (d instanceof hr && (d = d._def.innerType), d.isNullable() || (d = d.nullable()), f = !1);
    const o = Ie(d._def, {
      ...e,
      currentPath: [...e.currentPath, "properties", u],
      propertyPath: [...e.currentPath, "properties", u]
    });
    o !== void 0 && (a.properties[u] = o, f || r.push(u));
  }
  r.length && (a.required = r);
  const s = aF(t, e);
  return s !== void 0 && (a.additionalProperties = s), a;
}
function aF(t, e) {
  if (t.catchall._def.typeName !== "ZodNever")
    return Ie(t.catchall._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    });
  switch (t.unknownKeys) {
    case "passthrough":
      return e.allowedAdditionalProperties;
    case "strict":
      return e.rejectedAdditionalProperties;
    case "strip":
      return e.removeAdditionalStrategy === "strict" ? e.allowedAdditionalProperties : e.rejectedAdditionalProperties;
  }
}
function iF(t) {
  try {
    return t.isOptional();
  } catch {
    return !0;
  }
}
const sF = (t, e) => {
  if (e.currentPath.toString() === e.propertyPath?.toString())
    return Ie(t.innerType._def, e);
  const n = Ie(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "1"]
  });
  return n ? {
    anyOf: [
      {
        not: {}
      },
      n
    ]
  } : {};
}, oF = (t, e) => {
  if (e.pipeStrategy === "input")
    return Ie(t.in._def, e);
  if (e.pipeStrategy === "output")
    return Ie(t.out._def, e);
  const n = Ie(t.in._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", "0"]
  }), a = Ie(t.out._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", n ? "1" : "0"]
  });
  return {
    allOf: [n, a].filter((r) => r !== void 0)
  };
};
function uF(t, e) {
  return Ie(t.type._def, e);
}
function cF(t, e) {
  const a = {
    type: "array",
    uniqueItems: !0,
    items: Ie(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "items"]
    })
  };
  return t.minSize && Ue(a, "minItems", t.minSize.value, t.minSize.message, e), t.maxSize && Ue(a, "maxItems", t.maxSize.value, t.maxSize.message, e), a;
}
function lF(t, e) {
  return t.rest ? {
    type: "array",
    minItems: t.items.length,
    items: t.items.map((n, a) => Ie(n._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${a}`]
    })).reduce((n, a) => a === void 0 ? n : [...n, a], []),
    additionalItems: Ie(t.rest._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: t.items.length,
    maxItems: t.items.length,
    items: t.items.map((n, a) => Ie(n._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${a}`]
    })).reduce((n, a) => a === void 0 ? n : [...n, a], [])
  };
}
function dF() {
  return {
    not: {}
  };
}
function fF() {
  return {};
}
const hF = (t, e) => Ie(t.innerType._def, e), pF = (t, e, n) => {
  switch (e) {
    case K.ZodString:
      return QC(t, n);
    case K.ZodNumber:
      return nF(t, n);
    case K.ZodObject:
      return rF(t, n);
    case K.ZodBigInt:
      return qN(t, n);
    case K.ZodBoolean:
      return JN();
    case K.ZodDate:
      return XC(t, n);
    case K.ZodUndefined:
      return dF();
    case K.ZodNull:
      return YN(n);
    case K.ZodArray:
      return DN(t, n);
    case K.ZodUnion:
    case K.ZodDiscriminatedUnion:
      return eF(t, n);
    case K.ZodIntersection:
      return ZN(t, n);
    case K.ZodTuple:
      return lF(t, n);
    case K.ZodRecord:
      return YC(t, n);
    case K.ZodLiteral:
      return KN(t, n);
    case K.ZodEnum:
      return VN(t);
    case K.ZodNativeEnum:
      return XN(t);
    case K.ZodNullable:
      return tF(t, n);
    case K.ZodOptional:
      return sF(t, n);
    case K.ZodMap:
      return WN(t, n);
    case K.ZodSet:
      return cF(t, n);
    case K.ZodLazy:
      return () => t.getter()._def;
    case K.ZodPromise:
      return uF(t, n);
    case K.ZodNaN:
    case K.ZodNever:
      return QN();
    case K.ZodEffects:
      return xN(t, n);
    case K.ZodAny:
      return kN();
    case K.ZodUnknown:
      return fF();
    case K.ZodDefault:
      return BN(t, n);
    case K.ZodBranded:
      return WC(t, n);
    case K.ZodReadonly:
      return hF(t, n);
    case K.ZodCatch:
      return LN(t, n);
    case K.ZodPipeline:
      return oF(t, n);
    case K.ZodFunction:
    case K.ZodVoid:
    case K.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((a) => {
      })();
  }
};
function Ie(t, e, n = !1) {
  const a = e.seen.get(t);
  if (e.override) {
    const u = e.override?.(t, e, a, n);
    if (u !== IN)
      return u;
  }
  if (a && !n) {
    const u = mF(a, e);
    if (u !== void 0)
      return u;
  }
  const r = { def: t, path: e.currentPath, jsonSchema: void 0 };
  e.seen.set(t, r);
  const i = pF(t, t.typeName, e), s = typeof i == "function" ? Ie(i(), e) : i;
  if (s && gF(t, e, s), e.postProcess) {
    const u = e.postProcess(s, t, e);
    return r.jsonSchema = s, u;
  }
  return r.jsonSchema = s, s;
}
const mF = (t, e) => {
  switch (e.$refStrategy) {
    case "root":
      return { $ref: t.path.join("/") };
    case "relative":
      return { $ref: bF(e.currentPath, t.path) };
    case "none":
    case "seen":
      return t.path.length < e.currentPath.length && t.path.every((n, a) => e.currentPath[a] === n) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`), {}) : e.$refStrategy === "seen" ? {} : void 0;
  }
}, bF = (t, e) => {
  let n = 0;
  for (; n < t.length && n < e.length && t[n] === e[n]; n++)
    ;
  return [(t.length - n).toString(), ...e.slice(n)].join("/");
}, gF = (t, e, n) => (t.description && (n.description = t.description, e.markdownDescription && (n.markdownDescription = t.description)), n), xn = (t, e) => {
  const n = FN(e), a = typeof e == "object" && e.definitions ? Object.entries(e.definitions).reduce((d, [f, o]) => ({
    ...d,
    [f]: Ie(o._def, {
      ...n,
      currentPath: [...n.basePath, n.definitionPath, f]
    }, !0) ?? {}
  }), {}) : void 0, r = typeof e == "string" ? e : e?.nameStrategy === "title" ? void 0 : e?.name, i = Ie(t._def, r === void 0 ? n : {
    ...n,
    currentPath: [...n.basePath, n.definitionPath, r]
  }, !1) ?? {}, s = typeof e == "object" && e.name !== void 0 && e.nameStrategy === "title" ? e.name : void 0;
  s !== void 0 && (i.title = s);
  const u = r === void 0 ? a ? {
    ...i,
    [n.definitionPath]: a
  } : i : {
    $ref: [
      ...n.$refStrategy === "relative" ? [] : n.basePath,
      n.definitionPath,
      r
    ].join("/"),
    [n.definitionPath]: {
      ...a,
      [r]: i
    }
  };
  return n.target === "jsonSchema7" ? u.$schema = "http://json-schema.org/draft-07/schema#" : (n.target === "jsonSchema2019-09" || n.target === "openAi") && (u.$schema = "https://json-schema.org/draft/2019-09/schema#"), n.target === "openAi" && ("anyOf" in u || "oneOf" in u || "allOf" in u || "type" in u && Array.isArray(u.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."), u;
};
function Sm(t) {
  return t.replace(/[^a-zA-Z-_0-9]/g, "_");
}
const _F = ["*", "_", "`"];
function yF(t) {
  let e = "";
  for (const [n, a] of Object.entries(t))
    e += `	classDef ${n} ${a};
`;
  return e;
}
function vF(t, e, n) {
  const { firstNode: a, lastNode: r, nodeColors: i, withStyles: s = !0, curveStyle: u = "linear", wrapLabelNWords: d = 9 } = n ?? {};
  let f = s ? `%%{init: {'flowchart': {'curve': '${u}'}}}%%
graph TD;
` : `graph TD;
`;
  if (s) {
    const p = "default", l = {
      [p]: "{0}({1})"
    };
    a !== void 0 && (l[a] = "{0}([{1}]):::first"), r !== void 0 && (l[r] = "{0}([{1}]):::last");
    for (const [m, b] of Object.entries(t)) {
      const g = b.name.split(":").pop() ?? "";
      let P = _F.some((C) => g.startsWith(C) && g.endsWith(C)) ? `<p>${g}</p>` : g;
      Object.keys(b.metadata ?? {}).length && (P += `<hr/><small><em>${Object.entries(b.metadata ?? {}).map(([C, T]) => `${C} = ${T}`).join(`
`)}</em></small>`);
      const R = (l[m] ?? l[p]).replace("{0}", Sm(m)).replace("{1}", P);
      f += `	${R}
`;
    }
  }
  const o = {};
  for (const p of e) {
    const l = p.source.split(":"), m = p.target.split(":"), b = l.filter((g, _) => g === m[_]).join(":");
    o[b] || (o[b] = []), o[b].push(p);
  }
  const c = /* @__PURE__ */ new Set();
  function h(p, l) {
    const m = p.length === 1 && p[0].source === p[0].target;
    if (l && !m) {
      const b = l.split(":").pop();
      if (c.has(b))
        throw new Error(`Found duplicate subgraph '${b}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
      c.add(b), f += `	subgraph ${b}
`;
    }
    for (const b of p) {
      const { source: g, target: _, data: P, conditional: R } = b;
      let C = "";
      if (P !== void 0) {
        let T = P;
        const O = T.split(" ");
        O.length > d && (T = Array.from({ length: Math.ceil(O.length / d) }, (A, M) => O.slice(M * d, (M + 1) * d).join(" ")).join("&nbsp;<br>&nbsp;")), C = R ? ` -. &nbsp;${T}&nbsp; .-> ` : ` -- &nbsp;${T}&nbsp; --> `;
      } else
        C = R ? " -.-> " : " --> ";
      f += `	${Sm(g)}${C}${Sm(_)};
`;
    }
    for (const b in o)
      b.startsWith(`${l}:`) && b !== l && h(o[b], b);
    l && !m && (f += `	end
`);
  }
  h(o[""] ?? [], "");
  for (const p in o)
    !p.includes(":") && p !== "" && h(o[p], p);
  return s && (f += yF(i ?? {})), f;
}
async function wF(t, e) {
  let { backgroundColor: n = "white" } = e ?? {};
  const a = btoa(t);
  n !== void 0 && (/^#(?:[0-9a-fA-F]{3}){1,2}$/.test(n) || (n = `!${n}`));
  const r = `https://mermaid.ink/img/${a}?bgColor=${n}`, i = await fetch(r);
  if (!i.ok)
    throw new Error([
      "Failed to render the graph using the Mermaid.INK API.",
      `Status code: ${i.status}`,
      `Status text: ${i.statusText}`
    ].join(`
`));
  return await i.blob();
}
function SF(t, e) {
  if (t !== void 0 && !qs(t))
    return t;
  if (Dg(e))
    try {
      let n = e.getName();
      return n = n.startsWith("Runnable") ? n.slice(8) : n, n;
    } catch {
      return e.getName();
    }
  else
    return e.name ?? "UnknownSchema";
}
function OF(t) {
  return Dg(t.data) ? {
    type: "runnable",
    data: {
      id: t.data.lc_id,
      name: t.data.getName()
    }
  } : {
    type: "schema",
    data: { ...xn(t.data.schema), title: t.data.name }
  };
}
let Rh = class eR {
  constructor(e) {
    Object.defineProperty(this, "nodes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "edges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this.nodes = e?.nodes ?? this.nodes, this.edges = e?.edges ?? this.edges;
  }
  // Convert the graph to a JSON-serializable format.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON() {
    const e = {};
    return Object.values(this.nodes).forEach((n, a) => {
      e[n.id] = qs(n.id) ? a : n.id;
    }), {
      nodes: Object.values(this.nodes).map((n) => ({
        id: e[n.id],
        ...OF(n)
      })),
      edges: this.edges.map((n) => {
        const a = {
          source: e[n.source],
          target: e[n.target]
        };
        return typeof n.data < "u" && (a.data = n.data), typeof n.conditional < "u" && (a.conditional = n.conditional), a;
      })
    };
  }
  addNode(e, n, a) {
    if (n !== void 0 && this.nodes[n] !== void 0)
      throw new Error(`Node with id ${n} already exists`);
    const r = n ?? jt(), i = {
      id: r,
      data: e,
      name: SF(n, e),
      metadata: a
    };
    return this.nodes[r] = i, i;
  }
  removeNode(e) {
    delete this.nodes[e.id], this.edges = this.edges.filter((n) => n.source !== e.id && n.target !== e.id);
  }
  addEdge(e, n, a, r) {
    if (this.nodes[e.id] === void 0)
      throw new Error(`Source node ${e.id} not in graph`);
    if (this.nodes[n.id] === void 0)
      throw new Error(`Target node ${n.id} not in graph`);
    const i = {
      source: e.id,
      target: n.id,
      data: a,
      conditional: r
    };
    return this.edges.push(i), i;
  }
  firstNode() {
    return pv(this);
  }
  lastNode() {
    return mv(this);
  }
  /**
   * Add all nodes and edges from another graph.
   * Note this doesn't check for duplicates, nor does it connect the graphs.
   */
  extend(e, n = "") {
    let a = n;
    Object.values(e.nodes).map((f) => f.id).every(qs) && (a = "");
    const i = (f) => a ? `${a}:${f}` : f;
    Object.entries(e.nodes).forEach(([f, o]) => {
      this.nodes[i(f)] = { ...o, id: i(f) };
    });
    const s = e.edges.map((f) => ({
      ...f,
      source: i(f.source),
      target: i(f.target)
    }));
    this.edges = [...this.edges, ...s];
    const u = e.firstNode(), d = e.lastNode();
    return [
      u ? { id: i(u.id), data: u.data } : void 0,
      d ? { id: i(d.id), data: d.data } : void 0
    ];
  }
  trimFirstNode() {
    const e = this.firstNode();
    e && pv(this, [e.id]) && this.removeNode(e);
  }
  trimLastNode() {
    const e = this.lastNode();
    e && mv(this, [e.id]) && this.removeNode(e);
  }
  /**
   * Return a new graph with all nodes re-identified,
   * using their unique, readable names where possible.
   */
  reid() {
    const e = Object.fromEntries(Object.values(this.nodes).map((r) => [r.id, r.name])), n = /* @__PURE__ */ new Map();
    Object.values(e).forEach((r) => {
      n.set(r, (n.get(r) || 0) + 1);
    });
    const a = (r) => {
      const i = e[r];
      return qs(r) && n.get(i) === 1 ? i : r;
    };
    return new eR({
      nodes: Object.fromEntries(Object.entries(this.nodes).map(([r, i]) => [
        a(r),
        { ...i, id: a(r) }
      ])),
      edges: this.edges.map((r) => ({
        ...r,
        source: a(r.source),
        target: a(r.target)
      }))
    });
  }
  drawMermaid(e) {
    const { withStyles: n, curveStyle: a, nodeColors: r = {
      default: "fill:#f2f0ff,line-height:1.2",
      first: "fill-opacity:0",
      last: "fill:#bfb6fc"
    }, wrapLabelNWords: i } = e ?? {}, s = this.reid(), u = s.firstNode(), d = s.lastNode();
    return vF(s.nodes, s.edges, {
      firstNode: u?.id,
      lastNode: d?.id,
      withStyles: n,
      curveStyle: a,
      nodeColors: r,
      wrapLabelNWords: i
    });
  }
  async drawMermaidPng(e) {
    const n = this.drawMermaid(e);
    return wF(n, {
      backgroundColor: e?.backgroundColor
    });
  }
};
function pv(t, e = []) {
  const n = new Set(t.edges.filter((r) => !e.includes(r.source)).map((r) => r.target)), a = [];
  for (const r of Object.values(t.nodes))
    !e.includes(r.id) && !n.has(r.id) && a.push(r);
  return a.length === 1 ? a[0] : void 0;
}
function mv(t, e = []) {
  const n = new Set(t.edges.filter((r) => !e.includes(r.target)).map((r) => r.source)), a = [];
  for (const r of Object.values(t.nodes))
    !e.includes(r.id) && !n.has(r.id) && a.push(r);
  return a.length === 1 ? a[0] : void 0;
}
function jF(t) {
  const e = new TextEncoder(), n = new ReadableStream({
    async start(a) {
      for await (const r of t)
        a.enqueue(e.encode(`event: data
data: ${JSON.stringify(r)}

`));
      a.enqueue(e.encode(`event: end

`)), a.close();
    }
  });
  return un.fromReadableStream(n);
}
function bv(t) {
  return typeof t == "object" && t !== null && typeof t[Symbol.iterator] == "function" && // avoid detecting array/set as iterator
  typeof t.next == "function";
}
const PF = (t) => t != null && typeof t == "object" && "next" in t && typeof t.next == "function";
function qb(t) {
  return typeof t == "object" && t !== null && typeof t[Symbol.asyncIterator] == "function";
}
function* gv(t, e) {
  for (; ; ) {
    const { value: n, done: a } = Ln.runWithConfig(Vu(t), e.next.bind(e), !0);
    if (a)
      break;
    yield n;
  }
}
async function* Jb(t, e) {
  const n = e[Symbol.asyncIterator]();
  for (; ; ) {
    const { value: a, done: r } = await Ln.runWithConfig(Vu(t), n.next.bind(e), !0);
    if (r)
      break;
    yield a;
  }
}
function Pt(t, e) {
  return t && !Array.isArray(t) && // eslint-disable-next-line no-instanceof/no-instanceof
  !(t instanceof Date) && typeof t == "object" ? t : { [e]: t };
}
class Te extends pr {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_runnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  getName(e) {
    const n = (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this.name ?? this.constructor.lc_name() ?? this.constructor.name
    );
    return e ? `${n}${e}` : n;
  }
  /**
   * Bind arguments to a Runnable, returning a new Runnable.
   * @param kwargs
   * @returns A new RunnableBinding that, when invoked, will apply the bound args.
   */
  bind(e) {
    return new oo({ bound: this, kwargs: e, config: {} });
  }
  /**
   * Return a new Runnable that maps a list of inputs to a list of outputs,
   * by calling invoke() with each input.
   */
  map() {
    return new Th({ bound: this });
  }
  /**
   * Add retry logic to an existing runnable.
   * @param kwargs
   * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
   */
  withRetry(e) {
    return new CF({
      bound: this,
      kwargs: {},
      config: {},
      maxAttemptNumber: e?.stopAfterAttempt,
      ...e
    });
  }
  /**
   * Bind config to a Runnable, returning a new Runnable.
   * @param config New configuration parameters to attach to the new runnable.
   * @returns A new RunnableBinding with a config matching what's passed.
   */
  withConfig(e) {
    return new oo({
      bound: this,
      config: e,
      kwargs: {}
    });
  }
  /**
   * Create a new runnable from the current one that will try invoking
   * other passed fallback runnables if the initial invocation fails.
   * @param fields.fallbacks Other runnables to call if the runnable errors.
   * @returns A new RunnableWithFallbacks.
   */
  withFallbacks(e) {
    const n = Array.isArray(e) ? e : e.fallbacks;
    return new TF({
      runnable: this,
      fallbacks: n
    });
  }
  _getOptionsList(e, n = 0) {
    if (Array.isArray(e) && e.length !== n)
      throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${e.length} options for ${n} inputs`);
    if (Array.isArray(e))
      return e.map(Ce);
    if (n > 1 && !Array.isArray(e) && e.runId) {
      console.warn("Provided runId will be used only for the first element of the batch.");
      const a = Object.fromEntries(Object.entries(e).filter(([r]) => r !== "runId"));
      return Array.from({ length: n }, (r, i) => Ce(i === 0 ? e : a));
    }
    return Array.from({ length: n }, () => Ce(e));
  }
  async batch(e, n, a) {
    const r = this._getOptionsList(n ?? {}, e.length), i = r[0]?.maxConcurrency ?? a?.maxConcurrency, s = new Qo({
      maxConcurrency: i,
      onFailedAttempt: (d) => {
        throw d;
      }
    }), u = e.map((d, f) => s.call(async () => {
      try {
        return await this.invoke(d, r[f]);
      } catch (o) {
        if (a?.returnExceptions)
          return o;
        throw o;
      }
    }));
    return Promise.all(u);
  }
  /**
   * Default streaming implementation.
   * Subclasses should override this method if they support streaming output.
   * @param input
   * @param options
   */
  async *_streamIterator(e, n) {
    yield this.invoke(e, n);
  }
  /**
   * Stream output in chunks.
   * @param input
   * @param options
   * @returns A readable stream that is also an iterable.
   */
  async stream(e, n) {
    const a = Ce(n), r = new Yu({
      generator: this._streamIterator(e, a),
      config: a
    });
    return await r.setup, un.fromAsyncGenerator(r);
  }
  _separateRunnableConfigFromCallOptions(e) {
    let n;
    e === void 0 ? n = Ce(e) : n = Ce({
      callbacks: e.callbacks,
      tags: e.tags,
      metadata: e.metadata,
      runName: e.runName,
      configurable: e.configurable,
      recursionLimit: e.recursionLimit,
      maxConcurrency: e.maxConcurrency,
      runId: e.runId,
      timeout: e.timeout,
      signal: e.signal
    });
    const a = { ...e };
    return delete a.callbacks, delete a.tags, delete a.metadata, delete a.runName, delete a.configurable, delete a.recursionLimit, delete a.maxConcurrency, delete a.runId, delete a.timeout, delete a.signal, [n, a];
  }
  async _callWithConfig(e, n, a) {
    const r = Ce(a), s = await (await Un(r))?.handleChainStart(this.toJSON(), Pt(n, "input"), r.runId, r?.runType, void 0, void 0, r?.runName ?? this.getName());
    delete r.runId;
    let u;
    try {
      const d = e.call(this, n, r, s);
      u = await po(d, a?.signal);
    } catch (d) {
      throw await s?.handleChainError(d), d;
    }
    return await s?.handleChainEnd(Pt(u, "output")), u;
  }
  /**
   * Internal method that handles batching and configuration for a runnable
   * It takes a function, input values, and optional configuration, and
   * returns a promise that resolves to the output values.
   * @param func The function to be executed for each input value.
   * @param input The input values to be processed.
   * @param config Optional configuration for the function execution.
   * @returns A promise that resolves to the output values.
   */
  async _batchWithConfig(e, n, a, r) {
    const i = this._getOptionsList(a ?? {}, n.length), s = await Promise.all(i.map(Un)), u = await Promise.all(s.map(async (f, o) => {
      const c = await f?.handleChainStart(this.toJSON(), Pt(n[o], "input"), i[o].runId, i[o].runType, void 0, void 0, i[o].runName ?? this.getName());
      return delete i[o].runId, c;
    }));
    let d;
    try {
      const f = e.call(this, n, i, u, r);
      d = await po(f, i?.[0]?.signal);
    } catch (f) {
      throw await Promise.all(u.map((o) => o?.handleChainError(f))), f;
    }
    return await Promise.all(u.map((f) => f?.handleChainEnd(Pt(d, "output")))), d;
  }
  /**
   * Helper method to transform an Iterator of Input values into an Iterator of
   * Output values, with callbacks.
   * Use this to implement `stream()` or `transform()` in Runnable subclasses.
   */
  async *_transformStreamWithConfig(e, n, a) {
    let r, i = !0, s, u = !0;
    const d = Ce(a), f = await Un(d);
    async function* o() {
      for await (const h of e) {
        if (i)
          if (r === void 0)
            r = h;
          else
            try {
              r = an(r, h);
            } catch {
              r = void 0, i = !1;
            }
        yield h;
      }
    }
    let c;
    try {
      const h = await PN(n.bind(this), o(), async () => f?.handleChainStart(this.toJSON(), { input: "" }, d.runId, d.runType, void 0, void 0, d.runName ?? this.getName()), a?.signal, d);
      delete d.runId, c = h.setup;
      const p = c?.handlers.find(TN);
      let l = h.output;
      p !== void 0 && c !== void 0 && (l = p.tapOutputIterable(c.runId, l));
      const m = c?.handlers.find(CN);
      m !== void 0 && c !== void 0 && (l = m.tapOutputIterable(c.runId, l));
      for await (const b of l)
        if (yield b, u)
          if (s === void 0)
            s = b;
          else
            try {
              s = an(s, b);
            } catch {
              s = void 0, u = !1;
            }
    } catch (h) {
      throw await c?.handleChainError(h, void 0, void 0, void 0, {
        inputs: Pt(r, "input")
      }), h;
    }
    await c?.handleChainEnd(s ?? {}, void 0, void 0, void 0, { inputs: Pt(r, "input") });
  }
  getGraph(e) {
    const n = new Rh(), a = n.addNode({
      name: `${this.getName()}Input`,
      schema: wn.any()
    }), r = n.addNode(this), i = n.addNode({
      name: `${this.getName()}Output`,
      schema: wn.any()
    });
    return n.addEdge(a, r), n.addEdge(r, i), n;
  }
  /**
   * Create a new runnable sequence that runs each individual runnable in series,
   * piping the output of one runnable into another runnable or runnable-like.
   * @param coerceable A runnable, function, or object whose values are functions or runnables.
   * @returns A new runnable sequence.
   */
  pipe(e) {
    return new gt({
      first: this,
      last: Sn(e)
    });
  }
  /**
   * Pick keys from the dict output of this runnable. Returns a new runnable.
   */
  pick(e) {
    return this.pipe(new $F(e));
  }
  /**
   * Assigns new fields to the dict output of this runnable. Returns a new runnable.
   */
  assign(e) {
    return this.pipe(
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      new tR(
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        new ec({ steps: e })
      )
    );
  }
  /**
   * Default implementation of transform, which buffers input and then calls stream.
   * Subclasses should override this method if they can start producing output while
   * input is still being generated.
   * @param generator
   * @param options
   */
  async *transform(e, n) {
    let a;
    for await (const r of e)
      a === void 0 ? a = r : a = an(a, r);
    yield* this._streamIterator(a, Ce(n));
  }
  /**
   * Stream all output from a runnable, as reported to the callback system.
   * This includes all inner runs of LLMs, Retrievers, Tools, etc.
   * Output is streamed as Log objects, which include a list of
   * jsonpatch ops that describe how the state of the run has changed in each
   * step, and the final state of the run.
   * The jsonpatch ops can be applied in order to construct state.
   * @param input
   * @param options
   * @param streamOptions
   */
  async *streamLog(e, n, a) {
    const r = new lv({
      ...a,
      autoClose: !1,
      _schemaFormat: "original"
    }), i = Ce(n);
    yield* this._streamLog(e, r, i);
  }
  async *_streamLog(e, n, a) {
    const { callbacks: r } = a;
    if (r === void 0)
      a.callbacks = [n];
    else if (Array.isArray(r))
      a.callbacks = r.concat([n]);
    else {
      const d = r.copy();
      d.addHandler(n, !0), a.callbacks = d;
    }
    const i = this.stream(e, a);
    async function s() {
      try {
        const d = await i;
        for await (const f of d) {
          const o = new eo({
            ops: [
              {
                op: "add",
                path: "/streamed_output/-",
                value: f
              }
            ]
          });
          await n.writer.write(o);
        }
      } finally {
        await n.writer.close();
      }
    }
    const u = s();
    try {
      for await (const d of n)
        yield d;
    } finally {
      await u;
    }
  }
  streamEvents(e, n, a) {
    let r;
    if (n.version === "v1")
      r = this._streamEventsV1(e, n, a);
    else if (n.version === "v2")
      r = this._streamEventsV2(e, n, a);
    else
      throw new Error('Only versions "v1" and "v2" of the schema are currently supported.');
    return n.encoding === "text/event-stream" ? jF(r) : un.fromAsyncGenerator(r);
  }
  async *_streamEventsV2(e, n, a) {
    const r = new $N({
      ...a,
      autoClose: !1
    }), i = Ce(n), s = i.runId ?? jt();
    i.runId = s;
    const u = i.callbacks;
    if (u === void 0)
      i.callbacks = [r];
    else if (Array.isArray(u))
      i.callbacks = u.concat(r);
    else {
      const l = u.copy();
      l.addHandler(r, !0), i.callbacks = l;
    }
    const d = new AbortController(), f = this;
    async function o() {
      try {
        let l;
        n?.signal ? "any" in AbortSignal ? l = AbortSignal.any([
          d.signal,
          n.signal
        ]) : (l = n.signal, n.signal.addEventListener("abort", () => {
          d.abort();
        }, { once: !0 })) : l = d.signal;
        const m = await f.stream(e, {
          ...i,
          signal: l
        }), b = r.tapOutputIterable(s, m);
        for await (const g of b)
          if (d.signal.aborted)
            break;
      } finally {
        await r.finish();
      }
    }
    const c = o();
    let h = !1, p;
    try {
      for await (const l of r) {
        if (!h) {
          l.data.input = e, h = !0, p = l.run_id, yield l;
          continue;
        }
        l.run_id === p && l.event.endsWith("_end") && l.data?.input && delete l.data.input, yield l;
      }
    } finally {
      d.abort(), await c;
    }
  }
  async *_streamEventsV1(e, n, a) {
    let r, i = !1;
    const s = Ce(n), u = s.tags ?? [], d = s.metadata ?? {}, f = s.runName ?? this.getName(), o = new lv({
      ...a,
      autoClose: !1,
      _schemaFormat: "streaming_events"
    }), c = new EN({
      ...a
    }), h = this._streamLog(e, o, s);
    for await (const l of h) {
      if (r ? r = r.concat(l) : r = hd.fromRunLogPatch(l), r.state === void 0)
        throw new Error('Internal error: "streamEvents" state is missing. Please open a bug report.');
      if (!i) {
        i = !0;
        const _ = { ...r.state }, P = {
          run_id: _.id,
          event: `on_${_.type}_start`,
          name: f,
          tags: u,
          metadata: d,
          data: {
            input: e
          }
        };
        c.includeEvent(P, _.type) && (yield P);
      }
      const m = l.ops.filter((_) => _.path.startsWith("/logs/")).map((_) => _.path.split("/")[2]), b = [...new Set(m)];
      for (const _ of b) {
        let P, R = {};
        const C = r.state.logs[_];
        if (C.end_time === void 0 ? C.streamed_output.length > 0 ? P = "stream" : P = "start" : P = "end", P === "start")
          C.inputs !== void 0 && (R.input = C.inputs);
        else if (P === "end")
          C.inputs !== void 0 && (R.input = C.inputs), R.output = C.final_output;
        else if (P === "stream") {
          const T = C.streamed_output.length;
          if (T !== 1)
            throw new Error(`Expected exactly one chunk of streamed output, got ${T} instead. Encountered in: "${C.name}"`);
          R = { chunk: C.streamed_output[0] }, C.streamed_output = [];
        }
        yield {
          event: `on_${C.type}_${P}`,
          name: C.name,
          run_id: C.id,
          tags: C.tags,
          metadata: C.metadata,
          data: R
        };
      }
      const { state: g } = r;
      if (g.streamed_output.length > 0) {
        const _ = g.streamed_output.length;
        if (_ !== 1)
          throw new Error(`Expected exactly one chunk of streamed output, got ${_} instead. Encountered in: "${g.name}"`);
        const P = { chunk: g.streamed_output[0] };
        g.streamed_output = [];
        const R = {
          event: `on_${g.type}_stream`,
          run_id: g.id,
          tags: u,
          metadata: d,
          name: f,
          data: P
        };
        c.includeEvent(R, g.type) && (yield R);
      }
    }
    const p = r?.state;
    if (p !== void 0) {
      const l = {
        event: `on_${p.type}_end`,
        name: f,
        run_id: p.id,
        tags: u,
        metadata: d,
        data: {
          output: p.final_output
        }
      };
      c.includeEvent(l, p.type) && (yield l);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isRunnable(e) {
    return Dg(e);
  }
  /**
   * Bind lifecycle listeners to a Runnable, returning a new Runnable.
   * The Run object contains information about the run, including its id,
   * type, input, output, error, startTime, endTime, and any tags or metadata
   * added to the run.
   *
   * @param {Object} params - The object containing the callback functions.
   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
   */
  withListeners({ onStart: e, onEnd: n, onError: a }) {
    return new oo({
      bound: this,
      config: {},
      configFactories: [
        (r) => ({
          callbacks: [
            new HC({
              config: r,
              onStart: e,
              onEnd: n,
              onError: a
            })
          ]
        })
      ]
    });
  }
  /**
   * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
   * which contains the runnable, name, description and schema.
   *
   * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
   *
   * @param fields
   * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
   * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
   * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
   * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
   */
  asTool(e) {
    return MF(this, e);
  }
}
class oo extends Te {
  static lc_name() {
    return "RunnableBinding";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "bound", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "kwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "configFactories", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.bound = e.bound, this.kwargs = e.kwargs, this.config = e.config, this.configFactories = e.configFactories;
  }
  getName(e) {
    return this.bound.getName(e);
  }
  async _mergeConfig(...e) {
    const n = aa(this.config, ...e);
    return aa(n, ...this.configFactories ? await Promise.all(this.configFactories.map(async (a) => await a(n))) : []);
  }
  bind(e) {
    return new this.constructor({
      bound: this.bound,
      kwargs: { ...this.kwargs, ...e },
      config: this.config
    });
  }
  withConfig(e) {
    return new this.constructor({
      bound: this.bound,
      kwargs: this.kwargs,
      config: { ...this.config, ...e }
    });
  }
  withRetry(e) {
    return new this.constructor({
      bound: this.bound.withRetry(e),
      kwargs: this.kwargs,
      config: this.config
    });
  }
  async invoke(e, n) {
    return this.bound.invoke(e, await this._mergeConfig(Ce(n), this.kwargs));
  }
  async batch(e, n, a) {
    const r = Array.isArray(n) ? await Promise.all(n.map(async (i) => this._mergeConfig(Ce(i), this.kwargs))) : await this._mergeConfig(Ce(n), this.kwargs);
    return this.bound.batch(e, r, a);
  }
  async *_streamIterator(e, n) {
    yield* this.bound._streamIterator(e, await this._mergeConfig(Ce(n), this.kwargs));
  }
  async stream(e, n) {
    return this.bound.stream(e, await this._mergeConfig(Ce(n), this.kwargs));
  }
  async *transform(e, n) {
    yield* this.bound.transform(e, await this._mergeConfig(Ce(n), this.kwargs));
  }
  streamEvents(e, n, a) {
    const r = this, i = async function* () {
      yield* r.bound.streamEvents(e, {
        ...await r._mergeConfig(Ce(n), r.kwargs),
        version: n.version
      }, a);
    };
    return un.fromAsyncGenerator(i());
  }
  static isRunnableBinding(e) {
    return e.bound && Te.isRunnable(e.bound);
  }
  /**
   * Bind lifecycle listeners to a Runnable, returning a new Runnable.
   * The Run object contains information about the run, including its id,
   * type, input, output, error, startTime, endTime, and any tags or metadata
   * added to the run.
   *
   * @param {Object} params - The object containing the callback functions.
   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
   */
  withListeners({ onStart: e, onEnd: n, onError: a }) {
    return new oo({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      configFactories: [
        (r) => ({
          callbacks: [
            new HC({
              config: r,
              onStart: e,
              onEnd: n,
              onError: a
            })
          ]
        })
      ]
    });
  }
}
class Th extends Te {
  static lc_name() {
    return "RunnableEach";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "bound", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.bound = e.bound;
  }
  /**
   * Binds the runnable with the specified arguments.
   * @param kwargs The arguments to bind the runnable with.
   * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.
   */
  bind(e) {
    return new Th({
      bound: this.bound.bind(e)
    });
  }
  /**
   * Invokes the runnable with the specified input and configuration.
   * @param input The input to invoke the runnable with.
   * @param config The configuration to invoke the runnable with.
   * @returns A promise that resolves to the output of the runnable.
   */
  async invoke(e, n) {
    return this._callWithConfig(this._invoke.bind(this), e, n);
  }
  /**
   * A helper method that is used to invoke the runnable with the specified input and configuration.
   * @param input The input to invoke the runnable with.
   * @param config The configuration to invoke the runnable with.
   * @returns A promise that resolves to the output of the runnable.
   */
  async _invoke(e, n, a) {
    return this.bound.batch(e, Qe(n, { callbacks: a?.getChild() }));
  }
  /**
   * Bind lifecycle listeners to a Runnable, returning a new Runnable.
   * The Run object contains information about the run, including its id,
   * type, input, output, error, startTime, endTime, and any tags or metadata
   * added to the run.
   *
   * @param {Object} params - The object containing the callback functions.
   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
   */
  withListeners({ onStart: e, onEnd: n, onError: a }) {
    return new Th({
      bound: this.bound.withListeners({ onStart: e, onEnd: n, onError: a })
    });
  }
}
class CF extends oo {
  static lc_name() {
    return "RunnableRetry";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "maxAttemptNumber", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "onFailedAttempt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
      }
    }), this.maxAttemptNumber = e.maxAttemptNumber ?? this.maxAttemptNumber, this.onFailedAttempt = e.onFailedAttempt ?? this.onFailedAttempt;
  }
  _patchConfigForRetry(e, n, a) {
    const r = e > 1 ? `retry:attempt:${e}` : void 0;
    return Qe(n, { callbacks: a?.getChild(r) });
  }
  async _invoke(e, n, a) {
    return vh((r) => super.invoke(e, this._patchConfigForRetry(r, n, a)), {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onFailedAttempt: (r) => this.onFailedAttempt(r, e),
      retries: Math.max(this.maxAttemptNumber - 1, 0),
      randomize: !0
    });
  }
  /**
   * Method that invokes the runnable with the specified input, run manager,
   * and config. It handles the retry logic by catching any errors and
   * recursively invoking itself with the updated config for the next retry
   * attempt.
   * @param input The input for the runnable.
   * @param runManager The run manager for the runnable.
   * @param config The config for the runnable.
   * @returns A promise that resolves to the output of the runnable.
   */
  async invoke(e, n) {
    return this._callWithConfig(this._invoke.bind(this), e, n);
  }
  async _batch(e, n, a, r) {
    const i = {};
    try {
      await vh(async (s) => {
        const u = e.map((h, p) => p).filter((h) => i[h.toString()] === void 0 || // eslint-disable-next-line no-instanceof/no-instanceof
        i[h.toString()] instanceof Error), d = u.map((h) => e[h]), f = u.map((h) => this._patchConfigForRetry(s, n?.[h], a?.[h])), o = await super.batch(d, f, {
          ...r,
          returnExceptions: !0
        });
        let c;
        for (let h = 0; h < o.length; h += 1) {
          const p = o[h], l = u[h];
          p instanceof Error && c === void 0 && (c = p, c.input = d[h]), i[l.toString()] = p;
        }
        if (c)
          throw c;
        return o;
      }, {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        onFailedAttempt: (s) => this.onFailedAttempt(s, s.input),
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: !0
      });
    } catch (s) {
      if (r?.returnExceptions !== !0)
        throw s;
    }
    return Object.keys(i).sort((s, u) => parseInt(s, 10) - parseInt(u, 10)).map((s) => i[parseInt(s, 10)]);
  }
  async batch(e, n, a) {
    return this._batchWithConfig(this._batch.bind(this), e, n, a);
  }
}
class gt extends Te {
  static lc_name() {
    return "RunnableSequence";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "first", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "middle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "last", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "omitSequenceTags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), this.first = e.first, this.middle = e.middle ?? this.middle, this.last = e.last, this.name = e.name, this.omitSequenceTags = e.omitSequenceTags ?? this.omitSequenceTags;
  }
  get steps() {
    return [this.first, ...this.middle, this.last];
  }
  async invoke(e, n) {
    const a = Ce(n), i = await (await Un(a))?.handleChainStart(this.toJSON(), Pt(e, "input"), a.runId, void 0, void 0, void 0, a?.runName);
    delete a.runId;
    let s = e, u;
    try {
      const d = [this.first, ...this.middle];
      for (let f = 0; f < d.length; f += 1) {
        const c = d[f].invoke(s, Qe(a, {
          callbacks: i?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${f + 1}`)
        }));
        s = await po(c, n?.signal);
      }
      if (n?.signal?.aborted)
        throw new Error("Aborted");
      u = await this.last.invoke(s, Qe(a, {
        callbacks: i?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`)
      }));
    } catch (d) {
      throw await i?.handleChainError(d), d;
    }
    return await i?.handleChainEnd(Pt(u, "output")), u;
  }
  async batch(e, n, a) {
    const r = this._getOptionsList(n ?? {}, e.length), i = await Promise.all(r.map(Un)), s = await Promise.all(i.map(async (d, f) => {
      const o = await d?.handleChainStart(this.toJSON(), Pt(e[f], "input"), r[f].runId, void 0, void 0, void 0, r[f].runName);
      return delete r[f].runId, o;
    }));
    let u = e;
    try {
      for (let d = 0; d < this.steps.length; d += 1) {
        const o = this.steps[d].batch(u, s.map((c, h) => {
          const p = c?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${d + 1}`);
          return Qe(r[h], { callbacks: p });
        }), a);
        u = await po(o, r[0]?.signal);
      }
    } catch (d) {
      throw await Promise.all(s.map((f) => f?.handleChainError(d))), d;
    }
    return await Promise.all(s.map((d) => d?.handleChainEnd(Pt(u, "output")))), u;
  }
  async *_streamIterator(e, n) {
    const a = await Un(n), { runId: r, ...i } = n ?? {}, s = await a?.handleChainStart(this.toJSON(), Pt(e, "input"), r, void 0, void 0, void 0, i?.runName), u = [this.first, ...this.middle, this.last];
    let d = !0, f;
    async function* o() {
      yield e;
    }
    try {
      let c = u[0].transform(o(), Qe(i, {
        callbacks: s?.getChild(this.omitSequenceTags ? void 0 : "seq:step:1")
      }));
      for (let h = 1; h < u.length; h += 1)
        c = await u[h].transform(c, Qe(i, {
          callbacks: s?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${h + 1}`)
        }));
      for await (const h of c)
        if (n?.signal?.throwIfAborted(), yield h, d)
          if (f === void 0)
            f = h;
          else
            try {
              f = an(f, h);
            } catch {
              f = void 0, d = !1;
            }
    } catch (c) {
      throw await s?.handleChainError(c), c;
    }
    await s?.handleChainEnd(Pt(f, "output"));
  }
  getGraph(e) {
    const n = new Rh();
    let a = null;
    return this.steps.forEach((r, i) => {
      const s = r.getGraph(e);
      i !== 0 && s.trimFirstNode(), i !== this.steps.length - 1 && s.trimLastNode(), n.extend(s);
      const u = s.firstNode();
      if (!u)
        throw new Error(`Runnable ${r} has no first node`);
      a && n.addEdge(a, u), a = s.lastNode();
    }), n;
  }
  pipe(e) {
    return gt.isRunnableSequence(e) ? new gt({
      first: this.first,
      middle: this.middle.concat([
        this.last,
        e.first,
        ...e.middle
      ]),
      last: e.last,
      name: this.name ?? e.name
    }) : new gt({
      first: this.first,
      middle: [...this.middle, this.last],
      last: Sn(e),
      name: this.name
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isRunnableSequence(e) {
    return Array.isArray(e.middle) && Te.isRunnable(e);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static from([e, ...n], a) {
    let r = {};
    return typeof a == "string" ? r.name = a : a !== void 0 && (r = a), new gt({
      ...r,
      first: Sn(e),
      middle: n.slice(0, -1).map(Sn),
      last: Sn(n[n.length - 1])
    });
  }
}
class ec extends Te {
  static lc_name() {
    return "RunnableMap";
  }
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "steps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.steps = {};
    for (const [n, a] of Object.entries(e.steps))
      this.steps[n] = Sn(a);
  }
  static from(e) {
    return new ec({ steps: e });
  }
  async invoke(e, n) {
    const a = Ce(n), i = await (await Un(a))?.handleChainStart(this.toJSON(), {
      input: e
    }, a.runId, void 0, void 0, void 0, a?.runName);
    delete a.runId;
    const s = {};
    try {
      const u = Object.entries(this.steps).map(async ([d, f]) => {
        s[d] = await f.invoke(e, Qe(a, {
          callbacks: i?.getChild(`map:key:${d}`)
        }));
      });
      await po(Promise.all(u), n?.signal);
    } catch (u) {
      throw await i?.handleChainError(u), u;
    }
    return await i?.handleChainEnd(s), s;
  }
  async *_transform(e, n, a) {
    const r = { ...this.steps }, i = KC(e, Object.keys(r).length), s = new Map(Object.entries(r).map(([u, d], f) => {
      const o = d.transform(i[f], Qe(a, {
        callbacks: n?.getChild(`map:key:${u}`)
      }));
      return [u, o.next().then((c) => ({ key: u, gen: o, result: c }))];
    }));
    for (; s.size; ) {
      const u = Promise.race(s.values()), { key: d, result: f, gen: o } = await po(u, a?.signal);
      s.delete(d), f.done || (yield { [d]: f.value }, s.set(d, o.next().then((c) => ({ key: d, gen: o, result: c }))));
    }
  }
  transform(e, n) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), n);
  }
  async stream(e, n) {
    async function* a() {
      yield e;
    }
    const r = Ce(n), i = new Yu({
      generator: this.transform(a(), r),
      config: r
    });
    return await i.setup, un.fromAsyncGenerator(i);
  }
}
class qg extends Te {
  constructor(e) {
    if (super(e), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "func", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), !Fg(e.func))
      throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
    this.func = e.func;
  }
  async invoke(e, n) {
    const [a] = this._getOptionsList(n ?? {}, 1), r = await Un(a), i = this.func(Qe(a, { callbacks: r }), e);
    return po(i, a?.signal);
  }
  async *_streamIterator(e, n) {
    const [a] = this._getOptionsList(n ?? {}, 1), r = await this.invoke(e, n);
    if (qb(r)) {
      for await (const i of r)
        a?.signal?.throwIfAborted(), yield i;
      return;
    }
    if (PF(r)) {
      for (; ; ) {
        a?.signal?.throwIfAborted();
        const i = r.next();
        if (i.done)
          break;
        yield i.value;
      }
      return;
    }
    yield r;
  }
  static from(e) {
    return new qg({ func: e });
  }
}
function RF(t) {
  if (Fg(t))
    throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
}
class Yo extends Te {
  static lc_name() {
    return "RunnableLambda";
  }
  constructor(e) {
    if (Fg(e.func))
      return qg.from(e.func);
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "func", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), RF(e.func), this.func = e.func;
  }
  static from(e) {
    return new Yo({
      func: e
    });
  }
  async _invoke(e, n, a) {
    return new Promise((r, i) => {
      const s = Qe(n, {
        callbacks: a?.getChild(),
        recursionLimit: (n?.recursionLimit ?? ym) - 1
      });
      Ln.runWithConfig(Vu(s), async () => {
        try {
          let u = await this.func(e, {
            ...s
          });
          if (u && Te.isRunnable(u)) {
            if (n?.recursionLimit === 0)
              throw new Error("Recursion limit reached.");
            u = await u.invoke(e, {
              ...s,
              recursionLimit: (s.recursionLimit ?? ym) - 1
            });
          } else if (qb(u)) {
            let d;
            for await (const f of Jb(s, u))
              if (n?.signal?.throwIfAborted(), d === void 0)
                d = f;
              else
                try {
                  d = an(d, f);
                } catch {
                  d = f;
                }
            u = d;
          } else if (bv(u)) {
            let d;
            for (const f of gv(s, u))
              if (n?.signal?.throwIfAborted(), d === void 0)
                d = f;
              else
                try {
                  d = an(d, f);
                } catch {
                  d = f;
                }
            u = d;
          }
          r(u);
        } catch (u) {
          i(u);
        }
      });
    });
  }
  async invoke(e, n) {
    return this._callWithConfig(this._invoke.bind(this), e, n);
  }
  async *_transform(e, n, a) {
    let r;
    for await (const u of e)
      if (r === void 0)
        r = u;
      else
        try {
          r = an(r, u);
        } catch {
          r = u;
        }
    const i = Qe(a, {
      callbacks: n?.getChild(),
      recursionLimit: (a?.recursionLimit ?? ym) - 1
    }), s = await new Promise((u, d) => {
      Ln.runWithConfig(Vu(i), async () => {
        try {
          const f = await this.func(r, {
            ...i,
            config: i
          });
          u(f);
        } catch (f) {
          d(f);
        }
      });
    });
    if (s && Te.isRunnable(s)) {
      if (a?.recursionLimit === 0)
        throw new Error("Recursion limit reached.");
      const u = await s.stream(r, i);
      for await (const d of u)
        yield d;
    } else if (qb(s))
      for await (const u of Jb(i, s))
        a?.signal?.throwIfAborted(), yield u;
    else if (bv(s))
      for (const u of gv(i, s))
        a?.signal?.throwIfAborted(), yield u;
    else
      yield s;
  }
  transform(e, n) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), n);
  }
  async stream(e, n) {
    async function* a() {
      yield e;
    }
    const r = Ce(n), i = new Yu({
      generator: this.transform(a(), r),
      config: r
    });
    return await i.setup, un.fromAsyncGenerator(i);
  }
}
class TF extends Te {
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "runnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fallbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.runnable = e.runnable, this.fallbacks = e.fallbacks;
  }
  *runnables() {
    yield this.runnable;
    for (const e of this.fallbacks)
      yield e;
  }
  async invoke(e, n) {
    const a = Ce(n), r = await Un(a), { runId: i, ...s } = a, u = await r?.handleChainStart(this.toJSON(), Pt(e, "input"), i, void 0, void 0, void 0, s?.runName), d = Qe(s, {
      callbacks: u?.getChild()
    });
    return await Ln.runWithConfig(d, async () => {
      let o;
      for (const c of this.runnables()) {
        a?.signal?.throwIfAborted();
        try {
          const h = await c.invoke(e, d);
          return await u?.handleChainEnd(Pt(h, "output")), h;
        } catch (h) {
          o === void 0 && (o = h);
        }
      }
      throw o === void 0 ? new Error("No error stored at end of fallback.") : (await u?.handleChainError(o), o);
    });
  }
  async *_streamIterator(e, n) {
    const a = Ce(n), r = await Un(a), { runId: i, ...s } = a, u = await r?.handleChainStart(this.toJSON(), Pt(e, "input"), i, void 0, void 0, void 0, s?.runName);
    let d, f;
    for (const c of this.runnables()) {
      a?.signal?.throwIfAborted();
      const h = Qe(s, {
        callbacks: u?.getChild()
      });
      try {
        const p = await c.stream(e, h);
        f = Jb(h, p);
        break;
      } catch (p) {
        d === void 0 && (d = p);
      }
    }
    if (f === void 0) {
      const c = d ?? new Error("No error stored at end of fallback.");
      throw await u?.handleChainError(c), c;
    }
    let o;
    try {
      for await (const c of f) {
        yield c;
        try {
          o = o === void 0 ? o : an(o, c);
        } catch {
          o = void 0;
        }
      }
    } catch (c) {
      throw await u?.handleChainError(c), c;
    }
    await u?.handleChainEnd(Pt(o, "output"));
  }
  async batch(e, n, a) {
    if (a?.returnExceptions)
      throw new Error("Not implemented.");
    const r = this._getOptionsList(n ?? {}, e.length), i = await Promise.all(r.map((d) => Un(d))), s = await Promise.all(i.map(async (d, f) => {
      const o = await d?.handleChainStart(this.toJSON(), Pt(e[f], "input"), r[f].runId, void 0, void 0, void 0, r[f].runName);
      return delete r[f].runId, o;
    }));
    let u;
    for (const d of this.runnables()) {
      r[0].signal?.throwIfAborted();
      try {
        const f = await d.batch(e, s.map((o, c) => Qe(r[c], {
          callbacks: o?.getChild()
        })), a);
        return await Promise.all(s.map((o, c) => o?.handleChainEnd(Pt(f[c], "output")))), f;
      } catch (f) {
        u === void 0 && (u = f);
      }
    }
    throw u ? (await Promise.all(s.map((d) => d?.handleChainError(u))), u) : new Error("No error stored at end of fallbacks.");
  }
}
function Sn(t) {
  if (typeof t == "function")
    return new Yo({ func: t });
  if (Te.isRunnable(t))
    return t;
  if (!Array.isArray(t) && typeof t == "object") {
    const e = {};
    for (const [n, a] of Object.entries(t))
      e[n] = Sn(a);
    return new ec({
      steps: e
    });
  } else
    throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
}
class tR extends Te {
  static lc_name() {
    return "RunnableAssign";
  }
  constructor(e) {
    e instanceof ec && (e = { mapper: e }), super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "mapper", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.mapper = e.mapper;
  }
  async invoke(e, n) {
    const a = await this.mapper.invoke(e, n);
    return {
      ...e,
      ...a
    };
  }
  async *_transform(e, n, a) {
    const r = this.mapper.getStepsKeys(), [i, s] = KC(e), u = this.mapper.transform(s, Qe(a, { callbacks: n?.getChild() })), d = u.next();
    for await (const f of i) {
      if (typeof f != "object" || Array.isArray(f))
        throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof f}`);
      const o = Object.fromEntries(Object.entries(f).filter(([c]) => !r.includes(c)));
      Object.keys(o).length > 0 && (yield o);
    }
    yield (await d).value;
    for await (const f of u)
      yield f;
  }
  transform(e, n) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), n);
  }
  async stream(e, n) {
    async function* a() {
      yield e;
    }
    const r = Ce(n), i = new Yu({
      generator: this.transform(a(), r),
      config: r
    });
    return await i.setup, un.fromAsyncGenerator(i);
  }
}
class $F extends Te {
  static lc_name() {
    return "RunnablePick";
  }
  constructor(e) {
    (typeof e == "string" || Array.isArray(e)) && (e = { keys: e }), super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "keys", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.keys = e.keys;
  }
  async _pick(e) {
    if (typeof this.keys == "string")
      return e[this.keys];
    {
      const n = this.keys.map((a) => [a, e[a]]).filter((a) => a[1] !== void 0);
      return n.length === 0 ? void 0 : Object.fromEntries(n);
    }
  }
  async invoke(e, n) {
    return this._callWithConfig(this._pick.bind(this), e, n);
  }
  async *_transform(e) {
    for await (const n of e) {
      const a = await this._pick(n);
      a !== void 0 && (yield a);
    }
  }
  transform(e, n) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), n);
  }
  async stream(e, n) {
    async function* a() {
      yield e;
    }
    const r = Ce(n), i = new Yu({
      generator: this.transform(a(), r),
      config: r
    });
    return await i.setup, un.fromAsyncGenerator(i);
  }
}
class _v extends oo {
  constructor(e) {
    const n = gt.from([
      Yo.from(async (a) => {
        let r;
        if (Ig(a))
          try {
            r = await this.schema.parseAsync(a.args);
          } catch {
            throw new fh("Received tool input did not match expected schema", JSON.stringify(a.args));
          }
        else
          r = a;
        return r;
      }).withConfig({ runName: `${e.name}:parse_input` }),
      e.bound
    ]).withConfig({ runName: e.name });
    super({
      bound: n,
      config: e.config ?? {}
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "description", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "schema", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = e.name, this.description = e.description, this.schema = e.schema;
  }
  static lc_name() {
    return "RunnableToolLike";
  }
}
function MF(t, e) {
  const n = e.name ?? t.getName(), a = e.description ?? e.schema?.description;
  return e.schema.constructor === wn.ZodString ? new _v({
    name: n,
    description: a,
    schema: wn.object({
      input: wn.string()
    }).transform((r) => r.input),
    bound: t
  }) : new _v({
    name: n,
    description: a,
    schema: e.schema,
    bound: t
  });
}
/*
 * [js-sha1]{@link https://github.com/emn178/js-sha1}
 *
 * @version 0.6.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
var AF = typeof window == "object" ? window : {}, _e = "0123456789abcdef".split(""), EF = [-2147483648, 8388608, 32768, 128], Wn = [24, 16, 8, 0], St = [];
function gr(t) {
  t ? (St[0] = St[16] = St[1] = St[2] = St[3] = St[4] = St[5] = St[6] = St[7] = St[8] = St[9] = St[10] = St[11] = St[12] = St[13] = St[14] = St[15] = 0, this.blocks = St) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.h0 = 1732584193, this.h1 = 4023233417, this.h2 = 2562383102, this.h3 = 271733878, this.h4 = 3285377520, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0;
}
gr.prototype.update = function(t) {
  if (!this.finalized) {
    var e = typeof t != "string";
    e && t.constructor === AF.ArrayBuffer && (t = new Uint8Array(t));
    for (var n, a = 0, r, i = t.length || 0, s = this.blocks; a < i; ) {
      if (this.hashed && (this.hashed = !1, s[0] = this.block, s[16] = s[1] = s[2] = s[3] = s[4] = s[5] = s[6] = s[7] = s[8] = s[9] = s[10] = s[11] = s[12] = s[13] = s[14] = s[15] = 0), e)
        for (r = this.start; a < i && r < 64; ++a)
          s[r >> 2] |= t[a] << Wn[r++ & 3];
      else
        for (r = this.start; a < i && r < 64; ++a)
          n = t.charCodeAt(a), n < 128 ? s[r >> 2] |= n << Wn[r++ & 3] : n < 2048 ? (s[r >> 2] |= (192 | n >> 6) << Wn[r++ & 3], s[r >> 2] |= (128 | n & 63) << Wn[r++ & 3]) : n < 55296 || n >= 57344 ? (s[r >> 2] |= (224 | n >> 12) << Wn[r++ & 3], s[r >> 2] |= (128 | n >> 6 & 63) << Wn[r++ & 3], s[r >> 2] |= (128 | n & 63) << Wn[r++ & 3]) : (n = 65536 + ((n & 1023) << 10 | t.charCodeAt(++a) & 1023), s[r >> 2] |= (240 | n >> 18) << Wn[r++ & 3], s[r >> 2] |= (128 | n >> 12 & 63) << Wn[r++ & 3], s[r >> 2] |= (128 | n >> 6 & 63) << Wn[r++ & 3], s[r >> 2] |= (128 | n & 63) << Wn[r++ & 3]);
      this.lastByteIndex = r, this.bytes += r - this.start, r >= 64 ? (this.block = s[16], this.start = r - 64, this.hash(), this.hashed = !0) : this.start = r;
    }
    return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
  }
};
gr.prototype.finalize = function() {
  if (!this.finalized) {
    this.finalized = !0;
    var t = this.blocks, e = this.lastByteIndex;
    t[16] = this.block, t[e >> 2] |= EF[e & 3], this.block = t[16], e >= 56 && (this.hashed || this.hash(), t[0] = this.block, t[16] = t[1] = t[2] = t[3] = t[4] = t[5] = t[6] = t[7] = t[8] = t[9] = t[10] = t[11] = t[12] = t[13] = t[14] = t[15] = 0), t[14] = this.hBytes << 3 | this.bytes >>> 29, t[15] = this.bytes << 3, this.hash();
  }
};
gr.prototype.hash = function() {
  var t = this.h0, e = this.h1, n = this.h2, a = this.h3, r = this.h4, i, s, u, d = this.blocks;
  for (s = 16; s < 80; ++s)
    u = d[s - 3] ^ d[s - 8] ^ d[s - 14] ^ d[s - 16], d[s] = u << 1 | u >>> 31;
  for (s = 0; s < 20; s += 5)
    i = e & n | ~e & a, u = t << 5 | t >>> 27, r = u + i + r + 1518500249 + d[s] << 0, e = e << 30 | e >>> 2, i = t & e | ~t & n, u = r << 5 | r >>> 27, a = u + i + a + 1518500249 + d[s + 1] << 0, t = t << 30 | t >>> 2, i = r & t | ~r & e, u = a << 5 | a >>> 27, n = u + i + n + 1518500249 + d[s + 2] << 0, r = r << 30 | r >>> 2, i = a & r | ~a & t, u = n << 5 | n >>> 27, e = u + i + e + 1518500249 + d[s + 3] << 0, a = a << 30 | a >>> 2, i = n & a | ~n & r, u = e << 5 | e >>> 27, t = u + i + t + 1518500249 + d[s + 4] << 0, n = n << 30 | n >>> 2;
  for (; s < 40; s += 5)
    i = e ^ n ^ a, u = t << 5 | t >>> 27, r = u + i + r + 1859775393 + d[s] << 0, e = e << 30 | e >>> 2, i = t ^ e ^ n, u = r << 5 | r >>> 27, a = u + i + a + 1859775393 + d[s + 1] << 0, t = t << 30 | t >>> 2, i = r ^ t ^ e, u = a << 5 | a >>> 27, n = u + i + n + 1859775393 + d[s + 2] << 0, r = r << 30 | r >>> 2, i = a ^ r ^ t, u = n << 5 | n >>> 27, e = u + i + e + 1859775393 + d[s + 3] << 0, a = a << 30 | a >>> 2, i = n ^ a ^ r, u = e << 5 | e >>> 27, t = u + i + t + 1859775393 + d[s + 4] << 0, n = n << 30 | n >>> 2;
  for (; s < 60; s += 5)
    i = e & n | e & a | n & a, u = t << 5 | t >>> 27, r = u + i + r - 1894007588 + d[s] << 0, e = e << 30 | e >>> 2, i = t & e | t & n | e & n, u = r << 5 | r >>> 27, a = u + i + a - 1894007588 + d[s + 1] << 0, t = t << 30 | t >>> 2, i = r & t | r & e | t & e, u = a << 5 | a >>> 27, n = u + i + n - 1894007588 + d[s + 2] << 0, r = r << 30 | r >>> 2, i = a & r | a & t | r & t, u = n << 5 | n >>> 27, e = u + i + e - 1894007588 + d[s + 3] << 0, a = a << 30 | a >>> 2, i = n & a | n & r | a & r, u = e << 5 | e >>> 27, t = u + i + t - 1894007588 + d[s + 4] << 0, n = n << 30 | n >>> 2;
  for (; s < 80; s += 5)
    i = e ^ n ^ a, u = t << 5 | t >>> 27, r = u + i + r - 899497514 + d[s] << 0, e = e << 30 | e >>> 2, i = t ^ e ^ n, u = r << 5 | r >>> 27, a = u + i + a - 899497514 + d[s + 1] << 0, t = t << 30 | t >>> 2, i = r ^ t ^ e, u = a << 5 | a >>> 27, n = u + i + n - 899497514 + d[s + 2] << 0, r = r << 30 | r >>> 2, i = a ^ r ^ t, u = n << 5 | n >>> 27, e = u + i + e - 899497514 + d[s + 3] << 0, a = a << 30 | a >>> 2, i = n ^ a ^ r, u = e << 5 | e >>> 27, t = u + i + t - 899497514 + d[s + 4] << 0, n = n << 30 | n >>> 2;
  this.h0 = this.h0 + t << 0, this.h1 = this.h1 + e << 0, this.h2 = this.h2 + n << 0, this.h3 = this.h3 + a << 0, this.h4 = this.h4 + r << 0;
};
gr.prototype.hex = function() {
  this.finalize();
  var t = this.h0, e = this.h1, n = this.h2, a = this.h3, r = this.h4;
  return _e[t >> 28 & 15] + _e[t >> 24 & 15] + _e[t >> 20 & 15] + _e[t >> 16 & 15] + _e[t >> 12 & 15] + _e[t >> 8 & 15] + _e[t >> 4 & 15] + _e[t & 15] + _e[e >> 28 & 15] + _e[e >> 24 & 15] + _e[e >> 20 & 15] + _e[e >> 16 & 15] + _e[e >> 12 & 15] + _e[e >> 8 & 15] + _e[e >> 4 & 15] + _e[e & 15] + _e[n >> 28 & 15] + _e[n >> 24 & 15] + _e[n >> 20 & 15] + _e[n >> 16 & 15] + _e[n >> 12 & 15] + _e[n >> 8 & 15] + _e[n >> 4 & 15] + _e[n & 15] + _e[a >> 28 & 15] + _e[a >> 24 & 15] + _e[a >> 20 & 15] + _e[a >> 16 & 15] + _e[a >> 12 & 15] + _e[a >> 8 & 15] + _e[a >> 4 & 15] + _e[a & 15] + _e[r >> 28 & 15] + _e[r >> 24 & 15] + _e[r >> 20 & 15] + _e[r >> 16 & 15] + _e[r >> 12 & 15] + _e[r >> 8 & 15] + _e[r >> 4 & 15] + _e[r & 15];
};
gr.prototype.toString = gr.prototype.hex;
gr.prototype.digest = function() {
  this.finalize();
  var t = this.h0, e = this.h1, n = this.h2, a = this.h3, r = this.h4;
  return [
    t >> 24 & 255,
    t >> 16 & 255,
    t >> 8 & 255,
    t & 255,
    e >> 24 & 255,
    e >> 16 & 255,
    e >> 8 & 255,
    e & 255,
    n >> 24 & 255,
    n >> 16 & 255,
    n >> 8 & 255,
    n & 255,
    a >> 24 & 255,
    a >> 16 & 255,
    a >> 8 & 255,
    a & 255,
    r >> 24 & 255,
    r >> 16 & 255,
    r >> 8 & 255,
    r & 255
  ];
};
gr.prototype.array = gr.prototype.digest;
gr.prototype.arrayBuffer = function() {
  this.finalize();
  var t = new ArrayBuffer(20), e = new DataView(t);
  return e.setUint32(0, this.h0), e.setUint32(4, this.h1), e.setUint32(8, this.h2), e.setUint32(12, this.h3), e.setUint32(16, this.h4), t;
};
const IF = (t) => new gr(!0).update(t).hex(), yv = (...t) => IF(t.join("_"));
class NF {
}
const FF = /* @__PURE__ */ new Map();
class Jg extends NF {
  constructor(e) {
    super(), Object.defineProperty(this, "cache", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cache = e ?? /* @__PURE__ */ new Map();
  }
  /**
   * Retrieves data from the cache using a prompt and an LLM key. If the
   * data is not found, it returns null.
   * @param prompt The prompt used to find the data.
   * @param llmKey The LLM key used to find the data.
   * @returns The data corresponding to the prompt and LLM key, or null if not found.
   */
  lookup(e, n) {
    return Promise.resolve(this.cache.get(yv(e, n)) ?? null);
  }
  /**
   * Updates the cache with new data using a prompt and an LLM key.
   * @param prompt The prompt used to store the data.
   * @param llmKey The LLM key used to store the data.
   * @param value The data to be stored.
   */
  async update(e, n, a) {
    this.cache.set(yv(e, n), a);
  }
  /**
   * Returns a global instance of InMemoryCache using a predefined global
   * map as the initial cache.
   * @returns A global instance of InMemoryCache.
   */
  static global() {
    return new Jg(FF);
  }
}
class Lg extends pr {
}
class nR extends Lg {
  static lc_name() {
    return "StringPromptValue";
  }
  constructor(e) {
    super({ value: e }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompt_values"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.value = e;
  }
  toString() {
    return this.value;
  }
  toChatMessages() {
    return [new mr(this.value)];
  }
}
class rR extends Lg {
  static lc_name() {
    return "ChatPromptValue";
  }
  constructor(e) {
    Array.isArray(e) && (e = { messages: e }), super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompt_values"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "messages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.messages = e.messages;
  }
  toString() {
    return so(this.messages);
  }
  toChatMessages() {
    return this.messages;
  }
}
class kF extends Lg {
  static lc_name() {
    return "ImagePromptValue";
  }
  constructor(e) {
    "imageUrl" in e || (e = { imageUrl: e }), super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompt_values"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "imageUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.imageUrl = e.imageUrl;
  }
  toString() {
    return this.imageUrl.url;
  }
  toChatMessages() {
    return [
      new mr({
        content: [
          {
            type: "image_url",
            image_url: {
              detail: this.imageUrl.detail,
              url: this.imageUrl.url
            }
          }
        ]
      })
    ];
  }
}
var hc = {}, vv;
function DF() {
  if (vv) return hc;
  vv = 1, hc.byteLength = u, hc.toByteArray = f, hc.fromByteArray = h;
  for (var t = [], e = [], n = typeof Uint8Array < "u" ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = 0, i = a.length; r < i; ++r)
    t[r] = a[r], e[a.charCodeAt(r)] = r;
  e[45] = 62, e[95] = 63;
  function s(p) {
    var l = p.length;
    if (l % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var m = p.indexOf("=");
    m === -1 && (m = l);
    var b = m === l ? 0 : 4 - m % 4;
    return [m, b];
  }
  function u(p) {
    var l = s(p), m = l[0], b = l[1];
    return (m + b) * 3 / 4 - b;
  }
  function d(p, l, m) {
    return (l + m) * 3 / 4 - m;
  }
  function f(p) {
    var l, m = s(p), b = m[0], g = m[1], _ = new n(d(p, b, g)), P = 0, R = g > 0 ? b - 4 : b, C;
    for (C = 0; C < R; C += 4)
      l = e[p.charCodeAt(C)] << 18 | e[p.charCodeAt(C + 1)] << 12 | e[p.charCodeAt(C + 2)] << 6 | e[p.charCodeAt(C + 3)], _[P++] = l >> 16 & 255, _[P++] = l >> 8 & 255, _[P++] = l & 255;
    return g === 2 && (l = e[p.charCodeAt(C)] << 2 | e[p.charCodeAt(C + 1)] >> 4, _[P++] = l & 255), g === 1 && (l = e[p.charCodeAt(C)] << 10 | e[p.charCodeAt(C + 1)] << 4 | e[p.charCodeAt(C + 2)] >> 2, _[P++] = l >> 8 & 255, _[P++] = l & 255), _;
  }
  function o(p) {
    return t[p >> 18 & 63] + t[p >> 12 & 63] + t[p >> 6 & 63] + t[p & 63];
  }
  function c(p, l, m) {
    for (var b, g = [], _ = l; _ < m; _ += 3)
      b = (p[_] << 16 & 16711680) + (p[_ + 1] << 8 & 65280) + (p[_ + 2] & 255), g.push(o(b));
    return g.join("");
  }
  function h(p) {
    for (var l, m = p.length, b = m % 3, g = [], _ = 16383, P = 0, R = m - b; P < R; P += _)
      g.push(c(p, P, P + _ > R ? R : P + _));
    return b === 1 ? (l = p[m - 1], g.push(
      t[l >> 2] + t[l << 4 & 63] + "=="
    )) : b === 2 && (l = (p[m - 2] << 8) + p[m - 1], g.push(
      t[l >> 10] + t[l >> 4 & 63] + t[l << 2 & 63] + "="
    )), g.join("");
  }
  return hc;
}
var qF = /* @__PURE__ */ DF();
const JF = /* @__PURE__ */ Rd(qF);
var LF = Object.defineProperty, UF = (t, e, n) => e in t ? LF(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, BF = (t, e, n) => (UF(t, e + "", n), n);
function xF(t, e) {
  let n = Array.from(
    { length: t.length },
    (a, r) => ({ start: r, end: r + 1 })
  );
  for (; n.length > 1; ) {
    let a = null;
    for (let r = 0; r < n.length - 1; r++) {
      const i = t.slice(n[r].start, n[r + 1].end), s = e.get(i.join(","));
      s != null && (a == null || s < a[0]) && (a = [s, r]);
    }
    if (a != null) {
      const r = a[1];
      n[r] = { start: n[r].start, end: n[r + 1].end }, n.splice(r + 1, 1);
    } else
      break;
  }
  return n;
}
function VF(t, e) {
  return t.length === 1 ? [e.get(t.join(","))] : xF(t, e).map((n) => e.get(t.slice(n.start, n.end).join(","))).filter((n) => n != null);
}
function zF(t) {
  return t.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var Lb = class {
  /** @internal */
  specialTokens;
  /** @internal */
  inverseSpecialTokens;
  /** @internal */
  patStr;
  /** @internal */
  textEncoder = new TextEncoder();
  /** @internal */
  textDecoder = new TextDecoder("utf-8");
  /** @internal */
  rankMap = /* @__PURE__ */ new Map();
  /** @internal */
  textMap = /* @__PURE__ */ new Map();
  constructor(t, e) {
    this.patStr = t.pat_str;
    const n = t.bpe_ranks.split(`
`).filter(Boolean).reduce((a, r) => {
      const [i, s, ...u] = r.split(" "), d = Number.parseInt(s, 10);
      return u.forEach((f, o) => a[f] = d + o), a;
    }, {});
    for (const [a, r] of Object.entries(n)) {
      const i = JF.toByteArray(a);
      this.rankMap.set(i.join(","), r), this.textMap.set(r, i);
    }
    this.specialTokens = { ...t.special_tokens, ...e }, this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((a, [r, i]) => (a[i] = this.textEncoder.encode(r), a), {});
  }
  encode(t, e = [], n = "all") {
    const a = new RegExp(this.patStr, "ug"), r = Lb.specialTokenRegex(
      Object.keys(this.specialTokens)
    ), i = [], s = new Set(
      e === "all" ? Object.keys(this.specialTokens) : e
    ), u = new Set(
      n === "all" ? Object.keys(this.specialTokens).filter(
        (f) => !s.has(f)
      ) : n
    );
    if (u.size > 0) {
      const f = Lb.specialTokenRegex([
        ...u
      ]), o = t.match(f);
      if (o != null)
        throw new Error(
          `The text contains a special token that is not allowed: ${o[0]}`
        );
    }
    let d = 0;
    for (; ; ) {
      let f = null, o = d;
      for (; r.lastIndex = o, f = r.exec(t), !(f == null || s.has(f[0])); )
        o = f.index + 1;
      const c = f?.index ?? t.length;
      for (const p of t.substring(d, c).matchAll(a)) {
        const l = this.textEncoder.encode(p[0]), m = this.rankMap.get(l.join(","));
        if (m != null) {
          i.push(m);
          continue;
        }
        i.push(...VF(l, this.rankMap));
      }
      if (f == null)
        break;
      let h = this.specialTokens[f[0]];
      i.push(h), d = f.index + f[0].length;
    }
    return i;
  }
  decode(t) {
    const e = [];
    let n = 0;
    for (let i = 0; i < t.length; ++i) {
      const s = t[i], u = this.textMap.get(s) ?? this.inverseSpecialTokens[s];
      u != null && (e.push(u), n += u.length);
    }
    const a = new Uint8Array(n);
    let r = 0;
    for (const i of e)
      a.set(i, r), r += i.length;
    return this.textDecoder.decode(a);
  }
}, aR = Lb;
BF(aR, "specialTokenRegex", (t) => new RegExp(t.map((e) => zF(e)).join("|"), "g"));
function ZF(t) {
  switch (t) {
    case "gpt2":
      return "gpt2";
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003":
      return "p50k_base";
    case "code-davinci-edit-001":
    case "text-davinci-edit-001":
      return "p50k_edit";
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001":
      return "r50k_base";
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002":
    case "text-embedding-3-small":
    case "text-embedding-3-large":
      return "cl100k_base";
    case "gpt-4o":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
    case "gpt-4o-2024-11-20":
    case "gpt-4o-mini-2024-07-18":
    case "gpt-4o-mini":
    case "o1":
    case "o1-2024-12-17":
    case "o1-mini":
    case "o1-preview":
    case "o1-preview-2024-09-12":
    case "o1-mini-2024-09-12":
    case "o3-mini":
    case "o3-mini-2025-01-31":
    case "chatgpt-4o-latest":
    case "gpt-4o-realtime":
    case "gpt-4o-realtime-preview-2024-10-01":
      return "o200k_base";
    default:
      throw new Error("Unknown model");
  }
}
const hf = {}, KF = /* @__PURE__ */ new Qo({});
async function iR(t) {
  return t in hf || (hf[t] = KF.fetch(`https://tiktoken.pages.dev/js/${t}.json`).then((e) => e.json()).then((e) => new aR(e)).catch((e) => {
    throw delete hf[t], e;
  })), await hf[t];
}
async function sR(t) {
  return iR(ZF(t));
}
const Ug = (t) => t.startsWith("gpt-3.5-turbo-16k") ? "gpt-3.5-turbo-16k" : t.startsWith("gpt-3.5-turbo-") ? "gpt-3.5-turbo" : t.startsWith("gpt-4-32k") ? "gpt-4-32k" : t.startsWith("gpt-4-") ? "gpt-4" : t.startsWith("gpt-4o") ? "gpt-4o" : t, HF = (t) => {
  switch (Ug(t)) {
    case "gpt-3.5-turbo-16k":
      return 16384;
    case "gpt-3.5-turbo":
      return 4096;
    case "gpt-4-32k":
      return 32768;
    case "gpt-4":
      return 8192;
    case "text-davinci-003":
      return 4097;
    case "text-curie-001":
      return 2048;
    case "text-babbage-001":
      return 2048;
    case "text-ada-001":
      return 2048;
    case "code-davinci-002":
      return 8e3;
    case "code-cushman-001":
      return 2048;
    default:
      return 4097;
  }
};
function tc(t) {
  return typeof t != "object" || !t ? !1 : !!("type" in t && t.type === "function" && "function" in t && typeof t.function == "object" && t.function && "name" in t.function && "parameters" in t.function);
}
const GF = async ({ prompt: t, modelName: e }) => {
  let n;
  try {
    n = (await sR(Ug(e))).encode(t).length;
  } catch {
    console.warn("Failed to calculate number of tokens, falling back to approximate count"), n = Math.ceil(t.length / 4);
  }
  return HF(e) - n;
}, WF = () => !1;
class Bg extends Te {
  get lc_attributes() {
    return {
      callbacks: void 0,
      verbose: void 0
    };
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "verbose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.verbose = e.verbose ?? WF(), this.callbacks = e.callbacks, this.tags = e.tags ?? [], this.metadata = e.metadata ?? {};
  }
}
class xg extends Bg {
  /**
   * Keys that the language model accepts as call options.
   */
  get callKeys() {
    return ["stop", "timeout", "signal", "tags", "metadata", "callbacks"];
  }
  constructor({ callbacks: e, callbackManager: n, ...a }) {
    const { cache: r, ...i } = a;
    super({
      callbacks: e ?? n,
      ...i
    }), Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cache", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_encoding", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), typeof r == "object" ? this.cache = r : r ? this.cache = Jg.global() : this.cache = void 0, this.caller = new Qo(a ?? {});
  }
  async getNumTokens(e) {
    if (typeof e != "string")
      return 0;
    let n = Math.ceil(e.length / 4);
    if (!this._encoding)
      try {
        this._encoding = await sR("modelName" in this ? Ug(this.modelName) : "gpt2");
      } catch (a) {
        console.warn("Failed to calculate number of tokens, falling back to approximate count", a);
      }
    if (this._encoding)
      try {
        n = this._encoding.encode(e).length;
      } catch (a) {
        console.warn("Failed to calculate number of tokens, falling back to approximate count", a);
      }
    return n;
  }
  static _convertInputToPromptValue(e) {
    return typeof e == "string" ? new nR(e) : Array.isArray(e) ? new rR(e.map(io)) : e;
  }
  /**
   * Get the identifying parameters of the LLM.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _identifyingParams() {
    return {};
  }
  /**
   * Create a unique cache key for a specific call to a specific language model.
   * @param callOptions Call options for the model
   * @returns A unique cache key.
   */
  _getSerializedCacheKeyParametersForCall({ config: e, ...n }) {
    const a = {
      ...this._identifyingParams(),
      ...n,
      _type: this._llmType(),
      _model: this._modelType()
    };
    return Object.entries(a).filter(([s, u]) => u !== void 0).map(([s, u]) => `${s}:${JSON.stringify(u)}`).sort().join(",");
  }
  /**
   * @deprecated
   * Return a json-like object representing this LLM.
   */
  serialize() {
    return {
      ...this._identifyingParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  /**
   * @deprecated
   * Load an LLM from a json-like object describing it.
   */
  static async deserialize(e) {
    throw new Error("Use .toJSON() instead");
  }
}
class Ut extends Te {
  static lc_name() {
    return "RunnablePassthrough";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "runnables"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "func", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), e && (this.func = e.func);
  }
  async invoke(e, n) {
    const a = Ce(n);
    return this.func && await this.func(e, a), this._callWithConfig((r) => Promise.resolve(r), e, a);
  }
  async *transform(e, n) {
    const a = Ce(n);
    let r, i = !0;
    for await (const s of this._transformStreamWithConfig(e, (u) => u, a))
      if (yield s, i)
        if (r === void 0)
          r = s;
        else
          try {
            r = an(r, s);
          } catch {
            r = void 0, i = !1;
          }
    this.func && r !== void 0 && await this.func(r, a);
  }
  /**
   * A runnable that assigns key-value pairs to the input.
   *
   * The example below shows how you could use it with an inline function.
   *
   * @example
   * ```typescript
   * const prompt =
   *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}
   * Question: {question}
   * SQL Query:`);
   *
   * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`
   * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.
   * // In this case, we're passing the schema.
   * const sqlQueryGeneratorChain = RunnableSequence.from([
   *   RunnablePassthrough.assign({
   *     schema: async () => db.getTableInfo(),
   *   }),
   *   prompt,
   *   new ChatOpenAI({}).bind({ stop: ["\nSQLResult:"] }),
   *   new StringOutputParser(),
   * ]);
   * const result = await sqlQueryGeneratorChain.invoke({
   *   question: "How many employees are there?",
   * });
   * ```
   */
  static assign(e) {
    return new tR(new ec({ steps: e }));
  }
}
function Nd(t) {
  return typeof t?.parse == "function";
}
class kn extends xg {
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "chat_models", this._llmType()]
    }), Object.defineProperty(this, "disableStreaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _separateRunnableConfigFromCallOptionsCompat(e) {
    const [n, a] = super._separateRunnableConfigFromCallOptions(e);
    return a.signal = n.signal, [n, a];
  }
  /**
   * Invokes the chat model with a single input.
   * @param input The input for the language model.
   * @param options The call options.
   * @returns A Promise that resolves to a BaseMessageChunk.
   */
  async invoke(e, n) {
    const a = kn._convertInputToPromptValue(e);
    return (await this.generatePrompt([a], n, n?.callbacks)).generations[0][0].message;
  }
  // eslint-disable-next-line require-yield
  async *_streamResponseChunks(e, n, a) {
    throw new Error("Not implemented.");
  }
  async *_streamIterator(e, n) {
    if (this._streamResponseChunks === kn.prototype._streamResponseChunks || this.disableStreaming)
      yield this.invoke(e, n);
    else {
      const r = kn._convertInputToPromptValue(e).toChatMessages(), [i, s] = this._separateRunnableConfigFromCallOptionsCompat(n), u = {
        ...i.metadata,
        ...this.getLsParams(s)
      }, d = await it.configure(i.callbacks, this.callbacks, i.tags, this.tags, u, this.metadata, { verbose: this.verbose }), f = {
        options: s,
        invocation_params: this?.invocationParams(s),
        batch_size: 1
      }, o = await d?.handleChatModelStart(this.toJSON(), [r], i.runId, void 0, f, void 0, void 0, i.runName);
      let c, h;
      try {
        for await (const p of this._streamResponseChunks(r, s, o?.[0])) {
          if (p.message.id == null) {
            const l = o?.at(0)?.runId;
            l != null && p.message._updateId(`run-${l}`);
          }
          p.message.response_metadata = {
            ...p.generationInfo,
            ...p.message.response_metadata
          }, yield p.message, c ? c = c.concat(p) : c = p, My(p.message) && p.message.usage_metadata !== void 0 && (h = {
            tokenUsage: {
              promptTokens: p.message.usage_metadata.input_tokens,
              completionTokens: p.message.usage_metadata.output_tokens,
              totalTokens: p.message.usage_metadata.total_tokens
            }
          });
        }
      } catch (p) {
        throw await Promise.all((o ?? []).map((l) => l?.handleLLMError(p))), p;
      }
      await Promise.all((o ?? []).map((p) => p?.handleLLMEnd({
        // TODO: Remove cast after figuring out inheritance
        generations: [[c]],
        llmOutput: h
      })));
    }
  }
  getLsParams(e) {
    const n = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
    return {
      ls_model_type: "chat",
      ls_stop: e.stop,
      ls_provider: n
    };
  }
  /** @ignore */
  async _generateUncached(e, n, a, r) {
    const i = e.map((c) => c.map(io));
    let s;
    if (r !== void 0 && r.length === i.length)
      s = r;
    else {
      const c = {
        ...a.metadata,
        ...this.getLsParams(n)
      }, h = await it.configure(a.callbacks, this.callbacks, a.tags, this.tags, c, this.metadata, { verbose: this.verbose }), p = {
        options: n,
        invocation_params: this?.invocationParams(n),
        batch_size: 1
      };
      s = await h?.handleChatModelStart(this.toJSON(), i, a.runId, void 0, p, void 0, void 0, a.runName);
    }
    const u = [], d = [];
    if (!!s?.[0].handlers.find(xC) && !this.disableStreaming && i.length === 1 && this._streamResponseChunks !== kn.prototype._streamResponseChunks)
      try {
        const c = await this._streamResponseChunks(i[0], n, s?.[0]);
        let h, p;
        for await (const l of c) {
          if (l.message.id == null) {
            const m = s?.at(0)?.runId;
            m != null && l.message._updateId(`run-${m}`);
          }
          h === void 0 ? h = l : h = an(h, l), My(l.message) && l.message.usage_metadata !== void 0 && (p = {
            tokenUsage: {
              promptTokens: l.message.usage_metadata.input_tokens,
              completionTokens: l.message.usage_metadata.output_tokens,
              totalTokens: l.message.usage_metadata.total_tokens
            }
          });
        }
        if (h === void 0)
          throw new Error("Received empty response from chat model call.");
        u.push([h]), await s?.[0].handleLLMEnd({
          generations: u,
          llmOutput: p
        });
      } catch (c) {
        throw await s?.[0].handleLLMError(c), c;
      }
    else {
      const c = await Promise.allSettled(i.map((h, p) => this._generate(h, { ...n, promptIndex: p }, s?.[p])));
      await Promise.all(c.map(async (h, p) => {
        if (h.status === "fulfilled") {
          const l = h.value;
          for (const m of l.generations) {
            if (m.message.id == null) {
              const b = s?.at(0)?.runId;
              b != null && m.message._updateId(`run-${b}`);
            }
            m.message.response_metadata = {
              ...m.generationInfo,
              ...m.message.response_metadata
            };
          }
          return l.generations.length === 1 && (l.generations[0].message.response_metadata = {
            ...l.llmOutput,
            ...l.generations[0].message.response_metadata
          }), u[p] = l.generations, d[p] = l.llmOutput, s?.[p]?.handleLLMEnd({
            generations: [l.generations],
            llmOutput: l.llmOutput
          });
        } else
          return await s?.[p]?.handleLLMError(h.reason), Promise.reject(h.reason);
      }));
    }
    const o = {
      generations: u,
      llmOutput: d.length ? this._combineLLMOutput?.(...d) : void 0
    };
    return Object.defineProperty(o, pd, {
      value: s ? { runIds: s?.map((c) => c.runId) } : void 0,
      configurable: !0
    }), o;
  }
  async _generateCached({ messages: e, cache: n, llmStringKey: a, parsedOptions: r, handledOptions: i }) {
    const s = e.map((b) => b.map(io)), u = {
      ...i.metadata,
      ...this.getLsParams(r)
    }, d = await it.configure(i.callbacks, this.callbacks, i.tags, this.tags, u, this.metadata, { verbose: this.verbose }), f = {
      options: r,
      invocation_params: this?.invocationParams(r),
      batch_size: 1
    }, o = await d?.handleChatModelStart(this.toJSON(), s, i.runId, void 0, f, void 0, void 0, i.runName), c = [], p = (await Promise.allSettled(s.map(async (b, g) => {
      const _ = kn._convertInputToPromptValue(b).toString(), P = await n.lookup(_, a);
      return P == null && c.push(g), P;
    }))).map((b, g) => ({ result: b, runManager: o?.[g] })).filter(({ result: b }) => b.status === "fulfilled" && b.value != null || b.status === "rejected"), l = [];
    await Promise.all(p.map(async ({ result: b, runManager: g }, _) => {
      if (b.status === "fulfilled") {
        const P = b.value;
        return l[_] = P.map((R) => ("message" in R && nn(R.message) && uo(R.message) && (R.message.usage_metadata = {
          input_tokens: 0,
          output_tokens: 0,
          total_tokens: 0
        }), R.generationInfo = {
          ...R.generationInfo,
          tokenUsage: {}
        }, R)), P.length && await g?.handleLLMNewToken(P[0].text), g?.handleLLMEnd({
          generations: [P]
        }, void 0, void 0, void 0, {
          cached: !0
        });
      } else
        return await g?.handleLLMError(b.reason, void 0, void 0, void 0, {
          cached: !0
        }), Promise.reject(b.reason);
    }));
    const m = {
      generations: l,
      missingPromptIndices: c,
      startedRunManagers: o
    };
    return Object.defineProperty(m, pd, {
      value: o ? { runIds: o?.map((b) => b.runId) } : void 0,
      configurable: !0
    }), m;
  }
  /**
   * Generates chat based on the input messages.
   * @param messages An array of arrays of BaseMessage instances.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to an LLMResult.
   */
  async generate(e, n, a) {
    let r;
    Array.isArray(n) ? r = { stop: n } : r = n;
    const i = e.map((l) => l.map(io)), [s, u] = this._separateRunnableConfigFromCallOptionsCompat(r);
    if (s.callbacks = s.callbacks ?? a, !this.cache)
      return this._generateUncached(i, u, s);
    const { cache: d } = this, f = this._getSerializedCacheKeyParametersForCall(u), { generations: o, missingPromptIndices: c, startedRunManagers: h } = await this._generateCached({
      messages: i,
      cache: d,
      llmStringKey: f,
      parsedOptions: u,
      handledOptions: s
    });
    let p = {};
    if (c.length > 0) {
      const l = await this._generateUncached(c.map((m) => i[m]), u, s, h !== void 0 ? c.map((m) => h?.[m]) : void 0);
      await Promise.all(l.generations.map(async (m, b) => {
        const g = c[b];
        o[g] = m;
        const _ = kn._convertInputToPromptValue(i[g]).toString();
        return d.update(_, f, m);
      })), p = l.llmOutput ?? {};
    }
    return { generations: o, llmOutput: p };
  }
  /**
   * Get the parameters used to invoke the model
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  invocationParams(e) {
    return {};
  }
  _modelType() {
    return "base_chat_model";
  }
  /**
   * @deprecated
   * Return a json-like object representing this LLM.
   */
  serialize() {
    return {
      ...this.invocationParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  /**
   * Generates a prompt based on the input prompt values.
   * @param promptValues An array of BasePromptValue instances.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to an LLMResult.
   */
  async generatePrompt(e, n, a) {
    const r = e.map((i) => i.toChatMessages());
    return this.generate(r, n, a);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Makes a single call to the chat model.
   * @param messages An array of BaseMessage instances.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to a BaseMessage.
   */
  async call(e, n, a) {
    return (await this.generate([e.map(io)], n, a)).generations[0][0].message;
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Makes a single call to the chat model with a prompt value.
   * @param promptValue The value of the prompt.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to a BaseMessage.
   */
  async callPrompt(e, n, a) {
    const r = e.toChatMessages();
    return this.call(r, n, a);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Predicts the next message based on the input messages.
   * @param messages An array of BaseMessage instances.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to a BaseMessage.
   */
  async predictMessages(e, n, a) {
    return this.call(e, n, a);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Predicts the next message based on a text input.
   * @param text The text input.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to a string.
   */
  async predict(e, n, a) {
    const r = new mr(e), i = await this.call([r], n, a);
    if (typeof i.content != "string")
      throw new Error("Cannot use predict when output is not a string.");
    return i.content;
  }
  withStructuredOutput(e, n) {
    if (typeof this.bindTools != "function")
      throw new Error('Chat model must implement ".bindTools()" to use withStructuredOutput.');
    if (n?.strict)
      throw new Error('"strict" mode is not supported for this model by default.');
    const a = e, r = n?.name, i = a.description ?? "A function available to call.", s = n?.method, u = n?.includeRaw;
    if (s === "jsonMode")
      throw new Error('Base withStructuredOutput implementation only supports "functionCalling" as a method.');
    let d = r ?? "extract", f;
    Nd(a) ? f = [
      {
        type: "function",
        function: {
          name: d,
          description: i,
          parameters: xn(a)
        }
      }
    ] : ("name" in a && (d = a.name), f = [
      {
        type: "function",
        function: {
          name: d,
          description: i,
          parameters: a
        }
      }
    ]);
    const o = this.bindTools(f), c = Yo.from((m) => {
      if (!m.tool_calls || m.tool_calls.length === 0)
        throw new Error("No tool calls found in the response.");
      const b = m.tool_calls.find((g) => g.name === d);
      if (!b)
        throw new Error(`No tool call found with name ${d}.`);
      return b.args;
    });
    if (!u)
      return o.pipe(c).withConfig({
        runName: "StructuredOutput"
      });
    const h = Ut.assign({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parsed: (m, b) => c.invoke(m.raw, b)
    }), p = Ut.assign({
      parsed: () => null
    }), l = h.withFallbacks({
      fallbacks: [p]
    });
    return gt.from([
      {
        raw: o
      },
      l
    ]).withConfig({
      runName: "StructuredOutputRunnable"
    });
  }
}
class oR extends Te {
  /**
   * Parses the result of an LLM call with a given prompt. By default, it
   * simply calls `parseResult`.
   * @param generations The generations from an LLM call.
   * @param _prompt The prompt used in the LLM call.
   * @param callbacks Optional callbacks.
   * @returns A promise of the parsed output.
   */
  parseResultWithPrompt(e, n, a) {
    return this.parseResult(e, a);
  }
  _baseMessageToString(e) {
    return typeof e.content == "string" ? e.content : this._baseMessageContentToString(e.content);
  }
  _baseMessageContentToString(e) {
    return JSON.stringify(e);
  }
  /**
   * Calls the parser with a given input and optional configuration options.
   * If the input is a string, it creates a generation with the input as
   * text and calls `parseResult`. If the input is a `BaseMessage`, it
   * creates a generation with the input as a message and the content of the
   * input as text, and then calls `parseResult`.
   * @param input The input to the parser, which can be a string or a `BaseMessage`.
   * @param options Optional configuration options.
   * @returns A promise of the parsed output.
   */
  async invoke(e, n) {
    return typeof e == "string" ? this._callWithConfig(async (a, r) => this.parseResult([{ text: a }], r?.callbacks), e, { ...n, runType: "parser" }) : this._callWithConfig(async (a, r) => this.parseResult([
      {
        message: a,
        text: this._baseMessageToString(a)
      }
    ], r?.callbacks), e, { ...n, runType: "parser" });
  }
}
class Fd extends oR {
  parseResult(e, n) {
    return this.parse(e[0].text, n);
  }
  async parseWithPrompt(e, n, a) {
    return this.parse(e, a);
  }
  /**
   * Return the string type key uniquely identifying this class of parser
   */
  _type() {
    throw new Error("_type not implemented");
  }
}
class Bt extends Error {
  constructor(e, n, a, r = !1) {
    if (super(e), Object.defineProperty(this, "llmOutput", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "observation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sendToLLM", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.llmOutput = n, this.observation = a, this.sendToLLM = r, r && (a === void 0 || n === void 0))
      throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
    op(this, "OUTPUT_PARSING_FAILURE");
  }
}
function Ub(t, e) {
  const n = typeof t;
  if (n !== typeof e)
    return !1;
  if (Array.isArray(t)) {
    if (!Array.isArray(e))
      return !1;
    const a = t.length;
    if (a !== e.length)
      return !1;
    for (let r = 0; r < a; r++)
      if (!Ub(t[r], e[r]))
        return !1;
    return !0;
  }
  if (n === "object") {
    if (!t || !e)
      return t === e;
    const a = Object.keys(t), r = Object.keys(e);
    if (a.length !== r.length)
      return !1;
    for (const s of a)
      if (!Ub(t[s], e[s]))
        return !1;
    return !0;
  }
  return t === e;
}
class Vg extends Fd {
  async *_transform(e) {
    for await (const n of e)
      typeof n == "string" ? yield this.parseResult([{ text: n }]) : yield this.parseResult([
        {
          message: n,
          text: this._baseMessageToString(n)
        }
      ]);
  }
  /**
   * Transforms an asynchronous generator of input into an asynchronous
   * generator of parsed output.
   * @param inputGenerator An asynchronous generator of input.
   * @param options A configuration object.
   * @returns An asynchronous generator of parsed output.
   */
  async *transform(e, n) {
    yield* this._transformStreamWithConfig(e, this._transform.bind(this), {
      ...n,
      runType: "parser"
    });
  }
}
class uR extends Vg {
  constructor(e) {
    super(e), Object.defineProperty(this, "diff", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.diff = e?.diff ?? this.diff;
  }
  async *_transform(e) {
    let n, a;
    for await (const r of e) {
      if (typeof r != "string" && typeof r.content != "string")
        throw new Error("Cannot handle non-string output.");
      let i;
      if (Pb(r)) {
        if (typeof r.content != "string")
          throw new Error("Cannot handle non-string message output.");
        i = new On({
          message: r,
          text: r.content
        });
      } else if (nn(r)) {
        if (typeof r.content != "string")
          throw new Error("Cannot handle non-string message output.");
        i = new On({
          message: CE(r),
          text: r.content
        });
      } else
        i = new fa({ text: r });
      a === void 0 ? a = i : a = a.concat(i);
      const s = await this.parsePartialResult([a]);
      s != null && !Ub(s, n) && (this.diff ? yield this._diff(n, s) : yield s, n = s);
    }
  }
  getFormatInstructions() {
    return "";
  }
}
class XF extends Vg {
  constructor() {
    super(...arguments), Object.defineProperty(this, "re", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  async *_transform(e) {
    let n = "";
    for await (const a of e)
      if (typeof a == "string" ? n += a : n += a.content, this.re) {
        const r = [...n.matchAll(this.re)];
        if (r.length > 1) {
          let i = 0;
          for (const s of r.slice(0, -1))
            yield [s[1]], i += (s.index ?? 0) + s[0].length;
          n = n.slice(i);
        }
      } else {
        const r = await this.parse(n);
        if (r.length > 1) {
          for (const i of r.slice(0, -1))
            yield [i];
          n = r[r.length - 1];
        }
      }
    for (const a of await this.parse(n))
      yield [a];
  }
}
class iV extends XF {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "output_parsers", "list"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
  }
  static lc_name() {
    return "CommaSeparatedListOutputParser";
  }
  /**
   * Parses the given text into an array of strings, using a comma as the
   * separator. If the parsing fails, throws an OutputParserException.
   * @param text The text to parse.
   * @returns An array of strings obtained by splitting the input text at each comma.
   */
  async parse(e) {
    try {
      return e.trim().split(",").map((n) => n.trim());
    } catch {
      throw new Bt(`Could not parse output: ${e}`, e);
    }
  }
  /**
   * Provides instructions on the expected format of the response for the
   * CommaSeparatedListOutputParser.
   * @returns A string containing instructions on the expected format of the response.
   */
  getFormatInstructions() {
    return "Your response should be a list of comma separated values, eg: `foo, bar, baz`";
  }
}
class sV extends Vg {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "output_parsers", "string"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
  }
  static lc_name() {
    return "StrOutputParser";
  }
  /**
   * Parses a string output from an LLM call. This method is meant to be
   * implemented by subclasses to define how a string output from an LLM
   * should be parsed.
   * @param text The string output from an LLM call.
   * @param callbacks Optional callbacks.
   * @returns A promise of the parsed output.
   */
  parse(e) {
    return Promise.resolve(e);
  }
  getFormatInstructions() {
    return "";
  }
  _textContentToString(e) {
    return e.text;
  }
  _imageUrlContentToString(e) {
    throw new Error('Cannot coerce a multimodal "image_url" message part into a string.');
  }
  _messageContentComplexToString(e) {
    switch (e.type) {
      case "text":
      case "text_delta":
        if ("text" in e)
          return this._textContentToString(e);
        break;
      case "image_url":
        if ("image_url" in e)
          return this._imageUrlContentToString(e);
        break;
      default:
        throw new Error(`Cannot coerce "${e.type}" message part into a string.`);
    }
    throw new Error(`Invalid content type: ${e.type}`);
  }
  _baseMessageContentToString(e) {
    return e.reduce((n, a) => n + this._messageContentComplexToString(a), "");
  }
}
class $h extends Fd {
  static lc_name() {
    return "StructuredOutputParser";
  }
  toJSON() {
    return this.toJSONNotImplemented();
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "schema", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "output_parsers", "structured"]
    });
  }
  /**
   * Creates a new StructuredOutputParser from a Zod schema.
   * @param schema The Zod schema which the output should match
   * @returns A new instance of StructuredOutputParser.
   */
  static fromZodSchema(e) {
    return new this(e);
  }
  /**
   * Creates a new StructuredOutputParser from a set of names and
   * descriptions.
   * @param schemas An object where each key is a name and each value is a description
   * @returns A new instance of StructuredOutputParser.
   */
  static fromNamesAndDescriptions(e) {
    const n = wn.object(Object.fromEntries(Object.entries(e).map(([a, r]) => [a, wn.string().describe(r)])));
    return new this(n);
  }
  /**
   * Returns a markdown code snippet with a JSON object formatted according
   * to the schema.
   * @param options Optional. The options for formatting the instructions
   * @returns A markdown code snippet with a JSON object formatted according to the schema.
   */
  getFormatInstructions() {
    return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(xn(this.schema))}
\`\`\`
`;
  }
  /**
   * Parses the given text according to the schema.
   * @param text The text to parse
   * @returns The parsed output.
   */
  async parse(e) {
    try {
      const a = (e.includes("```") ? e.trim().split(/```(?:json)?/)[1] : e.trim()).replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (r, i) => `"${i.replace(/\n/g, "\\n")}"`).replace(/\n/g, "");
      return await this.schema.parseAsync(JSON.parse(a));
    } catch (n) {
      throw new Bt(`Failed to parse. Text: "${e}". Error: ${n}`, e);
    }
  }
}
class Mh extends uR {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "output_parsers"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
  }
  static lc_name() {
    return "JsonOutputParser";
  }
  _diff(e, n) {
    if (n)
      return e ? W1(e, n) : [{ op: "replace", path: "", value: n }];
  }
  // This should actually return Partial<T>, but there's no way
  // to specify emitted chunks as instances separate from the main output type.
  async parsePartialResult(e) {
    return Ry(e[0].text);
  }
  async parse(e) {
    return Ry(e, JSON.parse);
  }
  getFormatInstructions() {
    return "";
  }
}
function dp(t, e) {
  if (t.function === void 0)
    return;
  let n;
  if (e?.partial)
    try {
      n = Eg(t.function.arguments ?? "{}");
    } catch {
      return;
    }
  else
    try {
      n = JSON.parse(t.function.arguments);
    } catch (r) {
      throw new Bt([
        `Function "${t.function.name}" arguments:`,
        "",
        t.function.arguments,
        "",
        "are not valid JSON.",
        `Error: ${r.message}`
      ].join(`
`));
    }
  const a = {
    name: t.function.name,
    args: n,
    type: "tool_call"
  };
  return e?.returnId && (a.id = t.id), a;
}
function cR(t) {
  if (t.id === void 0)
    throw new Error('All OpenAI tool calls must have an "id" field.');
  return {
    id: t.id,
    type: "function",
    function: {
      name: t.name,
      arguments: JSON.stringify(t.args)
    }
  };
}
function zg(t, e) {
  return {
    name: t.function?.name,
    args: t.function?.arguments,
    id: t.id,
    error: e,
    type: "invalid_tool_call"
  };
}
class QF extends uR {
  static lc_name() {
    return "JsonOutputToolsParser";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "returnId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "output_parsers", "openai_tools"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.returnId = e?.returnId ?? this.returnId;
  }
  _diff() {
    throw new Error("Not supported.");
  }
  async parse() {
    throw new Error("Not implemented.");
  }
  async parseResult(e) {
    return await this.parsePartialResult(e, !1);
  }
  /**
   * Parses the output and returns a JSON object. If `argsOnly` is true,
   * only the arguments of the function call are returned.
   * @param generations The output of the LLM to parse.
   * @returns A JSON object representation of the function call or its arguments.
   */
  async parsePartialResult(e, n = !0) {
    const a = e[0].message;
    let r;
    if (uo(a) && a.tool_calls?.length ? r = a.tool_calls.map((s) => {
      const { id: u, ...d } = s;
      return this.returnId ? {
        id: u,
        ...d
      } : d;
    }) : a.additional_kwargs.tool_calls !== void 0 && (r = JSON.parse(JSON.stringify(a.additional_kwargs.tool_calls)).map((u) => dp(u, { returnId: this.returnId, partial: n }))), !r)
      return [];
    const i = [];
    for (const s of r)
      if (s !== void 0) {
        const u = {
          type: s.name,
          args: s.args,
          id: s.id
        };
        i.push(u);
      }
    return i;
  }
}
class Ah extends QF {
  static lc_name() {
    return "JsonOutputKeyToolsParser";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "output_parsers", "openai_tools"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "returnId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "keyName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnSingle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "zodSchema", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.keyName = e.keyName, this.returnSingle = e.returnSingle ?? this.returnSingle, this.zodSchema = e.zodSchema;
  }
  async _validateResult(e) {
    if (this.zodSchema === void 0)
      return e;
    const n = await this.zodSchema.safeParseAsync(e);
    if (n.success)
      return n.data;
    throw new Bt(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(n.error.errors)}`, JSON.stringify(e, null, 2));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async parsePartialResult(e) {
    const a = (await super.parsePartialResult(e)).filter((i) => i.type === this.keyName);
    let r = a;
    if (a.length)
      return this.returnId || (r = a.map((i) => i.args)), this.returnSingle ? r[0] : r;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async parseResult(e) {
    const a = (await super.parsePartialResult(e, !1)).filter((s) => s.type === this.keyName);
    let r = a;
    return a.length ? (this.returnId || (r = a.map((s) => s.args)), this.returnSingle ? this._validateResult(r[0]) : await Promise.all(r.map((s) => this._validateResult(s)))) : void 0;
  }
}
const YF = Symbol("Let zodToJsonSchema decide on which parser to use"), wv = {
  name: void 0,
  $refStrategy: "root",
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  nullableStrategy: "from-target",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, ek = (t) => typeof t == "string" ? {
  ...wv,
  basePath: ["#"],
  definitions: {},
  name: t
} : {
  ...wv,
  basePath: ["#"],
  definitions: {},
  ...t
}, Bb = (t) => "_def" in t ? t._def : t;
function tk(t) {
  if (!t)
    return !0;
  for (const e in t)
    return !1;
  return !0;
}
const nk = (t) => {
  const e = ek(t), n = e.name !== void 0 ? [...e.basePath, e.definitionPath, e.name] : e.basePath;
  return {
    ...e,
    currentPath: n,
    propertyPath: void 0,
    seenRefs: /* @__PURE__ */ new Set(),
    seen: new Map(Object.entries(e.definitions).map(([a, r]) => [
      Bb(r),
      {
        def: Bb(r),
        path: [...e.basePath, e.definitionPath, a],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function lR(t, e, n, a) {
  a?.errorMessages && n && (t.errorMessage = {
    ...t.errorMessage,
    [e]: n
  });
}
function Be(t, e, n, a, r) {
  t[e] = n, lR(t, e, a, r);
}
function rk() {
  return {};
}
function ak(t, e) {
  const n = {
    type: "array"
  };
  return t.type?._def?.typeName !== K.ZodAny && (n.items = Ae(t.type._def, {
    ...e,
    currentPath: [...e.currentPath, "items"]
  })), t.minLength && Be(n, "minItems", t.minLength.value, t.minLength.message, e), t.maxLength && Be(n, "maxItems", t.maxLength.value, t.maxLength.message, e), t.exactLength && (Be(n, "minItems", t.exactLength.value, t.exactLength.message, e), Be(n, "maxItems", t.exactLength.value, t.exactLength.message, e)), n;
}
function ik(t, e) {
  const n = {
    type: "integer",
    format: "int64"
  };
  if (!t.checks)
    return n;
  for (const a of t.checks)
    switch (a.kind) {
      case "min":
        e.target === "jsonSchema7" ? a.inclusive ? Be(n, "minimum", a.value, a.message, e) : Be(n, "exclusiveMinimum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMinimum = !0), Be(n, "minimum", a.value, a.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? a.inclusive ? Be(n, "maximum", a.value, a.message, e) : Be(n, "exclusiveMaximum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMaximum = !0), Be(n, "maximum", a.value, a.message, e));
        break;
      case "multipleOf":
        Be(n, "multipleOf", a.value, a.message, e);
        break;
    }
  return n;
}
function sk() {
  return {
    type: "boolean"
  };
}
function ok(t, e) {
  return Ae(t.type._def, e);
}
const uk = (t, e) => Ae(t.innerType._def, e);
function dR(t, e, n) {
  const a = n ?? e.dateStrategy;
  if (Array.isArray(a))
    return {
      anyOf: a.map((r, i) => dR(t, e, r))
    };
  switch (a) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return ck(t, e);
  }
}
const ck = (t, e) => {
  const n = {
    type: "integer",
    format: "unix-time"
  };
  if (e.target === "openApi3")
    return n;
  for (const a of t.checks)
    switch (a.kind) {
      case "min":
        Be(
          n,
          "minimum",
          a.value,
          // This is in milliseconds
          a.message,
          e
        );
        break;
      case "max":
        Be(
          n,
          "maximum",
          a.value,
          // This is in milliseconds
          a.message,
          e
        );
        break;
    }
  return n;
};
function lk(t, e) {
  return {
    ...Ae(t.innerType._def, e),
    default: t.defaultValue()
  };
}
function dk(t, e, n) {
  return e.effectStrategy === "input" ? Ae(t.schema._def, e, n) : {};
}
function fk(t) {
  return {
    type: "string",
    enum: [...t.values]
  };
}
const hk = (t) => "type" in t && t.type === "string" ? !1 : "allOf" in t;
function pk(t, e) {
  const n = [
    Ae(t.left._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "0"]
    }),
    Ae(t.right._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "1"]
    })
  ].filter((i) => !!i);
  let a = e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const r = [];
  return n.forEach((i) => {
    if (hk(i))
      r.push(...i.allOf), i.unevaluatedProperties === void 0 && (a = void 0);
    else {
      let s = i;
      if ("additionalProperties" in i && i.additionalProperties === !1) {
        const { additionalProperties: u, ...d } = i;
        s = d;
      } else
        a = void 0;
      r.push(s);
    }
  }), r.length ? {
    allOf: r,
    ...a
  } : void 0;
}
function mk(t, e) {
  const n = typeof t.value;
  return n !== "bigint" && n !== "number" && n !== "boolean" && n !== "string" ? {
    type: Array.isArray(t.value) ? "array" : "object"
  } : e.target === "openApi3" ? {
    type: n === "bigint" ? "integer" : n,
    enum: [t.value]
  } : {
    type: n === "bigint" ? "integer" : n,
    const: t.value
  };
}
let Om;
const So = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (Om === void 0 && (Om = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), Om),
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/
};
function fR(t, e) {
  const n = {
    type: "string"
  };
  function a(r) {
    return e.patternStrategy === "escape" ? bk(r) : r;
  }
  if (t.checks)
    for (const r of t.checks)
      switch (r.kind) {
        case "min":
          Be(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value, r.message, e);
          break;
        case "max":
          Be(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value, r.message, e);
          break;
        case "email":
          switch (e.emailStrategy) {
            case "format:email":
              Xn(n, "email", r.message, e);
              break;
            case "format:idn-email":
              Xn(n, "idn-email", r.message, e);
              break;
            case "pattern:zod":
              Qn(n, So.email, r.message, e);
              break;
          }
          break;
        case "url":
          Xn(n, "uri", r.message, e);
          break;
        case "uuid":
          Xn(n, "uuid", r.message, e);
          break;
        case "regex":
          Qn(n, r.regex, r.message, e);
          break;
        case "cuid":
          Qn(n, So.cuid, r.message, e);
          break;
        case "cuid2":
          Qn(n, So.cuid2, r.message, e);
          break;
        case "startsWith":
          Qn(n, RegExp(`^${a(r.value)}`), r.message, e);
          break;
        case "endsWith":
          Qn(n, RegExp(`${a(r.value)}$`), r.message, e);
          break;
        case "datetime":
          Xn(n, "date-time", r.message, e);
          break;
        case "date":
          Xn(n, "date", r.message, e);
          break;
        case "time":
          Xn(n, "time", r.message, e);
          break;
        case "duration":
          Xn(n, "duration", r.message, e);
          break;
        case "length":
          Be(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value, r.message, e), Be(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value, r.message, e);
          break;
        case "includes": {
          Qn(n, RegExp(a(r.value)), r.message, e);
          break;
        }
        case "ip": {
          r.version !== "v6" && Xn(n, "ipv4", r.message, e), r.version !== "v4" && Xn(n, "ipv6", r.message, e);
          break;
        }
        case "emoji":
          Qn(n, So.emoji, r.message, e);
          break;
        case "ulid": {
          Qn(n, So.ulid, r.message, e);
          break;
        }
        case "base64": {
          switch (e.base64Strategy) {
            case "format:binary": {
              Xn(n, "binary", r.message, e);
              break;
            }
            case "contentEncoding:base64": {
              Be(n, "contentEncoding", "base64", r.message, e);
              break;
            }
            case "pattern:zod": {
              Qn(n, So.base64, r.message, e);
              break;
            }
          }
          break;
        }
        case "nanoid":
          Qn(n, So.nanoid, r.message, e);
      }
  return n;
}
const bk = (t) => Array.from(t).map((e) => /[a-zA-Z0-9]/.test(e) ? e : `\\${e}`).join(""), Xn = (t, e, n, a) => {
  t.format || t.anyOf?.some((r) => r.format) ? (t.anyOf || (t.anyOf = []), t.format && (t.anyOf.push({
    format: t.format,
    ...t.errorMessage && a.errorMessages && {
      errorMessage: { format: t.errorMessage.format }
    }
  }), delete t.format, t.errorMessage && (delete t.errorMessage.format, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.anyOf.push({
    format: e,
    ...n && a.errorMessages && { errorMessage: { format: n } }
  })) : Be(t, "format", e, n, a);
}, Qn = (t, e, n, a) => {
  t.pattern || t.allOf?.some((r) => r.pattern) ? (t.allOf || (t.allOf = []), t.pattern && (t.allOf.push({
    pattern: t.pattern,
    ...t.errorMessage && a.errorMessages && {
      errorMessage: { pattern: t.errorMessage.pattern }
    }
  }), delete t.pattern, t.errorMessage && (delete t.errorMessage.pattern, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.allOf.push({
    pattern: Sv(e, a),
    ...n && a.errorMessages && { errorMessage: { pattern: n } }
  })) : Be(t, "pattern", Sv(e, a), n, a);
}, Sv = (t, e) => {
  const n = typeof t == "function" ? t() : t;
  if (!e.applyRegexFlags || !n.flags)
    return n.source;
  const a = {
    i: n.flags.includes("i"),
    m: n.flags.includes("m"),
    s: n.flags.includes("s")
    // `.` matches newlines
  }, r = a.i ? n.source.toLowerCase() : n.source;
  let i = "", s = !1, u = !1, d = !1;
  for (let f = 0; f < r.length; f++) {
    if (s) {
      i += r[f], s = !1;
      continue;
    }
    if (a.i) {
      if (u) {
        if (r[f].match(/[a-z]/)) {
          d ? (i += r[f], i += `${r[f - 2]}-${r[f]}`.toUpperCase(), d = !1) : r[f + 1] === "-" && r[f + 2]?.match(/[a-z]/) ? (i += r[f], d = !0) : i += `${r[f]}${r[f].toUpperCase()}`;
          continue;
        }
      } else if (r[f].match(/[a-z]/)) {
        i += `[${r[f]}${r[f].toUpperCase()}]`;
        continue;
      }
    }
    if (a.m) {
      if (r[f] === "^") {
        i += `(^|(?<=[\r
]))`;
        continue;
      } else if (r[f] === "$") {
        i += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (a.s && r[f] === ".") {
      i += u ? `${r[f]}\r
` : `[${r[f]}\r
]`;
      continue;
    }
    i += r[f], r[f] === "\\" ? s = !0 : u && r[f] === "]" ? u = !1 : !u && r[f] === "[" && (u = !0);
  }
  try {
    const f = new RegExp(i);
  } catch {
    return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), n.source;
  }
  return i;
};
function hR(t, e) {
  if (e.target === "openApi3" && t.keyType?._def.typeName === K.ZodEnum)
    return {
      type: "object",
      required: t.keyType._def.values,
      properties: t.keyType._def.values.reduce((a, r) => ({
        ...a,
        [r]: Ae(t.valueType._def, {
          ...e,
          currentPath: [...e.currentPath, "properties", r]
        }) ?? {}
      }), {}),
      additionalProperties: !1
    };
  const n = {
    type: "object",
    additionalProperties: Ae(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (e.target === "openApi3")
    return n;
  if (t.keyType?._def.typeName === K.ZodString && t.keyType._def.checks?.length) {
    const a = Object.entries(fR(t.keyType._def, e)).reduce((r, [i, s]) => i === "type" ? r : { ...r, [i]: s }, {});
    return {
      ...n,
      propertyNames: a
    };
  } else if (t.keyType?._def.typeName === K.ZodEnum)
    return {
      ...n,
      propertyNames: {
        enum: t.keyType._def.values
      }
    };
  return n;
}
function gk(t, e) {
  if (e.mapStrategy === "record")
    return hR(t, e);
  const n = Ae(t.keyType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "0"]
  }) || {}, a = Ae(t.valueType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, a],
      minItems: 2,
      maxItems: 2
    }
  };
}
function _k(t) {
  const e = t.values, a = Object.keys(t.values).filter((i) => typeof e[e[i]] != "number").map((i) => e[i]), r = Array.from(new Set(a.map((i) => typeof i)));
  return {
    type: r.length === 1 ? r[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: a
  };
}
function yk() {
  return {
    not: {}
  };
}
function vk(t) {
  return t.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const Eh = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function wk(t, e) {
  if (e.target === "openApi3")
    return Ov(t, e);
  const n = t.options instanceof Map ? Array.from(t.options.values()) : t.options;
  if (n.every((a) => a._def.typeName in Eh && (!a._def.checks || !a._def.checks.length))) {
    const a = n.reduce((r, i) => {
      const s = Eh[i._def.typeName];
      return s && !r.includes(s) ? [...r, s] : r;
    }, []);
    return {
      type: a.length > 1 ? a : a[0]
    };
  } else if (n.every((a) => a._def.typeName === "ZodLiteral" && !a.description)) {
    const a = n.reduce((r, i) => {
      const s = typeof i._def.value;
      switch (s) {
        case "string":
        case "number":
        case "boolean":
          return [...r, s];
        case "bigint":
          return [...r, "integer"];
        case "object":
          if (i._def.value === null)
            return [...r, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return r;
      }
    }, []);
    if (a.length === n.length) {
      const r = a.filter((i, s, u) => u.indexOf(i) === s);
      return {
        type: r.length > 1 ? r : r[0],
        enum: n.reduce((i, s) => i.includes(s._def.value) ? i : [...i, s._def.value], [])
      };
    }
  } else if (n.every((a) => a._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce((a, r) => [...a, ...r._def.values.filter((i) => !a.includes(i))], [])
    };
  return Ov(t, e);
}
const Ov = (t, e) => {
  const n = (t.options instanceof Map ? Array.from(t.options.values()) : t.options).map((a, r) => Ae(a._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", `${r}`]
  })).filter((a) => !!a && (!e.strictUnions || typeof a == "object" && Object.keys(a).length > 0));
  return n.length ? { anyOf: n } : void 0;
};
function Sk(t, e) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(t.innerType._def.typeName) && (!t.innerType._def.checks || !t.innerType._def.checks.length))
    return e.target === "openApi3" || e.nullableStrategy === "property" ? {
      type: Eh[t.innerType._def.typeName],
      nullable: !0
    } : {
      type: [Eh[t.innerType._def.typeName], "null"]
    };
  if (e.target === "openApi3") {
    const a = Ae(t.innerType._def, {
      ...e,
      currentPath: [...e.currentPath]
    });
    return a && "$ref" in a ? { allOf: [a], nullable: !0 } : a && { ...a, nullable: !0 };
  }
  const n = Ae(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "0"]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function Ok(t, e) {
  const n = {
    type: "number"
  };
  if (!t.checks)
    return n;
  for (const a of t.checks)
    switch (a.kind) {
      case "int":
        n.type = "integer", lR(n, "type", a.message, e);
        break;
      case "min":
        e.target === "jsonSchema7" ? a.inclusive ? Be(n, "minimum", a.value, a.message, e) : Be(n, "exclusiveMinimum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMinimum = !0), Be(n, "minimum", a.value, a.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? a.inclusive ? Be(n, "maximum", a.value, a.message, e) : Be(n, "exclusiveMaximum", a.value, a.message, e) : (a.inclusive || (n.exclusiveMaximum = !0), Be(n, "maximum", a.value, a.message, e));
        break;
      case "multipleOf":
        Be(n, "multipleOf", a.value, a.message, e);
        break;
    }
  return n;
}
function jk(t, e) {
  return e.removeAdditionalStrategy === "strict" ? t.catchall._def.typeName === "ZodNever" ? t.unknownKeys !== "strict" : Ae(t.catchall._def, {
    ...e,
    currentPath: [...e.currentPath, "additionalProperties"]
  }) ?? !0 : t.catchall._def.typeName === "ZodNever" ? t.unknownKeys === "passthrough" : Ae(t.catchall._def, {
    ...e,
    currentPath: [...e.currentPath, "additionalProperties"]
  }) ?? !0;
}
function Pk(t, e) {
  const n = {
    type: "object",
    ...Object.entries(t.shape()).reduce((a, [r, i]) => {
      if (i === void 0 || i._def === void 0)
        return a;
      const s = Ae(i._def, {
        ...e,
        currentPath: [...e.currentPath, "properties", r],
        propertyPath: [...e.currentPath, "properties", r]
      });
      return s === void 0 ? a : {
        properties: {
          ...a.properties,
          [r]: s
        },
        required: i.isOptional() && !e.openaiStrictMode ? a.required : [...a.required, r]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: jk(t, e)
  };
  return n.required.length || delete n.required, n;
}
const Ck = (t, e) => {
  if (e.currentPath.toString() === e.propertyPath?.toString())
    return Ae(t.innerType._def, e);
  const n = Ae(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "1"]
  });
  return n ? {
    anyOf: [
      {
        not: {}
      },
      n
    ]
  } : {};
}, Rk = (t, e) => {
  if (e.pipeStrategy === "input")
    return Ae(t.in._def, e);
  if (e.pipeStrategy === "output")
    return Ae(t.out._def, e);
  const n = Ae(t.in._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", "0"]
  }), a = Ae(t.out._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", n ? "1" : "0"]
  });
  return {
    allOf: [n, a].filter((r) => r !== void 0)
  };
};
function Tk(t, e) {
  return Ae(t.type._def, e);
}
function $k(t, e) {
  const a = {
    type: "array",
    uniqueItems: !0,
    items: Ae(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "items"]
    })
  };
  return t.minSize && Be(a, "minItems", t.minSize.value, t.minSize.message, e), t.maxSize && Be(a, "maxItems", t.maxSize.value, t.maxSize.message, e), a;
}
function Mk(t, e) {
  return t.rest ? {
    type: "array",
    minItems: t.items.length,
    items: t.items.map((n, a) => Ae(n._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${a}`]
    })).reduce((n, a) => a === void 0 ? n : [...n, a], []),
    additionalItems: Ae(t.rest._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: t.items.length,
    maxItems: t.items.length,
    items: t.items.map((n, a) => Ae(n._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${a}`]
    })).reduce((n, a) => a === void 0 ? n : [...n, a], [])
  };
}
function Ak() {
  return {
    not: {}
  };
}
function Ek() {
  return {};
}
const Ik = (t, e) => Ae(t.innerType._def, e);
function Ae(t, e, n = !1) {
  const a = e.seen.get(t);
  if (e.override) {
    const s = e.override?.(t, e, a, n);
    if (s !== YF)
      return s;
  }
  if (a && !n) {
    const s = Nk(a, e);
    if (s !== void 0)
      return "$ref" in s && e.seenRefs.add(s.$ref), s;
  }
  const r = { def: t, path: e.currentPath, jsonSchema: void 0 };
  e.seen.set(t, r);
  const i = kk(t, t.typeName, e, n);
  return i && Dk(t, e, i), r.jsonSchema = i, i;
}
const Nk = (t, e) => {
  switch (e.$refStrategy) {
    case "root":
      return { $ref: t.path.join("/") };
    // this case is needed as OpenAI strict mode doesn't support top-level `$ref`s, i.e.
    // the top-level schema *must* be `{"type": "object", "properties": {...}}` but if we ever
    // need to define a `$ref`, relative `$ref`s aren't supported, so we need to extract
    // the schema to `#/definitions/` and reference that.
    //
    // e.g. if we need to reference a schema at
    // `["#","definitions","contactPerson","properties","person1","properties","name"]`
    // then we'll extract it out to `contactPerson_properties_person1_properties_name`
    case "extract-to-root":
      const n = t.path.slice(e.basePath.length + 1).join("_");
      return n !== e.name && e.nameStrategy === "duplicate-ref" && (e.definitions[n] = t.def), { $ref: [...e.basePath, e.definitionPath, n].join("/") };
    case "relative":
      return { $ref: Fk(e.currentPath, t.path) };
    case "none":
    case "seen":
      return t.path.length < e.currentPath.length && t.path.every((a, r) => e.currentPath[r] === a) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`), {}) : e.$refStrategy === "seen" ? {} : void 0;
  }
}, Fk = (t, e) => {
  let n = 0;
  for (; n < t.length && n < e.length && t[n] === e[n]; n++)
    ;
  return [(t.length - n).toString(), ...e.slice(n)].join("/");
}, kk = (t, e, n, a) => {
  switch (e) {
    case K.ZodString:
      return fR(t, n);
    case K.ZodNumber:
      return Ok(t, n);
    case K.ZodObject:
      return Pk(t, n);
    case K.ZodBigInt:
      return ik(t, n);
    case K.ZodBoolean:
      return sk();
    case K.ZodDate:
      return dR(t, n);
    case K.ZodUndefined:
      return Ak();
    case K.ZodNull:
      return vk(n);
    case K.ZodArray:
      return ak(t, n);
    case K.ZodUnion:
    case K.ZodDiscriminatedUnion:
      return wk(t, n);
    case K.ZodIntersection:
      return pk(t, n);
    case K.ZodTuple:
      return Mk(t, n);
    case K.ZodRecord:
      return hR(t, n);
    case K.ZodLiteral:
      return mk(t, n);
    case K.ZodEnum:
      return fk(t);
    case K.ZodNativeEnum:
      return _k(t);
    case K.ZodNullable:
      return Sk(t, n);
    case K.ZodOptional:
      return Ck(t, n);
    case K.ZodMap:
      return gk(t, n);
    case K.ZodSet:
      return $k(t, n);
    case K.ZodLazy:
      return Ae(t.getter()._def, n);
    case K.ZodPromise:
      return Tk(t, n);
    case K.ZodNaN:
    case K.ZodNever:
      return yk();
    case K.ZodEffects:
      return dk(t, n, a);
    case K.ZodAny:
      return rk();
    case K.ZodUnknown:
      return Ek();
    case K.ZodDefault:
      return lk(t, n);
    case K.ZodBranded:
      return ok(t, n);
    case K.ZodReadonly:
      return Ik(t, n);
    case K.ZodCatch:
      return uk(t, n);
    case K.ZodPipeline:
      return Rk(t, n);
    case K.ZodFunction:
    case K.ZodVoid:
    case K.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((r) => {
      })();
  }
}, Dk = (t, e, n) => (t.description && (n.description = t.description, e.markdownDescription && (n.markdownDescription = t.description)), n), qk = (t, e) => {
  const n = nk(e), a = typeof e == "string" ? e : e?.nameStrategy === "title" ? void 0 : e?.name, r = Ae(t._def, a === void 0 ? n : {
    ...n,
    currentPath: [...n.basePath, n.definitionPath, a]
  }, !1) ?? {}, i = typeof e == "object" && e.name !== void 0 && e.nameStrategy === "title" ? e.name : void 0;
  i !== void 0 && (r.title = i);
  const s = (() => {
    if (tk(n.definitions))
      return;
    const d = {}, f = /* @__PURE__ */ new Set();
    for (let o = 0; o < 500; o++) {
      const c = Object.entries(n.definitions).filter(([h]) => !f.has(h));
      if (c.length === 0)
        break;
      for (const [h, p] of c)
        d[h] = Ae(Bb(p), { ...n, currentPath: [...n.basePath, n.definitionPath, h] }, !0) ?? {}, f.add(h);
    }
    return d;
  })(), u = a === void 0 ? s ? {
    ...r,
    [n.definitionPath]: s
  } : r : n.nameStrategy === "duplicate-ref" ? {
    ...r,
    ...s || n.seenRefs.size ? {
      [n.definitionPath]: {
        ...s,
        // only actually duplicate the schema definition if it was ever referenced
        // otherwise the duplication is completely pointless
        ...n.seenRefs.size ? { [a]: r } : void 0
      }
    } : void 0
  } : {
    $ref: [...n.$refStrategy === "relative" ? [] : n.basePath, n.definitionPath, a].join("/"),
    [n.definitionPath]: {
      ...s,
      [a]: r
    }
  };
  return n.target === "jsonSchema7" ? u.$schema = "http://json-schema.org/draft-07/schema#" : n.target === "jsonSchema2019-09" && (u.$schema = "https://json-schema.org/draft/2019-09/schema#"), u;
};
function pR(t, e) {
  return qk(t, {
    openaiStrictMode: !0,
    name: e.name,
    nameStrategy: "duplicate-ref",
    $refStrategy: "extract-to-root",
    nullableStrategy: "property"
  });
}
function Jk(t, e, n) {
  return BA({
    type: "json_schema",
    json_schema: {
      ...n,
      name: e,
      strict: !0,
      schema: pR(t, { name: e })
    }
  }, (a) => t.parse(JSON.parse(a)));
}
function Lk(t) {
  return xA({
    type: "function",
    function: {
      name: t.name,
      parameters: pR(t.parameters, { name: t.name }),
      strict: !0,
      ...t.description ? { description: t.description } : void 0
    }
  }, {
    callback: t.function,
    parser: (e) => t.parameters.parse(JSON.parse(e))
  });
}
function Zg(t) {
  const { azureOpenAIApiDeploymentName: e, azureOpenAIApiInstanceName: n, azureOpenAIApiKey: a, azureOpenAIBasePath: r, baseURL: i, azureADTokenProvider: s, azureOpenAIEndpoint: u } = t;
  if ((a || s) && r && e)
    return `${r}/${e}`;
  if ((a || s) && u && e)
    return `${u}/openai/deployments/${e}`;
  if (a || s) {
    if (!n)
      throw new Error("azureOpenAIApiInstanceName is required when using azureOpenAIApiKey");
    if (!e)
      throw new Error("azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey");
    return `https://${n}.openai.azure.com/openai/deployments/${e}`;
  }
  return i;
}
function Kg(t, e) {
  const n = typeof e == "number" ? void 0 : e;
  return {
    name: t.name,
    description: t.description,
    parameters: xn(t.schema),
    // Do not include the `strict` field if it is `undefined`.
    ...n?.strict !== void 0 ? { strict: n.strict } : {}
  };
}
function Ih(t, e) {
  let n;
  return Hg(t) ? n = {
    type: "function",
    function: Kg(t)
  } : n = t, n;
}
function mR(t) {
  return t !== void 0 && Array.isArray(t.lc_namespace);
}
function Uk(t) {
  return t !== void 0 && Te.isRunnable(t) && "lc_name" in t.constructor && typeof t.constructor.lc_name == "function" && t.constructor.lc_name() === "RunnableToolLike";
}
function Bk(t) {
  return !!t && typeof t == "object" && "name" in t && "schema" in t && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Nd(t.schema);
}
function Hg(t) {
  return Bk(t) || Uk(t) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
  mR(t);
}
function pf(t, e) {
  return t.lc_error_code = e, t.message = `${t.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${e}/
`, t;
}
function Ul(t) {
  let e;
  return t.constructor.name === Wh.name ? (e = new Error(t.message), e.name = "TimeoutError") : t.constructor.name === vn.name ? (e = new Error(t.message), e.name = "AbortError") : t.status === 400 && t.message.includes("tool_calls") ? e = pf(t, "INVALID_TOOL_RESULTS") : t.status === 401 ? e = pf(t, "MODEL_AUTHENTICATION") : t.status === 429 ? e = pf(t, "MODEL_RATE_LIMIT") : t.status === 404 ? e = pf(t, "MODEL_NOT_FOUND") : e = t, e;
}
function jv(t) {
  if (t)
    return t === "any" || t === "required" ? "required" : t === "auto" ? "auto" : t === "none" ? "none" : typeof t == "string" ? {
      type: "function",
      function: {
        name: t
      }
    } : t;
}
function xk(t) {
  return t.anyOf !== void 0 && Array.isArray(t.anyOf);
}
function Vk(t) {
  const e = ["namespace functions {", ""];
  for (const n of t)
    n.description && e.push(`// ${n.description}`), Object.keys(n.parameters.properties ?? {}).length > 0 ? (e.push(`type ${n.name} = (_: {`), e.push(bR(n.parameters, 0)), e.push("}) => any;")) : e.push(`type ${n.name} = () => any;`), e.push("");
  return e.push("} // namespace functions"), e.join(`
`);
}
function bR(t, e) {
  const n = [];
  for (const [a, r] of Object.entries(t.properties ?? {}))
    r.description && e < 2 && n.push(`// ${r.description}`), t.required?.includes(a) ? n.push(`${a}: ${Nh(r, e)},`) : n.push(`${a}?: ${Nh(r, e)},`);
  return n.map((a) => " ".repeat(e) + a).join(`
`);
}
function Nh(t, e) {
  if (xk(t))
    return t.anyOf.map((n) => Nh(n, e)).join(" | ");
  switch (t.type) {
    case "string":
      return t.enum ? t.enum.map((n) => `"${n}"`).join(" | ") : "string";
    case "number":
      return t.enum ? t.enum.map((n) => `${n}`).join(" | ") : "number";
    case "integer":
      return t.enum ? t.enum.map((n) => `${n}`).join(" | ") : "number";
    case "boolean":
      return "boolean";
    case "null":
      return "null";
    case "object":
      return ["{", bR(t, e + 2), "}"].join(`
`);
    case "array":
      return t.items ? `${Nh(t.items, e)}[]` : "any[]";
    default:
      return "";
  }
}
function zk(t, e) {
  let n;
  if (Hg(t)) {
    const a = Lk({
      name: t.name,
      parameters: t.schema,
      description: t.description
    });
    a.function.parameters ? n = {
      type: a.type,
      function: {
        name: a.function.name,
        description: a.function.description,
        parameters: a.function.parameters,
        ...e?.strict !== void 0 ? { strict: e.strict } : {}
      }
    } : n = {
      type: "function",
      function: Kg(t, e)
    };
  } else
    n = t;
  return e?.strict !== void 0 && (n.function.strict = e.strict), n;
}
function Zk(t) {
  return t.role !== "system" && t.role !== "developer" && t.role !== "assistant" && t.role !== "user" && t.role !== "function" && t.role !== "tool" && console.warn(`Unknown message role: ${t.role}`), t.role;
}
function Gg(t) {
  const e = t._getType();
  switch (e) {
    case "system":
      return "system";
    case "ai":
      return "assistant";
    case "human":
      return "user";
    case "function":
      return "function";
    case "tool":
      return "tool";
    case "generic": {
      if (!Xo.isInstance(t))
        throw new Error("Invalid generic chat message");
      return Zk(t);
    }
    default:
      throw new Error(`Unknown message type: ${e}`);
  }
}
function Pv(t, e) {
  return t.flatMap((n) => {
    let a = Gg(n);
    a === "system" && Wg(e) && (a = "developer");
    const r = {
      role: a,
      content: n.content
    };
    if (n.name != null && (r.name = n.name), n.additional_kwargs.function_call != null && (r.function_call = n.additional_kwargs.function_call, r.content = ""), uo(n) && n.tool_calls?.length ? (r.tool_calls = n.tool_calls.map(cR), r.content = "") : (n.additional_kwargs.tool_calls != null && (r.tool_calls = n.additional_kwargs.tool_calls), n.tool_call_id != null && (r.tool_call_id = n.tool_call_id)), n.additional_kwargs.audio && typeof n.additional_kwargs.audio == "object" && "id" in n.additional_kwargs.audio) {
      const i = {
        role: "assistant",
        audio: {
          id: n.additional_kwargs.audio.id
        }
      };
      return [r, i];
    }
    return r;
  });
}
const Fh = "__openai_function_call_ids__";
function Cv(t, e) {
  return t.flatMap((n) => {
    let a = Gg(n);
    if (a === "system" && Wg(e) && (a = "developer"), a === "function")
      throw new Error("Function messages are not supported in Responses API");
    if (a === "tool") {
      const r = n;
      return r.additional_kwargs?.type === "computer_call_output" ? {
        type: "computer_call_output",
        output: (() => {
          if (typeof r.content == "string")
            return {
              type: "computer_screenshot",
              image_url: r.content
            };
          if (Array.isArray(r.content)) {
            const s = r.content.find((d) => d.type === "computer_screenshot");
            if (s)
              return s;
            const u = r.content.find((d) => d.type === "image_url");
            if (u)
              return {
                type: "computer_screenshot",
                image_url: typeof u.image_url == "string" ? u.image_url : u.image_url.url
              };
          }
          throw new Error("Invalid computer call output");
        })(),
        call_id: r.tool_call_id
      } : {
        type: "function_call_output",
        call_id: r.tool_call_id,
        id: r.id,
        output: typeof r.content != "string" ? JSON.stringify(r.content) : r.content
      };
    }
    if (a === "assistant") {
      const r = [];
      n.additional_kwargs.reasoning != null && ((d) => typeof d == "object" && d != null && "type" in d && d.type === "reasoning")(n.additional_kwargs.reasoning) && r.push(n.additional_kwargs.reasoning);
      let { content: i } = n;
      n.additional_kwargs.refusal != null && (typeof i == "string" && (i = [{ type: "output_text", text: i, annotations: [] }]), i = [
        ...i,
        { type: "refusal", refusal: n.additional_kwargs.refusal }
      ]), r.push({
        type: "message",
        role: "assistant",
        content: typeof i == "string" ? i : i.flatMap((u) => u.type === "text" ? {
          type: "output_text",
          text: u.text,
          // @ts-expect-error TODO: add types for `annotations`
          annotations: u.annotations ?? []
        } : u.type === "output_text" || u.type === "refusal" ? u : [])
      });
      const s = (
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        n.additional_kwargs[Fh]
      );
      if (uo(n) && n.tool_calls?.length ? r.push(...n.tool_calls.map((u) => ({
        type: "function_call",
        name: u.name,
        arguments: JSON.stringify(u.args),
        call_id: u.id,
        // @ts-expect-error Might come from a non-Responses API message
        id: s?.[u.id]
      }))) : n.additional_kwargs.tool_calls != null && r.push(...n.additional_kwargs.tool_calls.map((u) => ({
        type: "function_call",
        name: u.function.name,
        call_id: u.id,
        // @ts-expect-error Might come from a non-Responses API message
        id: s?.[u.id],
        arguments: u.function.arguments
      }))), n.additional_kwargs.tool_outputs != null) {
        const d = n.additional_kwargs.tool_outputs?.filter((f) => f.type === "computer_call");
        d.length > 0 && r.push(...d);
      }
      return r;
    }
    return a === "user" ? {
      type: "message",
      role: "user",
      content: typeof n.content == "string" ? n.content : n.content.flatMap((r) => {
        if (r.type === "text")
          return { type: "input_text", text: r.text };
        if (r.type === "image_url") {
          const i = typeof r.image_url == "string" ? r.image_url : r.image_url.url, s = typeof r.image_url == "string" ? "auto" : r.image_url.detail;
          return { type: "input_image", image_url: i, detail: s };
        }
        return r.type === "input_text" || r.type === "input_image" || r.type === "input_file" ? r : [];
      })
    } : [];
  });
}
function gR(t) {
  if (t.error) {
    const s = new Error(t.error.message);
    throw s.name = t.error.code, s;
  }
  const e = [], n = [], a = [], r = {
    model: t.model,
    created_at: t.created_at,
    id: t.id,
    incomplete_details: t.incomplete_details,
    metadata: t.metadata,
    object: t.object,
    status: t.status,
    user: t.user,
    // for compatibility with chat completion calls.
    model_name: t.model
  }, i = {};
  for (const s of t.output)
    if (s.type === "message")
      e.push(...s.content.flatMap((u) => u.type === "output_text" ? ("parsed" in u && u.parsed != null && (i.parsed = u.parsed), {
        type: "text",
        text: u.text,
        annotations: u.annotations
      }) : u.type === "refusal" ? (i.refusal = u.refusal, []) : u));
    else if (s.type === "function_call") {
      const u = {
        function: { name: s.name, arguments: s.arguments },
        id: s.call_id
      };
      try {
        n.push(dp(u, { returnId: !0 }));
      } catch (d) {
        let f;
        typeof d == "object" && d != null && "message" in d && typeof d.message == "string" && (f = d.message), a.push(zg(u, f));
      }
      i[Fh] ??= {}, i[Fh][s.call_id] = s.id;
    } else s.type === "reasoning" ? i.reasoning = s : (i.tool_outputs ??= [], i.tool_outputs.push(s));
  return new At({
    id: t.id,
    content: e,
    tool_calls: n,
    invalid_tool_calls: a,
    usage_metadata: t.usage,
    additional_kwargs: i,
    response_metadata: r
  });
}
function Kk(t) {
  const e = [];
  let n = {}, a;
  const r = [], i = {}, s = {};
  let u;
  if (t.type === "response.output_text.delta")
    e.push({
      type: "text",
      text: t.delta,
      index: t.content_index
    });
  else if (t.type === "response.output_text.annotation.added")
    e.push({
      type: "text",
      text: "",
      annotations: [t.annotation],
      index: t.content_index
    });
  else if (t.type === "response.output_item.added" && t.item.type === "message")
    u = t.item.id;
  else if (t.type === "response.output_item.added" && t.item.type === "function_call")
    r.push({
      type: "tool_call_chunk",
      name: t.item.name,
      args: t.item.arguments,
      id: t.item.id,
      index: t.output_index
    }), s[Fh] = {
      [t.item.call_id]: t.item.id
    };
  else if (t.type === "response.output_item.done" && (t.item.type === "web_search_call" || t.item.type === "file_search_call" || t.item.type === "computer_call"))
    s.tool_outputs = [t.item];
  else if (t.type === "response.created")
    i.id = t.response.id, i.model_name = t.response.model, i.model = t.response.model;
  else if (t.type === "response.completed") {
    const d = gR(t.response);
    a = t.response.usage, t.response.text?.format?.type === "json_schema" && (s.parsed ??= JSON.parse(d.text));
    for (const [f, o] of Object.entries(t.response))
      f !== "id" && (i[f] = o);
  } else if (t.type === "response.function_call_arguments.delta")
    r.push({
      type: "tool_call_chunk",
      args: t.delta,
      index: t.output_index
    });
  else if (t.type === "response.web_search_call.completed" || t.type === "response.file_search_call.completed")
    n = {
      tool_outputs: {
        id: t.item_id,
        type: t.type.replace("response.", "").replace(".completed", ""),
        status: "completed"
      }
    };
  else if (t.type === "response.refusal.done")
    s.refusal = t.refusal;
  else
    return null;
  return new On({
    // Legacy reasons, `onLLMNewToken` should pulls this out
    text: e.map((d) => d.text).join(""),
    message: new We({
      id: u,
      content: e,
      tool_call_chunks: r,
      usage_metadata: a,
      additional_kwargs: s,
      response_metadata: i
    }),
    generationInfo: n
  });
}
function jm(t) {
  return "type" in t && t.type !== "function";
}
function Hk(t) {
  return t != null && typeof t == "object" && "type" in t && t.type !== "function";
}
function Rv(t, e) {
  return tc(t) ? e?.strict !== void 0 ? {
    ...t,
    function: {
      ...t.function,
      strict: e.strict
    }
  } : t : zk(t, e);
}
function Wg(t) {
  return t?.startsWith("o1") || t?.startsWith("o3");
}
class oV extends kn {
  static lc_name() {
    return "ChatOpenAI";
  }
  get callKeys() {
    return [
      ...super.callKeys,
      "options",
      "function_call",
      "functions",
      "tools",
      "tool_choice",
      "promptIndex",
      "response_format",
      "seed",
      "reasoning_effort"
    ];
  }
  get lc_secrets() {
    return {
      openAIApiKey: "OPENAI_API_KEY",
      apiKey: "OPENAI_API_KEY",
      organization: "OPENAI_ORGANIZATION"
    };
  }
  get lc_aliases() {
    return {
      modelName: "model",
      openAIApiKey: "openai_api_key",
      apiKey: "openai_api_key"
    };
  }
  get lc_serializable_keys() {
    return [
      "configuration",
      "logprobs",
      "topLogprobs",
      "prefixMessages",
      "supportsStrictToolCalling",
      "modalities",
      "audio",
      "reasoningEffort",
      "temperature",
      "maxTokens",
      "topP",
      "frequencyPenalty",
      "presencePenalty",
      "n",
      "logitBias",
      "user",
      "streaming",
      "streamUsage",
      "modelName",
      "model",
      "modelKwargs",
      "stop",
      "stopSequences",
      "timeout",
      "openAIApiKey",
      "apiKey",
      "cache",
      "maxConcurrency",
      "maxRetries",
      "verbose",
      "callbacks",
      "tags",
      "metadata",
      "disableStreaming"
    ];
  }
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "frequencyPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "presencePenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "n", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logitBias", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "modelName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "gpt-3.5-turbo"
    }), Object.defineProperty(this, "modelKwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stopSequences", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "user", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "streamUsage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "maxTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logprobs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topLogprobs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "openAIApiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "organization", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "__includeRawResponse", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "clientConfig", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "supportsStrictToolCalling", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "audio", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "modalities", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reasoningEffort", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useResponsesApi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.openAIApiKey = e?.apiKey ?? e?.openAIApiKey ?? e?.configuration?.apiKey ?? _t("OPENAI_API_KEY"), this.apiKey = this.openAIApiKey, this.organization = e?.configuration?.organization ?? _t("OPENAI_ORGANIZATION"), this.model = e?.model ?? e?.modelName ?? this.model, this.modelName = this.model, this.modelKwargs = e?.modelKwargs ?? {}, this.timeout = e?.timeout, this.temperature = e?.temperature ?? this.temperature, this.topP = e?.topP ?? this.topP, this.frequencyPenalty = e?.frequencyPenalty ?? this.frequencyPenalty, this.presencePenalty = e?.presencePenalty ?? this.presencePenalty, this.logprobs = e?.logprobs, this.topLogprobs = e?.topLogprobs, this.n = e?.n ?? this.n, this.logitBias = e?.logitBias, this.stop = e?.stopSequences ?? e?.stop, this.stopSequences = this.stop, this.user = e?.user, this.__includeRawResponse = e?.__includeRawResponse, this.audio = e?.audio, this.modalities = e?.modalities, this.reasoningEffort = e?.reasoningEffort, this.maxTokens = e?.maxCompletionTokens ?? e?.maxTokens, this.useResponsesApi = e?.useResponsesApi ?? this.useResponsesApi, this.model === "o1" && (this.disableStreaming = !0), this.streaming = e?.streaming ?? !1, this.streamUsage = e?.streamUsage ?? this.streamUsage, this.clientConfig = {
      apiKey: this.apiKey,
      organization: this.organization,
      dangerouslyAllowBrowser: !0,
      ...e?.configuration
    }, e?.supportsStrictToolCalling !== void 0 && (this.supportsStrictToolCalling = e.supportsStrictToolCalling);
  }
  getLsParams(e) {
    const n = this.invocationParams(e);
    return {
      ls_provider: "openai",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: n.temperature ?? void 0,
      ls_max_tokens: n.max_tokens ?? void 0,
      ls_stop: e.stop
    };
  }
  bindTools(e, n) {
    let a;
    return n?.strict !== void 0 ? a = n.strict : this.supportsStrictToolCalling !== void 0 && (a = this.supportsStrictToolCalling), this.bind({
      tools: e.map((r) => jm(r) ? r : Rv(r, { strict: a })),
      ...n
    });
  }
  createResponseFormat(e) {
    return e && e.type === "json_schema" && e.json_schema.schema && mf(e.json_schema.schema) ? Jk(e.json_schema.schema, e.json_schema.name, {
      description: e.json_schema.description
    }) : e;
  }
  /**
   * Get the parameters used to invoke the model
   */
  invocationParams(e, n) {
    let a;
    if (e?.strict !== void 0 ? a = e.strict : this.supportsStrictToolCalling !== void 0 && (a = this.supportsStrictToolCalling), this._useResponseApi(e)) {
      const u = {
        model: this.model,
        temperature: this.temperature,
        top_p: this.topP,
        user: this.user,
        // if include_usage is set or streamUsage then stream must be set to true.
        stream: this.streaming,
        previous_response_id: e?.previous_response_id,
        truncation: e?.truncation,
        include: e?.include,
        tools: e?.tools?.length ? e.tools.map((f) => jm(f) ? f : tc(f) ? {
          type: "function",
          name: f.function.name,
          parameters: f.function.parameters,
          description: f.function.description,
          strict: a
        } : null).filter((f) => f !== null) : void 0,
        tool_choice: Hk(e?.tool_choice) ? e?.tool_choice : (() => {
          const f = jv(e?.tool_choice);
          if (typeof f == "object" && "type" in f)
            return { type: "function", name: f.function.name };
        })(),
        text: (() => {
          if (e?.text)
            return e.text;
          const f = this.createResponseFormat(e?.response_format);
          return f?.type === "json_schema" ? f.json_schema.schema != null ? {
            format: {
              type: "json_schema",
              schema: f.json_schema.schema,
              description: f.json_schema.description,
              name: f.json_schema.name,
              strict: f.json_schema.strict
            }
          } : void 0 : { format: f };
        })(),
        parallel_tool_calls: e?.parallel_tool_calls,
        max_output_tokens: this.maxTokens === -1 ? void 0 : this.maxTokens,
        ...this.modelKwargs
      }, d = e?.reasoning_effort ?? this.reasoningEffort;
      return d !== void 0 && (u.reasoning = { effort: d }), u;
    }
    let r = {};
    e?.stream_options !== void 0 ? r = { stream_options: e.stream_options } : this.streamUsage && (this.streaming || n?.streaming) && (r = { stream_options: { include_usage: !0 } });
    const i = {
      model: this.model,
      temperature: this.temperature,
      top_p: this.topP,
      frequency_penalty: this.frequencyPenalty,
      presence_penalty: this.presencePenalty,
      logprobs: this.logprobs,
      top_logprobs: this.topLogprobs,
      n: this.n,
      logit_bias: this.logitBias,
      stop: e?.stop ?? this.stopSequences,
      user: this.user,
      // if include_usage is set or streamUsage then stream must be set to true.
      stream: this.streaming,
      functions: e?.functions,
      function_call: e?.function_call,
      tools: e?.tools?.length ? e.tools.map((u) => Rv(u, { strict: a })) : void 0,
      tool_choice: jv(e?.tool_choice),
      response_format: this.createResponseFormat(e?.response_format),
      seed: e?.seed,
      ...r,
      parallel_tool_calls: e?.parallel_tool_calls,
      ...this.audio || e?.audio ? { audio: this.audio || e?.audio } : {},
      ...this.modalities || e?.modalities ? { modalities: this.modalities || e?.modalities } : {},
      ...this.modelKwargs
    };
    e?.prediction !== void 0 && (i.prediction = e.prediction);
    const s = e?.reasoning_effort ?? this.reasoningEffort;
    return s !== void 0 && (i.reasoning_effort = s), Wg(i.model) ? i.max_completion_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens : i.max_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens, i;
  }
  _convertOpenAIChatCompletionMessageToBaseMessage(e, n) {
    const a = e.tool_calls;
    switch (e.role) {
      case "assistant": {
        const r = [], i = [];
        for (const d of a ?? [])
          try {
            r.push(dp(d, { returnId: !0 }));
          } catch (f) {
            i.push(zg(d, f.message));
          }
        const s = {
          function_call: e.function_call,
          tool_calls: a
        };
        this.__includeRawResponse !== void 0 && (s.__raw_response = n);
        const u = {
          model_name: n.model,
          ...n.system_fingerprint ? {
            usage: { ...n.usage },
            system_fingerprint: n.system_fingerprint
          } : {}
        };
        return e.audio && (s.audio = e.audio), new At({
          content: e.content || "",
          tool_calls: r,
          invalid_tool_calls: i,
          additional_kwargs: s,
          response_metadata: u,
          id: n.id
        });
      }
      default:
        return new Xo(e.content || "", e.role ?? "unknown");
    }
  }
  _convertOpenAIDeltaToBaseMessageChunk(e, n, a) {
    const r = e.role ?? a, i = e.content ?? "";
    let s;
    e.function_call ? s = {
      function_call: e.function_call
    } : e.tool_calls ? s = {
      tool_calls: e.tool_calls
    } : s = {}, this.__includeRawResponse && (s.__raw_response = n), e.audio && (s.audio = {
      ...e.audio,
      index: n.choices[0].index
    });
    const u = { usage: { ...n.usage } };
    if (r === "user")
      return new Md({ content: i, response_metadata: u });
    if (r === "assistant") {
      const d = [];
      if (Array.isArray(e.tool_calls))
        for (const f of e.tool_calls)
          d.push({
            name: f.function?.name,
            args: f.function?.arguments,
            id: f.id,
            index: f.index,
            type: "tool_call_chunk"
          });
      return new We({
        content: i,
        tool_call_chunks: d,
        additional_kwargs: s,
        id: n.id,
        response_metadata: u
      });
    } else return r === "system" ? new Xl({ content: i, response_metadata: u }) : r === "developer" ? new Xl({
      content: i,
      response_metadata: u,
      additional_kwargs: {
        __openai_role__: "developer"
      }
    }) : r === "function" ? new $d({
      content: i,
      additional_kwargs: s,
      name: e.name,
      response_metadata: u
    }) : r === "tool" ? new sp({
      content: i,
      additional_kwargs: s,
      tool_call_id: e.tool_call_id,
      response_metadata: u
    }) : new Td({ content: i, role: r, response_metadata: u });
  }
  /** @ignore */
  _identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams(),
      ...this.clientConfig
    };
  }
  async *_streamResponseChunks(e, n, a) {
    if (this._useResponseApi(n)) {
      const f = await this.responseApiWithRetry({
        ...this.invocationParams(n, { streaming: !0 }),
        input: Cv(e, this.model),
        stream: !0
      }, n);
      for await (const o of f) {
        const c = Kk(o);
        c != null && (yield c);
      }
      return;
    }
    const r = Pv(e, this.model), i = {
      ...this.invocationParams(n, {
        streaming: !0
      }),
      messages: r,
      stream: !0
    };
    let s;
    const u = await this.completionWithRetry(i, n);
    let d;
    for await (const f of u) {
      const o = f?.choices?.[0];
      if (f.usage && (d = f.usage), !o)
        continue;
      const { delta: c } = o;
      if (!c)
        continue;
      const h = this._convertOpenAIDeltaToBaseMessageChunk(c, f, s);
      s = c.role ?? s;
      const p = {
        prompt: n.promptIndex ?? 0,
        completion: o.index ?? 0
      };
      if (typeof h.content != "string") {
        console.log("[WARNING]: Received non-string content from OpenAI. This is currently not supported.");
        continue;
      }
      const l = { ...p };
      o.finish_reason != null && (l.finish_reason = o.finish_reason, l.system_fingerprint = f.system_fingerprint, l.model_name = f.model), this.logprobs && (l.logprobs = o.logprobs);
      const m = new On({
        message: h,
        text: h.content,
        generationInfo: l
      });
      yield m, await a?.handleLLMNewToken(m.text ?? "", p, void 0, void 0, void 0, { chunk: m });
    }
    if (d) {
      const f = {
        ...d.prompt_tokens_details?.audio_tokens !== null && {
          audio: d.prompt_tokens_details?.audio_tokens
        },
        ...d.prompt_tokens_details?.cached_tokens !== null && {
          cache_read: d.prompt_tokens_details?.cached_tokens
        }
      }, o = {
        ...d.completion_tokens_details?.audio_tokens !== null && {
          audio: d.completion_tokens_details?.audio_tokens
        },
        ...d.completion_tokens_details?.reasoning_tokens !== null && {
          reasoning: d.completion_tokens_details?.reasoning_tokens
        }
      };
      yield new On({
        message: new We({
          content: "",
          response_metadata: {
            usage: { ...d }
          },
          usage_metadata: {
            input_tokens: d.prompt_tokens,
            output_tokens: d.completion_tokens,
            total_tokens: d.total_tokens,
            ...Object.keys(f).length > 0 && {
              input_token_details: f
            },
            ...Object.keys(o).length > 0 && {
              output_token_details: o
            }
          }
        }),
        text: ""
      });
    }
    if (n.signal?.aborted)
      throw new Error("AbortError");
  }
  /**
   * Get the identifying parameters for the model
   *
   */
  identifyingParams() {
    return this._identifyingParams();
  }
  /** @ignore */
  async _responseApiGenerate(e, n, a) {
    const r = this.invocationParams(n);
    if (r.stream) {
      const u = this._streamResponseChunks(e, n, a);
      let d;
      for await (const f of u)
        f.message.response_metadata = {
          ...f.generationInfo,
          ...f.message.response_metadata
        }, d = d?.concat(f) ?? f;
      return {
        generations: d ? [d] : [],
        llmOutput: {
          estimatedTokenUsage: d?.message?.usage_metadata
        }
      };
    }
    const i = Cv(e, this.model), s = await this.responseApiWithRetry({ input: i, ...r }, { signal: n?.signal, ...n?.options });
    return {
      generations: [
        {
          text: s.output_text,
          message: gR(s)
        }
      ],
      llmOutput: {
        id: s.id,
        estimatedTokenUsage: s.usage ? {
          promptTokens: s.usage.input_tokens,
          completionTokens: s.usage.output_tokens,
          totalTokens: s.usage.total_tokens
        } : void 0
      }
    };
  }
  _useResponseApi(e) {
    const n = e?.tools?.some(jm), a = e?.previous_response_id != null || e?.text != null || e?.truncation != null || e?.include != null;
    return this.useResponsesApi || n || a;
  }
  /** @ignore */
  async _generate(e, n, a) {
    if (this._useResponseApi(n))
      return this._responseApiGenerate(e, n, a);
    const r = {}, i = this.invocationParams(n), s = Pv(e, this.model);
    if (i.stream) {
      const u = this._streamResponseChunks(e, n, a), d = {};
      for await (const l of u) {
        l.message.response_metadata = {
          ...l.generationInfo,
          ...l.message.response_metadata
        };
        const m = l.generationInfo?.completion ?? 0;
        d[m] === void 0 ? d[m] = l : d[m] = d[m].concat(l);
      }
      const f = Object.entries(d).sort(([l], [m]) => parseInt(l, 10) - parseInt(m, 10)).map(([l, m]) => m), { functions: o, function_call: c } = this.invocationParams(n), h = await this.getEstimatedTokenCountFromPrompt(e, o, c), p = await this.getNumTokensFromGenerations(f);
      return r.input_tokens = h, r.output_tokens = p, r.total_tokens = h + p, {
        generations: f,
        llmOutput: {
          estimatedTokenUsage: {
            promptTokens: r.input_tokens,
            completionTokens: r.output_tokens,
            totalTokens: r.total_tokens
          }
        }
      };
    } else {
      let u;
      n.response_format && n.response_format.type === "json_schema" ? u = await this.betaParsedCompletionWithRetry({
        ...i,
        stream: !1,
        messages: s
      }, {
        signal: n?.signal,
        ...n?.options
      }) : u = await this.completionWithRetry({
        ...i,
        stream: !1,
        messages: s
      }, {
        signal: n?.signal,
        ...n?.options
      });
      const { completion_tokens: d, prompt_tokens: f, total_tokens: o, prompt_tokens_details: c, completion_tokens_details: h } = u?.usage ?? {};
      d && (r.output_tokens = (r.output_tokens ?? 0) + d), f && (r.input_tokens = (r.input_tokens ?? 0) + f), o && (r.total_tokens = (r.total_tokens ?? 0) + o), (c?.audio_tokens !== null || c?.cached_tokens !== null) && (r.input_token_details = {
        ...c?.audio_tokens !== null && {
          audio: c?.audio_tokens
        },
        ...c?.cached_tokens !== null && {
          cache_read: c?.cached_tokens
        }
      }), (h?.audio_tokens !== null || h?.reasoning_tokens !== null) && (r.output_token_details = {
        ...h?.audio_tokens !== null && {
          audio: h?.audio_tokens
        },
        ...h?.reasoning_tokens !== null && {
          reasoning: h?.reasoning_tokens
        }
      });
      const p = [];
      for (const l of u?.choices ?? []) {
        const b = {
          text: l.message?.content ?? "",
          message: this._convertOpenAIChatCompletionMessageToBaseMessage(l.message ?? { role: "assistant" }, u)
        };
        b.generationInfo = {
          ...l.finish_reason ? { finish_reason: l.finish_reason } : {},
          ...l.logprobs ? { logprobs: l.logprobs } : {}
        }, uo(b.message) && (b.message.usage_metadata = r), b.message = new At(Object.fromEntries(Object.entries(b.message).filter(([g]) => !g.startsWith("lc_")))), p.push(b);
      }
      return {
        generations: p,
        llmOutput: {
          tokenUsage: {
            promptTokens: r.input_tokens,
            completionTokens: r.output_tokens,
            totalTokens: r.total_tokens
          }
        }
      };
    }
  }
  /**
   * Estimate the number of tokens a prompt will use.
   * Modified from: https://github.com/hmarr/openai-chat-tokens/blob/main/src/index.ts
   */
  async getEstimatedTokenCountFromPrompt(e, n, a) {
    let r = (await this.getNumTokensFromMessages(e)).totalCount;
    if (n && a !== "auto") {
      const i = Vk(n);
      r += await this.getNumTokens(i), r += 9;
    }
    return n && e.find((i) => i._getType() === "system") && (r -= 4), a === "none" ? r += 1 : typeof a == "object" && (r += await this.getNumTokens(a.name) + 4), r;
  }
  /**
   * Estimate the number of tokens an array of generations have used.
   */
  async getNumTokensFromGenerations(e) {
    return (await Promise.all(e.map(async (a) => a.message.additional_kwargs?.function_call ? (await this.getNumTokensFromMessages([a.message])).countPerMessage[0] : await this.getNumTokens(a.message.content)))).reduce((a, r) => a + r, 0);
  }
  async getNumTokensFromMessages(e) {
    let n = 0, a = 0, r = 0;
    this.model === "gpt-3.5-turbo-0301" ? (a = 4, r = -1) : (a = 3, r = 1);
    const i = await Promise.all(e.map(async (s) => {
      const u = await this.getNumTokens(s.content), d = await this.getNumTokens(Gg(s)), f = s.name !== void 0 ? r + await this.getNumTokens(s.name) : 0;
      let o = u + a + d + f;
      const c = s;
      if (c._getType() === "function" && (o -= 2), c.additional_kwargs?.function_call && (o += 3), c?.additional_kwargs.function_call?.name && (o += await this.getNumTokens(c.additional_kwargs.function_call?.name)), c.additional_kwargs.function_call?.arguments)
        try {
          o += await this.getNumTokens(
            // Remove newlines and spaces
            JSON.stringify(JSON.parse(c.additional_kwargs.function_call?.arguments))
          );
        } catch (h) {
          console.error("Error parsing function arguments", h, JSON.stringify(c.additional_kwargs.function_call)), o += await this.getNumTokens(c.additional_kwargs.function_call?.arguments);
        }
      return n += o, o;
    }));
    return n += 3, { totalCount: n, countPerMessage: i };
  }
  async completionWithRetry(e, n) {
    const a = this._getClientOptions(n);
    return this.caller.call(async () => {
      try {
        return await this.client.chat.completions.create(e, a);
      } catch (r) {
        throw Ul(r);
      }
    });
  }
  async responseApiWithRetry(e, n) {
    return this.caller.call(async () => {
      const a = this._getClientOptions(n);
      try {
        return e.text?.format?.type === "json_schema" && !e.stream ? await this.client.responses.parse(e, a) : await this.client.responses.create(e, a);
      } catch (r) {
        throw Ul(r);
      }
    });
  }
  /**
   * Call the beta chat completions parse endpoint. This should only be called if
   * response_format is set to "json_object".
   * @param {OpenAIClient.Chat.ChatCompletionCreateParamsNonStreaming} request
   * @param {OpenAICoreRequestOptions | undefined} options
   */
  async betaParsedCompletionWithRetry(e, n) {
    const a = this._getClientOptions(n);
    return this.caller.call(async () => {
      try {
        return await this.client.beta.chat.completions.parse(e, a);
      } catch (r) {
        throw Ul(r);
      }
    });
  }
  _getClientOptions(e) {
    if (!this.client) {
      const a = {
        baseURL: this.clientConfig.baseURL
      }, r = Zg(a), i = {
        ...this.clientConfig,
        baseURL: r,
        timeout: this.timeout,
        maxRetries: 0
      };
      i.baseURL || delete i.baseURL, this.client = new ge(i);
    }
    return {
      ...this.clientConfig,
      ...e
    };
  }
  _llmType() {
    return "openai";
  }
  /** @ignore */
  _combineLLMOutput(...e) {
    return e.reduce((n, a) => (a && a.tokenUsage && (n.tokenUsage.completionTokens += a.tokenUsage.completionTokens ?? 0, n.tokenUsage.promptTokens += a.tokenUsage.promptTokens ?? 0, n.tokenUsage.totalTokens += a.tokenUsage.totalTokens ?? 0), n), {
      tokenUsage: {
        completionTokens: 0,
        promptTokens: 0,
        totalTokens: 0
      }
    });
  }
  withStructuredOutput(e, n) {
    let a, r, i, s;
    Gk(e) ? (a = e.schema, r = e.name, i = e.method, s = e.includeRaw) : (a = e, r = n?.name, i = n?.method, s = n?.includeRaw);
    let u, d;
    if (n?.strict !== void 0 && i === "jsonMode")
      throw new Error("Argument `strict` is only supported for `method` = 'function_calling'");
    if (!this.model.startsWith("gpt-3") && !this.model.startsWith("gpt-4-") && this.model !== "gpt-4" ? i === void 0 && (i = "jsonSchema") : i === "jsonSchema" && console.warn(`[WARNING]: JSON Schema is not supported for model "${this.model}". Falling back to tool calling.`), i === "jsonMode")
      u = this.bind({
        response_format: { type: "json_object" }
      }), mf(a) ? d = $h.fromZodSchema(a) : d = new Mh();
    else if (i === "jsonSchema")
      if (u = this.bind({
        response_format: {
          type: "json_schema",
          json_schema: {
            name: r ?? "extract",
            description: a.description,
            schema: a,
            strict: n?.strict
          }
        }
      }), mf(a)) {
        const h = $h.fromZodSchema(a);
        d = Yo.from((p) => "parsed" in p.additional_kwargs ? p.additional_kwargs.parsed : h);
      } else
        d = new Mh();
    else {
      let h = r ?? "extract";
      if (mf(a)) {
        const p = xn(a);
        u = this.bind({
          tools: [
            {
              type: "function",
              function: {
                name: h,
                description: p.description,
                parameters: p
              }
            }
          ],
          tool_choice: {
            type: "function",
            function: {
              name: h
            }
          },
          // Do not pass `strict` argument to OpenAI if `config.strict` is undefined
          ...n?.strict !== void 0 ? { strict: n.strict } : {}
        }), d = new Ah({
          returnSingle: !0,
          keyName: h,
          zodSchema: a
        });
      } else {
        let p;
        typeof a.name == "string" && typeof a.parameters == "object" && a.parameters != null ? (p = a, h = a.name) : (h = a.title ?? h, p = {
          name: h,
          description: a.description ?? "",
          parameters: a
        }), u = this.bind({
          tools: [
            {
              type: "function",
              function: p
            }
          ],
          tool_choice: {
            type: "function",
            function: {
              name: h
            }
          },
          // Do not pass `strict` argument to OpenAI if `config.strict` is undefined
          ...n?.strict !== void 0 ? { strict: n.strict } : {}
        }), d = new Ah({
          returnSingle: !0,
          keyName: h
        });
      }
    }
    if (!s)
      return u.pipe(d);
    const f = Ut.assign({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parsed: (h, p) => d.invoke(h.raw, p)
    }), o = Ut.assign({
      parsed: () => null
    }), c = f.withFallbacks({
      fallbacks: [o]
    });
    return gt.from([{ raw: u }, c]);
  }
}
function mf(t) {
  return typeof t?.parse == "function";
}
function Gk(t) {
  return t !== void 0 && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  typeof t.schema == "object";
}
class Fo extends xg {
  constructor({ concurrency: e, ...n }) {
    super(e ? { maxConcurrency: e, ...n } : n), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "llms", this._llmType()]
    });
  }
  /**
   * This method takes an input and options, and returns a string. It
   * converts the input to a prompt value and generates a result based on
   * the prompt.
   * @param input Input for the LLM.
   * @param options Options for the LLM call.
   * @returns A string result based on the prompt.
   */
  async invoke(e, n) {
    const a = Fo._convertInputToPromptValue(e);
    return (await this.generatePrompt([a], n, n?.callbacks)).generations[0][0].text;
  }
  // eslint-disable-next-line require-yield
  async *_streamResponseChunks(e, n, a) {
    throw new Error("Not implemented.");
  }
  _separateRunnableConfigFromCallOptionsCompat(e) {
    const [n, a] = super._separateRunnableConfigFromCallOptions(e);
    return a.signal = n.signal, [n, a];
  }
  async *_streamIterator(e, n) {
    if (this._streamResponseChunks === Fo.prototype._streamResponseChunks)
      yield this.invoke(e, n);
    else {
      const a = Fo._convertInputToPromptValue(e), [r, i] = this._separateRunnableConfigFromCallOptionsCompat(n), s = await it.configure(r.callbacks, this.callbacks, r.tags, this.tags, r.metadata, this.metadata, { verbose: this.verbose }), u = {
        options: i,
        invocation_params: this?.invocationParams(i),
        batch_size: 1
      }, d = await s?.handleLLMStart(this.toJSON(), [a.toString()], r.runId, void 0, u, void 0, void 0, r.runName);
      let f = new fa({
        text: ""
      });
      try {
        for await (const o of this._streamResponseChunks(a.toString(), i, d?.[0]))
          f ? f = f.concat(o) : f = o, typeof o.text == "string" && (yield o.text);
      } catch (o) {
        throw await Promise.all((d ?? []).map((c) => c?.handleLLMError(o))), o;
      }
      await Promise.all((d ?? []).map((o) => o?.handleLLMEnd({
        generations: [[f]]
      })));
    }
  }
  /**
   * This method takes prompt values, options, and callbacks, and generates
   * a result based on the prompts.
   * @param promptValues Prompt values for the LLM.
   * @param options Options for the LLM call.
   * @param callbacks Callbacks for the LLM call.
   * @returns An LLMResult based on the prompts.
   */
  async generatePrompt(e, n, a) {
    const r = e.map((i) => i.toString());
    return this.generate(r, n, a);
  }
  /**
   * Get the parameters used to invoke the model
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  invocationParams(e) {
    return {};
  }
  _flattenLLMResult(e) {
    const n = [];
    for (let a = 0; a < e.generations.length; a += 1) {
      const r = e.generations[a];
      if (a === 0)
        n.push({
          generations: [r],
          llmOutput: e.llmOutput
        });
      else {
        const i = e.llmOutput ? { ...e.llmOutput, tokenUsage: {} } : void 0;
        n.push({
          generations: [r],
          llmOutput: i
        });
      }
    }
    return n;
  }
  /** @ignore */
  async _generateUncached(e, n, a, r) {
    let i;
    if (r !== void 0 && r.length === e.length)
      i = r;
    else {
      const f = await it.configure(a.callbacks, this.callbacks, a.tags, this.tags, a.metadata, this.metadata, { verbose: this.verbose }), o = {
        options: n,
        invocation_params: this?.invocationParams(n),
        batch_size: e.length
      };
      i = await f?.handleLLMStart(this.toJSON(), e, a.runId, void 0, o, void 0, void 0, a?.runName);
    }
    const s = !!i?.[0].handlers.find(xC);
    let u;
    if (s && e.length === 1 && this._streamResponseChunks !== Fo.prototype._streamResponseChunks)
      try {
        const f = await this._streamResponseChunks(e[0], n, i?.[0]);
        let o;
        for await (const c of f)
          o === void 0 ? o = c : o = an(o, c);
        if (o === void 0)
          throw new Error("Received empty response from chat model call.");
        u = { generations: [[o]], llmOutput: {} }, await i?.[0].handleLLMEnd(u);
      } catch (f) {
        throw await i?.[0].handleLLMError(f), f;
      }
    else {
      try {
        u = await this._generate(e, n, i?.[0]);
      } catch (o) {
        throw await Promise.all((i ?? []).map((c) => c?.handleLLMError(o))), o;
      }
      const f = this._flattenLLMResult(u);
      await Promise.all((i ?? []).map((o, c) => o?.handleLLMEnd(f[c])));
    }
    const d = i?.map((f) => f.runId) || void 0;
    return Object.defineProperty(u, pd, {
      value: d ? { runIds: d } : void 0,
      configurable: !0
    }), u;
  }
  async _generateCached({ prompts: e, cache: n, llmStringKey: a, parsedOptions: r, handledOptions: i, runId: s }) {
    const u = await it.configure(i.callbacks, this.callbacks, i.tags, this.tags, i.metadata, this.metadata, { verbose: this.verbose }), d = {
      options: r,
      invocation_params: this?.invocationParams(r),
      batch_size: e.length
    }, f = await u?.handleLLMStart(this.toJSON(), e, s, void 0, d, void 0, void 0, i?.runName), o = [], h = (await Promise.allSettled(e.map(async (m, b) => {
      const g = await n.lookup(m, a);
      return g == null && o.push(b), g;
    }))).map((m, b) => ({ result: m, runManager: f?.[b] })).filter(({ result: m }) => m.status === "fulfilled" && m.value != null || m.status === "rejected"), p = [];
    await Promise.all(h.map(async ({ result: m, runManager: b }, g) => {
      if (m.status === "fulfilled") {
        const _ = m.value;
        return p[g] = _.map((P) => (P.generationInfo = {
          ...P.generationInfo,
          tokenUsage: {}
        }, P)), _.length && await b?.handleLLMNewToken(_[0].text), b?.handleLLMEnd({
          generations: [_]
        }, void 0, void 0, void 0, {
          cached: !0
        });
      } else
        return await b?.handleLLMError(m.reason, void 0, void 0, void 0, {
          cached: !0
        }), Promise.reject(m.reason);
    }));
    const l = {
      generations: p,
      missingPromptIndices: o,
      startedRunManagers: f
    };
    return Object.defineProperty(l, pd, {
      value: f ? { runIds: f?.map((m) => m.runId) } : void 0,
      configurable: !0
    }), l;
  }
  /**
   * Run the LLM on the given prompts and input, handling caching.
   */
  async generate(e, n, a) {
    if (!Array.isArray(e))
      throw new Error("Argument 'prompts' is expected to be a string[]");
    let r;
    Array.isArray(n) ? r = { stop: n } : r = n;
    const [i, s] = this._separateRunnableConfigFromCallOptionsCompat(r);
    if (i.callbacks = i.callbacks ?? a, !this.cache)
      return this._generateUncached(e, s, i);
    const { cache: u } = this, d = this._getSerializedCacheKeyParametersForCall(s), { generations: f, missingPromptIndices: o, startedRunManagers: c } = await this._generateCached({
      prompts: e,
      cache: u,
      llmStringKey: d,
      parsedOptions: s,
      handledOptions: i,
      runId: i.runId
    });
    let h = {};
    if (o.length > 0) {
      const p = await this._generateUncached(o.map((l) => e[l]), s, i, c !== void 0 ? o.map((l) => c?.[l]) : void 0);
      await Promise.all(p.generations.map(async (l, m) => {
        const b = o[m];
        return f[b] = l, u.update(e[b], d, l);
      })), h = p.llmOutput ?? {};
    }
    return { generations: f, llmOutput: h };
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   * Convenience wrapper for {@link generate} that takes in a single string prompt and returns a single string output.
   */
  async call(e, n, a) {
    const { generations: r } = await this.generate([e], n, a);
    return r[0][0].text;
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * This method is similar to `call`, but it's used for making predictions
   * based on the input text.
   * @param text Input text for the prediction.
   * @param options Options for the LLM call.
   * @param callbacks Callbacks for the LLM call.
   * @returns A prediction based on the input text.
   */
  async predict(e, n, a) {
    return this.call(e, n, a);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * This method takes a list of messages, options, and callbacks, and
   * returns a predicted message.
   * @param messages A list of messages for the prediction.
   * @param options Options for the LLM call.
   * @param callbacks Callbacks for the LLM call.
   * @returns A predicted message based on the list of messages.
   */
  async predictMessages(e, n, a) {
    const r = so(e), i = await this.call(r, n, a);
    return new At(i);
  }
  /**
   * Get the identifying parameters of the LLM.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _identifyingParams() {
    return {};
  }
  /**
   * @deprecated
   * Return a json-like object representing this LLM.
   */
  serialize() {
    return {
      ...this._identifyingParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  _modelType() {
    return "base_llm";
  }
}
class Wk extends Fo {
  async _generate(e, n, a) {
    return { generations: await Promise.all(e.map((i, s) => this._call(i, { ...n, promptIndex: s }, a).then((u) => [{ text: u }]))) };
  }
}
const kh = (t, e) => t.reduce((n, a, r) => {
  const i = Math.floor(r / e), s = n[i] || [];
  return n[i] = s.concat([a]), n;
}, []);
class uV extends Fo {
  static lc_name() {
    return "OpenAI";
  }
  get callKeys() {
    return [...super.callKeys, "options"];
  }
  get lc_secrets() {
    return {
      openAIApiKey: "OPENAI_API_KEY",
      apiKey: "OPENAI_API_KEY",
      organization: "OPENAI_ORGANIZATION"
    };
  }
  get lc_aliases() {
    return {
      modelName: "model",
      openAIApiKey: "openai_api_key",
      apiKey: "openai_api_key"
    };
  }
  constructor(e) {
    if (super(e ?? {}), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "frequencyPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "presencePenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "n", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "bestOf", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logitBias", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "gpt-3.5-turbo-instruct"
    }), Object.defineProperty(this, "modelName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "modelKwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 20
    }), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stopSequences", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "user", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "openAIApiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "organization", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "clientConfig", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.openAIApiKey = e?.apiKey ?? e?.openAIApiKey ?? _t("OPENAI_API_KEY"), this.apiKey = this.openAIApiKey, this.organization = e?.configuration?.organization ?? _t("OPENAI_ORGANIZATION"), this.model = e?.model ?? e?.modelName ?? this.model, (this.model?.startsWith("gpt-3.5-turbo") || this.model?.startsWith("gpt-4") || this.model?.startsWith("o1")) && !this.model?.includes("-instruct"))
      throw new Error([
        `Your chosen OpenAI model, "${this.model}", is a chat model and not a text-in/text-out LLM.`,
        'Passing it into the "OpenAI" class is no longer supported.',
        'Please use the "ChatOpenAI" class instead.',
        "",
        "See this page for more information:",
        "|",
        "> https://js.langchain.com/docs/integrations/chat/openai"
      ].join(`
`));
    if (this.modelName = this.model, this.modelKwargs = e?.modelKwargs ?? {}, this.batchSize = e?.batchSize ?? this.batchSize, this.timeout = e?.timeout, this.temperature = e?.temperature ?? this.temperature, this.maxTokens = e?.maxTokens ?? this.maxTokens, this.topP = e?.topP ?? this.topP, this.frequencyPenalty = e?.frequencyPenalty ?? this.frequencyPenalty, this.presencePenalty = e?.presencePenalty ?? this.presencePenalty, this.n = e?.n ?? this.n, this.bestOf = e?.bestOf ?? this.bestOf, this.logitBias = e?.logitBias, this.stop = e?.stopSequences ?? e?.stop, this.stopSequences = this.stop, this.user = e?.user, this.streaming = e?.streaming ?? !1, this.streaming && this.bestOf && this.bestOf > 1)
      throw new Error("Cannot stream results when bestOf > 1");
    this.clientConfig = {
      apiKey: this.apiKey,
      organization: this.organization,
      dangerouslyAllowBrowser: !0,
      ...e?.configuration
    };
  }
  /**
   * Get the parameters used to invoke the model
   */
  invocationParams(e) {
    return {
      model: this.model,
      temperature: this.temperature,
      max_tokens: this.maxTokens,
      top_p: this.topP,
      frequency_penalty: this.frequencyPenalty,
      presence_penalty: this.presencePenalty,
      n: this.n,
      best_of: this.bestOf,
      logit_bias: this.logitBias,
      stop: e?.stop ?? this.stopSequences,
      user: this.user,
      stream: this.streaming,
      ...this.modelKwargs
    };
  }
  /** @ignore */
  _identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams(),
      ...this.clientConfig
    };
  }
  /**
   * Get the identifying parameters for the model
   */
  identifyingParams() {
    return this._identifyingParams();
  }
  /**
   * Call out to OpenAI's endpoint with k unique prompts
   *
   * @param [prompts] - The prompts to pass into the model.
   * @param [options] - Optional list of stop words to use when generating.
   * @param [runManager] - Optional callback manager to use when generating.
   *
   * @returns The full LLM output.
   *
   * @example
   * ```ts
   * import { OpenAI } from "langchain/llms/openai";
   * const openai = new OpenAI();
   * const response = await openai.generate(["Tell me a joke."]);
   * ```
   */
  async _generate(e, n, a) {
    const r = kh(e, this.batchSize), i = [], s = {}, u = this.invocationParams(n);
    if (u.max_tokens === -1) {
      if (e.length !== 1)
        throw new Error("max_tokens set to -1 not supported for multiple inputs");
      u.max_tokens = await GF({
        prompt: e[0],
        // Cast here to allow for other models that may not fit the union
        modelName: this.model
      });
    }
    for (let f = 0; f < r.length; f += 1) {
      const o = u.stream ? await (async () => {
        const l = [];
        let m;
        const b = await this.completionWithRetry({
          ...u,
          stream: !0,
          prompt: r[f]
        }, n);
        for await (const g of b) {
          m || (m = {
            id: g.id,
            object: g.object,
            created: g.created,
            model: g.model
          });
          for (const _ of g.choices) {
            if (!l[_.index])
              l[_.index] = _;
            else {
              const P = l[_.index];
              P.text += _.text, P.finish_reason = _.finish_reason, P.logprobs = _.logprobs;
            }
            a?.handleLLMNewToken(_.text, {
              prompt: Math.floor(_.index / this.n),
              completion: _.index % this.n
            });
          }
        }
        if (n.signal?.aborted)
          throw new Error("AbortError");
        return { ...m, choices: l };
      })() : await this.completionWithRetry({
        ...u,
        stream: !1,
        prompt: r[f]
      }, {
        signal: n.signal,
        ...n.options
      });
      i.push(...o.choices);
      const { completion_tokens: c, prompt_tokens: h, total_tokens: p } = o.usage ? o.usage : {
        completion_tokens: void 0,
        prompt_tokens: void 0,
        total_tokens: void 0
      };
      c && (s.completionTokens = (s.completionTokens ?? 0) + c), h && (s.promptTokens = (s.promptTokens ?? 0) + h), p && (s.totalTokens = (s.totalTokens ?? 0) + p);
    }
    return {
      generations: kh(i, this.n).map((f) => f.map((o) => ({
        text: o.text ?? "",
        generationInfo: {
          finishReason: o.finish_reason,
          logprobs: o.logprobs
        }
      }))),
      llmOutput: { tokenUsage: s }
    };
  }
  // TODO(jacoblee): Refactor with _generate(..., {stream: true}) implementation?
  async *_streamResponseChunks(e, n, a) {
    const r = {
      ...this.invocationParams(n),
      prompt: e,
      stream: !0
    }, i = await this.completionWithRetry(r, n);
    for await (const s of i) {
      const u = s?.choices[0];
      if (!u)
        continue;
      const d = new fa({
        text: u.text,
        generationInfo: {
          finishReason: u.finish_reason
        }
      });
      yield d, a?.handleLLMNewToken(d.text ?? "");
    }
    if (n.signal?.aborted)
      throw new Error("AbortError");
  }
  async completionWithRetry(e, n) {
    const a = this._getClientOptions(n);
    return this.caller.call(async () => {
      try {
        return await this.client.completions.create(e, a);
      } catch (r) {
        throw Ul(r);
      }
    });
  }
  /**
   * Calls the OpenAI API with retry logic in case of failures.
   * @param request The request to send to the OpenAI API.
   * @param options Optional configuration for the API call.
   * @returns The response from the OpenAI API.
   */
  _getClientOptions(e) {
    if (!this.client) {
      const a = {
        baseURL: this.clientConfig.baseURL
      }, r = Zg(a), i = {
        ...this.clientConfig,
        baseURL: r,
        timeout: this.timeout,
        maxRetries: 0
      };
      i.baseURL || delete i.baseURL, this.client = new ge(i);
    }
    return {
      ...this.clientConfig,
      ...e
    };
  }
  _llmType() {
    return "openai";
  }
}
class Xg {
  constructor(e) {
    Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.caller = new Qo(e ?? {});
  }
}
class cV extends Xg {
  constructor(e) {
    const n = { maxConcurrency: 2, ...e };
    super(n), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "text-embedding-ada-002"
    }), Object.defineProperty(this, "modelName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 512
    }), Object.defineProperty(this, "stripNewLines", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "dimensions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "organization", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "clientConfig", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const a = n?.apiKey ?? n?.openAIApiKey ?? _t("OPENAI_API_KEY");
    this.organization = n?.configuration?.organization ?? _t("OPENAI_ORGANIZATION"), this.model = n?.model ?? n?.modelName ?? this.model, this.modelName = this.model, this.batchSize = n?.batchSize ?? this.batchSize, this.stripNewLines = n?.stripNewLines ?? this.stripNewLines, this.timeout = n?.timeout, this.dimensions = n?.dimensions, this.clientConfig = {
      apiKey: a,
      organization: this.organization,
      dangerouslyAllowBrowser: !0,
      ...e?.configuration
    };
  }
  /**
   * Method to generate embeddings for an array of documents. Splits the
   * documents into batches and makes requests to the OpenAI API to generate
   * embeddings.
   * @param texts Array of documents to generate embeddings for.
   * @returns Promise that resolves to a 2D array of embeddings for each document.
   */
  async embedDocuments(e) {
    const n = kh(this.stripNewLines ? e.map((s) => s.replace(/\n/g, " ")) : e, this.batchSize), a = n.map((s) => {
      const u = {
        model: this.model,
        input: s
      };
      return this.dimensions && (u.dimensions = this.dimensions), this.embeddingWithRetry(u);
    }), r = await Promise.all(a), i = [];
    for (let s = 0; s < r.length; s += 1) {
      const u = n[s], { data: d } = r[s];
      for (let f = 0; f < u.length; f += 1)
        i.push(d[f].embedding);
    }
    return i;
  }
  /**
   * Method to generate an embedding for a single document. Calls the
   * embeddingWithRetry method with the document as the input.
   * @param text Document to generate an embedding for.
   * @returns Promise that resolves to an embedding for the document.
   */
  async embedQuery(e) {
    const n = {
      model: this.model,
      input: this.stripNewLines ? e.replace(/\n/g, " ") : e
    };
    this.dimensions && (n.dimensions = this.dimensions);
    const { data: a } = await this.embeddingWithRetry(n);
    return a[0].embedding;
  }
  /**
   * Private method to make a request to the OpenAI API to generate
   * embeddings. Handles the retry logic and returns the response from the
   * API.
   * @param request Request to send to the OpenAI API.
   * @returns Promise that resolves to the response from the API.
   */
  async embeddingWithRetry(e) {
    if (!this.client) {
      const a = {
        baseURL: this.clientConfig.baseURL
      }, r = Zg(a), i = {
        ...this.clientConfig,
        baseURL: r,
        timeout: this.timeout,
        maxRetries: 0
      };
      i.baseURL || delete i.baseURL, this.client = new ge(i);
    }
    const n = {};
    return this.caller.call(async () => {
      try {
        return await this.client.embeddings.create(e, n);
      } catch (a) {
        throw Ul(a);
      }
    });
  }
}
class Xk extends Bg {
  get lc_namespace() {
    return ["langchain", "tools"];
  }
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "returnDirect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "verboseParsingErrors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "responseFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "content"
    }), this.verboseParsingErrors = e?.verboseParsingErrors ?? this.verboseParsingErrors, this.responseFormat = e?.responseFormat ?? this.responseFormat;
  }
  /**
   * Invokes the tool with the provided input and configuration.
   * @param input The input for the tool.
   * @param config Optional configuration for the tool.
   * @returns A Promise that resolves with a string.
   */
  async invoke(e, n) {
    let a, r, i = Ce(n);
    return Ig(e) ? (a = e.id, r = e.args, i = {
      ...i,
      toolCall: e,
      configurable: {
        ...i.configurable,
        tool_call_id: a
      }
    }) : r = e, this.call(r, i);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
   *
   * Calls the tool with the provided argument, configuration, and tags. It
   * parses the input according to the schema, handles any errors, and
   * manages callbacks.
   * @param arg The input argument for the tool.
   * @param configArg Optional configuration or callbacks for the tool.
   * @param tags Optional tags for the tool.
   * @returns A Promise that resolves with a string.
   */
  async call(e, n, a) {
    let r;
    try {
      r = await this.schema.parseAsync(e);
    } catch (p) {
      let l = "Received tool input did not match expected schema";
      throw this.verboseParsingErrors && (l = `${l}
Details: ${p.message}`), new fh(l, JSON.stringify(e));
    }
    const i = cp(n), u = await it.configure(i.callbacks, this.callbacks, i.tags || a, this.tags, i.metadata, this.metadata, { verbose: this.verbose })?.handleToolStart(this.toJSON(), typeof r == "string" ? r : JSON.stringify(r), i.runId, void 0, void 0, void 0, i.runName);
    delete i.runId;
    let d;
    try {
      d = await this._call(r, u, i);
    } catch (p) {
      throw await u?.handleToolError(p), p;
    }
    let f, o;
    if (this.responseFormat === "content_and_artifact")
      if (Array.isArray(d) && d.length === 2)
        [f, o] = d;
      else
        throw new Error(`Tool response format is "content_and_artifact" but the output was not a two-tuple.
Result: ${JSON.stringify(d)}`);
    else
      f = d;
    let c;
    i && "configurable" in i && (c = i.configurable.tool_call_id);
    const h = Qk({
      content: f,
      artifact: o,
      toolCallId: c,
      name: this.name
    });
    return await u?.handleToolEnd(h), h;
  }
}
class fp extends Xk {
  constructor(e) {
    super(e), Object.defineProperty(this, "schema", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: wn.object({ input: wn.string().optional() }).transform((n) => n.input)
    });
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
   *
   * Calls the tool with the provided argument and callbacks. It handles
   * string inputs specifically.
   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.
   * @param callbacks Optional callbacks for the tool.
   * @returns A Promise that resolves with a string.
   */
  call(e, n) {
    return super.call(typeof e == "string" || !e ? { input: e } : e, n);
  }
}
class lV extends fp {
  static lc_name() {
    return "DynamicTool";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "description", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "func", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = e.name, this.description = e.description, this.func = e.func, this.returnDirect = e.returnDirect ?? this.returnDirect;
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
   */
  async call(e, n) {
    const a = cp(n);
    return a.runName === void 0 && (a.runName = this.name), super.call(e, a);
  }
  /** @ignore */
  async _call(e, n, a) {
    return this.func(e, n, a);
  }
}
function Qk(t) {
  const { content: e, artifact: n, toolCallId: a } = t;
  return a && !vE(e) ? typeof e == "string" || Array.isArray(e) && e.every((r) => typeof r == "object") ? new Cb({
    content: e,
    artifact: n,
    tool_call_id: a,
    name: t.name
  }) : new Cb({
    content: Yk(e),
    artifact: n,
    tool_call_id: a,
    name: t.name
  }) : e;
}
function Yk(t) {
  try {
    return JSON.stringify(t, null, 2);
  } catch {
    return `${t}`;
  }
}
const ju = "0.37.0";
let Tv = !1, Bl, _R, xb, yR, vR, wR;
function eD(t, e = { auto: !1 }) {
  if (Tv)
    throw new Error(`you must \`import '@anthropic-ai/sdk/shims/${t.kind}'\` before importing anything else from @anthropic-ai/sdk`);
  if (Bl)
    throw new Error(`can't \`import '@anthropic-ai/sdk/shims/${t.kind}'\` after \`import '@anthropic-ai/sdk/shims/${Bl}'\``);
  Tv = e.auto, Bl = t.kind, _R = t.fetch, xb = t.File, yR = t.ReadableStream, vR = t.getDefaultAgent, wR = t.fileFromPath;
}
let tD = class {
  constructor(e) {
    this.body = e;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};
function nD({ manuallyImported: t } = {}) {
  const e = t ? "You may need to use polyfills" : "Add one of these imports before your first `import  from '@anthropic-ai/sdk'`:\n- `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)\n- `import '@anthropic-ai/sdk/shims/web'` (otherwise)\n";
  let n, a, r, i;
  try {
    n = fetch, a = Request, r = Response, i = Headers;
  } catch (s) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${s.message}. ${e}`);
  }
  return {
    kind: "web",
    fetch: n,
    Request: a,
    Response: r,
    Headers: i,
    FormData: (
      // @ts-ignore
      typeof FormData < "u" ? FormData : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`);
        }
      }
    ),
    Blob: typeof Blob < "u" ? Blob : class {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File < "u" ? File : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream < "u" ? ReadableStream : class {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`);
        }
      }
    ),
    getMultipartRequestOptions: async (s, u) => ({
      ...u,
      body: new tD(s)
    }),
    getDefaultAgent: (s) => {
    },
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/anthropics/anthropic-sdk-typescript#file-uploads");
    },
    isFsReadStream: (s) => !1
  };
}
Bl || eD(nD(), { auto: !0 });
class je extends Error {
}
let Cn = class Vb extends je {
  constructor(e, n, a, r) {
    super(`${Vb.makeMessage(e, n, a)}`), this.status = e, this.headers = r, this.request_id = r?.["request-id"], this.error = n;
  }
  static makeMessage(e, n, a) {
    const r = n?.message ? typeof n.message == "string" ? n.message : JSON.stringify(n.message) : n ? JSON.stringify(n) : a;
    return e && r ? `${e} ${r}` : e ? `${e} status code (no body)` : r || "(no status code or body)";
  }
  static generate(e, n, a, r) {
    if (!e || !r)
      return new hp({ message: a, cause: zb(n) });
    const i = n;
    return e === 400 ? new OR(e, i, a, r) : e === 401 ? new jR(e, i, a, r) : e === 403 ? new PR(e, i, a, r) : e === 404 ? new CR(e, i, a, r) : e === 409 ? new RR(e, i, a, r) : e === 422 ? new TR(e, i, a, r) : e === 429 ? new $R(e, i, a, r) : e >= 500 ? new MR(e, i, a, r) : new Vb(e, i, a, r);
  }
}, or = class extends Cn {
  constructor({ message: e } = {}) {
    super(void 0, void 0, e || "Request was aborted.", void 0);
  }
}, hp = class extends Cn {
  constructor({ message: e, cause: n }) {
    super(void 0, void 0, e || "Connection error.", void 0), n && (this.cause = n);
  }
}, SR = class extends hp {
  constructor({ message: e } = {}) {
    super({ message: e ?? "Request timed out." });
  }
}, OR = class extends Cn {
}, jR = class extends Cn {
}, PR = class extends Cn {
}, CR = class extends Cn {
}, RR = class extends Cn {
}, TR = class extends Cn {
}, $R = class extends Cn {
}, MR = class extends Cn {
};
var bf = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, Oo = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, bn;
let kd = class {
  constructor() {
    bn.set(this, void 0), this.buffer = new Uint8Array(), bf(this, bn, null, "f");
  }
  decode(e) {
    if (e == null)
      return [];
    const n = e instanceof ArrayBuffer ? new Uint8Array(e) : typeof e == "string" ? new TextEncoder().encode(e) : e;
    let a = new Uint8Array(this.buffer.length + n.length);
    a.set(this.buffer), a.set(n, this.buffer.length), this.buffer = a;
    const r = [];
    let i;
    for (; (i = rD(this.buffer, Oo(this, bn, "f"))) != null; ) {
      if (i.carriage && Oo(this, bn, "f") == null) {
        bf(this, bn, i.index, "f");
        continue;
      }
      if (Oo(this, bn, "f") != null && (i.index !== Oo(this, bn, "f") + 1 || i.carriage)) {
        r.push(this.decodeText(this.buffer.slice(0, Oo(this, bn, "f") - 1))), this.buffer = this.buffer.slice(Oo(this, bn, "f")), bf(this, bn, null, "f");
        continue;
      }
      const s = Oo(this, bn, "f") !== null ? i.preceding - 1 : i.preceding, u = this.decodeText(this.buffer.slice(0, s));
      r.push(u), this.buffer = this.buffer.slice(i.index), bf(this, bn, null, "f");
    }
    return r;
  }
  decodeText(e) {
    if (e == null)
      return "";
    if (typeof e == "string")
      return e;
    if (typeof st < "u") {
      if (e instanceof st)
        return e.toString();
      if (e instanceof Uint8Array)
        return st.from(e).toString();
      throw new je(`Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder < "u") {
      if (e instanceof Uint8Array || e instanceof ArrayBuffer)
        return this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8")), this.textDecoder.decode(e);
      throw new je(`Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new je("Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.");
  }
  flush() {
    return this.buffer.length ? this.decode(`
`) : [];
  }
};
bn = /* @__PURE__ */ new WeakMap();
kd.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r"]);
kd.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function rD(t, e) {
  for (let r = e ?? 0; r < t.length; r++) {
    if (t[r] === 10)
      return { preceding: r, index: r + 1, carriage: !1 };
    if (t[r] === 13)
      return { preceding: r, index: r + 1, carriage: !0 };
  }
  return null;
}
function aD(t) {
  for (let a = 0; a < t.length - 1; a++) {
    if (t[a] === 10 && t[a + 1] === 10 || t[a] === 13 && t[a + 1] === 13)
      return a + 2;
    if (t[a] === 13 && t[a + 1] === 10 && a + 3 < t.length && t[a + 2] === 13 && t[a + 3] === 10)
      return a + 4;
  }
  return -1;
}
function Qg(t) {
  if (t[Symbol.asyncIterator])
    return t;
  const e = t.getReader();
  return {
    async next() {
      try {
        const n = await e.read();
        return n?.done && e.releaseLock(), n;
      } catch (n) {
        throw e.releaseLock(), n;
      }
    },
    async return() {
      const n = e.cancel();
      return e.releaseLock(), await n, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
let md = class Il {
  constructor(e, n) {
    this.iterator = e, this.controller = n;
  }
  static fromSSEResponse(e, n) {
    let a = !1;
    async function* r() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let i = !1;
      try {
        for await (const s of iD(e, n)) {
          if (s.event === "completion")
            try {
              yield JSON.parse(s.data);
            } catch (u) {
              throw console.error("Could not parse message into JSON:", s.data), console.error("From chunk:", s.raw), u;
            }
          if (s.event === "message_start" || s.event === "message_delta" || s.event === "message_stop" || s.event === "content_block_start" || s.event === "content_block_delta" || s.event === "content_block_stop")
            try {
              yield JSON.parse(s.data);
            } catch (u) {
              throw console.error("Could not parse message into JSON:", s.data), console.error("From chunk:", s.raw), u;
            }
          if (s.event !== "ping" && s.event === "error")
            throw Cn.generate(void 0, `SSE Error: ${s.data}`, s.data, FR(e.headers));
        }
        i = !0;
      } catch (s) {
        if (s instanceof Error && s.name === "AbortError")
          return;
        throw s;
      } finally {
        i || n.abort();
      }
    }
    return new Il(r, n);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(e, n) {
    let a = !1;
    async function* r() {
      const s = new kd(), u = Qg(e);
      for await (const d of u)
        for (const f of s.decode(d))
          yield f;
      for (const d of s.flush())
        yield d;
    }
    async function* i() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let s = !1;
      try {
        for await (const u of r())
          s || u && (yield JSON.parse(u));
        s = !0;
      } catch (u) {
        if (u instanceof Error && u.name === "AbortError")
          return;
        throw u;
      } finally {
        s || n.abort();
      }
    }
    return new Il(i, n);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const e = [], n = [], a = this.iterator(), r = (i) => ({
      next: () => {
        if (i.length === 0) {
          const s = a.next();
          e.push(s), n.push(s);
        }
        return i.shift();
      }
    });
    return [
      new Il(() => r(e), this.controller),
      new Il(() => r(n), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const e = this;
    let n;
    const a = new TextEncoder();
    return new yR({
      async start() {
        n = e[Symbol.asyncIterator]();
      },
      async pull(r) {
        try {
          const { value: i, done: s } = await n.next();
          if (s)
            return r.close();
          const u = a.encode(JSON.stringify(i) + `
`);
          r.enqueue(u);
        } catch (i) {
          r.error(i);
        }
      },
      async cancel() {
        await n.return?.();
      }
    });
  }
};
async function* iD(t, e) {
  if (!t.body)
    throw e.abort(), new je("Attempted to iterate over a response with no body");
  const n = new oD(), a = new kd(), r = Qg(t.body);
  for await (const i of sD(r))
    for (const s of a.decode(i)) {
      const u = n.decode(s);
      u && (yield u);
    }
  for (const i of a.flush()) {
    const s = n.decode(i);
    s && (yield s);
  }
}
async function* sD(t) {
  let e = new Uint8Array();
  for await (const n of t) {
    if (n == null)
      continue;
    const a = n instanceof ArrayBuffer ? new Uint8Array(n) : typeof n == "string" ? new TextEncoder().encode(n) : n;
    let r = new Uint8Array(e.length + a.length);
    r.set(e), r.set(a, e.length), e = r;
    let i;
    for (; (i = aD(e)) !== -1; )
      yield e.slice(0, i), e = e.slice(i);
  }
  e.length > 0 && (yield e);
}
let oD = class {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(e) {
    if (e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e) {
      if (!this.event && !this.data.length)
        return null;
      const i = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], i;
    }
    if (this.chunks.push(e), e.startsWith(":"))
      return null;
    let [n, a, r] = uD(e, ":");
    return r.startsWith(" ") && (r = r.substring(1)), n === "event" ? this.event = r : n === "data" && this.data.push(r), null;
  }
};
function uD(t, e) {
  const n = t.indexOf(e);
  return n !== -1 ? [t.substring(0, n), e, t.substring(n + e.length)] : [t, "", ""];
}
const cD = (t) => t != null && typeof t == "object" && typeof t.url == "string" && typeof t.blob == "function", lD = (t) => t != null && typeof t == "object" && typeof t.name == "string" && typeof t.lastModified == "number" && pp(t), pp = (t) => t != null && typeof t == "object" && typeof t.size == "number" && typeof t.type == "string" && typeof t.text == "function" && typeof t.slice == "function" && typeof t.arrayBuffer == "function";
async function dD(t, e, n) {
  if (t = await t, lD(t))
    return t;
  if (cD(t)) {
    const r = await t.blob();
    e || (e = new URL(t.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const i = pp(r) ? [await r.arrayBuffer()] : [r];
    return new xb(i, e, n);
  }
  const a = await fD(t);
  if (e || (e = pD(t) ?? "unknown_file"), !n?.type) {
    const r = a[0]?.type;
    typeof r == "string" && (n = { ...n, type: r });
  }
  return new xb(a, e, n);
}
async function fD(t) {
  let e = [];
  if (typeof t == "string" || ArrayBuffer.isView(t) || // includes Uint8Array, Buffer, etc.
  t instanceof ArrayBuffer)
    e.push(t);
  else if (pp(t))
    e.push(await t.arrayBuffer());
  else if (mD(t))
    for await (const n of t)
      e.push(n);
  else
    throw new Error(`Unexpected data type: ${typeof t}; constructor: ${t?.constructor?.name}; props: ${hD(t)}`);
  return e;
}
function hD(t) {
  return `[${Object.getOwnPropertyNames(t).map((n) => `"${n}"`).join(", ")}]`;
}
function pD(t) {
  return Pm(t.name) || Pm(t.filename) || // For fs.ReadStream
  Pm(t.path)?.split(/[\\/]/).pop();
}
const Pm = (t) => {
  if (typeof t == "string")
    return t;
  if (typeof st < "u" && t instanceof st)
    return String(t);
}, mD = (t) => t != null && typeof t == "object" && typeof t[Symbol.asyncIterator] == "function", $v = (t) => t && typeof t == "object" && t.body && t[Symbol.toStringTag] === "MultipartBody";
var bD = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, gD = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, gf;
async function AR(t) {
  const { response: e } = t;
  if (t.options.stream)
    return Ju("response", e.status, e.url, e.headers, e.body), t.options.__streamClass ? t.options.__streamClass.fromSSEResponse(e, t.controller) : md.fromSSEResponse(e, t.controller);
  if (e.status === 204)
    return null;
  if (t.options.__binaryResponse)
    return e;
  const n = e.headers.get("content-type");
  if (n?.includes("application/json") || n?.includes("application/vnd.api+json")) {
    const i = await e.json();
    return Ju("response", e.status, e.url, e.headers, i), ER(i, e);
  }
  const r = await e.text();
  return Ju("response", e.status, e.url, e.headers, r), r;
}
function ER(t, e) {
  return !t || typeof t != "object" || Array.isArray(t) ? t : Object.defineProperty(t, "_request_id", {
    value: e.headers.get("request-id"),
    enumerable: !1
  });
}
let IR = class NR extends Promise {
  constructor(e, n = AR) {
    super((a) => {
      a(null);
    }), this.responsePromise = e, this.parseResponse = n;
  }
  _thenUnwrap(e) {
    return new NR(this.responsePromise, async (n) => ER(e(await this.parseResponse(n), n), n.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from '@anthropic-ai/sdk'`:
   * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
   * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((e) => e.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from '@anthropic-ai/sdk'`:
   * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
   * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
   */
  async withResponse() {
    const [e, n] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: e, response: n, request_id: n.headers.get("request-id") };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)), this.parsedPromise;
  }
  then(e, n) {
    return this.parse().then(e, n);
  }
  catch(e) {
    return this.parse().catch(e);
  }
  finally(e) {
    return this.parse().finally(e);
  }
}, _D = class {
  constructor({
    baseURL: e,
    maxRetries: n = 2,
    timeout: a = 6e5,
    // 10 minutes
    httpAgent: r,
    fetch: i
  }) {
    this.baseURL = e, this.maxRetries = Cm("maxRetries", n), this.timeout = Cm("timeout", a), this.httpAgent = r, this.fetch = i ?? _R;
  }
  authHeaders(e) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(e) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...jD(),
      ...this.authHeaders(e)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(e, n) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${$D()}`;
  }
  get(e, n) {
    return this.methodRequest("get", e, n);
  }
  post(e, n) {
    return this.methodRequest("post", e, n);
  }
  patch(e, n) {
    return this.methodRequest("patch", e, n);
  }
  put(e, n) {
    return this.methodRequest("put", e, n);
  }
  delete(e, n) {
    return this.methodRequest("delete", e, n);
  }
  methodRequest(e, n, a) {
    return this.request(Promise.resolve(a).then(async (r) => {
      const i = r && pp(r?.body) ? new DataView(await r.body.arrayBuffer()) : r?.body instanceof DataView ? r.body : r?.body instanceof ArrayBuffer ? new DataView(r.body) : r && ArrayBuffer.isView(r?.body) ? new DataView(r.body.buffer) : r?.body;
      return { method: e, path: n, ...r, body: i };
    }));
  }
  getAPIList(e, n, a) {
    return this.requestAPIList(n, { method: "get", path: e, ...a });
  }
  calculateContentLength(e) {
    if (typeof e == "string") {
      if (typeof st < "u")
        return st.byteLength(e, "utf8").toString();
      if (typeof TextEncoder < "u")
        return new TextEncoder().encode(e).length.toString();
    } else if (ArrayBuffer.isView(e))
      return e.byteLength.toString();
    return null;
  }
  buildRequest(e, { retryCount: n = 0 } = {}) {
    e = { ...e };
    const { method: a, path: r, query: i, headers: s = {} } = e, u = ArrayBuffer.isView(e.body) || e.__binaryRequest && typeof e.body == "string" ? e.body : $v(e.body) ? e.body.body : e.body ? JSON.stringify(e.body, null, 2) : null, d = this.calculateContentLength(u), f = this.buildURL(r, i);
    "timeout" in e && Cm("timeout", e.timeout), e.timeout = e.timeout ?? this.timeout;
    const o = e.httpAgent ?? this.httpAgent ?? vR(f), c = e.timeout + 1e3;
    typeof o?.options?.timeout == "number" && c > (o.options.timeout ?? 0) && (o.options.timeout = c), this.idempotencyHeader && a !== "get" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()), s[this.idempotencyHeader] = e.idempotencyKey);
    const h = this.buildHeaders({ options: e, headers: s, contentLength: d, retryCount: n });
    return { req: {
      method: a,
      ...u && { body: u },
      headers: h,
      ...o && { agent: o },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: e.signal ?? null
    }, url: f, timeout: e.timeout };
  }
  buildHeaders({ options: e, headers: n, contentLength: a, retryCount: r }) {
    const i = {};
    a && (i["content-length"] = a);
    const s = this.defaultHeaders(e);
    return Iv(i, s), Iv(i, n), $v(e.body) && Bl !== "node" && delete i["content-type"], _f(s, "x-stainless-retry-count") === void 0 && _f(n, "x-stainless-retry-count") === void 0 && (i["x-stainless-retry-count"] = String(r)), _f(s, "x-stainless-timeout") === void 0 && _f(n, "x-stainless-timeout") === void 0 && e.timeout && (i["x-stainless-timeout"] = String(e.timeout)), this.validateHeaders(i, n), i;
  }
  _calculateNonstreamingTimeout(e) {
    if (3600 * e / 128e3 > 600)
      throw new je("Streaming is strongly recommended for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-python#streaming-responses for more details");
    return 600 * 1e3;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(e) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(e, { url: n, options: a }) {
  }
  parseHeaders(e) {
    return e ? Symbol.iterator in e ? Object.fromEntries(Array.from(e).map((n) => [...n])) : { ...e } : {};
  }
  makeStatusError(e, n, a, r) {
    return Cn.generate(e, n, a, r);
  }
  request(e, n = null) {
    return new IR(this.makeRequest(e, n));
  }
  async makeRequest(e, n) {
    const a = await e, r = a.maxRetries ?? this.maxRetries;
    n == null && (n = r), await this.prepareOptions(a);
    const { req: i, url: s, timeout: u } = this.buildRequest(a, { retryCount: r - n });
    if (await this.prepareRequest(i, { url: s, options: a }), Ju("request", s, a, i.headers), a.signal?.aborted)
      throw new or();
    const d = new AbortController(), f = await this.fetchWithTimeout(s, i, u, d).catch(zb);
    if (f instanceof Error) {
      if (a.signal?.aborted)
        throw new or();
      if (n)
        return this.retryRequest(a, n);
      throw f.name === "AbortError" ? new SR() : new hp({ cause: f });
    }
    const o = FR(f.headers);
    if (!f.ok) {
      if (n && this.shouldRetry(f)) {
        const b = `retrying, ${n} attempts remaining`;
        return Ju(`response (error; ${b})`, f.status, s, o), this.retryRequest(a, n, o);
      }
      const c = await f.text().catch((b) => zb(b).message), h = PD(c), p = h ? void 0 : c;
      throw Ju(`response (error; ${n ? "(error; no more retries left)" : "(error; not retryable)"})`, f.status, s, o, p), this.makeStatusError(f.status, h, p, o);
    }
    return { response: f, options: a, controller: d };
  }
  requestAPIList(e, n) {
    const a = this.makeRequest(n, null);
    return new vD(this, a, e);
  }
  buildURL(e, n) {
    const a = RD(e) ? new URL(e) : new URL(this.baseURL + (this.baseURL.endsWith("/") && e.startsWith("/") ? e.slice(1) : e)), r = this.defaultQuery();
    return Dh(r) || (n = { ...r, ...n }), typeof n == "object" && n && !Array.isArray(n) && (a.search = this.stringifyQuery(n)), a.toString();
  }
  stringifyQuery(e) {
    return Object.entries(e).filter(([n, a]) => typeof a < "u").map(([n, a]) => {
      if (typeof a == "string" || typeof a == "number" || typeof a == "boolean")
        return `${encodeURIComponent(n)}=${encodeURIComponent(a)}`;
      if (a === null)
        return `${encodeURIComponent(n)}=`;
      throw new je(`Cannot stringify type ${typeof a}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(e, n, a, r) {
    const { signal: i, ...s } = n || {};
    i && i.addEventListener("abort", () => r.abort());
    const u = setTimeout(() => r.abort(), a), d = {
      signal: r.signal,
      ...s
    };
    d.method && (d.method = d.method.toUpperCase());
    const f = 60 * 1e3, o = setTimeout(() => {
      if (d && d?.agent?.sockets)
        for (const c of Object.values(d?.agent?.sockets).flat())
          c?.setKeepAlive && c.setKeepAlive(!0, f);
    }, f);
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, e, d).finally(() => {
        clearTimeout(u), clearTimeout(o);
      })
    );
  }
  shouldRetry(e) {
    const n = e.headers.get("x-should-retry");
    return n === "true" ? !0 : n === "false" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500;
  }
  async retryRequest(e, n, a) {
    let r;
    const i = a?.["retry-after-ms"];
    if (i) {
      const u = parseFloat(i);
      Number.isNaN(u) || (r = u);
    }
    const s = a?.["retry-after"];
    if (s && !r) {
      const u = parseFloat(s);
      Number.isNaN(u) ? r = Date.parse(s) - Date.now() : r = u * 1e3;
    }
    if (!(r && 0 <= r && r < 60 * 1e3)) {
      const u = e.maxRetries ?? this.maxRetries;
      r = this.calculateDefaultRetryTimeoutMillis(n, u);
    }
    return await TD(r), this.makeRequest(e, n - 1);
  }
  calculateDefaultRetryTimeoutMillis(e, n) {
    const i = n - e, s = Math.min(0.5 * Math.pow(2, i), 8), u = 1 - Math.random() * 0.25;
    return s * u * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${ju}`;
  }
};
class yD {
  constructor(e, n, a, r) {
    gf.set(this, void 0), bD(this, gf, e, "f"), this.options = r, this.response = n, this.body = a;
  }
  hasNextPage() {
    return this.getPaginatedItems().length ? this.nextPageInfo() != null : !1;
  }
  async getNextPage() {
    const e = this.nextPageInfo();
    if (!e)
      throw new je("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    const n = { ...this.options };
    if ("params" in e && typeof n.query == "object")
      n.query = { ...n.query, ...e.params };
    else if ("url" in e) {
      const a = [...Object.entries(n.query || {}), ...e.url.searchParams.entries()];
      for (const [r, i] of a)
        e.url.searchParams.set(r, i);
      n.query = void 0, n.path = e.url.toString();
    }
    return await gD(this, gf, "f").requestAPIList(this.constructor, n);
  }
  async *iterPages() {
    let e = this;
    for (yield e; e.hasNextPage(); )
      e = await e.getNextPage(), yield e;
  }
  async *[(gf = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const e of this.iterPages())
      for (const n of e.getPaginatedItems())
        yield n;
  }
}
let vD = class extends IR {
  constructor(e, n, a) {
    super(n, async (r) => new a(e, r.response, await AR(r), r.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const e = await this;
    for await (const n of e)
      yield n;
  }
};
const FR = (t) => new Proxy(Object.fromEntries(
  // @ts-ignore
  t.entries()
), {
  get(e, n) {
    const a = n.toString();
    return e[a.toLowerCase()] || e[a];
  }
}), wD = {
  method: !0,
  path: !0,
  query: !0,
  body: !0,
  headers: !0,
  maxRetries: !0,
  stream: !0,
  timeout: !0,
  httpAgent: !0,
  signal: !0,
  idempotencyKey: !0,
  __binaryRequest: !0,
  __binaryResponse: !0,
  __streamClass: !0
}, ro = (t) => typeof t == "object" && t !== null && !Dh(t) && Object.keys(t).every((e) => kR(wD, e)), SD = () => {
  if (typeof Deno < "u" && Deno.build != null)
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": ju,
      "X-Stainless-OS": Av(Deno.build.os),
      "X-Stainless-Arch": Mv(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": ju,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": pe.version
    };
  if (Object.prototype.toString.call(typeof pe < "u" ? pe : 0) === "[object process]")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": ju,
      "X-Stainless-OS": Av(pe.platform),
      "X-Stainless-Arch": Mv(pe.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": pe.version
    };
  const t = OD();
  return t ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": ju,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${t.browser}`,
    "X-Stainless-Runtime-Version": t.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": ju,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function OD() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const t = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: e, pattern: n } of t) {
    const a = n.exec(navigator.userAgent);
    if (a) {
      const r = a[1] || 0, i = a[2] || 0, s = a[3] || 0;
      return { browser: e, version: `${r}.${i}.${s}` };
    }
  }
  return null;
}
const Mv = (t) => t === "x32" ? "x32" : t === "x86_64" || t === "x64" ? "x64" : t === "arm" ? "arm" : t === "aarch64" || t === "arm64" ? "arm64" : t ? `other:${t}` : "unknown", Av = (t) => (t = t.toLowerCase(), t.includes("ios") ? "iOS" : t === "android" ? "Android" : t === "darwin" ? "MacOS" : t === "win32" ? "Windows" : t === "freebsd" ? "FreeBSD" : t === "openbsd" ? "OpenBSD" : t === "linux" ? "Linux" : t ? `Other:${t}` : "Unknown");
let Ev;
const jD = () => Ev ?? (Ev = SD()), PD = (t) => {
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}, CD = /^[a-z][a-z0-9+.-]*:/i, RD = (t) => CD.test(t), TD = (t) => new Promise((e) => setTimeout(e, t)), Cm = (t, e) => {
  if (typeof e != "number" || !Number.isInteger(e))
    throw new je(`${t} must be an integer`);
  if (e < 0)
    throw new je(`${t} must be a positive integer`);
  return e;
}, zb = (t) => {
  if (t instanceof Error)
    return t;
  if (typeof t == "object" && t !== null)
    try {
      return new Error(JSON.stringify(t));
    } catch {
    }
  return new Error(String(t));
}, Rm = (t) => {
  if (typeof pe < "u")
    return pe.env?.[t]?.trim() ?? void 0;
  if (typeof Deno < "u")
    return Deno.env?.get?.(t)?.trim();
};
function Dh(t) {
  if (!t)
    return !0;
  for (const e in t)
    return !1;
  return !0;
}
function kR(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function Iv(t, e) {
  for (const n in e) {
    if (!kR(e, n))
      continue;
    const a = n.toLowerCase();
    if (!a)
      continue;
    const r = e[n];
    r === null ? delete t[a] : r !== void 0 && (t[a] = r);
  }
}
function Ju(t, ...e) {
  typeof pe < "u" && pe?.env?.DEBUG === "true" && console.log(`Anthropic:DEBUG:${t}`, ...e);
}
const $D = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
  const e = Math.random() * 16 | 0;
  return (t === "x" ? e : e & 3 | 8).toString(16);
}), MD = () => (
  // @ts-ignore
  typeof window < "u" && // @ts-ignore
  typeof window.document < "u" && // @ts-ignore
  typeof navigator < "u"
), AD = (t) => typeof t?.get == "function", _f = (t, e) => {
  const n = e.toLowerCase();
  if (AD(t)) {
    const a = e[0]?.toUpperCase() + e.substring(1).replace(/([^\w])(\w)/g, (r, i, s) => i + s.toUpperCase());
    for (const r of [e, n, e.toUpperCase(), a]) {
      const i = t.get(r);
      if (i)
        return i;
    }
  }
  for (const [a, r] of Object.entries(t))
    if (a.toLowerCase() === n)
      return Array.isArray(r) ? (r.length <= 1 || console.warn(`Received ${r.length} entries for the ${e} header, using the first entry.`), r[0]) : r;
};
class mp extends yD {
  constructor(e, n, a, r) {
    super(e, n, a, r), this.data = a.data || [], this.has_more = a.has_more || !1, this.first_id = a.first_id || null, this.last_id = a.last_id || null;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const e = this.nextPageInfo();
    if (!e)
      return null;
    if ("params" in e)
      return e.params;
    const n = Object.fromEntries(e.url.searchParams);
    return Object.keys(n).length ? n : null;
  }
  nextPageInfo() {
    if (this.options.query?.before_id) {
      const n = this.first_id;
      return n ? {
        params: {
          before_id: n
        }
      } : null;
    }
    const e = this.last_id;
    return e ? {
      params: {
        after_id: e
      }
    } : null;
  }
}
let bo = class {
  constructor(e) {
    this._client = e;
  }
}, Yg = class extends bo {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
  retrieve(e, n) {
    return this._client.get(`/v1/models/${e}?beta=true`, n);
  }
  list(e = {}, n) {
    return ro(e) ? this.list({}, e) : this._client.getAPIList("/v1/models?beta=true", e_, { query: e, ...n });
  }
};
class e_ extends mp {
}
Yg.BetaModelInfosPage = e_;
class bp {
  constructor(e, n) {
    this.iterator = e, this.controller = n;
  }
  async *decoder() {
    const e = new kd();
    for await (const n of this.iterator)
      for (const a of e.decode(n))
        yield JSON.parse(a);
    for (const n of e.flush())
      yield JSON.parse(n);
  }
  [Symbol.asyncIterator]() {
    return this.decoder();
  }
  static fromResponse(e, n) {
    if (!e.body)
      throw n.abort(), new je("Attempted to iterate over a response with no body");
    return new bp(Qg(e.body), n);
  }
}
let t_ = class extends bo {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  create(e, n) {
    const { betas: a, ...r } = e;
    return this._client.post("/v1/messages/batches?beta=true", {
      body: r,
      ...n,
      headers: {
        "anthropic-beta": [...a ?? [], "message-batches-2024-09-24"].toString(),
        ...n?.headers
      }
    });
  }
  retrieve(e, n = {}, a) {
    if (ro(n))
      return this.retrieve(e, {}, n);
    const { betas: r } = n;
    return this._client.get(`/v1/messages/batches/${e}?beta=true`, {
      ...a,
      headers: {
        "anthropic-beta": [...r ?? [], "message-batches-2024-09-24"].toString(),
        ...a?.headers
      }
    });
  }
  list(e = {}, n) {
    if (ro(e))
      return this.list({}, e);
    const { betas: a, ...r } = e;
    return this._client.getAPIList("/v1/messages/batches?beta=true", n_, {
      query: r,
      ...n,
      headers: {
        "anthropic-beta": [...a ?? [], "message-batches-2024-09-24"].toString(),
        ...n?.headers
      }
    });
  }
  delete(e, n = {}, a) {
    if (ro(n))
      return this.delete(e, {}, n);
    const { betas: r } = n;
    return this._client.delete(`/v1/messages/batches/${e}?beta=true`, {
      ...a,
      headers: {
        "anthropic-beta": [...r ?? [], "message-batches-2024-09-24"].toString(),
        ...a?.headers
      }
    });
  }
  cancel(e, n = {}, a) {
    if (ro(n))
      return this.cancel(e, {}, n);
    const { betas: r } = n;
    return this._client.post(`/v1/messages/batches/${e}/cancel?beta=true`, {
      ...a,
      headers: {
        "anthropic-beta": [...r ?? [], "message-batches-2024-09-24"].toString(),
        ...a?.headers
      }
    });
  }
  async results(e, n = {}, a) {
    if (ro(n))
      return this.results(e, {}, n);
    const r = await this.retrieve(e);
    if (!r.results_url)
      throw new je(`No batch \`results_url\`; Has it finished processing? ${r.processing_status} - ${r.id}`);
    const { betas: i } = n;
    return this._client.get(r.results_url, {
      ...a,
      headers: {
        "anthropic-beta": [...i ?? [], "message-batches-2024-09-24"].toString(),
        Accept: "application/binary",
        ...a?.headers
      },
      __binaryResponse: !0
    })._thenUnwrap((s, u) => bp.fromResponse(u.response, u.controller));
  }
};
class n_ extends mp {
}
t_.BetaMessageBatchesPage = n_;
const ED = (t) => {
  let e = 0, n = [];
  for (; e < t.length; ) {
    let a = t[e];
    if (a === "\\") {
      e++;
      continue;
    }
    if (a === "{") {
      n.push({
        type: "brace",
        value: "{"
      }), e++;
      continue;
    }
    if (a === "}") {
      n.push({
        type: "brace",
        value: "}"
      }), e++;
      continue;
    }
    if (a === "[") {
      n.push({
        type: "paren",
        value: "["
      }), e++;
      continue;
    }
    if (a === "]") {
      n.push({
        type: "paren",
        value: "]"
      }), e++;
      continue;
    }
    if (a === ":") {
      n.push({
        type: "separator",
        value: ":"
      }), e++;
      continue;
    }
    if (a === ",") {
      n.push({
        type: "delimiter",
        value: ","
      }), e++;
      continue;
    }
    if (a === '"') {
      let u = "", d = !1;
      for (a = t[++e]; a !== '"'; ) {
        if (e === t.length) {
          d = !0;
          break;
        }
        if (a === "\\") {
          if (e++, e === t.length) {
            d = !0;
            break;
          }
          u += a + t[e], a = t[++e];
        } else
          u += a, a = t[++e];
      }
      a = t[++e], d || n.push({
        type: "string",
        value: u
      });
      continue;
    }
    if (a && /\s/.test(a)) {
      e++;
      continue;
    }
    let i = /[0-9]/;
    if (a && i.test(a) || a === "-" || a === ".") {
      let u = "";
      for (a === "-" && (u += a, a = t[++e]); a && i.test(a) || a === "."; )
        u += a, a = t[++e];
      n.push({
        type: "number",
        value: u
      });
      continue;
    }
    let s = /[a-z]/i;
    if (a && s.test(a)) {
      let u = "";
      for (; a && s.test(a) && e !== t.length; )
        u += a, a = t[++e];
      if (u == "true" || u == "false" || u === "null")
        n.push({
          type: "name",
          value: u
        });
      else {
        e++;
        continue;
      }
      continue;
    }
    e++;
  }
  return n;
}, Pu = (t) => {
  if (t.length === 0)
    return t;
  let e = t[t.length - 1];
  switch (e.type) {
    case "separator":
      return t = t.slice(0, t.length - 1), Pu(t);
    case "number":
      let n = e.value[e.value.length - 1];
      if (n === "." || n === "-")
        return t = t.slice(0, t.length - 1), Pu(t);
    case "string":
      let a = t[t.length - 2];
      if (a?.type === "delimiter")
        return t = t.slice(0, t.length - 1), Pu(t);
      if (a?.type === "brace" && a.value === "{")
        return t = t.slice(0, t.length - 1), Pu(t);
      break;
    case "delimiter":
      return t = t.slice(0, t.length - 1), Pu(t);
  }
  return t;
}, ID = (t) => {
  let e = [];
  return t.map((n) => {
    n.type === "brace" && (n.value === "{" ? e.push("}") : e.splice(e.lastIndexOf("}"), 1)), n.type === "paren" && (n.value === "[" ? e.push("]") : e.splice(e.lastIndexOf("]"), 1));
  }), e.length > 0 && e.reverse().map((n) => {
    n === "}" ? t.push({
      type: "brace",
      value: "}"
    }) : n === "]" && t.push({
      type: "paren",
      value: "]"
    });
  }), t;
}, ND = (t) => {
  let e = "";
  return t.map((n) => {
    switch (n.type) {
      case "string":
        e += '"' + n.value + '"';
        break;
      default:
        e += n.value;
        break;
    }
  }), e;
}, DR = (t) => JSON.parse(ND(ID(Pu(ED(t)))));
var kt = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, ve = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, Mn, Ws, pc, yf, mc, bc, vf, gc, ya, _c, wf, Sf, fu, Of, jf, Tm, Nv, $m, Mm, Am, Em, Fv;
const kv = "__json_buf";
class qh {
  constructor() {
    Mn.add(this), this.messages = [], this.receivedMessages = [], Ws.set(this, void 0), this.controller = new AbortController(), pc.set(this, void 0), yf.set(this, () => {
    }), mc.set(this, () => {
    }), bc.set(this, void 0), vf.set(this, () => {
    }), gc.set(this, () => {
    }), ya.set(this, {}), _c.set(this, !1), wf.set(this, !1), Sf.set(this, !1), fu.set(this, !1), Of.set(this, void 0), jf.set(this, void 0), $m.set(this, (e) => {
      if (kt(this, wf, !0, "f"), e instanceof Error && e.name === "AbortError" && (e = new or()), e instanceof or)
        return kt(this, Sf, !0, "f"), this._emit("abort", e);
      if (e instanceof je)
        return this._emit("error", e);
      if (e instanceof Error) {
        const n = new je(e.message);
        return n.cause = e, this._emit("error", n);
      }
      return this._emit("error", new je(String(e)));
    }), kt(this, pc, new Promise((e, n) => {
      kt(this, yf, e, "f"), kt(this, mc, n, "f");
    }), "f"), kt(this, bc, new Promise((e, n) => {
      kt(this, vf, e, "f"), kt(this, gc, n, "f");
    }), "f"), ve(this, pc, "f").catch(() => {
    }), ve(this, bc, "f").catch(() => {
    });
  }
  get response() {
    return ve(this, Of, "f");
  }
  get request_id() {
    return ve(this, jf, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    const e = await ve(this, pc, "f");
    if (!e)
      throw new Error("Could not resolve a `Response` object");
    return {
      data: this,
      response: e,
      request_id: e.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(e) {
    const n = new qh();
    return n._run(() => n._fromReadableStream(e)), n;
  }
  static createMessage(e, n, a) {
    const r = new qh();
    for (const i of n.messages)
      r._addMessageParam(i);
    return r._run(() => r._createMessage(e, { ...n, stream: !0 }, { ...a, headers: { ...a?.headers, "X-Stainless-Helper-Method": "stream" } })), r;
  }
  _run(e) {
    e().then(() => {
      this._emitFinal(), this._emit("end");
    }, ve(this, $m, "f"));
  }
  _addMessageParam(e) {
    this.messages.push(e);
  }
  _addMessage(e, n = !0) {
    this.receivedMessages.push(e), n && this._emit("message", e);
  }
  async _createMessage(e, n, a) {
    const r = a?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), ve(this, Mn, "m", Mm).call(this);
    const { response: i, data: s } = await e.create({ ...n, stream: !0 }, { ...a, signal: this.controller.signal }).withResponse();
    this._connected(i);
    for await (const u of s)
      ve(this, Mn, "m", Am).call(this, u);
    if (s.controller.signal?.aborted)
      throw new or();
    ve(this, Mn, "m", Em).call(this);
  }
  _connected(e) {
    this.ended || (kt(this, Of, e, "f"), kt(this, jf, e?.headers.get("request-id"), "f"), ve(this, yf, "f").call(this, e), this._emit("connect"));
  }
  get ended() {
    return ve(this, _c, "f");
  }
  get errored() {
    return ve(this, wf, "f");
  }
  get aborted() {
    return ve(this, Sf, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(e, n) {
    return (ve(this, ya, "f")[e] || (ve(this, ya, "f")[e] = [])).push({ listener: n }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(e, n) {
    const a = ve(this, ya, "f")[e];
    if (!a)
      return this;
    const r = a.findIndex((i) => i.listener === n);
    return r >= 0 && a.splice(r, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(e, n) {
    return (ve(this, ya, "f")[e] || (ve(this, ya, "f")[e] = [])).push({ listener: n, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(e) {
    return new Promise((n, a) => {
      kt(this, fu, !0, "f"), e !== "error" && this.once("error", a), this.once(e, n);
    });
  }
  async done() {
    kt(this, fu, !0, "f"), await ve(this, bc, "f");
  }
  get currentMessage() {
    return ve(this, Ws, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalMessage() {
    return await this.done(), ve(this, Mn, "m", Tm).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    return await this.done(), ve(this, Mn, "m", Nv).call(this);
  }
  _emit(e, ...n) {
    if (ve(this, _c, "f"))
      return;
    e === "end" && (kt(this, _c, !0, "f"), ve(this, vf, "f").call(this));
    const a = ve(this, ya, "f")[e];
    if (a && (ve(this, ya, "f")[e] = a.filter((r) => !r.once), a.forEach(({ listener: r }) => r(...n))), e === "abort") {
      const r = n[0];
      !ve(this, fu, "f") && !a?.length && Promise.reject(r), ve(this, mc, "f").call(this, r), ve(this, gc, "f").call(this, r), this._emit("end");
      return;
    }
    if (e === "error") {
      const r = n[0];
      !ve(this, fu, "f") && !a?.length && Promise.reject(r), ve(this, mc, "f").call(this, r), ve(this, gc, "f").call(this, r), this._emit("end");
    }
  }
  _emitFinal() {
    this.receivedMessages.at(-1) && this._emit("finalMessage", ve(this, Mn, "m", Tm).call(this));
  }
  async _fromReadableStream(e, n) {
    const a = n?.signal;
    a && (a.aborted && this.controller.abort(), a.addEventListener("abort", () => this.controller.abort())), ve(this, Mn, "m", Mm).call(this), this._connected(null);
    const r = md.fromReadableStream(e, this.controller);
    for await (const i of r)
      ve(this, Mn, "m", Am).call(this, i);
    if (r.controller.signal?.aborted)
      throw new or();
    ve(this, Mn, "m", Em).call(this);
  }
  [(Ws = /* @__PURE__ */ new WeakMap(), pc = /* @__PURE__ */ new WeakMap(), yf = /* @__PURE__ */ new WeakMap(), mc = /* @__PURE__ */ new WeakMap(), bc = /* @__PURE__ */ new WeakMap(), vf = /* @__PURE__ */ new WeakMap(), gc = /* @__PURE__ */ new WeakMap(), ya = /* @__PURE__ */ new WeakMap(), _c = /* @__PURE__ */ new WeakMap(), wf = /* @__PURE__ */ new WeakMap(), Sf = /* @__PURE__ */ new WeakMap(), fu = /* @__PURE__ */ new WeakMap(), Of = /* @__PURE__ */ new WeakMap(), jf = /* @__PURE__ */ new WeakMap(), $m = /* @__PURE__ */ new WeakMap(), Mn = /* @__PURE__ */ new WeakSet(), Tm = function() {
    if (this.receivedMessages.length === 0)
      throw new je("stream ended without producing a Message with role=assistant");
    return this.receivedMessages.at(-1);
  }, Nv = function() {
    if (this.receivedMessages.length === 0)
      throw new je("stream ended without producing a Message with role=assistant");
    const n = this.receivedMessages.at(-1).content.filter((a) => a.type === "text").map((a) => a.text);
    if (n.length === 0)
      throw new je("stream ended without producing a content block with type=text");
    return n.join(" ");
  }, Mm = function() {
    this.ended || kt(this, Ws, void 0, "f");
  }, Am = function(n) {
    if (this.ended)
      return;
    const a = ve(this, Mn, "m", Fv).call(this, n);
    switch (this._emit("streamEvent", n, a), n.type) {
      case "content_block_delta": {
        const r = a.content.at(-1);
        switch (n.delta.type) {
          case "text_delta": {
            r.type === "text" && this._emit("text", n.delta.text, r.text || "");
            break;
          }
          case "citations_delta": {
            r.type === "text" && this._emit("citation", n.delta.citation, r.citations ?? []);
            break;
          }
          case "input_json_delta": {
            r.type === "tool_use" && r.input && this._emit("inputJson", n.delta.partial_json, r.input);
            break;
          }
          case "thinking_delta": {
            r.type === "thinking" && this._emit("thinking", n.delta.thinking, r.thinking);
            break;
          }
          case "signature_delta": {
            r.type === "thinking" && this._emit("signature", r.signature);
            break;
          }
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(a), this._addMessage(a, !0);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", a.content.at(-1));
        break;
      }
      case "message_start": {
        kt(this, Ws, a, "f");
        break;
      }
    }
  }, Em = function() {
    if (this.ended)
      throw new je("stream has ended, this shouldn't happen");
    const n = ve(this, Ws, "f");
    if (!n)
      throw new je("request ended without sending any chunks");
    return kt(this, Ws, void 0, "f"), n;
  }, Fv = function(n) {
    let a = ve(this, Ws, "f");
    if (n.type === "message_start") {
      if (a)
        throw new je(`Unexpected event order, got ${n.type} before receiving "message_stop"`);
      return n.message;
    }
    if (!a)
      throw new je(`Unexpected event order, got ${n.type} before "message_start"`);
    switch (n.type) {
      case "message_stop":
        return a;
      case "message_delta":
        return a.stop_reason = n.delta.stop_reason, a.stop_sequence = n.delta.stop_sequence, a.usage.output_tokens = n.usage.output_tokens, a;
      case "content_block_start":
        return a.content.push(n.content_block), a;
      case "content_block_delta": {
        const r = a.content.at(n.index);
        switch (n.delta.type) {
          case "text_delta": {
            r?.type === "text" && (r.text += n.delta.text);
            break;
          }
          case "citations_delta": {
            r?.type === "text" && (r.citations ?? (r.citations = []), r.citations.push(n.delta.citation));
            break;
          }
          case "input_json_delta": {
            if (r?.type === "tool_use") {
              let i = r[kv] || "";
              i += n.delta.partial_json, Object.defineProperty(r, kv, {
                value: i,
                enumerable: !1,
                writable: !0
              }), i && (r.input = DR(i));
            }
            break;
          }
          case "thinking_delta": {
            r?.type === "thinking" && (r.thinking += n.delta.thinking);
            break;
          }
          case "signature_delta": {
            r?.type === "thinking" && (r.signature = n.delta.signature);
            break;
          }
        }
        return a;
      }
      case "content_block_stop":
        return a;
    }
  }, Symbol.asyncIterator)]() {
    const e = [], n = [];
    let a = !1;
    return this.on("streamEvent", (r) => {
      const i = n.shift();
      i ? i.resolve(r) : e.push(r);
    }), this.on("end", () => {
      a = !0;
      for (const r of n)
        r.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), this.on("error", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : a ? { value: void 0, done: !0 } : new Promise((i, s) => n.push({ resolve: i, reject: s })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new md(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
const Dv = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025"
};
let gp = class extends bo {
  constructor() {
    super(...arguments), this.batches = new t_(this._client);
  }
  create(e, n) {
    const { betas: a, ...r } = e;
    return r.model in Dv && console.warn(`The model '${r.model}' is deprecated and will reach end-of-life on ${Dv[r.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`), this._client.post("/v1/messages?beta=true", {
      body: r,
      timeout: this._client._options.timeout ?? (r.stream ? 6e5 : this._client._calculateNonstreamingTimeout(r.max_tokens)),
      ...n,
      headers: {
        ...a?.toString() != null ? { "anthropic-beta": a?.toString() } : void 0,
        ...n?.headers
      },
      stream: e.stream ?? !1
    });
  }
  /**
   * Create a Message stream
   */
  stream(e, n) {
    return qh.createMessage(this, e, n);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](/en/docs/build-with-claude/token-counting)
   */
  countTokens(e, n) {
    const { betas: a, ...r } = e;
    return this._client.post("/v1/messages/count_tokens?beta=true", {
      body: r,
      ...n,
      headers: {
        "anthropic-beta": [...a ?? [], "token-counting-2024-11-01"].toString(),
        ...n?.headers
      }
    });
  }
};
gp.Batches = t_;
gp.BetaMessageBatchesPage = n_;
class Dd extends bo {
  constructor() {
    super(...arguments), this.models = new Yg(this._client), this.messages = new gp(this._client);
  }
}
Dd.Models = Yg;
Dd.BetaModelInfosPage = e_;
Dd.Messages = gp;
let qR = class extends bo {
  create(e, n) {
    return this._client.post("/v1/complete", {
      body: e,
      timeout: this._client._options.timeout ?? 6e5,
      ...n,
      stream: e.stream ?? !1
    });
  }
};
class r_ extends bo {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  create(e, n) {
    return this._client.post("/v1/messages/batches", { body: e, ...n });
  }
  /**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  retrieve(e, n) {
    return this._client.get(`/v1/messages/batches/${e}`, n);
  }
  list(e = {}, n) {
    return ro(e) ? this.list({}, e) : this._client.getAPIList("/v1/messages/batches", a_, { query: e, ...n });
  }
  /**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they've finished processing. If you'd
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  delete(e, n) {
    return this._client.delete(`/v1/messages/batches/${e}`, n);
  }
  /**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  cancel(e, n) {
    return this._client.post(`/v1/messages/batches/${e}/cancel`, n);
  }
  /**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  async results(e, n) {
    const a = await this.retrieve(e);
    if (!a.results_url)
      throw new je(`No batch \`results_url\`; Has it finished processing? ${a.processing_status} - ${a.id}`);
    return this._client.get(a.results_url, {
      ...n,
      headers: {
        Accept: "application/binary",
        ...n?.headers
      },
      __binaryResponse: !0
    })._thenUnwrap((r, i) => bp.fromResponse(i.response, i.controller));
  }
}
class a_ extends mp {
}
r_.MessageBatchesPage = a_;
var Dt = function(t, e, n, a, r) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? r.call(t, n) : r ? r.value = n : e.set(t, n), n;
}, we = function(t, e, n, a) {
  if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? a : n === "a" ? a.call(t) : a ? a.value : e.get(t);
}, An, Xs, yc, Pf, vc, wc, Cf, Sc, va, Oc, Rf, Tf, hu, $f, Mf, Im, qv, Nm, Fm, km, Dm, Jv;
const Lv = "__json_buf";
class Jh {
  constructor() {
    An.add(this), this.messages = [], this.receivedMessages = [], Xs.set(this, void 0), this.controller = new AbortController(), yc.set(this, void 0), Pf.set(this, () => {
    }), vc.set(this, () => {
    }), wc.set(this, void 0), Cf.set(this, () => {
    }), Sc.set(this, () => {
    }), va.set(this, {}), Oc.set(this, !1), Rf.set(this, !1), Tf.set(this, !1), hu.set(this, !1), $f.set(this, void 0), Mf.set(this, void 0), Nm.set(this, (e) => {
      if (Dt(this, Rf, !0, "f"), e instanceof Error && e.name === "AbortError" && (e = new or()), e instanceof or)
        return Dt(this, Tf, !0, "f"), this._emit("abort", e);
      if (e instanceof je)
        return this._emit("error", e);
      if (e instanceof Error) {
        const n = new je(e.message);
        return n.cause = e, this._emit("error", n);
      }
      return this._emit("error", new je(String(e)));
    }), Dt(this, yc, new Promise((e, n) => {
      Dt(this, Pf, e, "f"), Dt(this, vc, n, "f");
    }), "f"), Dt(this, wc, new Promise((e, n) => {
      Dt(this, Cf, e, "f"), Dt(this, Sc, n, "f");
    }), "f"), we(this, yc, "f").catch(() => {
    }), we(this, wc, "f").catch(() => {
    });
  }
  get response() {
    return we(this, $f, "f");
  }
  get request_id() {
    return we(this, Mf, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    const e = await we(this, yc, "f");
    if (!e)
      throw new Error("Could not resolve a `Response` object");
    return {
      data: this,
      response: e,
      request_id: e.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(e) {
    const n = new Jh();
    return n._run(() => n._fromReadableStream(e)), n;
  }
  static createMessage(e, n, a) {
    const r = new Jh();
    for (const i of n.messages)
      r._addMessageParam(i);
    return r._run(() => r._createMessage(e, { ...n, stream: !0 }, { ...a, headers: { ...a?.headers, "X-Stainless-Helper-Method": "stream" } })), r;
  }
  _run(e) {
    e().then(() => {
      this._emitFinal(), this._emit("end");
    }, we(this, Nm, "f"));
  }
  _addMessageParam(e) {
    this.messages.push(e);
  }
  _addMessage(e, n = !0) {
    this.receivedMessages.push(e), n && this._emit("message", e);
  }
  async _createMessage(e, n, a) {
    const r = a?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), we(this, An, "m", Fm).call(this);
    const { response: i, data: s } = await e.create({ ...n, stream: !0 }, { ...a, signal: this.controller.signal }).withResponse();
    this._connected(i);
    for await (const u of s)
      we(this, An, "m", km).call(this, u);
    if (s.controller.signal?.aborted)
      throw new or();
    we(this, An, "m", Dm).call(this);
  }
  _connected(e) {
    this.ended || (Dt(this, $f, e, "f"), Dt(this, Mf, e?.headers.get("request-id"), "f"), we(this, Pf, "f").call(this, e), this._emit("connect"));
  }
  get ended() {
    return we(this, Oc, "f");
  }
  get errored() {
    return we(this, Rf, "f");
  }
  get aborted() {
    return we(this, Tf, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(e, n) {
    return (we(this, va, "f")[e] || (we(this, va, "f")[e] = [])).push({ listener: n }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(e, n) {
    const a = we(this, va, "f")[e];
    if (!a)
      return this;
    const r = a.findIndex((i) => i.listener === n);
    return r >= 0 && a.splice(r, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(e, n) {
    return (we(this, va, "f")[e] || (we(this, va, "f")[e] = [])).push({ listener: n, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(e) {
    return new Promise((n, a) => {
      Dt(this, hu, !0, "f"), e !== "error" && this.once("error", a), this.once(e, n);
    });
  }
  async done() {
    Dt(this, hu, !0, "f"), await we(this, wc, "f");
  }
  get currentMessage() {
    return we(this, Xs, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalMessage() {
    return await this.done(), we(this, An, "m", Im).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    return await this.done(), we(this, An, "m", qv).call(this);
  }
  _emit(e, ...n) {
    if (we(this, Oc, "f"))
      return;
    e === "end" && (Dt(this, Oc, !0, "f"), we(this, Cf, "f").call(this));
    const a = we(this, va, "f")[e];
    if (a && (we(this, va, "f")[e] = a.filter((r) => !r.once), a.forEach(({ listener: r }) => r(...n))), e === "abort") {
      const r = n[0];
      !we(this, hu, "f") && !a?.length && Promise.reject(r), we(this, vc, "f").call(this, r), we(this, Sc, "f").call(this, r), this._emit("end");
      return;
    }
    if (e === "error") {
      const r = n[0];
      !we(this, hu, "f") && !a?.length && Promise.reject(r), we(this, vc, "f").call(this, r), we(this, Sc, "f").call(this, r), this._emit("end");
    }
  }
  _emitFinal() {
    this.receivedMessages.at(-1) && this._emit("finalMessage", we(this, An, "m", Im).call(this));
  }
  async _fromReadableStream(e, n) {
    const a = n?.signal;
    a && (a.aborted && this.controller.abort(), a.addEventListener("abort", () => this.controller.abort())), we(this, An, "m", Fm).call(this), this._connected(null);
    const r = md.fromReadableStream(e, this.controller);
    for await (const i of r)
      we(this, An, "m", km).call(this, i);
    if (r.controller.signal?.aborted)
      throw new or();
    we(this, An, "m", Dm).call(this);
  }
  [(Xs = /* @__PURE__ */ new WeakMap(), yc = /* @__PURE__ */ new WeakMap(), Pf = /* @__PURE__ */ new WeakMap(), vc = /* @__PURE__ */ new WeakMap(), wc = /* @__PURE__ */ new WeakMap(), Cf = /* @__PURE__ */ new WeakMap(), Sc = /* @__PURE__ */ new WeakMap(), va = /* @__PURE__ */ new WeakMap(), Oc = /* @__PURE__ */ new WeakMap(), Rf = /* @__PURE__ */ new WeakMap(), Tf = /* @__PURE__ */ new WeakMap(), hu = /* @__PURE__ */ new WeakMap(), $f = /* @__PURE__ */ new WeakMap(), Mf = /* @__PURE__ */ new WeakMap(), Nm = /* @__PURE__ */ new WeakMap(), An = /* @__PURE__ */ new WeakSet(), Im = function() {
    if (this.receivedMessages.length === 0)
      throw new je("stream ended without producing a Message with role=assistant");
    return this.receivedMessages.at(-1);
  }, qv = function() {
    if (this.receivedMessages.length === 0)
      throw new je("stream ended without producing a Message with role=assistant");
    const n = this.receivedMessages.at(-1).content.filter((a) => a.type === "text").map((a) => a.text);
    if (n.length === 0)
      throw new je("stream ended without producing a content block with type=text");
    return n.join(" ");
  }, Fm = function() {
    this.ended || Dt(this, Xs, void 0, "f");
  }, km = function(n) {
    if (this.ended)
      return;
    const a = we(this, An, "m", Jv).call(this, n);
    switch (this._emit("streamEvent", n, a), n.type) {
      case "content_block_delta": {
        const r = a.content.at(-1);
        switch (n.delta.type) {
          case "text_delta": {
            r.type === "text" && this._emit("text", n.delta.text, r.text || "");
            break;
          }
          case "citations_delta": {
            r.type === "text" && this._emit("citation", n.delta.citation, r.citations ?? []);
            break;
          }
          case "input_json_delta": {
            r.type === "tool_use" && r.input && this._emit("inputJson", n.delta.partial_json, r.input);
            break;
          }
          case "thinking_delta": {
            r.type === "thinking" && this._emit("thinking", n.delta.thinking, r.thinking);
            break;
          }
          case "signature_delta": {
            r.type === "thinking" && this._emit("signature", r.signature);
            break;
          }
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(a), this._addMessage(a, !0);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", a.content.at(-1));
        break;
      }
      case "message_start": {
        Dt(this, Xs, a, "f");
        break;
      }
    }
  }, Dm = function() {
    if (this.ended)
      throw new je("stream has ended, this shouldn't happen");
    const n = we(this, Xs, "f");
    if (!n)
      throw new je("request ended without sending any chunks");
    return Dt(this, Xs, void 0, "f"), n;
  }, Jv = function(n) {
    let a = we(this, Xs, "f");
    if (n.type === "message_start") {
      if (a)
        throw new je(`Unexpected event order, got ${n.type} before receiving "message_stop"`);
      return n.message;
    }
    if (!a)
      throw new je(`Unexpected event order, got ${n.type} before "message_start"`);
    switch (n.type) {
      case "message_stop":
        return a;
      case "message_delta":
        return a.stop_reason = n.delta.stop_reason, a.stop_sequence = n.delta.stop_sequence, a.usage.output_tokens = n.usage.output_tokens, a;
      case "content_block_start":
        return a.content.push(n.content_block), a;
      case "content_block_delta": {
        const r = a.content.at(n.index);
        switch (n.delta.type) {
          case "text_delta": {
            r?.type === "text" && (r.text += n.delta.text);
            break;
          }
          case "citations_delta": {
            r?.type === "text" && (r.citations ?? (r.citations = []), r.citations.push(n.delta.citation));
            break;
          }
          case "input_json_delta": {
            if (r?.type === "tool_use") {
              let i = r[Lv] || "";
              i += n.delta.partial_json, Object.defineProperty(r, Lv, {
                value: i,
                enumerable: !1,
                writable: !0
              }), i && (r.input = DR(i));
            }
            break;
          }
          case "thinking_delta": {
            r?.type === "thinking" && (r.thinking += n.delta.thinking);
            break;
          }
          case "signature_delta": {
            r?.type === "thinking" && (r.signature = n.delta.signature);
            break;
          }
        }
        return a;
      }
      case "content_block_stop":
        return a;
    }
  }, Symbol.asyncIterator)]() {
    const e = [], n = [];
    let a = !1;
    return this.on("streamEvent", (r) => {
      const i = n.shift();
      i ? i.resolve(r) : e.push(r);
    }), this.on("end", () => {
      a = !0;
      for (const r of n)
        r.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), this.on("error", (r) => {
      a = !0;
      for (const i of n)
        i.reject(r);
      n.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : a ? { value: void 0, done: !0 } : new Promise((i, s) => n.push({ resolve: i, reject: s })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new md(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
class _p extends bo {
  constructor() {
    super(...arguments), this.batches = new r_(this._client);
  }
  create(e, n) {
    return e.model in Uv && console.warn(`The model '${e.model}' is deprecated and will reach end-of-life on ${Uv[e.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`), this._client.post("/v1/messages", {
      body: e,
      timeout: this._client._options.timeout ?? (e.stream ? 6e5 : this._client._calculateNonstreamingTimeout(e.max_tokens)),
      ...n,
      stream: e.stream ?? !1
    });
  }
  /**
   * Create a Message stream
   */
  stream(e, n) {
    return Jh.createMessage(this, e, n);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](/en/docs/build-with-claude/token-counting)
   */
  countTokens(e, n) {
    return this._client.post("/v1/messages/count_tokens", { body: e, ...n });
  }
}
const Uv = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025"
};
_p.Batches = r_;
_p.MessageBatchesPage = a_;
let i_ = class extends bo {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
  retrieve(e, n) {
    return this._client.get(`/v1/models/${e}`, n);
  }
  list(e = {}, n) {
    return ro(e) ? this.list({}, e) : this._client.getAPIList("/v1/models", s_, { query: e, ...n });
  }
};
class s_ extends mp {
}
i_.ModelInfosPage = s_;
var JR;
class Ge extends _D {
  /**
   * API Client for interfacing with the Anthropic API.
   *
   * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
   * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
   * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL: e = Rm("ANTHROPIC_BASE_URL"), apiKey: n = Rm("ANTHROPIC_API_KEY") ?? null, authToken: a = Rm("ANTHROPIC_AUTH_TOKEN") ?? null, ...r } = {}) {
    const i = {
      apiKey: n,
      authToken: a,
      ...r,
      baseURL: e || "https://api.anthropic.com"
    };
    if (!i.dangerouslyAllowBrowser && MD())
      throw new je(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new Anthropic({ apiKey, dangerouslyAllowBrowser: true });
`);
    super({
      baseURL: i.baseURL,
      timeout: i.timeout ?? 6e5,
      httpAgent: i.httpAgent,
      maxRetries: i.maxRetries,
      fetch: i.fetch
    }), this.completions = new qR(this), this.messages = new _p(this), this.models = new i_(this), this.beta = new Dd(this), this._options = i, this.apiKey = n, this.authToken = a;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(e) {
    return {
      ...super.defaultHeaders(e),
      ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
      "anthropic-version": "2023-06-01",
      ...this._options.defaultHeaders
    };
  }
  validateHeaders(e, n) {
    if (!(this.apiKey && e["x-api-key"]) && n["x-api-key"] !== null && !(this.authToken && e.authorization) && n.authorization !== null)
      throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
  }
  authHeaders(e) {
    const n = this.apiKeyAuth(e), a = this.bearerAuth(e);
    return n != null && !Dh(n) ? n : a != null && !Dh(a) ? a : {};
  }
  apiKeyAuth(e) {
    return this.apiKey == null ? {} : { "X-Api-Key": this.apiKey };
  }
  bearerAuth(e) {
    return this.authToken == null ? {} : { Authorization: `Bearer ${this.authToken}` };
  }
}
JR = Ge;
Ge.Anthropic = JR;
Ge.HUMAN_PROMPT = `

Human:`;
Ge.AI_PROMPT = `

Assistant:`;
Ge.DEFAULT_TIMEOUT = 6e5;
Ge.AnthropicError = je;
Ge.APIError = Cn;
Ge.APIConnectionError = hp;
Ge.APIConnectionTimeoutError = SR;
Ge.APIUserAbortError = or;
Ge.NotFoundError = CR;
Ge.ConflictError = RR;
Ge.RateLimitError = $R;
Ge.BadRequestError = OR;
Ge.AuthenticationError = jR;
Ge.InternalServerError = MR;
Ge.PermissionDeniedError = PR;
Ge.UnprocessableEntityError = TR;
Ge.toFile = dD;
Ge.fileFromPath = wR;
Ge.Completions = qR;
Ge.Messages = _p;
Ge.Models = i_;
Ge.ModelInfosPage = s_;
Ge.Beta = Dd;
class Bv extends oR {
  static lc_name() {
    return "AnthropicToolsOutputParser";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "anthropic", "output_parsers"]
    }), Object.defineProperty(this, "returnId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "keyName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnSingle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "zodSchema", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.keyName = e.keyName, this.returnSingle = e.returnSingle ?? this.returnSingle, this.zodSchema = e.zodSchema;
  }
  async _validateResult(e) {
    let n = e;
    if (typeof e == "string")
      try {
        n = JSON.parse(e);
      } catch (r) {
        throw new Bt(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(r.message)}`, e);
      }
    else
      n = e;
    if (this.zodSchema === void 0)
      return n;
    const a = await this.zodSchema.safeParseAsync(n);
    if (a.success)
      return a.data;
    throw new Bt(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(a.error.errors)}`, JSON.stringify(n, null, 2));
  }
  async parseResult(e) {
    const n = e.flatMap((i) => {
      const { message: s } = i;
      return Array.isArray(s.content) ? LR(s.content)[0] : [];
    });
    if (n[0] === void 0)
      throw new Error("No parseable tool calls provided to AnthropicToolsOutputParser.");
    const [a] = n;
    return await this._validateResult(a.args);
  }
}
function LR(t) {
  const e = [];
  for (const n of t)
    n.type === "tool_use" && e.push({
      name: n.name,
      args: n.input,
      id: n.id,
      type: "tool_call"
    });
  return e;
}
function FD(t) {
  if (t)
    return t === "any" ? {
      type: "any"
    } : t === "auto" ? {
      type: "auto"
    } : typeof t == "string" ? {
      type: "tool",
      name: t
    } : t;
}
function xv(t) {
  const e = /^data:(image\/.+);base64,(.+)$/, n = t.match(e);
  if (n === null)
    throw new Error([
      "Anthropic only supports base64-encoded images currently.",
      "Example: data:image/png;base64,/9j/4AAQSk..."
    ].join(`

`));
  return {
    type: "base64",
    media_type: n[1] ?? "",
    data: n[2] ?? ""
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  };
}
function kD(t) {
  const e = [];
  for (const n of t)
    if (n._getType() === "tool")
      if (typeof n.content == "string") {
        const a = e[e.length - 1];
        a?._getType() === "human" && Array.isArray(a.content) && "type" in a.content[0] && a.content[0].type === "tool_result" ? a.content.push({
          type: "tool_result",
          content: n.content,
          tool_use_id: n.tool_call_id
        }) : e.push(new mr({
          content: [
            {
              type: "tool_result",
              content: n.content,
              tool_use_id: n.tool_call_id
            }
          ]
        }));
      } else
        e.push(new mr({
          content: [
            {
              type: "tool_result",
              content: Zb(n.content),
              tool_use_id: n.tool_call_id
            }
          ]
        }));
    else
      e.push(n);
  return e;
}
function Vv(t) {
  if (t.id === void 0)
    throw new Error('Anthropic requires all tool calls to have an "id".');
  return {
    type: "tool_use",
    id: t.id,
    name: t.name,
    input: t.args
  };
}
function Zb(t) {
  const e = ["tool_use", "tool_result", "input_json_delta"], n = ["text", "text_delta"];
  return typeof t == "string" ? t : t.map((r) => {
    const i = "cache_control" in r ? r.cache_control : void 0;
    if (r.type === "image_url") {
      let s;
      return typeof r.image_url == "string" ? s = xv(r.image_url) : s = xv(r.image_url.url), {
        type: "image",
        source: s,
        ...i ? { cache_control: i } : {}
      };
    } else {
      if (r.type === "document")
        return {
          ...r,
          ...i ? { cache_control: i } : {}
        };
      if (r.type === "thinking")
        return {
          type: "thinking",
          thinking: r.thinking,
          signature: r.signature,
          ...i ? { cache_control: i } : {}
        };
      if (r.type === "redacted_thinking")
        return {
          type: "redacted_thinking",
          data: r.data,
          ...i ? { cache_control: i } : {}
        };
      if (n.find((s) => s === r.type) && "text" in r)
        return {
          type: "text",
          text: r.text,
          ...i ? { cache_control: i } : {}
        };
      if (e.find((s) => s === r.type)) {
        const s = { ...r };
        if ("index" in s && delete s.index, s.type === "input_json_delta" && (s.type = "tool_use"), "input" in s)
          try {
            s.input = JSON.parse(s.input);
          } catch {
          }
        return {
          ...s,
          ...i ? { cache_control: i } : {}
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        };
      } else
        throw new Error("Unsupported message content format");
    }
  });
}
function zv(t) {
  const e = kD(t);
  let n;
  e.length > 0 && e[0]._getType() === "system" && (n = t[0].content);
  const r = (n !== void 0 ? e.slice(1) : e).map((i) => {
    let s;
    if (i._getType() === "human")
      s = "user";
    else if (i._getType() === "ai")
      s = "assistant";
    else if (i._getType() === "tool")
      s = "user";
    else throw i._getType() === "system" ? new Error("System messages are only permitted as the first passed message.") : new Error(`Message type "${i._getType()}" is not supported.`);
    if (uo(i) && i.tool_calls?.length) {
      if (typeof i.content == "string")
        return i.content === "" ? {
          role: s,
          content: i.tool_calls.map(Vv)
        } : {
          role: s,
          content: [
            { type: "text", text: i.content },
            ...i.tool_calls.map(Vv)
          ]
        };
      {
        const { content: u } = i;
        return !i.tool_calls.every((f) => u.find((o) => (o.type === "tool_use" || o.type === "input_json_delta") && o.id === f.id)) && console.warn('The "tool_calls" field on a message is only respected if content is a string.'), {
          role: s,
          content: Zb(i.content)
        };
      }
    } else
      return {
        role: s,
        content: Zb(i.content)
      };
  });
  return {
    messages: DD(r),
    system: n
  };
}
function DD(t) {
  if (!t || t.length <= 1)
    return t;
  const e = [];
  let n = t[0];
  const a = (i) => typeof i == "string" ? [
    {
      type: "text",
      text: i
    }
  ] : i, r = (i) => i.role !== "user" || typeof i.content == "string" ? !1 : Array.isArray(i.content) && i.content.every((s) => s.type === "tool_result");
  for (let i = 1; i < t.length; i += 1) {
    const s = t[i];
    r(n) && r(s) ? n = {
      ...n,
      content: [
        ...a(n.content),
        ...a(s.content)
      ]
    } : (e.push(n), n = s);
  }
  return e.push(n), e;
}
function qD(t, e) {
  if (t.type === "message_start") {
    const { content: n, usage: a, ...r } = t.message, i = {};
    for (const [o, c] of Object.entries(r))
      c != null && (i[o] = c);
    const { input_tokens: s, output_tokens: u, ...d } = a ?? {}, f = {
      input_tokens: s,
      output_tokens: u,
      total_tokens: s + u,
      input_token_details: {
        cache_creation: d.cache_creation_input_tokens,
        cache_read: d.cache_read_input_tokens
      }
    };
    return {
      chunk: new We({
        content: e.coerceContentToString ? "" : [],
        additional_kwargs: i,
        usage_metadata: e.streamUsage ? f : void 0,
        response_metadata: {
          usage: {
            ...d
          }
        },
        id: t.message.id
      })
    };
  } else if (t.type === "message_delta") {
    const n = {
      input_tokens: 0,
      output_tokens: t.usage.output_tokens,
      total_tokens: t.usage.output_tokens,
      input_token_details: {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        cache_creation: t.usage.cache_creation_input_tokens,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        cache_read: t.usage.cache_read_input_tokens
      }
    };
    return {
      chunk: new We({
        content: e.coerceContentToString ? "" : [],
        additional_kwargs: { ...t.delta },
        usage_metadata: e.streamUsage ? n : void 0
      })
    };
  } else if (t.type === "content_block_start" && ["tool_use", "document"].includes(t.content_block.type)) {
    const n = t.content_block;
    let a;
    return n.type === "tool_use" ? a = [
      {
        id: n.id,
        index: t.index,
        name: n.name,
        args: ""
      }
    ] : a = [], {
      chunk: new We({
        content: e.coerceContentToString ? "" : [
          {
            index: t.index,
            ...t.content_block,
            input: ""
          }
        ],
        additional_kwargs: {},
        tool_call_chunks: a
      })
    };
  } else if (t.type === "content_block_delta" && [
    "text_delta",
    "citations_delta",
    "thinking_delta",
    "signature_delta"
  ].includes(t.delta.type)) {
    if (e.coerceContentToString && "text" in t.delta)
      return {
        chunk: new We({
          content: t.delta.text
        })
      };
    {
      const n = t.delta;
      return "citation" in n && (n.citations = [n.citation], delete n.citation), n.type === "thinking_delta" || n.type === "signature_delta" ? {
        chunk: new We({
          content: [{ index: t.index, ...n, type: "thinking" }]
        })
      } : {
        chunk: new We({
          content: [{ index: t.index, ...n, type: "text" }]
        })
      };
    }
  } else {
    if (t.type === "content_block_delta" && t.delta.type === "input_json_delta")
      return {
        chunk: new We({
          content: e.coerceContentToString ? "" : [
            {
              index: t.index,
              input: t.delta.partial_json,
              type: t.delta.type
            }
          ],
          additional_kwargs: {},
          tool_call_chunks: [
            {
              index: t.index,
              args: t.delta.partial_json
            }
          ]
        })
      };
    if (t.type === "content_block_start" && t.content_block.type === "text") {
      const n = t.content_block?.text;
      if (n !== void 0)
        return {
          chunk: new We({
            content: e.coerceContentToString ? n : [
              {
                index: t.index,
                ...t.content_block
              }
            ],
            additional_kwargs: {}
          })
        };
    } else {
      if (t.type === "content_block_start" && t.content_block.type === "redacted_thinking")
        return {
          chunk: new We({
            content: e.coerceContentToString ? "" : [{ index: t.index, ...t.content_block }]
          })
        };
      if (t.type === "content_block_start" && t.content_block.type === "thinking") {
        const n = t.content_block.thinking;
        return {
          chunk: new We({
            content: e.coerceContentToString ? n : [{ index: t.index, ...t.content_block }]
          })
        };
      }
    }
  }
  return null;
}
function JD(t, e) {
  const n = e.usage, a = n != null ? {
    input_tokens: n.input_tokens ?? 0,
    output_tokens: n.output_tokens ?? 0,
    total_tokens: (n.input_tokens ?? 0) + (n.output_tokens ?? 0),
    input_token_details: {
      cache_creation: n.cache_creation_input_tokens,
      cache_read: n.cache_read_input_tokens
    }
  } : void 0;
  if (t.length === 1 && t[0].type === "text")
    return [
      {
        text: t[0].text,
        message: new At({
          content: t[0].text,
          additional_kwargs: e,
          usage_metadata: a,
          response_metadata: e,
          id: e.id
        })
      }
    ];
  {
    const r = LR(t);
    return [
      {
        text: "",
        message: new At({
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          content: t,
          additional_kwargs: e,
          tool_calls: r,
          usage_metadata: a,
          response_metadata: e,
          id: e.id
        })
      }
    ];
  }
}
function Af(t, e) {
  return t.lc_error_code = e, t.message = `${t.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${e}/
`, t;
}
function Zv(t) {
  let e;
  return t.status === 400 && t.message.includes("tool") ? e = Af(t, "INVALID_TOOL_RESULTS") : t.status === 401 ? e = Af(t, "MODEL_AUTHENTICATION") : t.status === 404 ? e = Af(t, "MODEL_NOT_FOUND") : t.status === 429 ? e = Af(t, "MODEL_RATE_LIMIT") : e = t, e;
}
function LD(t) {
  return !!(t.tools && t.tools.length > 0);
}
function UD(t) {
  for (const e of t.messages ?? [])
    if (typeof e.content != "string") {
      for (const n of e.content ?? [])
        if (typeof n == "object" && n != null && n.type === "document" && typeof n.citations == "object" && n.citations.enabled)
          return !0;
    }
  return !1;
}
function BD(t) {
  return !!(t.thinking && t.thinking.type === "enabled");
}
function xD(t) {
  return "input_schema" in t;
}
function VD(t) {
  if (typeof t.content == "string")
    return t.content;
  if (Array.isArray(t.content) && t.content.length >= 1 && "input" in t.content[0])
    return typeof t.content[0].input == "string" ? t.content[0].input : JSON.stringify(t.content[0].input);
  if (Array.isArray(t.content) && t.content.length >= 1 && "text" in t.content[0])
    return t.content[0].text;
}
class zD extends kn {
  static lc_name() {
    return "ChatAnthropic";
  }
  get lc_secrets() {
    return {
      anthropicApiKey: "ANTHROPIC_API_KEY",
      apiKey: "ANTHROPIC_API_KEY"
    };
  }
  get lc_aliases() {
    return {
      modelName: "model"
    };
  }
  constructor(e) {
    if (super(e ?? {}), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "anthropicApiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "topK", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -1
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -1
    }), Object.defineProperty(this, "maxTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 2048
    }), Object.defineProperty(this, "modelName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "claude-2.1"
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "claude-2.1"
    }), Object.defineProperty(this, "invocationKwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stopSequences", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "clientOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "thinking", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { type: "disabled" }
    }), Object.defineProperty(this, "batchClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streamingClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streamUsage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "createClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.anthropicApiKey = e?.apiKey ?? e?.anthropicApiKey ?? _t("ANTHROPIC_API_KEY"), !this.anthropicApiKey && !e?.createClient)
      throw new Error("Anthropic API key not found");
    this.clientOptions = e?.clientOptions ?? {}, this.apiKey = this.anthropicApiKey, this.apiUrl = e?.anthropicApiUrl, this.modelName = e?.model ?? e?.modelName ?? this.model, this.model = this.modelName, this.invocationKwargs = e?.invocationKwargs ?? {}, this.temperature = e?.temperature ?? this.temperature, this.topK = e?.topK ?? this.topK, this.topP = e?.topP ?? this.topP, this.maxTokens = e?.maxTokensToSample ?? e?.maxTokens ?? this.maxTokens, this.stopSequences = e?.stopSequences ?? this.stopSequences, this.streaming = e?.streaming ?? !1, this.streamUsage = e?.streamUsage ?? this.streamUsage, this.thinking = e?.thinking ?? this.thinking, this.createClient = e?.createClient ?? ((n) => new Ge(n));
  }
  getLsParams(e) {
    const n = this.invocationParams(e);
    return {
      ls_provider: "anthropic",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: n.temperature ?? void 0,
      ls_max_tokens: n.max_tokens ?? void 0,
      ls_stop: e.stop
    };
  }
  /**
   * Formats LangChain StructuredTools to AnthropicTools.
   *
   * @param {ChatAnthropicCallOptions["tools"]} tools The tools to format
   * @returns {AnthropicTool[] | undefined} The formatted tools, or undefined if none are passed.
   */
  formatStructuredToolToAnthropic(e) {
    if (!(!e || !e.length))
      return e.map((n) => {
        if (xD(n))
          return n;
        if (tc(n))
          return {
            name: n.function.name,
            description: n.function.description,
            input_schema: n.function.parameters
          };
        if (Hg(n))
          return {
            name: n.name,
            description: n.description,
            input_schema: xn(n.schema)
          };
        throw new Error(`Unknown tool type passed to ChatAnthropic: ${JSON.stringify(n, null, 2)}`);
      });
  }
  bindTools(e, n) {
    return this.bind({
      tools: this.formatStructuredToolToAnthropic(e),
      ...n
    });
  }
  /**
   * Get the parameters used to invoke the model
   */
  invocationParams(e) {
    const n = FD(e?.tool_choice);
    if (this.thinking.type === "enabled") {
      if (this.topK !== -1)
        throw new Error("topK is not supported when thinking is enabled");
      if (this.topP !== -1)
        throw new Error("topP is not supported when thinking is enabled");
      if (this.temperature !== 1)
        throw new Error("temperature is not supported when thinking is enabled");
      return {
        model: this.model,
        stop_sequences: e?.stop ?? this.stopSequences,
        stream: this.streaming,
        max_tokens: this.maxTokens,
        tools: this.formatStructuredToolToAnthropic(e?.tools),
        tool_choice: n,
        thinking: this.thinking,
        ...this.invocationKwargs
      };
    }
    return {
      model: this.model,
      temperature: this.temperature,
      top_k: this.topK,
      top_p: this.topP,
      stop_sequences: e?.stop ?? this.stopSequences,
      stream: this.streaming,
      max_tokens: this.maxTokens,
      tools: this.formatStructuredToolToAnthropic(e?.tools),
      tool_choice: n,
      thinking: this.thinking,
      ...this.invocationKwargs
    };
  }
  /** @ignore */
  _identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams()
    };
  }
  /**
   * Get the identifying parameters for the model
   */
  identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams()
    };
  }
  async *_streamResponseChunks(e, n, a) {
    const r = this.invocationParams(n), i = zv(e), s = {
      ...r,
      ...i,
      stream: !0
    }, u = !LD(s) && !UD(s) && !BD(s), d = await this.createStreamWithRetry(s, {
      headers: n.headers
    });
    for await (const f of d) {
      if (n.signal?.aborted)
        throw d.controller.abort(), new Error("AbortError: User aborted the request.");
      const o = this.streamUsage ?? n.streamUsage, c = qD(f, {
        streamUsage: o,
        coerceContentToString: u
      });
      if (!c)
        continue;
      const { chunk: h } = c, p = VD(h), l = new On({
        message: new We({
          // Just yield chunk as it is and tool_use will be concat by BaseChatModel._generateUncached().
          content: h.content,
          additional_kwargs: h.additional_kwargs,
          tool_call_chunks: h.tool_call_chunks,
          usage_metadata: o ? h.usage_metadata : void 0,
          response_metadata: h.response_metadata,
          id: h.id
        }),
        text: p ?? ""
      });
      yield l, await a?.handleLLMNewToken(p ?? "", void 0, void 0, void 0, void 0, { chunk: l });
    }
  }
  /** @ignore */
  async _generateNonStreaming(e, n, a) {
    const r = await this.completionWithRetry({
      ...n,
      stream: !1,
      ...zv(e)
    }, a), { content: i, ...s } = r, u = JD(i, s), { role: d, type: f, ...o } = s;
    return { generations: u, llmOutput: o };
  }
  /** @ignore */
  async _generate(e, n, a) {
    if (this.stopSequences && n.stop)
      throw new Error('"stopSequence" parameter found in input and default params');
    const r = this.invocationParams(n);
    if (r.stream) {
      let i;
      const s = this._streamResponseChunks(e, n, a);
      for await (const u of s)
        i === void 0 ? i = u : i = i.concat(u);
      if (i === void 0)
        throw new Error("No chunks returned from Anthropic API.");
      return {
        generations: [
          {
            text: i.text,
            message: i.message
          }
        ]
      };
    } else
      return this._generateNonStreaming(e, r, {
        signal: n.signal,
        headers: n.headers
      });
  }
  /**
   * Creates a streaming request with retry.
   * @param request The parameters for creating a completion.
   * @param options
   * @returns A streaming request.
   */
  async createStreamWithRetry(e, n) {
    if (!this.streamingClient) {
      const r = this.apiUrl ? { baseURL: this.apiUrl } : void 0;
      this.streamingClient = this.createClient({
        dangerouslyAllowBrowser: !0,
        ...this.clientOptions,
        ...r,
        apiKey: this.apiKey,
        // Prefer LangChain built-in retries
        maxRetries: 0
      });
    }
    const a = async () => {
      try {
        return await this.streamingClient.messages.create({
          ...e,
          ...this.invocationKwargs,
          stream: !0
        }, n);
      } catch (r) {
        throw Zv(r);
      }
    };
    return this.caller.call(a);
  }
  /** @ignore */
  async completionWithRetry(e, n) {
    if (!this.batchClient) {
      const r = this.apiUrl ? { baseURL: this.apiUrl } : void 0;
      this.batchClient = this.createClient({
        dangerouslyAllowBrowser: !0,
        ...this.clientOptions,
        ...r,
        apiKey: this.apiKey,
        maxRetries: 0
      });
    }
    const a = async () => {
      try {
        return await this.batchClient.messages.create({
          ...e,
          ...this.invocationKwargs
        }, n);
      } catch (r) {
        throw Zv(r);
      }
    };
    return this.caller.callWithOptions({ signal: n.signal ?? void 0 }, a);
  }
  _llmType() {
    return "anthropic";
  }
  withStructuredOutput(e, n) {
    const a = e, r = n?.name, i = n?.method, s = n?.includeRaw;
    if (i === "jsonMode")
      throw new Error('Anthropic only supports "functionCalling" as a method.');
    let u = r ?? "extract", d, f;
    if (Nd(a)) {
      const l = xn(a);
      f = [
        {
          name: u,
          description: l.description ?? "A function available to call.",
          input_schema: l
        }
      ], d = new Bv({
        returnSingle: !0,
        keyName: u,
        zodSchema: a
      });
    } else {
      let l;
      typeof a.name == "string" && typeof a.description == "string" && typeof a.input_schema == "object" && a.input_schema != null ? (l = a, u = a.name) : l = {
        name: u,
        description: a.description ?? "",
        input_schema: a
      }, f = [l], d = new Bv({
        returnSingle: !0,
        keyName: u
      });
    }
    let o;
    if (this.thinking?.type === "enabled") {
      const l = "Anthropic structured output relies on forced tool calling, which is not supported when `thinking` is enabled. This method will raise OutputParserException if tool calls are not generated. Consider disabling `thinking` or adjust your prompt to ensure the tool is called.";
      console.warn(l), o = this.bind({
        tools: f
      });
      const m = (b) => {
        if (!b.tool_calls || b.tool_calls.length === 0)
          throw new Error(l);
        return b;
      };
      o = o.pipe(m);
    } else
      o = this.bind({
        tools: f,
        tool_choice: {
          type: "tool",
          name: u
        }
      });
    if (!s)
      return o.pipe(d).withConfig({
        runName: "ChatAnthropicStructuredOutput"
      });
    const c = Ut.assign({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parsed: (l, m) => d.invoke(l.raw, m)
    }), h = Ut.assign({
      parsed: () => null
    }), p = c.withFallbacks({
      fallbacks: [h]
    });
    return gt.from([
      {
        raw: o
      },
      p
    ]).withConfig({
      runName: "StructuredOutputRunnable"
    });
  }
}
class DV extends zD {
}
var Yn = {}, qm = {}, Ef = {}, Kv;
function Ee() {
  if (Kv) return Ef;
  Kv = 1, Object.defineProperty(Ef, "__esModule", { value: !0 }), Ef.pathToFunc = e;
  const t = Object.prototype.hasOwnProperty;
  function e(n, a) {
    const r = /\{([a-zA-Z0-9_]+?)\}/g;
    return function(s = {}) {
      return n.replace(r, function(u, d) {
        if (!t.call(s, d))
          throw new Error(`Parameter '${d}' is required`);
        const f = s[d];
        if (typeof f != "string" && typeof f != "number")
          throw new Error(`Parameter '${d}' must be a string or number`);
        return a?.charEncoding === "percent" ? encodeURIComponent(`${f}`) : `${f}`;
      });
    };
  }
  return Ef;
}
var Hv;
function o_() {
  return Hv || (Hv = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SDK_METADATA = t.ServerList = t.ServerEu = void 0, t.serverURLFromOptions = n;
    const e = /* @__PURE__ */ Ee();
    t.ServerEu = "eu", t.ServerList = {
      [t.ServerEu]: "https://api.mistral.ai"
    };
    function n(a) {
      let r = a.serverURL;
      const i = {};
      if (!r) {
        const u = a.server ?? t.ServerEu;
        r = t.ServerList[u] || "";
      }
      const s = (0, e.pathToFunc)(r)(i);
      return new URL(s);
    }
    t.SDK_METADATA = {
      language: "typescript",
      openapiDocVersion: "0.0.2",
      sdkVersion: "1.5.2",
      genVersion: "2.548.6",
      userAgent: "speakeasy-sdk/typescript 1.5.2 2.548.6 0.0.2 @mistralai/mistralai"
    };
  }(qm)), qm;
}
var If = {}, Gv;
function UR() {
  if (Gv) return If;
  Gv = 1, Object.defineProperty(If, "__esModule", { value: !0 }), If.readableStreamToArrayBuffer = t;
  async function t(e) {
    const n = e.getReader(), a = [];
    let r = 0, i = !1;
    for (; !i; ) {
      const { value: d, done: f } = await n.read();
      f ? i = !0 : (a.push(d), r += d.length);
    }
    const s = new Uint8Array(r);
    let u = 0;
    for (const d of a)
      s.set(d, u), u += d.length;
    return s.buffer;
  }
  return If;
}
var jc = {}, wa = {}, Pc = {}, Nf = {}, Cc = {}, Wv;
function ZD() {
  if (Wv) return Cc;
  Wv = 1, Object.defineProperty(Cc, "__esModule", { value: !0 }), Cc.CustomUserAgentHook = void 0;
  const t = /* @__PURE__ */ o_();
  class e {
    beforeRequest(a, r) {
      const s = `mistral-client-typescript/${t.SDK_METADATA.sdkVersion}`;
      return r.headers.set("user-agent", s), r.headers.get("user-agent") || r.headers.set("x-mistral-user-agent", s), r;
    }
  }
  return Cc.CustomUserAgentHook = e, Cc;
}
var Rc = {}, Xv;
function KD() {
  if (Xv) return Rc;
  Xv = 1, Object.defineProperty(Rc, "__esModule", { value: !0 }), Rc.DeprecationWarningHook = void 0;
  const t = "x-model-deprecation-timestamp";
  class e {
    afterSuccess(a, r) {
      return r.headers.has(t) && r.clone().json().then((i) => {
        const s = i.model;
        console.warn(`WARNING: The model ${s} is deprecated and will be removed on ${r.headers.get(t)}. Please refer to https://docs.mistral.ai/getting-started/models/#api-versioning for more information.`);
      }), r;
    }
  }
  return Rc.DeprecationWarningHook = e, Rc;
}
var Qv;
function HD() {
  if (Qv) return Nf;
  Qv = 1, Object.defineProperty(Nf, "__esModule", { value: !0 }), Nf.initHooks = n;
  const t = /* @__PURE__ */ ZD(), e = /* @__PURE__ */ KD();
  function n(a) {
    const r = new t.CustomUserAgentHook();
    a.registerBeforeRequestHook(r);
    const i = new e.DeprecationWarningHook();
    a.registerAfterSuccessHook(i);
  }
  return Nf;
}
var Yv;
function GD() {
  if (Yv) return Pc;
  Yv = 1, Object.defineProperty(Pc, "__esModule", { value: !0 }), Pc.SDKHooks = void 0;
  const t = /* @__PURE__ */ HD();
  class e {
    constructor() {
      this.sdkInitHooks = [], this.beforeCreateRequestHooks = [], this.beforeRequestHooks = [], this.afterSuccessHooks = [], this.afterErrorHooks = [];
      const a = [];
      for (const r of a)
        "sdkInit" in r && this.registerSDKInitHook(r), "beforeCreateRequest" in r && this.registerBeforeCreateRequestHook(r), "beforeRequest" in r && this.registerBeforeRequestHook(r), "afterSuccess" in r && this.registerAfterSuccessHook(r), "afterError" in r && this.registerAfterErrorHook(r);
      (0, t.initHooks)(this);
    }
    registerSDKInitHook(a) {
      this.sdkInitHooks.push(a);
    }
    registerBeforeCreateRequestHook(a) {
      this.beforeCreateRequestHooks.push(a);
    }
    registerBeforeRequestHook(a) {
      this.beforeRequestHooks.push(a);
    }
    registerAfterSuccessHook(a) {
      this.afterSuccessHooks.push(a);
    }
    registerAfterErrorHook(a) {
      this.afterErrorHooks.push(a);
    }
    sdkInit(a) {
      return this.sdkInitHooks.reduce((r, i) => i.sdkInit(r), a);
    }
    beforeCreateRequest(a, r) {
      let i = r;
      for (const s of this.beforeCreateRequestHooks)
        i = s.beforeCreateRequest(a, i);
      return i;
    }
    async beforeRequest(a, r) {
      let i = r;
      for (const s of this.beforeRequestHooks)
        i = await s.beforeRequest(a, i);
      return i;
    }
    async afterSuccess(a, r) {
      let i = r;
      for (const s of this.afterSuccessHooks)
        i = await s.afterSuccess(a, i);
      return i;
    }
    async afterError(a, r, i) {
      let s = r, u = i;
      for (const d of this.afterErrorHooks) {
        const f = await d.afterError(a, s, u);
        s = f.response, u = f.error;
      }
      return { response: s, error: u };
    }
  }
  return Pc.SDKHooks = e, Pc;
}
var Zt = {}, ew;
function BR() {
  if (ew) return Zt;
  ew = 1, Object.defineProperty(Zt, "__esModule", { value: !0 }), Zt.ConnectionError = Zt.RequestTimeoutError = Zt.RequestAbortedError = Zt.InvalidRequestError = Zt.UnexpectedClientError = Zt.HTTPClientError = void 0;
  class t extends Error {
    constructor(u, d) {
      let f = u;
      d?.cause && (f += `: ${d.cause}`), super(f, d), this.name = "HTTPClientError", typeof this.cause > "u" && (this.cause = d?.cause);
    }
  }
  Zt.HTTPClientError = t;
  class e extends t {
    constructor() {
      super(...arguments), this.name = "UnexpectedClientError";
    }
  }
  Zt.UnexpectedClientError = e;
  class n extends t {
    constructor() {
      super(...arguments), this.name = "InvalidRequestError";
    }
  }
  Zt.InvalidRequestError = n;
  class a extends t {
    constructor() {
      super(...arguments), this.name = "RequestAbortedError";
    }
  }
  Zt.RequestAbortedError = a;
  class r extends t {
    constructor() {
      super(...arguments), this.name = "RequestTimeoutError";
    }
  }
  Zt.RequestTimeoutError = r;
  class i extends t {
    constructor() {
      super(...arguments), this.name = "ConnectionError";
    }
  }
  return Zt.ConnectionError = i, Zt;
}
var jo = {}, tw;
function Vn() {
  if (tw) return jo;
  tw = 1, Object.defineProperty(jo, "__esModule", { value: !0 }), jo.OK = t, jo.ERR = e, jo.unwrap = n, jo.unwrapAsync = a;
  function t(r) {
    return { ok: !0, value: r };
  }
  function e(r) {
    return { ok: !1, error: r };
  }
  function n(r) {
    if (!r.ok)
      throw r.error;
    return r.value;
  }
  async function a(r) {
    const i = await r;
    if (!i.ok)
      throw i.error;
    return i.value;
  }
  return jo;
}
var ft = {}, er = {}, Po = {}, tr = {}, Ff = {}, Jm = {}, nw;
function yp() {
  return nw || (nw = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.getParsedType = t.ZodParsedType = t.objectUtil = t.util = void 0;
    var e;
    (function(r) {
      r.assertEqual = (d) => d;
      function i(d) {
      }
      r.assertIs = i;
      function s(d) {
        throw new Error();
      }
      r.assertNever = s, r.arrayToEnum = (d) => {
        const f = {};
        for (const o of d)
          f[o] = o;
        return f;
      }, r.getValidEnumValues = (d) => {
        const f = r.objectKeys(d).filter((c) => typeof d[d[c]] != "number"), o = {};
        for (const c of f)
          o[c] = d[c];
        return r.objectValues(o);
      }, r.objectValues = (d) => r.objectKeys(d).map(function(f) {
        return d[f];
      }), r.objectKeys = typeof Object.keys == "function" ? (d) => Object.keys(d) : (d) => {
        const f = [];
        for (const o in d)
          Object.prototype.hasOwnProperty.call(d, o) && f.push(o);
        return f;
      }, r.find = (d, f) => {
        for (const o of d)
          if (f(o))
            return o;
      }, r.isInteger = typeof Number.isInteger == "function" ? (d) => Number.isInteger(d) : (d) => typeof d == "number" && isFinite(d) && Math.floor(d) === d;
      function u(d, f = " | ") {
        return d.map((o) => typeof o == "string" ? `'${o}'` : o).join(f);
      }
      r.joinValues = u, r.jsonStringifyReplacer = (d, f) => typeof f == "bigint" ? f.toString() : f;
    })(e || (t.util = e = {}));
    var n;
    (function(r) {
      r.mergeShapes = (i, s) => ({
        ...i,
        ...s
        // second overwrites first
      });
    })(n || (t.objectUtil = n = {})), t.ZodParsedType = e.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    const a = (r) => {
      switch (typeof r) {
        case "undefined":
          return t.ZodParsedType.undefined;
        case "string":
          return t.ZodParsedType.string;
        case "number":
          return isNaN(r) ? t.ZodParsedType.nan : t.ZodParsedType.number;
        case "boolean":
          return t.ZodParsedType.boolean;
        case "function":
          return t.ZodParsedType.function;
        case "bigint":
          return t.ZodParsedType.bigint;
        case "symbol":
          return t.ZodParsedType.symbol;
        case "object":
          return Array.isArray(r) ? t.ZodParsedType.array : r === null ? t.ZodParsedType.null : r.then && typeof r.then == "function" && r.catch && typeof r.catch == "function" ? t.ZodParsedType.promise : typeof Map < "u" && r instanceof Map ? t.ZodParsedType.map : typeof Set < "u" && r instanceof Set ? t.ZodParsedType.set : typeof Date < "u" && r instanceof Date ? t.ZodParsedType.date : t.ZodParsedType.object;
        default:
          return t.ZodParsedType.unknown;
      }
    };
    t.getParsedType = a;
  }(Jm)), Jm;
}
var Sa = {}, rw;
function u_() {
  if (rw) return Sa;
  rw = 1, Object.defineProperty(Sa, "__esModule", { value: !0 }), Sa.ZodError = Sa.quotelessJson = Sa.ZodIssueCode = void 0;
  const t = /* @__PURE__ */ yp();
  Sa.ZodIssueCode = t.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const e = (a) => JSON.stringify(a, null, 2).replace(/"([^"]+)":/g, "$1:");
  Sa.quotelessJson = e;
  let n = class xR extends Error {
    get errors() {
      return this.issues;
    }
    constructor(r) {
      super(), this.issues = [], this.addIssue = (s) => {
        this.issues = [...this.issues, s];
      }, this.addIssues = (s = []) => {
        this.issues = [...this.issues, ...s];
      };
      const i = new.target.prototype;
      Object.setPrototypeOf ? Object.setPrototypeOf(this, i) : this.__proto__ = i, this.name = "ZodError", this.issues = r;
    }
    format(r) {
      const i = r || function(d) {
        return d.message;
      }, s = { _errors: [] }, u = (d) => {
        for (const f of d.issues)
          if (f.code === "invalid_union")
            f.unionErrors.map(u);
          else if (f.code === "invalid_return_type")
            u(f.returnTypeError);
          else if (f.code === "invalid_arguments")
            u(f.argumentsError);
          else if (f.path.length === 0)
            s._errors.push(i(f));
          else {
            let o = s, c = 0;
            for (; c < f.path.length; ) {
              const h = f.path[c];
              c === f.path.length - 1 ? (o[h] = o[h] || { _errors: [] }, o[h]._errors.push(i(f))) : o[h] = o[h] || { _errors: [] }, o = o[h], c++;
            }
          }
      };
      return u(this), s;
    }
    static assert(r) {
      if (!(r instanceof xR))
        throw new Error(`Not a ZodError: ${r}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, t.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(r = (i) => i.message) {
      const i = {}, s = [];
      for (const u of this.issues)
        u.path.length > 0 ? (i[u.path[0]] = i[u.path[0]] || [], i[u.path[0]].push(r(u))) : s.push(r(u));
      return { formErrors: s, fieldErrors: i };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  return Sa.ZodError = n, n.create = (a) => new n(a), Sa;
}
var aw;
function VR() {
  if (aw) return Ff;
  aw = 1, Object.defineProperty(Ff, "__esModule", { value: !0 });
  const t = /* @__PURE__ */ yp(), e = /* @__PURE__ */ u_(), n = (a, r) => {
    let i;
    switch (a.code) {
      case e.ZodIssueCode.invalid_type:
        a.received === t.ZodParsedType.undefined ? i = "Required" : i = `Expected ${a.expected}, received ${a.received}`;
        break;
      case e.ZodIssueCode.invalid_literal:
        i = `Invalid literal value, expected ${JSON.stringify(a.expected, t.util.jsonStringifyReplacer)}`;
        break;
      case e.ZodIssueCode.unrecognized_keys:
        i = `Unrecognized key(s) in object: ${t.util.joinValues(a.keys, ", ")}`;
        break;
      case e.ZodIssueCode.invalid_union:
        i = "Invalid input";
        break;
      case e.ZodIssueCode.invalid_union_discriminator:
        i = `Invalid discriminator value. Expected ${t.util.joinValues(a.options)}`;
        break;
      case e.ZodIssueCode.invalid_enum_value:
        i = `Invalid enum value. Expected ${t.util.joinValues(a.options)}, received '${a.received}'`;
        break;
      case e.ZodIssueCode.invalid_arguments:
        i = "Invalid function arguments";
        break;
      case e.ZodIssueCode.invalid_return_type:
        i = "Invalid function return type";
        break;
      case e.ZodIssueCode.invalid_date:
        i = "Invalid date";
        break;
      case e.ZodIssueCode.invalid_string:
        typeof a.validation == "object" ? "includes" in a.validation ? (i = `Invalid input: must include "${a.validation.includes}"`, typeof a.validation.position == "number" && (i = `${i} at one or more positions greater than or equal to ${a.validation.position}`)) : "startsWith" in a.validation ? i = `Invalid input: must start with "${a.validation.startsWith}"` : "endsWith" in a.validation ? i = `Invalid input: must end with "${a.validation.endsWith}"` : t.util.assertNever(a.validation) : a.validation !== "regex" ? i = `Invalid ${a.validation}` : i = "Invalid";
        break;
      case e.ZodIssueCode.too_small:
        a.type === "array" ? i = `Array must contain ${a.exact ? "exactly" : a.inclusive ? "at least" : "more than"} ${a.minimum} element(s)` : a.type === "string" ? i = `String must contain ${a.exact ? "exactly" : a.inclusive ? "at least" : "over"} ${a.minimum} character(s)` : a.type === "number" ? i = `Number must be ${a.exact ? "exactly equal to " : a.inclusive ? "greater than or equal to " : "greater than "}${a.minimum}` : a.type === "date" ? i = `Date must be ${a.exact ? "exactly equal to " : a.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(a.minimum))}` : i = "Invalid input";
        break;
      case e.ZodIssueCode.too_big:
        a.type === "array" ? i = `Array must contain ${a.exact ? "exactly" : a.inclusive ? "at most" : "less than"} ${a.maximum} element(s)` : a.type === "string" ? i = `String must contain ${a.exact ? "exactly" : a.inclusive ? "at most" : "under"} ${a.maximum} character(s)` : a.type === "number" ? i = `Number must be ${a.exact ? "exactly" : a.inclusive ? "less than or equal to" : "less than"} ${a.maximum}` : a.type === "bigint" ? i = `BigInt must be ${a.exact ? "exactly" : a.inclusive ? "less than or equal to" : "less than"} ${a.maximum}` : a.type === "date" ? i = `Date must be ${a.exact ? "exactly" : a.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(a.maximum))}` : i = "Invalid input";
        break;
      case e.ZodIssueCode.custom:
        i = "Invalid input";
        break;
      case e.ZodIssueCode.invalid_intersection_types:
        i = "Intersection results could not be merged";
        break;
      case e.ZodIssueCode.not_multiple_of:
        i = `Number must be a multiple of ${a.multipleOf}`;
        break;
      case e.ZodIssueCode.not_finite:
        i = "Number must be finite";
        break;
      default:
        i = r.defaultError, t.util.assertNever(a);
    }
    return { message: i };
  };
  return Ff.default = n, Ff;
}
var iw;
function c_() {
  if (iw) return tr;
  iw = 1;
  var t = tr && tr.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(tr, "__esModule", { value: !0 }), tr.getErrorMap = tr.setErrorMap = tr.defaultErrorMap = void 0;
  const e = t(/* @__PURE__ */ VR());
  tr.defaultErrorMap = e.default;
  let n = e.default;
  function a(i) {
    n = i;
  }
  tr.setErrorMap = a;
  function r() {
    return n;
  }
  return tr.getErrorMap = r, tr;
}
var Tc = {}, sw;
function zR() {
  return sw || (sw = 1, function(t) {
    var e = Tc && Tc.__importDefault || function(p) {
      return p && p.__esModule ? p : { default: p };
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.isAsync = t.isValid = t.isDirty = t.isAborted = t.OK = t.DIRTY = t.INVALID = t.ParseStatus = t.addIssueToContext = t.EMPTY_PATH = t.makeIssue = void 0;
    const n = /* @__PURE__ */ c_(), a = e(/* @__PURE__ */ VR()), r = (p) => {
      const { data: l, path: m, errorMaps: b, issueData: g } = p, _ = [...m, ...g.path || []], P = {
        ...g,
        path: _
      };
      if (g.message !== void 0)
        return {
          ...g,
          path: _,
          message: g.message
        };
      let R = "";
      const C = b.filter((T) => !!T).slice().reverse();
      for (const T of C)
        R = T(P, { data: l, defaultError: R }).message;
      return {
        ...g,
        path: _,
        message: R
      };
    };
    t.makeIssue = r, t.EMPTY_PATH = [];
    function i(p, l) {
      const m = (0, n.getErrorMap)(), b = (0, t.makeIssue)({
        issueData: l,
        data: p.data,
        path: p.path,
        errorMaps: [
          p.common.contextualErrorMap,
          // contextual error map is first priority
          p.schemaErrorMap,
          // then schema-bound map if available
          m,
          // then global override map
          m === a.default ? void 0 : a.default
          // then global default map
        ].filter((g) => !!g)
      });
      p.common.issues.push(b);
    }
    t.addIssueToContext = i;
    class s {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        this.value === "valid" && (this.value = "dirty");
      }
      abort() {
        this.value !== "aborted" && (this.value = "aborted");
      }
      static mergeArray(l, m) {
        const b = [];
        for (const g of m) {
          if (g.status === "aborted")
            return t.INVALID;
          g.status === "dirty" && l.dirty(), b.push(g.value);
        }
        return { status: l.value, value: b };
      }
      static async mergeObjectAsync(l, m) {
        const b = [];
        for (const g of m) {
          const _ = await g.key, P = await g.value;
          b.push({
            key: _,
            value: P
          });
        }
        return s.mergeObjectSync(l, b);
      }
      static mergeObjectSync(l, m) {
        const b = {};
        for (const g of m) {
          const { key: _, value: P } = g;
          if (_.status === "aborted" || P.status === "aborted")
            return t.INVALID;
          _.status === "dirty" && l.dirty(), P.status === "dirty" && l.dirty(), _.value !== "__proto__" && (typeof P.value < "u" || g.alwaysSet) && (b[_.value] = P.value);
        }
        return { status: l.value, value: b };
      }
    }
    t.ParseStatus = s, t.INVALID = Object.freeze({
      status: "aborted"
    });
    const u = (p) => ({ status: "dirty", value: p });
    t.DIRTY = u;
    const d = (p) => ({ status: "valid", value: p });
    t.OK = d;
    const f = (p) => p.status === "aborted";
    t.isAborted = f;
    const o = (p) => p.status === "dirty";
    t.isDirty = o;
    const c = (p) => p.status === "valid";
    t.isValid = c;
    const h = (p) => typeof Promise < "u" && p instanceof Promise;
    t.isAsync = h;
  }(Tc)), Tc;
}
var Lm = {}, ow;
function WD() {
  return ow || (ow = 1, Object.defineProperty(Lm, "__esModule", { value: !0 })), Lm;
}
var x = {}, $c = {}, uw;
function XD() {
  if (uw) return $c;
  uw = 1, Object.defineProperty($c, "__esModule", { value: !0 }), $c.errorUtil = void 0;
  var t;
  return function(e) {
    e.errToObj = (n) => typeof n == "string" ? { message: n } : n || {}, e.toString = (n) => typeof n == "string" ? n : n?.message;
  }(t || ($c.errorUtil = t = {})), $c;
}
var cw;
function QD() {
  if (cw) return x;
  cw = 1;
  var t = x && x.__classPrivateFieldGet || function(D, y, j, E) {
    if (j === "a" && !E) throw new TypeError("Private accessor was defined without a getter");
    if (typeof y == "function" ? D !== y || !E : !y.has(D)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return j === "m" ? E : j === "a" ? E.call(D) : E ? E.value : y.get(D);
  }, e = x && x.__classPrivateFieldSet || function(D, y, j, E, q) {
    if (E === "m") throw new TypeError("Private method is not writable");
    if (E === "a" && !q) throw new TypeError("Private accessor was defined without a setter");
    if (typeof y == "function" ? D !== y || !q : !y.has(D)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return E === "a" ? q.call(D, j) : q ? q.value = j : y.set(D, j), j;
  }, n, a;
  Object.defineProperty(x, "__esModule", { value: !0 }), x.boolean = x.bigint = x.array = x.any = x.coerce = x.ZodFirstPartyTypeKind = x.late = x.ZodSchema = x.Schema = x.custom = x.ZodReadonly = x.ZodPipeline = x.ZodBranded = x.BRAND = x.ZodNaN = x.ZodCatch = x.ZodDefault = x.ZodNullable = x.ZodOptional = x.ZodTransformer = x.ZodEffects = x.ZodPromise = x.ZodNativeEnum = x.ZodEnum = x.ZodLiteral = x.ZodLazy = x.ZodFunction = x.ZodSet = x.ZodMap = x.ZodRecord = x.ZodTuple = x.ZodIntersection = x.ZodDiscriminatedUnion = x.ZodUnion = x.ZodObject = x.ZodArray = x.ZodVoid = x.ZodNever = x.ZodUnknown = x.ZodAny = x.ZodNull = x.ZodUndefined = x.ZodSymbol = x.ZodDate = x.ZodBoolean = x.ZodBigInt = x.ZodNumber = x.ZodString = x.datetimeRegex = x.ZodType = void 0, x.NEVER = x.void = x.unknown = x.union = x.undefined = x.tuple = x.transformer = x.symbol = x.string = x.strictObject = x.set = x.record = x.promise = x.preprocess = x.pipeline = x.ostring = x.optional = x.onumber = x.oboolean = x.object = x.number = x.nullable = x.null = x.never = x.nativeEnum = x.nan = x.map = x.literal = x.lazy = x.intersection = x.instanceof = x.function = x.enum = x.effect = x.discriminatedUnion = x.date = void 0;
  const r = /* @__PURE__ */ c_(), i = /* @__PURE__ */ XD(), s = /* @__PURE__ */ zR(), u = /* @__PURE__ */ yp(), d = /* @__PURE__ */ u_();
  class f {
    constructor(y, j, E, q) {
      this._cachedPath = [], this.parent = y, this.data = j, this._path = E, this._key = q;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
  }
  const o = (D, y) => {
    if ((0, s.isValid)(y))
      return { success: !0, data: y.value };
    if (!D.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        const j = new d.ZodError(D.common.issues);
        return this._error = j, this._error;
      }
    };
  };
  function c(D) {
    if (!D)
      return {};
    const { errorMap: y, invalid_type_error: j, required_error: E, description: q } = D;
    if (y && (j || E))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return y ? { errorMap: y, description: q } : { errorMap: (Q, W) => {
      var re, ne;
      const { message: ce } = D;
      return Q.code === "invalid_enum_value" ? { message: ce ?? W.defaultError } : typeof W.data > "u" ? { message: (re = ce ?? E) !== null && re !== void 0 ? re : W.defaultError } : Q.code !== "invalid_type" ? { message: W.defaultError } : { message: (ne = ce ?? j) !== null && ne !== void 0 ? ne : W.defaultError };
    }, description: q };
  }
  class h {
    get description() {
      return this._def.description;
    }
    _getType(y) {
      return (0, u.getParsedType)(y.data);
    }
    _getOrReturnCtx(y, j) {
      return j || {
        common: y.parent.common,
        data: y.data,
        parsedType: (0, u.getParsedType)(y.data),
        schemaErrorMap: this._def.errorMap,
        path: y.path,
        parent: y.parent
      };
    }
    _processInputParams(y) {
      return {
        status: new s.ParseStatus(),
        ctx: {
          common: y.parent.common,
          data: y.data,
          parsedType: (0, u.getParsedType)(y.data),
          schemaErrorMap: this._def.errorMap,
          path: y.path,
          parent: y.parent
        }
      };
    }
    _parseSync(y) {
      const j = this._parse(y);
      if ((0, s.isAsync)(j))
        throw new Error("Synchronous parse encountered promise.");
      return j;
    }
    _parseAsync(y) {
      const j = this._parse(y);
      return Promise.resolve(j);
    }
    parse(y, j) {
      const E = this.safeParse(y, j);
      if (E.success)
        return E.data;
      throw E.error;
    }
    safeParse(y, j) {
      var E;
      const q = {
        common: {
          issues: [],
          async: (E = j?.async) !== null && E !== void 0 ? E : !1,
          contextualErrorMap: j?.errorMap
        },
        path: j?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: y,
        parsedType: (0, u.getParsedType)(y)
      }, J = this._parseSync({ data: y, path: q.path, parent: q });
      return o(q, J);
    }
    "~validate"(y) {
      var j, E;
      const q = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: y,
        parsedType: (0, u.getParsedType)(y)
      };
      if (!this["~standard"].async)
        try {
          const J = this._parseSync({ data: y, path: [], parent: q });
          return (0, s.isValid)(J) ? {
            value: J.value
          } : {
            issues: q.common.issues
          };
        } catch (J) {
          !((E = (j = J?.message) === null || j === void 0 ? void 0 : j.toLowerCase()) === null || E === void 0) && E.includes("encountered") && (this["~standard"].async = !0), q.common = {
            issues: [],
            async: !0
          };
        }
      return this._parseAsync({ data: y, path: [], parent: q }).then((J) => (0, s.isValid)(J) ? {
        value: J.value
      } : {
        issues: q.common.issues
      });
    }
    async parseAsync(y, j) {
      const E = await this.safeParseAsync(y, j);
      if (E.success)
        return E.data;
      throw E.error;
    }
    async safeParseAsync(y, j) {
      const E = {
        common: {
          issues: [],
          contextualErrorMap: j?.errorMap,
          async: !0
        },
        path: j?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: y,
        parsedType: (0, u.getParsedType)(y)
      }, q = this._parse({ data: y, path: E.path, parent: E }), J = await ((0, s.isAsync)(q) ? q : Promise.resolve(q));
      return o(E, J);
    }
    refine(y, j) {
      const E = (q) => typeof j == "string" || typeof j > "u" ? { message: j } : typeof j == "function" ? j(q) : j;
      return this._refinement((q, J) => {
        const Q = y(q), W = () => J.addIssue({
          code: d.ZodIssueCode.custom,
          ...E(q)
        });
        return typeof Promise < "u" && Q instanceof Promise ? Q.then((re) => re ? !0 : (W(), !1)) : Q ? !0 : (W(), !1);
      });
    }
    refinement(y, j) {
      return this._refinement((E, q) => y(E) ? !0 : (q.addIssue(typeof j == "function" ? j(E, q) : j), !1));
    }
    _refinement(y) {
      return new k({
        schema: this,
        typeName: de.ZodEffects,
        effect: { type: "refinement", refinement: y }
      });
    }
    superRefine(y) {
      return this._refinement(y);
    }
    constructor(y) {
      this.spa = this.safeParseAsync, this._def = y, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (j) => this["~validate"](j)
      };
    }
    optional() {
      return U.create(this, this._def);
    }
    nullable() {
      return z.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return fn.create(this);
    }
    promise() {
      return S.create(this, this._def);
    }
    or(y) {
      return Zn.create([this, y], this._def);
    }
    and(y) {
      return yo.create(this, y, this._def);
    }
    transform(y) {
      return new k({
        ...c(this._def),
        schema: this,
        typeName: de.ZodEffects,
        effect: { type: "transform", transform: y }
      });
    }
    default(y) {
      const j = typeof y == "function" ? y : () => y;
      return new G({
        ...c(this._def),
        innerType: this,
        defaultValue: j,
        typeName: de.ZodDefault
      });
    }
    brand() {
      return new xe({
        typeName: de.ZodBranded,
        type: this,
        ...c(this._def)
      });
    }
    catch(y) {
      const j = typeof y == "function" ? y : () => y;
      return new he({
        ...c(this._def),
        innerType: this,
        catchValue: j,
        typeName: de.ZodCatch
      });
    }
    describe(y) {
      const j = this.constructor;
      return new j({
        ...this._def,
        description: y
      });
    }
    pipe(y) {
      return Ve.create(this, y);
    }
    readonly() {
      return $e.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  x.ZodType = h, x.Schema = h, x.ZodSchema = h;
  const p = /^c[^\s-]{8,}$/i, l = /^[0-9a-z]+$/, m = /^[0-9A-HJKMNP-TV-Z]{26}$/i, b = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, g = /^[a-z0-9_-]{21}$/i, _ = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, P = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, R = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, C = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
  let T;
  const O = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, A = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, M = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, I = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, N = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, v = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, F = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", L = new RegExp(`^${F}$`);
  function B(D) {
    let y = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return D.precision ? y = `${y}\\.\\d{${D.precision}}` : D.precision == null && (y = `${y}(\\.\\d+)?`), y;
  }
  function V(D) {
    return new RegExp(`^${B(D)}$`);
  }
  function ue(D) {
    let y = `${F}T${B(D)}`;
    const j = [];
    return j.push(D.local ? "Z?" : "Z"), D.offset && j.push("([+-]\\d{2}:?\\d{2})"), y = `${y}(${j.join("|")})`, new RegExp(`^${y}$`);
  }
  x.datetimeRegex = ue;
  function ie(D, y) {
    return !!((y === "v4" || !y) && O.test(D) || (y === "v6" || !y) && M.test(D));
  }
  function ut(D, y) {
    if (!_.test(D))
      return !1;
    try {
      const [j] = D.split("."), E = j.replace(/-/g, "+").replace(/_/g, "/").padEnd(j.length + (4 - j.length % 4) % 4, "="), q = JSON.parse(atob(E));
      return !(typeof q != "object" || q === null || !q.typ || !q.alg || y && q.alg !== y);
    } catch {
      return !1;
    }
  }
  function ha(D, y) {
    return !!((y === "v4" || !y) && A.test(D) || (y === "v6" || !y) && I.test(D));
  }
  class Nt extends h {
    _parse(y) {
      if (this._def.coerce && (y.data = String(y.data)), this._getType(y) !== u.ZodParsedType.string) {
        const J = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(J, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.string,
          received: J.parsedType
        }), s.INVALID;
      }
      const E = new s.ParseStatus();
      let q;
      for (const J of this._def.checks)
        if (J.kind === "min")
          y.data.length < J.value && (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            code: d.ZodIssueCode.too_small,
            minimum: J.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: J.message
          }), E.dirty());
        else if (J.kind === "max")
          y.data.length > J.value && (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            code: d.ZodIssueCode.too_big,
            maximum: J.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: J.message
          }), E.dirty());
        else if (J.kind === "length") {
          const Q = y.data.length > J.value, W = y.data.length < J.value;
          (Q || W) && (q = this._getOrReturnCtx(y, q), Q ? (0, s.addIssueToContext)(q, {
            code: d.ZodIssueCode.too_big,
            maximum: J.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: J.message
          }) : W && (0, s.addIssueToContext)(q, {
            code: d.ZodIssueCode.too_small,
            minimum: J.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: J.message
          }), E.dirty());
        } else if (J.kind === "email")
          R.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "email",
            code: d.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "emoji")
          T || (T = new RegExp(C, "u")), T.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "emoji",
            code: d.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "uuid")
          b.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "uuid",
            code: d.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "nanoid")
          g.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "nanoid",
            code: d.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "cuid")
          p.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "cuid",
            code: d.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "cuid2")
          l.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "cuid2",
            code: d.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "ulid")
          m.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
            validation: "ulid",
            code: d.ZodIssueCode.invalid_string,
            message: J.message
          }), E.dirty());
        else if (J.kind === "url")
          try {
            new URL(y.data);
          } catch {
            q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
              validation: "url",
              code: d.ZodIssueCode.invalid_string,
              message: J.message
            }), E.dirty();
          }
        else J.kind === "regex" ? (J.regex.lastIndex = 0, J.regex.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "regex",
          code: d.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty())) : J.kind === "trim" ? y.data = y.data.trim() : J.kind === "includes" ? y.data.includes(J.value, J.position) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: d.ZodIssueCode.invalid_string,
          validation: { includes: J.value, position: J.position },
          message: J.message
        }), E.dirty()) : J.kind === "toLowerCase" ? y.data = y.data.toLowerCase() : J.kind === "toUpperCase" ? y.data = y.data.toUpperCase() : J.kind === "startsWith" ? y.data.startsWith(J.value) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: d.ZodIssueCode.invalid_string,
          validation: { startsWith: J.value },
          message: J.message
        }), E.dirty()) : J.kind === "endsWith" ? y.data.endsWith(J.value) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: d.ZodIssueCode.invalid_string,
          validation: { endsWith: J.value },
          message: J.message
        }), E.dirty()) : J.kind === "datetime" ? ue(J).test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: d.ZodIssueCode.invalid_string,
          validation: "datetime",
          message: J.message
        }), E.dirty()) : J.kind === "date" ? L.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: d.ZodIssueCode.invalid_string,
          validation: "date",
          message: J.message
        }), E.dirty()) : J.kind === "time" ? V(J).test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: d.ZodIssueCode.invalid_string,
          validation: "time",
          message: J.message
        }), E.dirty()) : J.kind === "duration" ? P.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "duration",
          code: d.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty()) : J.kind === "ip" ? ie(y.data, J.version) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "ip",
          code: d.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty()) : J.kind === "jwt" ? ut(y.data, J.alg) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "jwt",
          code: d.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty()) : J.kind === "cidr" ? ha(y.data, J.version) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "cidr",
          code: d.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty()) : J.kind === "base64" ? N.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "base64",
          code: d.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty()) : J.kind === "base64url" ? v.test(y.data) || (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          validation: "base64url",
          code: d.ZodIssueCode.invalid_string,
          message: J.message
        }), E.dirty()) : u.util.assertNever(J);
      return { status: E.value, value: y.data };
    }
    _regex(y, j, E) {
      return this.refinement((q) => y.test(q), {
        validation: j,
        code: d.ZodIssueCode.invalid_string,
        ...i.errorUtil.errToObj(E)
      });
    }
    _addCheck(y) {
      return new Nt({
        ...this._def,
        checks: [...this._def.checks, y]
      });
    }
    email(y) {
      return this._addCheck({ kind: "email", ...i.errorUtil.errToObj(y) });
    }
    url(y) {
      return this._addCheck({ kind: "url", ...i.errorUtil.errToObj(y) });
    }
    emoji(y) {
      return this._addCheck({ kind: "emoji", ...i.errorUtil.errToObj(y) });
    }
    uuid(y) {
      return this._addCheck({ kind: "uuid", ...i.errorUtil.errToObj(y) });
    }
    nanoid(y) {
      return this._addCheck({ kind: "nanoid", ...i.errorUtil.errToObj(y) });
    }
    cuid(y) {
      return this._addCheck({ kind: "cuid", ...i.errorUtil.errToObj(y) });
    }
    cuid2(y) {
      return this._addCheck({ kind: "cuid2", ...i.errorUtil.errToObj(y) });
    }
    ulid(y) {
      return this._addCheck({ kind: "ulid", ...i.errorUtil.errToObj(y) });
    }
    base64(y) {
      return this._addCheck({ kind: "base64", ...i.errorUtil.errToObj(y) });
    }
    base64url(y) {
      return this._addCheck({
        kind: "base64url",
        ...i.errorUtil.errToObj(y)
      });
    }
    jwt(y) {
      return this._addCheck({ kind: "jwt", ...i.errorUtil.errToObj(y) });
    }
    ip(y) {
      return this._addCheck({ kind: "ip", ...i.errorUtil.errToObj(y) });
    }
    cidr(y) {
      return this._addCheck({ kind: "cidr", ...i.errorUtil.errToObj(y) });
    }
    datetime(y) {
      var j, E;
      return typeof y == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        local: !1,
        message: y
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof y?.precision > "u" ? null : y?.precision,
        offset: (j = y?.offset) !== null && j !== void 0 ? j : !1,
        local: (E = y?.local) !== null && E !== void 0 ? E : !1,
        ...i.errorUtil.errToObj(y?.message)
      });
    }
    date(y) {
      return this._addCheck({ kind: "date", message: y });
    }
    time(y) {
      return typeof y == "string" ? this._addCheck({
        kind: "time",
        precision: null,
        message: y
      }) : this._addCheck({
        kind: "time",
        precision: typeof y?.precision > "u" ? null : y?.precision,
        ...i.errorUtil.errToObj(y?.message)
      });
    }
    duration(y) {
      return this._addCheck({ kind: "duration", ...i.errorUtil.errToObj(y) });
    }
    regex(y, j) {
      return this._addCheck({
        kind: "regex",
        regex: y,
        ...i.errorUtil.errToObj(j)
      });
    }
    includes(y, j) {
      return this._addCheck({
        kind: "includes",
        value: y,
        position: j?.position,
        ...i.errorUtil.errToObj(j?.message)
      });
    }
    startsWith(y, j) {
      return this._addCheck({
        kind: "startsWith",
        value: y,
        ...i.errorUtil.errToObj(j)
      });
    }
    endsWith(y, j) {
      return this._addCheck({
        kind: "endsWith",
        value: y,
        ...i.errorUtil.errToObj(j)
      });
    }
    min(y, j) {
      return this._addCheck({
        kind: "min",
        value: y,
        ...i.errorUtil.errToObj(j)
      });
    }
    max(y, j) {
      return this._addCheck({
        kind: "max",
        value: y,
        ...i.errorUtil.errToObj(j)
      });
    }
    length(y, j) {
      return this._addCheck({
        kind: "length",
        value: y,
        ...i.errorUtil.errToObj(j)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(y) {
      return this.min(1, i.errorUtil.errToObj(y));
    }
    trim() {
      return new Nt({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new Nt({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new Nt({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((y) => y.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((y) => y.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((y) => y.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((y) => y.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((y) => y.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((y) => y.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((y) => y.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((y) => y.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((y) => y.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((y) => y.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((y) => y.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((y) => y.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((y) => y.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((y) => y.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((y) => y.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((y) => y.kind === "base64url");
    }
    get minLength() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "min" && (y === null || j.value > y) && (y = j.value);
      return y;
    }
    get maxLength() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "max" && (y === null || j.value < y) && (y = j.value);
      return y;
    }
  }
  x.ZodString = Nt, Nt.create = (D) => {
    var y;
    return new Nt({
      checks: [],
      typeName: de.ZodString,
      coerce: (y = D?.coerce) !== null && y !== void 0 ? y : !1,
      ...c(D)
    });
  };
  function cc(D, y) {
    const j = (D.toString().split(".")[1] || "").length, E = (y.toString().split(".")[1] || "").length, q = j > E ? j : E, J = parseInt(D.toFixed(q).replace(".", "")), Q = parseInt(y.toFixed(q).replace(".", ""));
    return J % Q / Math.pow(10, q);
  }
  class Tt extends h {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(y) {
      if (this._def.coerce && (y.data = Number(y.data)), this._getType(y) !== u.ZodParsedType.number) {
        const J = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(J, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.number,
          received: J.parsedType
        }), s.INVALID;
      }
      let E;
      const q = new s.ParseStatus();
      for (const J of this._def.checks)
        J.kind === "int" ? u.util.isInteger(y.data) || (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: J.message
        }), q.dirty()) : J.kind === "min" ? (J.inclusive ? y.data < J.value : y.data <= J.value) && (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.too_small,
          minimum: J.value,
          type: "number",
          inclusive: J.inclusive,
          exact: !1,
          message: J.message
        }), q.dirty()) : J.kind === "max" ? (J.inclusive ? y.data > J.value : y.data >= J.value) && (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.too_big,
          maximum: J.value,
          type: "number",
          inclusive: J.inclusive,
          exact: !1,
          message: J.message
        }), q.dirty()) : J.kind === "multipleOf" ? cc(y.data, J.value) !== 0 && (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.not_multiple_of,
          multipleOf: J.value,
          message: J.message
        }), q.dirty()) : J.kind === "finite" ? Number.isFinite(y.data) || (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.not_finite,
          message: J.message
        }), q.dirty()) : u.util.assertNever(J);
      return { status: q.value, value: y.data };
    }
    gte(y, j) {
      return this.setLimit("min", y, !0, i.errorUtil.toString(j));
    }
    gt(y, j) {
      return this.setLimit("min", y, !1, i.errorUtil.toString(j));
    }
    lte(y, j) {
      return this.setLimit("max", y, !0, i.errorUtil.toString(j));
    }
    lt(y, j) {
      return this.setLimit("max", y, !1, i.errorUtil.toString(j));
    }
    setLimit(y, j, E, q) {
      return new Tt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: y,
            value: j,
            inclusive: E,
            message: i.errorUtil.toString(q)
          }
        ]
      });
    }
    _addCheck(y) {
      return new Tt({
        ...this._def,
        checks: [...this._def.checks, y]
      });
    }
    int(y) {
      return this._addCheck({
        kind: "int",
        message: i.errorUtil.toString(y)
      });
    }
    positive(y) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: i.errorUtil.toString(y)
      });
    }
    negative(y) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: i.errorUtil.toString(y)
      });
    }
    nonpositive(y) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: i.errorUtil.toString(y)
      });
    }
    nonnegative(y) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: i.errorUtil.toString(y)
      });
    }
    multipleOf(y, j) {
      return this._addCheck({
        kind: "multipleOf",
        value: y,
        message: i.errorUtil.toString(j)
      });
    }
    finite(y) {
      return this._addCheck({
        kind: "finite",
        message: i.errorUtil.toString(y)
      });
    }
    safe(y) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: i.errorUtil.toString(y)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: i.errorUtil.toString(y)
      });
    }
    get minValue() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "min" && (y === null || j.value > y) && (y = j.value);
      return y;
    }
    get maxValue() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "max" && (y === null || j.value < y) && (y = j.value);
      return y;
    }
    get isInt() {
      return !!this._def.checks.find((y) => y.kind === "int" || y.kind === "multipleOf" && u.util.isInteger(y.value));
    }
    get isFinite() {
      let y = null, j = null;
      for (const E of this._def.checks) {
        if (E.kind === "finite" || E.kind === "int" || E.kind === "multipleOf")
          return !0;
        E.kind === "min" ? (j === null || E.value > j) && (j = E.value) : E.kind === "max" && (y === null || E.value < y) && (y = E.value);
      }
      return Number.isFinite(j) && Number.isFinite(y);
    }
  }
  x.ZodNumber = Tt, Tt.create = (D) => new Tt({
    checks: [],
    typeName: de.ZodNumber,
    coerce: D?.coerce || !1,
    ...c(D)
  });
  class Je extends h {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(y) {
      if (this._def.coerce)
        try {
          y.data = BigInt(y.data);
        } catch {
          return this._getInvalidInput(y);
        }
      if (this._getType(y) !== u.ZodParsedType.bigint)
        return this._getInvalidInput(y);
      let E;
      const q = new s.ParseStatus();
      for (const J of this._def.checks)
        J.kind === "min" ? (J.inclusive ? y.data < J.value : y.data <= J.value) && (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.too_small,
          type: "bigint",
          minimum: J.value,
          inclusive: J.inclusive,
          message: J.message
        }), q.dirty()) : J.kind === "max" ? (J.inclusive ? y.data > J.value : y.data >= J.value) && (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.too_big,
          type: "bigint",
          maximum: J.value,
          inclusive: J.inclusive,
          message: J.message
        }), q.dirty()) : J.kind === "multipleOf" ? y.data % J.value !== BigInt(0) && (E = this._getOrReturnCtx(y, E), (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.not_multiple_of,
          multipleOf: J.value,
          message: J.message
        }), q.dirty()) : u.util.assertNever(J);
      return { status: q.value, value: y.data };
    }
    _getInvalidInput(y) {
      const j = this._getOrReturnCtx(y);
      return (0, s.addIssueToContext)(j, {
        code: d.ZodIssueCode.invalid_type,
        expected: u.ZodParsedType.bigint,
        received: j.parsedType
      }), s.INVALID;
    }
    gte(y, j) {
      return this.setLimit("min", y, !0, i.errorUtil.toString(j));
    }
    gt(y, j) {
      return this.setLimit("min", y, !1, i.errorUtil.toString(j));
    }
    lte(y, j) {
      return this.setLimit("max", y, !0, i.errorUtil.toString(j));
    }
    lt(y, j) {
      return this.setLimit("max", y, !1, i.errorUtil.toString(j));
    }
    setLimit(y, j, E, q) {
      return new Je({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: y,
            value: j,
            inclusive: E,
            message: i.errorUtil.toString(q)
          }
        ]
      });
    }
    _addCheck(y) {
      return new Je({
        ...this._def,
        checks: [...this._def.checks, y]
      });
    }
    positive(y) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: i.errorUtil.toString(y)
      });
    }
    negative(y) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: i.errorUtil.toString(y)
      });
    }
    nonpositive(y) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: i.errorUtil.toString(y)
      });
    }
    nonnegative(y) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: i.errorUtil.toString(y)
      });
    }
    multipleOf(y, j) {
      return this._addCheck({
        kind: "multipleOf",
        value: y,
        message: i.errorUtil.toString(j)
      });
    }
    get minValue() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "min" && (y === null || j.value > y) && (y = j.value);
      return y;
    }
    get maxValue() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "max" && (y === null || j.value < y) && (y = j.value);
      return y;
    }
  }
  x.ZodBigInt = Je, Je.create = (D) => {
    var y;
    return new Je({
      checks: [],
      typeName: de.ZodBigInt,
      coerce: (y = D?.coerce) !== null && y !== void 0 ? y : !1,
      ...c(D)
    });
  };
  class Le extends h {
    _parse(y) {
      if (this._def.coerce && (y.data = !!y.data), this._getType(y) !== u.ZodParsedType.boolean) {
        const E = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.boolean,
          received: E.parsedType
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
  }
  x.ZodBoolean = Le, Le.create = (D) => new Le({
    typeName: de.ZodBoolean,
    coerce: D?.coerce || !1,
    ...c(D)
  });
  class Xt extends h {
    _parse(y) {
      if (this._def.coerce && (y.data = new Date(y.data)), this._getType(y) !== u.ZodParsedType.date) {
        const J = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(J, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.date,
          received: J.parsedType
        }), s.INVALID;
      }
      if (isNaN(y.data.getTime())) {
        const J = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(J, {
          code: d.ZodIssueCode.invalid_date
        }), s.INVALID;
      }
      const E = new s.ParseStatus();
      let q;
      for (const J of this._def.checks)
        J.kind === "min" ? y.data.getTime() < J.value && (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: d.ZodIssueCode.too_small,
          message: J.message,
          inclusive: !0,
          exact: !1,
          minimum: J.value,
          type: "date"
        }), E.dirty()) : J.kind === "max" ? y.data.getTime() > J.value && (q = this._getOrReturnCtx(y, q), (0, s.addIssueToContext)(q, {
          code: d.ZodIssueCode.too_big,
          message: J.message,
          inclusive: !0,
          exact: !1,
          maximum: J.value,
          type: "date"
        }), E.dirty()) : u.util.assertNever(J);
      return {
        status: E.value,
        value: new Date(y.data.getTime())
      };
    }
    _addCheck(y) {
      return new Xt({
        ...this._def,
        checks: [...this._def.checks, y]
      });
    }
    min(y, j) {
      return this._addCheck({
        kind: "min",
        value: y.getTime(),
        message: i.errorUtil.toString(j)
      });
    }
    max(y, j) {
      return this._addCheck({
        kind: "max",
        value: y.getTime(),
        message: i.errorUtil.toString(j)
      });
    }
    get minDate() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "min" && (y === null || j.value > y) && (y = j.value);
      return y != null ? new Date(y) : null;
    }
    get maxDate() {
      let y = null;
      for (const j of this._def.checks)
        j.kind === "max" && (y === null || j.value < y) && (y = j.value);
      return y != null ? new Date(y) : null;
    }
  }
  x.ZodDate = Xt, Xt.create = (D) => new Xt({
    checks: [],
    coerce: D?.coerce || !1,
    typeName: de.ZodDate,
    ...c(D)
  });
  class Xe extends h {
    _parse(y) {
      if (this._getType(y) !== u.ZodParsedType.symbol) {
        const E = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.symbol,
          received: E.parsedType
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
  }
  x.ZodSymbol = Xe, Xe.create = (D) => new Xe({
    typeName: de.ZodSymbol,
    ...c(D)
  });
  class Ft extends h {
    _parse(y) {
      if (this._getType(y) !== u.ZodParsedType.undefined) {
        const E = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.undefined,
          received: E.parsedType
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
  }
  x.ZodUndefined = Ft, Ft.create = (D) => new Ft({
    typeName: de.ZodUndefined,
    ...c(D)
  });
  class zn extends h {
    _parse(y) {
      if (this._getType(y) !== u.ZodParsedType.null) {
        const E = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.null,
          received: E.parsedType
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
  }
  x.ZodNull = zn, zn.create = (D) => new zn({
    typeName: de.ZodNull,
    ...c(D)
  });
  class pa extends h {
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(y) {
      return (0, s.OK)(y.data);
    }
  }
  x.ZodAny = pa, pa.create = (D) => new pa({
    typeName: de.ZodAny,
    ...c(D)
  });
  class Qt extends h {
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(y) {
      return (0, s.OK)(y.data);
    }
  }
  x.ZodUnknown = Qt, Qt.create = (D) => new Qt({
    typeName: de.ZodUnknown,
    ...c(D)
  });
  class dn extends h {
    _parse(y) {
      const j = this._getOrReturnCtx(y);
      return (0, s.addIssueToContext)(j, {
        code: d.ZodIssueCode.invalid_type,
        expected: u.ZodParsedType.never,
        received: j.parsedType
      }), s.INVALID;
    }
  }
  x.ZodNever = dn, dn.create = (D) => new dn({
    typeName: de.ZodNever,
    ...c(D)
  });
  class go extends h {
    _parse(y) {
      if (this._getType(y) !== u.ZodParsedType.undefined) {
        const E = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.void,
          received: E.parsedType
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
  }
  x.ZodVoid = go, go.create = (D) => new go({
    typeName: de.ZodVoid,
    ...c(D)
  });
  class fn extends h {
    _parse(y) {
      const { ctx: j, status: E } = this._processInputParams(y), q = this._def;
      if (j.parsedType !== u.ZodParsedType.array)
        return (0, s.addIssueToContext)(j, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.array,
          received: j.parsedType
        }), s.INVALID;
      if (q.exactLength !== null) {
        const Q = j.data.length > q.exactLength.value, W = j.data.length < q.exactLength.value;
        (Q || W) && ((0, s.addIssueToContext)(j, {
          code: Q ? d.ZodIssueCode.too_big : d.ZodIssueCode.too_small,
          minimum: W ? q.exactLength.value : void 0,
          maximum: Q ? q.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: q.exactLength.message
        }), E.dirty());
      }
      if (q.minLength !== null && j.data.length < q.minLength.value && ((0, s.addIssueToContext)(j, {
        code: d.ZodIssueCode.too_small,
        minimum: q.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: q.minLength.message
      }), E.dirty()), q.maxLength !== null && j.data.length > q.maxLength.value && ((0, s.addIssueToContext)(j, {
        code: d.ZodIssueCode.too_big,
        maximum: q.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: q.maxLength.message
      }), E.dirty()), j.common.async)
        return Promise.all([...j.data].map((Q, W) => q.type._parseAsync(new f(j, Q, j.path, W)))).then((Q) => s.ParseStatus.mergeArray(E, Q));
      const J = [...j.data].map((Q, W) => q.type._parseSync(new f(j, Q, j.path, W)));
      return s.ParseStatus.mergeArray(E, J);
    }
    get element() {
      return this._def.type;
    }
    min(y, j) {
      return new fn({
        ...this._def,
        minLength: { value: y, message: i.errorUtil.toString(j) }
      });
    }
    max(y, j) {
      return new fn({
        ...this._def,
        maxLength: { value: y, message: i.errorUtil.toString(j) }
      });
    }
    length(y, j) {
      return new fn({
        ...this._def,
        exactLength: { value: y, message: i.errorUtil.toString(j) }
      });
    }
    nonempty(y) {
      return this.min(1, y);
    }
  }
  x.ZodArray = fn, fn.create = (D, y) => new fn({
    type: D,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: de.ZodArray,
    ...c(y)
  });
  function ma(D) {
    if (D instanceof qe) {
      const y = {};
      for (const j in D.shape) {
        const E = D.shape[j];
        y[j] = U.create(ma(E));
      }
      return new qe({
        ...D._def,
        shape: () => y
      });
    } else return D instanceof fn ? new fn({
      ...D._def,
      type: ma(D.element)
    }) : D instanceof U ? U.create(ma(D.unwrap())) : D instanceof z ? z.create(ma(D.unwrap())) : D instanceof $n ? $n.create(D.items.map((y) => ma(y))) : D;
  }
  class qe extends h {
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const y = this._def.shape(), j = u.util.objectKeys(y);
      return this._cached = { shape: y, keys: j };
    }
    _parse(y) {
      if (this._getType(y) !== u.ZodParsedType.object) {
        const ne = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(ne, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.object,
          received: ne.parsedType
        }), s.INVALID;
      }
      const { status: E, ctx: q } = this._processInputParams(y), { shape: J, keys: Q } = this._getCached(), W = [];
      if (!(this._def.catchall instanceof dn && this._def.unknownKeys === "strip"))
        for (const ne in q.data)
          Q.includes(ne) || W.push(ne);
      const re = [];
      for (const ne of Q) {
        const ce = J[ne], xt = q.data[ne];
        re.push({
          key: { status: "valid", value: ne },
          value: ce._parse(new f(q, xt, q.path, ne)),
          alwaysSet: ne in q.data
        });
      }
      if (this._def.catchall instanceof dn) {
        const ne = this._def.unknownKeys;
        if (ne === "passthrough")
          for (const ce of W)
            re.push({
              key: { status: "valid", value: ce },
              value: { status: "valid", value: q.data[ce] }
            });
        else if (ne === "strict")
          W.length > 0 && ((0, s.addIssueToContext)(q, {
            code: d.ZodIssueCode.unrecognized_keys,
            keys: W
          }), E.dirty());
        else if (ne !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        const ne = this._def.catchall;
        for (const ce of W) {
          const xt = q.data[ce];
          re.push({
            key: { status: "valid", value: ce },
            value: ne._parse(
              new f(q, xt, q.path, ce)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: ce in q.data
          });
        }
      }
      return q.common.async ? Promise.resolve().then(async () => {
        const ne = [];
        for (const ce of re) {
          const xt = await ce.key, Gd = await ce.value;
          ne.push({
            key: xt,
            value: Gd,
            alwaysSet: ce.alwaysSet
          });
        }
        return ne;
      }).then((ne) => s.ParseStatus.mergeObjectSync(E, ne)) : s.ParseStatus.mergeObjectSync(E, re);
    }
    get shape() {
      return this._def.shape();
    }
    strict(y) {
      return new qe({
        ...this._def,
        unknownKeys: "strict",
        ...y !== void 0 ? {
          errorMap: (j, E) => {
            var q, J, Q, W;
            const re = (Q = (J = (q = this._def).errorMap) === null || J === void 0 ? void 0 : J.call(q, j, E).message) !== null && Q !== void 0 ? Q : E.defaultError;
            return j.code === "unrecognized_keys" ? {
              message: (W = i.errorUtil.errToObj(y).message) !== null && W !== void 0 ? W : re
            } : {
              message: re
            };
          }
        } : {}
      });
    }
    strip() {
      return new qe({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new qe({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(y) {
      return new qe({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...y
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(y) {
      return new qe({
        unknownKeys: y._def.unknownKeys,
        catchall: y._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...y._def.shape()
        }),
        typeName: de.ZodObject
      });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(y, j) {
      return this.augment({ [y]: j });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(y) {
      return new qe({
        ...this._def,
        catchall: y
      });
    }
    pick(y) {
      const j = {};
      return u.util.objectKeys(y).forEach((E) => {
        y[E] && this.shape[E] && (j[E] = this.shape[E]);
      }), new qe({
        ...this._def,
        shape: () => j
      });
    }
    omit(y) {
      const j = {};
      return u.util.objectKeys(this.shape).forEach((E) => {
        y[E] || (j[E] = this.shape[E]);
      }), new qe({
        ...this._def,
        shape: () => j
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return ma(this);
    }
    partial(y) {
      const j = {};
      return u.util.objectKeys(this.shape).forEach((E) => {
        const q = this.shape[E];
        y && !y[E] ? j[E] = q : j[E] = q.optional();
      }), new qe({
        ...this._def,
        shape: () => j
      });
    }
    required(y) {
      const j = {};
      return u.util.objectKeys(this.shape).forEach((E) => {
        if (y && !y[E])
          j[E] = this.shape[E];
        else {
          let J = this.shape[E];
          for (; J instanceof U; )
            J = J._def.innerType;
          j[E] = J;
        }
      }), new qe({
        ...this._def,
        shape: () => j
      });
    }
    keyof() {
      return Hd(u.util.objectKeys(this.shape));
    }
  }
  x.ZodObject = qe, qe.create = (D, y) => new qe({
    shape: () => D,
    unknownKeys: "strip",
    catchall: dn.create(),
    typeName: de.ZodObject,
    ...c(y)
  }), qe.strictCreate = (D, y) => new qe({
    shape: () => D,
    unknownKeys: "strict",
    catchall: dn.create(),
    typeName: de.ZodObject,
    ...c(y)
  }), qe.lazycreate = (D, y) => new qe({
    shape: D,
    unknownKeys: "strip",
    catchall: dn.create(),
    typeName: de.ZodObject,
    ...c(y)
  });
  class Zn extends h {
    _parse(y) {
      const { ctx: j } = this._processInputParams(y), E = this._def.options;
      function q(J) {
        for (const W of J)
          if (W.result.status === "valid")
            return W.result;
        for (const W of J)
          if (W.result.status === "dirty")
            return j.common.issues.push(...W.ctx.common.issues), W.result;
        const Q = J.map((W) => new d.ZodError(W.ctx.common.issues));
        return (0, s.addIssueToContext)(j, {
          code: d.ZodIssueCode.invalid_union,
          unionErrors: Q
        }), s.INVALID;
      }
      if (j.common.async)
        return Promise.all(E.map(async (J) => {
          const Q = {
            ...j,
            common: {
              ...j.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await J._parseAsync({
              data: j.data,
              path: j.path,
              parent: Q
            }),
            ctx: Q
          };
        })).then(q);
      {
        let J;
        const Q = [];
        for (const re of E) {
          const ne = {
            ...j,
            common: {
              ...j.common,
              issues: []
            },
            parent: null
          }, ce = re._parseSync({
            data: j.data,
            path: j.path,
            parent: ne
          });
          if (ce.status === "valid")
            return ce;
          ce.status === "dirty" && !J && (J = { result: ce, ctx: ne }), ne.common.issues.length && Q.push(ne.common.issues);
        }
        if (J)
          return j.common.issues.push(...J.ctx.common.issues), J.result;
        const W = Q.map((re) => new d.ZodError(re));
        return (0, s.addIssueToContext)(j, {
          code: d.ZodIssueCode.invalid_union,
          unionErrors: W
        }), s.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  x.ZodUnion = Zn, Zn.create = (D, y) => new Zn({
    options: D,
    typeName: de.ZodUnion,
    ...c(y)
  });
  const Kn = (D) => D instanceof vo ? Kn(D.schema) : D instanceof k ? Kn(D.innerType()) : D instanceof Yt ? [D.value] : D instanceof $ ? D.options : D instanceof w ? u.util.objectValues(D.enum) : D instanceof G ? Kn(D._def.innerType) : D instanceof Ft ? [void 0] : D instanceof zn ? [null] : D instanceof U ? [void 0, ...Kn(D.unwrap())] : D instanceof z ? [null, ...Kn(D.unwrap())] : D instanceof xe || D instanceof $e ? Kn(D.unwrap()) : D instanceof he ? Kn(D._def.innerType) : [];
  class iu extends h {
    _parse(y) {
      const { ctx: j } = this._processInputParams(y);
      if (j.parsedType !== u.ZodParsedType.object)
        return (0, s.addIssueToContext)(j, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.object,
          received: j.parsedType
        }), s.INVALID;
      const E = this.discriminator, q = j.data[E], J = this.optionsMap.get(q);
      return J ? j.common.async ? J._parseAsync({
        data: j.data,
        path: j.path,
        parent: j
      }) : J._parseSync({
        data: j.data,
        path: j.path,
        parent: j
      }) : ((0, s.addIssueToContext)(j, {
        code: d.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [E]
      }), s.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(y, j, E) {
      const q = /* @__PURE__ */ new Map();
      for (const J of j) {
        const Q = Kn(J.shape[y]);
        if (!Q.length)
          throw new Error(`A discriminator value for key \`${y}\` could not be extracted from all schema options`);
        for (const W of Q) {
          if (q.has(W))
            throw new Error(`Discriminator property ${String(y)} has duplicate value ${String(W)}`);
          q.set(W, J);
        }
      }
      return new iu({
        typeName: de.ZodDiscriminatedUnion,
        discriminator: y,
        options: j,
        optionsMap: q,
        ...c(E)
      });
    }
  }
  x.ZodDiscriminatedUnion = iu;
  function _o(D, y) {
    const j = (0, u.getParsedType)(D), E = (0, u.getParsedType)(y);
    if (D === y)
      return { valid: !0, data: D };
    if (j === u.ZodParsedType.object && E === u.ZodParsedType.object) {
      const q = u.util.objectKeys(y), J = u.util.objectKeys(D).filter((W) => q.indexOf(W) !== -1), Q = { ...D, ...y };
      for (const W of J) {
        const re = _o(D[W], y[W]);
        if (!re.valid)
          return { valid: !1 };
        Q[W] = re.data;
      }
      return { valid: !0, data: Q };
    } else if (j === u.ZodParsedType.array && E === u.ZodParsedType.array) {
      if (D.length !== y.length)
        return { valid: !1 };
      const q = [];
      for (let J = 0; J < D.length; J++) {
        const Q = D[J], W = y[J], re = _o(Q, W);
        if (!re.valid)
          return { valid: !1 };
        q.push(re.data);
      }
      return { valid: !0, data: q };
    } else return j === u.ZodParsedType.date && E === u.ZodParsedType.date && +D == +y ? { valid: !0, data: D } : { valid: !1 };
  }
  class yo extends h {
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y), q = (J, Q) => {
        if ((0, s.isAborted)(J) || (0, s.isAborted)(Q))
          return s.INVALID;
        const W = _o(J.value, Q.value);
        return W.valid ? (((0, s.isDirty)(J) || (0, s.isDirty)(Q)) && j.dirty(), { status: j.value, value: W.data }) : ((0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_intersection_types
        }), s.INVALID);
      };
      return E.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: E.data,
          path: E.path,
          parent: E
        }),
        this._def.right._parseAsync({
          data: E.data,
          path: E.path,
          parent: E
        })
      ]).then(([J, Q]) => q(J, Q)) : q(this._def.left._parseSync({
        data: E.data,
        path: E.path,
        parent: E
      }), this._def.right._parseSync({
        data: E.data,
        path: E.path,
        parent: E
      }));
    }
  }
  x.ZodIntersection = yo, yo.create = (D, y, j) => new yo({
    left: D,
    right: y,
    typeName: de.ZodIntersection,
    ...c(j)
  });
  class $n extends h {
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y);
      if (E.parsedType !== u.ZodParsedType.array)
        return (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.array,
          received: E.parsedType
        }), s.INVALID;
      if (E.data.length < this._def.items.length)
        return (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), s.INVALID;
      !this._def.rest && E.data.length > this._def.items.length && ((0, s.addIssueToContext)(E, {
        code: d.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), j.dirty());
      const J = [...E.data].map((Q, W) => {
        const re = this._def.items[W] || this._def.rest;
        return re ? re._parse(new f(E, Q, E.path, W)) : null;
      }).filter((Q) => !!Q);
      return E.common.async ? Promise.all(J).then((Q) => s.ParseStatus.mergeArray(j, Q)) : s.ParseStatus.mergeArray(j, J);
    }
    get items() {
      return this._def.items;
    }
    rest(y) {
      return new $n({
        ...this._def,
        rest: y
      });
    }
  }
  x.ZodTuple = $n, $n.create = (D, y) => {
    if (!Array.isArray(D))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new $n({
      items: D,
      typeName: de.ZodTuple,
      rest: null,
      ...c(y)
    });
  };
  class Vs extends h {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y);
      if (E.parsedType !== u.ZodParsedType.object)
        return (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.object,
          received: E.parsedType
        }), s.INVALID;
      const q = [], J = this._def.keyType, Q = this._def.valueType;
      for (const W in E.data)
        q.push({
          key: J._parse(new f(E, W, E.path, W)),
          value: Q._parse(new f(E, E.data[W], E.path, W)),
          alwaysSet: W in E.data
        });
      return E.common.async ? s.ParseStatus.mergeObjectAsync(j, q) : s.ParseStatus.mergeObjectSync(j, q);
    }
    get element() {
      return this._def.valueType;
    }
    static create(y, j, E) {
      return j instanceof h ? new Vs({
        keyType: y,
        valueType: j,
        typeName: de.ZodRecord,
        ...c(E)
      }) : new Vs({
        keyType: Nt.create(),
        valueType: y,
        typeName: de.ZodRecord,
        ...c(j)
      });
    }
  }
  x.ZodRecord = Vs;
  class ba extends h {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y);
      if (E.parsedType !== u.ZodParsedType.map)
        return (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.map,
          received: E.parsedType
        }), s.INVALID;
      const q = this._def.keyType, J = this._def.valueType, Q = [...E.data.entries()].map(([W, re], ne) => ({
        key: q._parse(new f(E, W, E.path, [ne, "key"])),
        value: J._parse(new f(E, re, E.path, [ne, "value"]))
      }));
      if (E.common.async) {
        const W = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const re of Q) {
            const ne = await re.key, ce = await re.value;
            if (ne.status === "aborted" || ce.status === "aborted")
              return s.INVALID;
            (ne.status === "dirty" || ce.status === "dirty") && j.dirty(), W.set(ne.value, ce.value);
          }
          return { status: j.value, value: W };
        });
      } else {
        const W = /* @__PURE__ */ new Map();
        for (const re of Q) {
          const ne = re.key, ce = re.value;
          if (ne.status === "aborted" || ce.status === "aborted")
            return s.INVALID;
          (ne.status === "dirty" || ce.status === "dirty") && j.dirty(), W.set(ne.value, ce.value);
        }
        return { status: j.value, value: W };
      }
    }
  }
  x.ZodMap = ba, ba.create = (D, y, j) => new ba({
    valueType: y,
    keyType: D,
    typeName: de.ZodMap,
    ...c(j)
  });
  class wt extends h {
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y);
      if (E.parsedType !== u.ZodParsedType.set)
        return (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.set,
          received: E.parsedType
        }), s.INVALID;
      const q = this._def;
      q.minSize !== null && E.data.size < q.minSize.value && ((0, s.addIssueToContext)(E, {
        code: d.ZodIssueCode.too_small,
        minimum: q.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: q.minSize.message
      }), j.dirty()), q.maxSize !== null && E.data.size > q.maxSize.value && ((0, s.addIssueToContext)(E, {
        code: d.ZodIssueCode.too_big,
        maximum: q.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: q.maxSize.message
      }), j.dirty());
      const J = this._def.valueType;
      function Q(re) {
        const ne = /* @__PURE__ */ new Set();
        for (const ce of re) {
          if (ce.status === "aborted")
            return s.INVALID;
          ce.status === "dirty" && j.dirty(), ne.add(ce.value);
        }
        return { status: j.value, value: ne };
      }
      const W = [...E.data.values()].map((re, ne) => J._parse(new f(E, re, E.path, ne)));
      return E.common.async ? Promise.all(W).then((re) => Q(re)) : Q(W);
    }
    min(y, j) {
      return new wt({
        ...this._def,
        minSize: { value: y, message: i.errorUtil.toString(j) }
      });
    }
    max(y, j) {
      return new wt({
        ...this._def,
        maxSize: { value: y, message: i.errorUtil.toString(j) }
      });
    }
    size(y, j) {
      return this.min(y, j).max(y, j);
    }
    nonempty(y) {
      return this.min(1, y);
    }
  }
  x.ZodSet = wt, wt.create = (D, y) => new wt({
    valueType: D,
    minSize: null,
    maxSize: null,
    typeName: de.ZodSet,
    ...c(y)
  });
  class _r extends h {
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(y) {
      const { ctx: j } = this._processInputParams(y);
      if (j.parsedType !== u.ZodParsedType.function)
        return (0, s.addIssueToContext)(j, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.function,
          received: j.parsedType
        }), s.INVALID;
      function E(W, re) {
        return (0, s.makeIssue)({
          data: W,
          path: j.path,
          errorMaps: [
            j.common.contextualErrorMap,
            j.schemaErrorMap,
            (0, r.getErrorMap)(),
            r.defaultErrorMap
          ].filter((ne) => !!ne),
          issueData: {
            code: d.ZodIssueCode.invalid_arguments,
            argumentsError: re
          }
        });
      }
      function q(W, re) {
        return (0, s.makeIssue)({
          data: W,
          path: j.path,
          errorMaps: [
            j.common.contextualErrorMap,
            j.schemaErrorMap,
            (0, r.getErrorMap)(),
            r.defaultErrorMap
          ].filter((ne) => !!ne),
          issueData: {
            code: d.ZodIssueCode.invalid_return_type,
            returnTypeError: re
          }
        });
      }
      const J = { errorMap: j.common.contextualErrorMap }, Q = j.data;
      if (this._def.returns instanceof S) {
        const W = this;
        return (0, s.OK)(async function(...re) {
          const ne = new d.ZodError([]), ce = await W._def.args.parseAsync(re, J).catch((qp) => {
            throw ne.addIssue(E(re, qp)), ne;
          }), xt = await Reflect.apply(Q, this, ce);
          return await W._def.returns._def.type.parseAsync(xt, J).catch((qp) => {
            throw ne.addIssue(q(xt, qp)), ne;
          });
        });
      } else {
        const W = this;
        return (0, s.OK)(function(...re) {
          const ne = W._def.args.safeParse(re, J);
          if (!ne.success)
            throw new d.ZodError([E(re, ne.error)]);
          const ce = Reflect.apply(Q, this, ne.data), xt = W._def.returns.safeParse(ce, J);
          if (!xt.success)
            throw new d.ZodError([q(ce, xt.error)]);
          return xt.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...y) {
      return new _r({
        ...this._def,
        args: $n.create(y).rest(Qt.create())
      });
    }
    returns(y) {
      return new _r({
        ...this._def,
        returns: y
      });
    }
    implement(y) {
      return this.parse(y);
    }
    strictImplement(y) {
      return this.parse(y);
    }
    static create(y, j, E) {
      return new _r({
        args: y || $n.create([]).rest(Qt.create()),
        returns: j || Qt.create(),
        typeName: de.ZodFunction,
        ...c(E)
      });
    }
  }
  x.ZodFunction = _r;
  class vo extends h {
    get schema() {
      return this._def.getter();
    }
    _parse(y) {
      const { ctx: j } = this._processInputParams(y);
      return this._def.getter()._parse({ data: j.data, path: j.path, parent: j });
    }
  }
  x.ZodLazy = vo, vo.create = (D, y) => new vo({
    getter: D,
    typeName: de.ZodLazy,
    ...c(y)
  });
  class Yt extends h {
    _parse(y) {
      if (y.data !== this._def.value) {
        const j = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(j, {
          received: j.data,
          code: d.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), s.INVALID;
      }
      return { status: "valid", value: y.data };
    }
    get value() {
      return this._def.value;
    }
  }
  x.ZodLiteral = Yt, Yt.create = (D, y) => new Yt({
    value: D,
    typeName: de.ZodLiteral,
    ...c(y)
  });
  function Hd(D, y) {
    return new $({
      values: D,
      typeName: de.ZodEnum,
      ...c(y)
    });
  }
  class $ extends h {
    constructor() {
      super(...arguments), n.set(this, void 0);
    }
    _parse(y) {
      if (typeof y.data != "string") {
        const j = this._getOrReturnCtx(y), E = this._def.values;
        return (0, s.addIssueToContext)(j, {
          expected: u.util.joinValues(E),
          received: j.parsedType,
          code: d.ZodIssueCode.invalid_type
        }), s.INVALID;
      }
      if (t(this, n, "f") || e(this, n, new Set(this._def.values), "f"), !t(this, n, "f").has(y.data)) {
        const j = this._getOrReturnCtx(y), E = this._def.values;
        return (0, s.addIssueToContext)(j, {
          received: j.data,
          code: d.ZodIssueCode.invalid_enum_value,
          options: E
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const y = {};
      for (const j of this._def.values)
        y[j] = j;
      return y;
    }
    get Values() {
      const y = {};
      for (const j of this._def.values)
        y[j] = j;
      return y;
    }
    get Enum() {
      const y = {};
      for (const j of this._def.values)
        y[j] = j;
      return y;
    }
    extract(y, j = this._def) {
      return $.create(y, {
        ...this._def,
        ...j
      });
    }
    exclude(y, j = this._def) {
      return $.create(this.options.filter((E) => !y.includes(E)), {
        ...this._def,
        ...j
      });
    }
  }
  x.ZodEnum = $, n = /* @__PURE__ */ new WeakMap(), $.create = Hd;
  class w extends h {
    constructor() {
      super(...arguments), a.set(this, void 0);
    }
    _parse(y) {
      const j = u.util.getValidEnumValues(this._def.values), E = this._getOrReturnCtx(y);
      if (E.parsedType !== u.ZodParsedType.string && E.parsedType !== u.ZodParsedType.number) {
        const q = u.util.objectValues(j);
        return (0, s.addIssueToContext)(E, {
          expected: u.util.joinValues(q),
          received: E.parsedType,
          code: d.ZodIssueCode.invalid_type
        }), s.INVALID;
      }
      if (t(this, a, "f") || e(this, a, new Set(u.util.getValidEnumValues(this._def.values)), "f"), !t(this, a, "f").has(y.data)) {
        const q = u.util.objectValues(j);
        return (0, s.addIssueToContext)(E, {
          received: E.data,
          code: d.ZodIssueCode.invalid_enum_value,
          options: q
        }), s.INVALID;
      }
      return (0, s.OK)(y.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  x.ZodNativeEnum = w, a = /* @__PURE__ */ new WeakMap(), w.create = (D, y) => new w({
    values: D,
    typeName: de.ZodNativeEnum,
    ...c(y)
  });
  class S extends h {
    unwrap() {
      return this._def.type;
    }
    _parse(y) {
      const { ctx: j } = this._processInputParams(y);
      if (j.parsedType !== u.ZodParsedType.promise && j.common.async === !1)
        return (0, s.addIssueToContext)(j, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.promise,
          received: j.parsedType
        }), s.INVALID;
      const E = j.parsedType === u.ZodParsedType.promise ? j.data : Promise.resolve(j.data);
      return (0, s.OK)(E.then((q) => this._def.type.parseAsync(q, {
        path: j.path,
        errorMap: j.common.contextualErrorMap
      })));
    }
  }
  x.ZodPromise = S, S.create = (D, y) => new S({
    type: D,
    typeName: de.ZodPromise,
    ...c(y)
  });
  class k extends h {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === de.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y), q = this._def.effect || null, J = {
        addIssue: (Q) => {
          (0, s.addIssueToContext)(E, Q), Q.fatal ? j.abort() : j.dirty();
        },
        get path() {
          return E.path;
        }
      };
      if (J.addIssue = J.addIssue.bind(J), q.type === "preprocess") {
        const Q = q.transform(E.data, J);
        if (E.common.async)
          return Promise.resolve(Q).then(async (W) => {
            if (j.value === "aborted")
              return s.INVALID;
            const re = await this._def.schema._parseAsync({
              data: W,
              path: E.path,
              parent: E
            });
            return re.status === "aborted" ? s.INVALID : re.status === "dirty" || j.value === "dirty" ? (0, s.DIRTY)(re.value) : re;
          });
        {
          if (j.value === "aborted")
            return s.INVALID;
          const W = this._def.schema._parseSync({
            data: Q,
            path: E.path,
            parent: E
          });
          return W.status === "aborted" ? s.INVALID : W.status === "dirty" || j.value === "dirty" ? (0, s.DIRTY)(W.value) : W;
        }
      }
      if (q.type === "refinement") {
        const Q = (W) => {
          const re = q.refinement(W, J);
          if (E.common.async)
            return Promise.resolve(re);
          if (re instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return W;
        };
        if (E.common.async === !1) {
          const W = this._def.schema._parseSync({
            data: E.data,
            path: E.path,
            parent: E
          });
          return W.status === "aborted" ? s.INVALID : (W.status === "dirty" && j.dirty(), Q(W.value), { status: j.value, value: W.value });
        } else
          return this._def.schema._parseAsync({ data: E.data, path: E.path, parent: E }).then((W) => W.status === "aborted" ? s.INVALID : (W.status === "dirty" && j.dirty(), Q(W.value).then(() => ({ status: j.value, value: W.value }))));
      }
      if (q.type === "transform")
        if (E.common.async === !1) {
          const Q = this._def.schema._parseSync({
            data: E.data,
            path: E.path,
            parent: E
          });
          if (!(0, s.isValid)(Q))
            return Q;
          const W = q.transform(Q.value, J);
          if (W instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: j.value, value: W };
        } else
          return this._def.schema._parseAsync({ data: E.data, path: E.path, parent: E }).then((Q) => (0, s.isValid)(Q) ? Promise.resolve(q.transform(Q.value, J)).then((W) => ({ status: j.value, value: W })) : Q);
      u.util.assertNever(q);
    }
  }
  x.ZodEffects = k, x.ZodTransformer = k, k.create = (D, y, j) => new k({
    schema: D,
    typeName: de.ZodEffects,
    effect: y,
    ...c(j)
  }), k.createWithPreprocess = (D, y, j) => new k({
    schema: y,
    effect: { type: "preprocess", transform: D },
    typeName: de.ZodEffects,
    ...c(j)
  });
  class U extends h {
    _parse(y) {
      return this._getType(y) === u.ZodParsedType.undefined ? (0, s.OK)(void 0) : this._def.innerType._parse(y);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  x.ZodOptional = U, U.create = (D, y) => new U({
    innerType: D,
    typeName: de.ZodOptional,
    ...c(y)
  });
  class z extends h {
    _parse(y) {
      return this._getType(y) === u.ZodParsedType.null ? (0, s.OK)(null) : this._def.innerType._parse(y);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  x.ZodNullable = z, z.create = (D, y) => new z({
    innerType: D,
    typeName: de.ZodNullable,
    ...c(y)
  });
  class G extends h {
    _parse(y) {
      const { ctx: j } = this._processInputParams(y);
      let E = j.data;
      return j.parsedType === u.ZodParsedType.undefined && (E = this._def.defaultValue()), this._def.innerType._parse({
        data: E,
        path: j.path,
        parent: j
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  x.ZodDefault = G, G.create = (D, y) => new G({
    innerType: D,
    typeName: de.ZodDefault,
    defaultValue: typeof y.default == "function" ? y.default : () => y.default,
    ...c(y)
  });
  class he extends h {
    _parse(y) {
      const { ctx: j } = this._processInputParams(y), E = {
        ...j,
        common: {
          ...j.common,
          issues: []
        }
      }, q = this._def.innerType._parse({
        data: E.data,
        path: E.path,
        parent: {
          ...E
        }
      });
      return (0, s.isAsync)(q) ? q.then((J) => ({
        status: "valid",
        value: J.status === "valid" ? J.value : this._def.catchValue({
          get error() {
            return new d.ZodError(E.common.issues);
          },
          input: E.data
        })
      })) : {
        status: "valid",
        value: q.status === "valid" ? q.value : this._def.catchValue({
          get error() {
            return new d.ZodError(E.common.issues);
          },
          input: E.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  x.ZodCatch = he, he.create = (D, y) => new he({
    innerType: D,
    typeName: de.ZodCatch,
    catchValue: typeof y.catch == "function" ? y.catch : () => y.catch,
    ...c(y)
  });
  class Ze extends h {
    _parse(y) {
      if (this._getType(y) !== u.ZodParsedType.nan) {
        const E = this._getOrReturnCtx(y);
        return (0, s.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_type,
          expected: u.ZodParsedType.nan,
          received: E.parsedType
        }), s.INVALID;
      }
      return { status: "valid", value: y.data };
    }
  }
  x.ZodNaN = Ze, Ze.create = (D) => new Ze({
    typeName: de.ZodNaN,
    ...c(D)
  }), x.BRAND = Symbol("zod_brand");
  class xe extends h {
    _parse(y) {
      const { ctx: j } = this._processInputParams(y), E = j.data;
      return this._def.type._parse({
        data: E,
        path: j.path,
        parent: j
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  x.ZodBranded = xe;
  class Ve extends h {
    _parse(y) {
      const { status: j, ctx: E } = this._processInputParams(y);
      if (E.common.async)
        return (async () => {
          const J = await this._def.in._parseAsync({
            data: E.data,
            path: E.path,
            parent: E
          });
          return J.status === "aborted" ? s.INVALID : J.status === "dirty" ? (j.dirty(), (0, s.DIRTY)(J.value)) : this._def.out._parseAsync({
            data: J.value,
            path: E.path,
            parent: E
          });
        })();
      {
        const q = this._def.in._parseSync({
          data: E.data,
          path: E.path,
          parent: E
        });
        return q.status === "aborted" ? s.INVALID : q.status === "dirty" ? (j.dirty(), {
          status: "dirty",
          value: q.value
        }) : this._def.out._parseSync({
          data: q.value,
          path: E.path,
          parent: E
        });
      }
    }
    static create(y, j) {
      return new Ve({
        in: y,
        out: j,
        typeName: de.ZodPipeline
      });
    }
  }
  x.ZodPipeline = Ve;
  class $e extends h {
    _parse(y) {
      const j = this._def.innerType._parse(y), E = (q) => ((0, s.isValid)(q) && (q.value = Object.freeze(q.value)), q);
      return (0, s.isAsync)(j) ? j.then((q) => E(q)) : E(j);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  x.ZodReadonly = $e, $e.create = (D, y) => new $e({
    innerType: D,
    typeName: de.ZodReadonly,
    ...c(y)
  });
  function Q_(D, y) {
    const j = typeof D == "function" ? D(y) : typeof D == "string" ? { message: D } : D;
    return typeof j == "string" ? { message: j } : j;
  }
  function Y_(D, y = {}, j) {
    return D ? pa.create().superRefine((E, q) => {
      var J, Q;
      const W = D(E);
      if (W instanceof Promise)
        return W.then((re) => {
          var ne, ce;
          if (!re) {
            const xt = Q_(y, E), Gd = (ce = (ne = xt.fatal) !== null && ne !== void 0 ? ne : j) !== null && ce !== void 0 ? ce : !0;
            q.addIssue({ code: "custom", ...xt, fatal: Gd });
          }
        });
      if (!W) {
        const re = Q_(y, E), ne = (Q = (J = re.fatal) !== null && J !== void 0 ? J : j) !== null && Q !== void 0 ? Q : !0;
        q.addIssue({ code: "custom", ...re, fatal: ne });
      }
    }) : pa.create();
  }
  x.custom = Y_, x.late = {
    object: qe.lazycreate
  };
  var de;
  (function(D) {
    D.ZodString = "ZodString", D.ZodNumber = "ZodNumber", D.ZodNaN = "ZodNaN", D.ZodBigInt = "ZodBigInt", D.ZodBoolean = "ZodBoolean", D.ZodDate = "ZodDate", D.ZodSymbol = "ZodSymbol", D.ZodUndefined = "ZodUndefined", D.ZodNull = "ZodNull", D.ZodAny = "ZodAny", D.ZodUnknown = "ZodUnknown", D.ZodNever = "ZodNever", D.ZodVoid = "ZodVoid", D.ZodArray = "ZodArray", D.ZodObject = "ZodObject", D.ZodUnion = "ZodUnion", D.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", D.ZodIntersection = "ZodIntersection", D.ZodTuple = "ZodTuple", D.ZodRecord = "ZodRecord", D.ZodMap = "ZodMap", D.ZodSet = "ZodSet", D.ZodFunction = "ZodFunction", D.ZodLazy = "ZodLazy", D.ZodLiteral = "ZodLiteral", D.ZodEnum = "ZodEnum", D.ZodEffects = "ZodEffects", D.ZodNativeEnum = "ZodNativeEnum", D.ZodOptional = "ZodOptional", D.ZodNullable = "ZodNullable", D.ZodDefault = "ZodDefault", D.ZodCatch = "ZodCatch", D.ZodPromise = "ZodPromise", D.ZodBranded = "ZodBranded", D.ZodPipeline = "ZodPipeline", D.ZodReadonly = "ZodReadonly";
  })(de || (x.ZodFirstPartyTypeKind = de = {}));
  const uM = (D, y = {
    message: `Input not instance of ${D.name}`
  }) => Y_((j) => j instanceof D, y);
  x.instanceof = uM;
  const ey = Nt.create;
  x.string = ey;
  const ty = Tt.create;
  x.number = ty;
  const cM = Ze.create;
  x.nan = cM;
  const lM = Je.create;
  x.bigint = lM;
  const ny = Le.create;
  x.boolean = ny;
  const dM = Xt.create;
  x.date = dM;
  const fM = Xe.create;
  x.symbol = fM;
  const hM = Ft.create;
  x.undefined = hM;
  const pM = zn.create;
  x.null = pM;
  const mM = pa.create;
  x.any = mM;
  const bM = Qt.create;
  x.unknown = bM;
  const gM = dn.create;
  x.never = gM;
  const _M = go.create;
  x.void = _M;
  const yM = fn.create;
  x.array = yM;
  const vM = qe.create;
  x.object = vM;
  const wM = qe.strictCreate;
  x.strictObject = wM;
  const SM = Zn.create;
  x.union = SM;
  const OM = iu.create;
  x.discriminatedUnion = OM;
  const jM = yo.create;
  x.intersection = jM;
  const PM = $n.create;
  x.tuple = PM;
  const CM = Vs.create;
  x.record = CM;
  const RM = ba.create;
  x.map = RM;
  const TM = wt.create;
  x.set = TM;
  const $M = _r.create;
  x.function = $M;
  const MM = vo.create;
  x.lazy = MM;
  const AM = Yt.create;
  x.literal = AM;
  const EM = $.create;
  x.enum = EM;
  const IM = w.create;
  x.nativeEnum = IM;
  const NM = S.create;
  x.promise = NM;
  const ry = k.create;
  x.effect = ry, x.transformer = ry;
  const FM = U.create;
  x.optional = FM;
  const kM = z.create;
  x.nullable = kM;
  const DM = k.createWithPreprocess;
  x.preprocess = DM;
  const qM = Ve.create;
  x.pipeline = qM;
  const JM = () => ey().optional();
  x.ostring = JM;
  const LM = () => ty().optional();
  x.onumber = LM;
  const UM = () => ny().optional();
  return x.oboolean = UM, x.coerce = {
    string: (D) => Nt.create({ ...D, coerce: !0 }),
    number: (D) => Tt.create({ ...D, coerce: !0 }),
    boolean: (D) => Le.create({
      ...D,
      coerce: !0
    }),
    bigint: (D) => Je.create({ ...D, coerce: !0 }),
    date: (D) => Xt.create({ ...D, coerce: !0 })
  }, x.NEVER = s.INVALID, x;
}
var lw;
function dw() {
  return lw || (lw = 1, function(t) {
    var e = Po && Po.__createBinding || (Object.create ? function(a, r, i, s) {
      s === void 0 && (s = i);
      var u = Object.getOwnPropertyDescriptor(r, i);
      (!u || ("get" in u ? !r.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
        return r[i];
      } }), Object.defineProperty(a, s, u);
    } : function(a, r, i, s) {
      s === void 0 && (s = i), a[s] = r[i];
    }), n = Po && Po.__exportStar || function(a, r) {
      for (var i in a) i !== "default" && !Object.prototype.hasOwnProperty.call(r, i) && e(r, a, i);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(/* @__PURE__ */ c_(), t), n(/* @__PURE__ */ zR(), t), n(/* @__PURE__ */ WD(), t), n(/* @__PURE__ */ yp(), t), n(/* @__PURE__ */ QD(), t), n(/* @__PURE__ */ u_(), t);
  }(Po)), Po;
}
var fw;
function H() {
  return fw || (fw = 1, function(t) {
    var e = er && er.__createBinding || (Object.create ? function(s, u, d, f) {
      f === void 0 && (f = d);
      var o = Object.getOwnPropertyDescriptor(u, d);
      (!o || ("get" in o ? !u.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
        return u[d];
      } }), Object.defineProperty(s, f, o);
    } : function(s, u, d, f) {
      f === void 0 && (f = d), s[f] = u[d];
    }), n = er && er.__setModuleDefault || (Object.create ? function(s, u) {
      Object.defineProperty(s, "default", { enumerable: !0, value: u });
    } : function(s, u) {
      s.default = u;
    }), a = er && er.__importStar || function(s) {
      if (s && s.__esModule) return s;
      var u = {};
      if (s != null) for (var d in s) d !== "default" && Object.prototype.hasOwnProperty.call(s, d) && e(u, s, d);
      return n(u, s), u;
    }, r = er && er.__exportStar || function(s, u) {
      for (var d in s) d !== "default" && !Object.prototype.hasOwnProperty.call(u, d) && e(u, s, d);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.z = void 0;
    const i = a(/* @__PURE__ */ dw());
    t.z = i, r(/* @__PURE__ */ dw(), t), t.default = i;
  }(er)), er;
}
var hw;
function ZR() {
  if (hw) return ft;
  hw = 1;
  var t = ft && ft.__createBinding || (Object.create ? function(o, c, h, p) {
    p === void 0 && (p = h);
    var l = Object.getOwnPropertyDescriptor(c, h);
    (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
      return c[h];
    } }), Object.defineProperty(o, p, l);
  } : function(o, c, h, p) {
    p === void 0 && (p = h), o[p] = c[h];
  }), e = ft && ft.__setModuleDefault || (Object.create ? function(o, c) {
    Object.defineProperty(o, "default", { enumerable: !0, value: c });
  } : function(o, c) {
    o.default = c;
  }), n = ft && ft.__importStar || function(o) {
    if (o && o.__esModule) return o;
    var c = {};
    if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && t(c, o, h);
    return e(c, o), c;
  };
  Object.defineProperty(ft, "__esModule", { value: !0 }), ft.zodInbound = ft.zodOutbound = void 0, ft.bytesToBase64 = r, ft.bytesFromBase64 = i, ft.stringToBytes = s, ft.stringFromBytes = u, ft.stringToBase64 = d, ft.stringFromBase64 = f;
  const a = n(/* @__PURE__ */ H());
  function r(o) {
    return btoa(String.fromCodePoint(...o));
  }
  function i(o) {
    return Uint8Array.from(atob(o), (c) => c.charCodeAt(0));
  }
  function s(o) {
    return new TextEncoder().encode(o);
  }
  function u(o) {
    return new TextDecoder().decode(o);
  }
  function d(o) {
    return r(s(o));
  }
  function f(o) {
    return u(i(o));
  }
  return ft.zodOutbound = a.instanceof(Uint8Array).or(a.string().transform(s)), ft.zodInbound = a.instanceof(Uint8Array).or(a.string().transform(i)), ft;
}
var Um = {}, kf = {}, pw;
function KR() {
  if (pw) return kf;
  pw = 1, Object.defineProperty(kf, "__esModule", { value: !0 }), kf.isPlainObject = t;
  function t(e) {
    if (typeof e != "object" || e === null)
      return !1;
    const n = Object.getPrototypeOf(e);
    return (n === null || n === Object.prototype || Object.getPrototypeOf(n) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
  }
  return kf;
}
var mw;
function Ne() {
  return mw || (mw = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.encodeDeepObjectQuery = t.encodePipeDelimitedQuery = t.encodeSpaceDelimitedQuery = t.encodeFormQuery = t.encodeJSONQuery = t.encodeSimple = t.encodePipeDelimited = t.encodeSpaceDelimited = t.encodeForm = t.EncodingError = void 0, t.encodeMatrix = r, t.encodeLabel = i, t.encodeBodyForm = u, t.encodeDeepObject = d, t.encodeDeepObjectObject = f, t.encodeJSON = o, t.queryJoin = g, t.queryEncoder = _, t.appendForm = P;
    const e = /* @__PURE__ */ ZR(), n = /* @__PURE__ */ KR();
    class a extends Error {
      constructor(C) {
        super(C), this.name = "EncodingError";
      }
    }
    t.EncodingError = a;
    function r(R, C, T) {
      let O = "";
      const A = T?.explode ? h(R, C) : [[R, C]];
      if (A.every(([N, v]) => v == null))
        return;
      const M = (N) => T?.charEncoding === "percent" ? encodeURIComponent(N) : N, I = (N) => M(p(N));
      return A.forEach(([N, v]) => {
        let F = "", L = null;
        if (v == null || (Array.isArray(v) ? L = m(v, (V) => `${I(V)}`)?.join(",") : (0, n.isPlainObject)(v) ? L = b(Object.entries(v), ([ue, ie]) => `,${M(ue)},${I(ie)}`)?.join("").slice(1) : L = `${I(v)}`, L == null))
          return;
        const B = M(N);
        F = `${B}=${L}`, F === `${B}=` && (F = F.slice(0, -1)), F && (O += `;${F}`);
      }), O;
    }
    function i(R, C, T) {
      let O = "";
      const A = T?.explode ? h(R, C) : [[R, C]];
      if (A.every(([N, v]) => v == null))
        return;
      const M = (N) => T?.charEncoding === "percent" ? encodeURIComponent(N) : N, I = (N) => M(p(N));
      return A.forEach(([N, v]) => {
        let F = "";
        v != null && (Array.isArray(v) ? F = m(v, (L) => `${I(L)}`)?.join(".") : (0, n.isPlainObject)(v) ? F = b(Object.entries(v), ([B, V]) => `.${M(B)}.${I(V)}`)?.join("").slice(1) : F = `${T?.explode && (0, n.isPlainObject)(C) ? `${M(N)}=` : ""}${I(v)}`, O += F == null ? "" : `.${F}`);
      }), O;
    }
    function s(R) {
      return (C, T, O) => {
        let A = "";
        const M = O?.explode ? h(C, T) : [[C, T]];
        if (M.every(([F, L]) => L == null))
          return;
        const I = (F) => O?.charEncoding === "percent" ? encodeURIComponent(F) : F, N = (F) => I(p(F)), v = I(R);
        return M.forEach(([F, L]) => {
          let B = "", V = null;
          L != null && (Array.isArray(L) ? V = m(L, (ue) => `${N(ue)}`)?.join(v) : (0, n.isPlainObject)(L) ? V = b(Object.entries(L), ([ue, ie]) => `${I(ue)}${v}${N(ie)}`)?.join(v) : V = `${N(L)}`, V != null && (B = `${I(F)}=${V}`, !(!B || B === "=") && (A += `&${B}`)));
        }), A.slice(1);
      };
    }
    t.encodeForm = s(","), t.encodeSpaceDelimited = s(" "), t.encodePipeDelimited = s("|");
    function u(R, C, T) {
      let O = "";
      const A = T?.explode ? h(R, C) : [[R, C]], M = (N) => T?.charEncoding === "percent" ? encodeURIComponent(N) : N, I = (N) => M(p(N));
      return A.forEach(([N, v]) => {
        let F = "", L = "";
        v != null && (Array.isArray(v) || (0, n.isPlainObject)(v) ? L = JSON.stringify(v, l) : L = `${I(v)}`, F = `${M(N)}=${L}`, !(!F || F === "=") && (O += `&${F}`));
      }), O.slice(1);
    }
    function d(R, C, T) {
      if (C != null) {
        if (!(0, n.isPlainObject)(C))
          throw new a(`Value of parameter '${R}' which uses deepObject encoding must be an object or null`);
        return f(R, C, T);
      }
    }
    function f(R, C, T) {
      if (C == null)
        return;
      let O = "";
      const A = (M) => T?.charEncoding === "percent" ? encodeURIComponent(M) : M;
      if (!(0, n.isPlainObject)(C))
        throw new a(`Expected parameter '${R}' to be an object.`);
      return Object.entries(C).forEach(([M, I]) => {
        if (I == null)
          return;
        const N = `${R}[${M}]`;
        if ((0, n.isPlainObject)(I)) {
          const L = f(N, I, T);
          O += L == null ? "" : `&${L}`;
          return;
        }
        const v = Array.isArray(I) ? I : [I], F = m(v, (L) => `${A(N)}=${A(p(L))}`)?.join("&");
        O += F == null ? "" : `&${F}`;
      }), O.slice(1);
    }
    function o(R, C, T) {
      if (typeof C > "u")
        return;
      const O = (M) => T?.charEncoding === "percent" ? encodeURIComponent(M) : M, A = O(JSON.stringify(C, l));
      return T?.explode ? A : `${O(R)}=${A}`;
    }
    const c = (R, C, T) => {
      let O = "";
      const A = T?.explode ? h(R, C) : [[R, C]];
      if (A.every(([N, v]) => v == null))
        return;
      const M = (N) => T?.charEncoding === "percent" ? encodeURIComponent(N) : N, I = (N) => M(p(N));
      return A.forEach(([N, v]) => {
        let F = "";
        v != null && (Array.isArray(v) ? F = m(v, (L) => `${I(L)}`)?.join(",") : (0, n.isPlainObject)(v) ? F = b(Object.entries(v), ([B, V]) => `,${M(B)},${I(V)}`)?.join("").slice(1) : F = `${T?.explode && (0, n.isPlainObject)(C) ? `${N}=` : ""}${I(v)}`, O += F ? `,${F}` : "");
      }), O.slice(1);
    };
    t.encodeSimple = c;
    function h(R, C) {
      return Array.isArray(C) ? C.map((T) => [R, T]) : (0, n.isPlainObject)(C) ? Object.entries(C ?? {}).map(([O, A]) => [O, A]) : [[R, C]];
    }
    function p(R) {
      return R == null ? "" : R instanceof Date ? R.toISOString() : R instanceof Uint8Array ? (0, e.bytesToBase64)(R) : typeof R == "object" ? JSON.stringify(R, l) : `${R}`;
    }
    function l(R, C) {
      return C instanceof Uint8Array ? (0, e.bytesToBase64)(C) : C;
    }
    function m(R, C) {
      const T = R.reduce((O, A) => {
        if (A == null)
          return O;
        const M = C(A);
        return M == null || O.push(M), O;
      }, []);
      return T.length ? T : null;
    }
    function b(R, C) {
      const T = [];
      for (const [O, A] of R) {
        if (A == null)
          continue;
        const M = C([O, A]);
        M != null && T.push(M);
      }
      return T.length ? T : null;
    }
    function g(...R) {
      return R.filter(Boolean).join("&");
    }
    function _(R) {
      return function(T, O) {
        const A = {
          ...O,
          explode: O?.explode ?? !0,
          charEncoding: O?.charEncoding ?? "percent"
        }, M = Object.entries(T).map(([I, N]) => R(I, N, A));
        return g(...M);
      };
    }
    t.encodeJSONQuery = _(o), t.encodeFormQuery = _(t.encodeForm), t.encodeSpaceDelimitedQuery = _(t.encodeSpaceDelimited), t.encodePipeDelimitedQuery = _(t.encodePipeDelimited), t.encodeDeepObjectQuery = _(d);
    function P(R, C, T, O) {
      T != null && (T instanceof Blob && O ? R.append(C, T, O) : T instanceof Blob ? R.append(C, T) : R.append(C, String(T)));
    }
  }(Um)), Um;
}
var Oa = {}, Df = {}, bw;
function YD() {
  if (bw) return Df;
  bw = 1, Object.defineProperty(Df, "__esModule", { value: !0 }), Df.dlv = t;
  function t(e, n, a, r, i) {
    for (n = Array.isArray(n) ? n : n.split("."), r = 0; r < n.length; r++) {
      const s = n[r];
      e = s != null && e ? e[s] : i;
    }
    return e === i ? a : e;
  }
  return Df;
}
var gw;
function HR() {
  return gw || (gw = 1, function(t) {
    var e = Oa && Oa.__createBinding || (Object.create ? function(f, o, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(o, c);
      (!p || ("get" in p ? !o.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return o[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, o, c, h) {
      h === void 0 && (h = c), f[h] = o[c];
    }), n = Oa && Oa.__setModuleDefault || (Object.create ? function(f, o) {
      Object.defineProperty(f, "default", { enumerable: !0, value: o });
    } : function(f, o) {
      f.default = o;
    }), a = Oa && Oa.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var o = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(o, f, c);
      return n(o, f), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.envSchema = void 0, t.env = u, t.resetEnv = d;
    const r = /* @__PURE__ */ YD(), i = a(/* @__PURE__ */ H());
    t.envSchema = i.object({
      MISTRAL_API_KEY: i.string().optional(),
      MISTRAL_DEBUG: i.coerce.boolean().optional()
    });
    let s;
    function u() {
      return s || (s = t.envSchema.parse((0, r.dlv)(globalThis, "process.env") ?? (0, r.dlv)(globalThis, "Deno.env") ?? {}), s);
    }
    function d() {
      s = void 0;
    }
  }(Oa)), Oa;
}
var nr = {}, _w;
function vp() {
  if (_w) return nr;
  _w = 1, Object.defineProperty(nr, "__esModule", { value: !0 }), nr.HTTPClient = void 0, nr.matchContentType = a, nr.matchStatusCode = i, nr.matchResponse = s, nr.isConnectionError = u, nr.isTimeoutError = d, nr.isAbortError = f;
  const t = (o, c) => c == null ? fetch(o) : fetch(o, c);
  class e {
    constructor(c = {}) {
      this.options = c, this.requestHooks = [], this.requestErrorHooks = [], this.responseHooks = [], this.fetcher = c.fetcher || t;
    }
    async request(c) {
      let h = c;
      for (const p of this.requestHooks) {
        const l = await p(h);
        l && (h = l);
      }
      try {
        const p = await this.fetcher(h);
        for (const l of this.responseHooks)
          await l(p, h);
        return p;
      } catch (p) {
        for (const l of this.requestErrorHooks)
          await l(p, h);
        throw p;
      }
    }
    addHook(...c) {
      if (c[0] === "beforeRequest")
        this.requestHooks.push(c[1]);
      else if (c[0] === "requestError")
        this.requestErrorHooks.push(c[1]);
      else if (c[0] === "response")
        this.responseHooks.push(c[1]);
      else
        throw new Error(`Invalid hook type: ${c[0]}`);
      return this;
    }
    removeHook(...c) {
      let h;
      if (c[0] === "beforeRequest")
        h = this.requestHooks;
      else if (c[0] === "requestError")
        h = this.requestErrorHooks;
      else if (c[0] === "response")
        h = this.responseHooks;
      else
        throw new Error(`Invalid hook type: ${c[0]}`);
      const p = h.findIndex((l) => l === c[1]);
      return p >= 0 && h.splice(p, 1), this;
    }
    clone() {
      const c = new e(this.options);
      return c.requestHooks = this.requestHooks.slice(), c.requestErrorHooks = this.requestErrorHooks.slice(), c.responseHooks = this.responseHooks.slice(), c;
    }
  }
  nr.HTTPClient = e;
  const n = /\s*;\s*/g;
  function a(o, c) {
    if (c === "*")
      return !0;
    let h = o.headers.get("content-type")?.trim() || "application/octet-stream";
    h = h.toLowerCase();
    const p = c.toLowerCase().trim().split(n), [l = "", ...m] = p;
    if (l.split("/").length !== 2)
      return !1;
    const b = h.split(n), [g = "", ..._] = b, [P = "", R = ""] = g.split("/");
    if (!P || !R || l !== "*/*" && g !== l && `${P}/*` !== l && `*/${R}` !== l || _.length < m.length)
      return !1;
    const C = new Set(_);
    for (const T of m)
      if (!C.has(T))
        return !1;
    return !0;
  }
  const r = new RegExp("^[0-9]xx$", "i");
  function i(o, c) {
    const h = `${o.status}`, p = Array.isArray(c) ? c : [c];
    return p.length ? p.some((l) => {
      const m = `${l}`;
      if (m === "default")
        return !0;
      if (!r.test(`${m}`))
        return m === h;
      const b = m.charAt(0);
      if (!b)
        throw new Error("Invalid status code range");
      const g = h.charAt(0);
      if (!g)
        throw new Error(`Invalid response status code: ${h}`);
      return g === b;
    }) : !1;
  }
  function s(o, c, h) {
    return i(o, c) && a(o, h);
  }
  function u(o) {
    if (typeof o != "object" || o == null)
      return !1;
    const c = o instanceof TypeError && o.message.toLowerCase().startsWith("failed to fetch"), h = o instanceof TypeError && o.message.toLowerCase().startsWith("fetch failed"), p = "name" in o && o.name === "ConnectionError", l = "code" in o && typeof o.code == "string" && o.code.toLowerCase() === "econnreset";
    return c || h || l || p;
  }
  function d(o) {
    if (typeof o != "object" || o == null)
      return !1;
    const c = "name" in o && o.name === "TimeoutError", h = "code" in o && o.code === 23, p = "code" in o && typeof o.code == "string" && o.code.toLowerCase() === "econnaborted";
    return c || h || p;
  }
  function f(o) {
    if (typeof o != "object" || o == null)
      return !1;
    const c = "name" in o && o.name === "AbortError", h = "code" in o && o.code === 20, p = "code" in o && typeof o.code == "string" && o.code.toLowerCase() === "econnaborted";
    return c || h || p;
  }
  return nr;
}
var Qs = {}, yw;
function eq() {
  if (yw) return Qs;
  yw = 1, Object.defineProperty(Qs, "__esModule", { value: !0 }), Qs.TemporaryError = Qs.PermanentError = void 0, Qs.retry = r;
  const t = /* @__PURE__ */ vp(), e = {
    initialInterval: 500,
    maxInterval: 6e4,
    exponent: 1.5,
    maxElapsedTime: 36e5
  };
  class n extends Error {
    constructor(h, p) {
      let l = h;
      p?.cause && (l += `: ${p.cause}`), super(l, p), this.name = "PermanentError", typeof this.cause > "u" && (this.cause = p?.cause), Object.setPrototypeOf(this, n.prototype);
    }
  }
  Qs.PermanentError = n;
  class a extends Error {
    constructor(h, p) {
      super(h), this.response = p, this.name = "TemporaryError", Object.setPrototypeOf(this, a.prototype);
    }
  }
  Qs.TemporaryError = a;
  async function r(c, h) {
    switch (h.config.strategy) {
      case "backoff":
        return d(i(c, {
          statusCodes: h.statusCodes,
          retryConnectionErrors: !!h.config.retryConnectionErrors
        }), h.config.backoff ?? e);
      default:
        return await c();
    }
  }
  function i(c, h) {
    return async () => {
      try {
        const p = await c();
        if (u(p, h.statusCodes))
          throw new a("Response failed with retryable status code", p);
        return p;
      } catch (p) {
        throw p instanceof a || h.retryConnectionErrors && ((0, t.isTimeoutError)(p) || (0, t.isConnectionError)(p)) ? p : new n("Permanent error", { cause: p });
      }
    };
  }
  const s = new RegExp("^[0-9]xx$", "i");
  function u(c, h) {
    const p = `${c.status}`;
    return h.some((l) => {
      if (!s.test(l))
        return l === p;
      const m = l.charAt(0);
      if (!m)
        throw new Error("Invalid status code range");
      const b = p.charAt(0);
      if (!b)
        throw new Error(`Invalid response status code: ${p}`);
      return b === m;
    });
  }
  async function d(c, h) {
    const { maxElapsedTime: p, initialInterval: l, exponent: m, maxInterval: b } = h, g = Date.now();
    let _ = 0;
    for (; ; )
      try {
        return await c();
      } catch (P) {
        if (P instanceof n)
          throw P.cause;
        if (Date.now() - g > p) {
          if (P instanceof a)
            return P.response;
          throw P;
        }
        let C = 0;
        P instanceof a && (C = f(P.response)), C <= 0 && (C = l * Math.pow(_, m) + Math.random() * 1e3);
        const T = Math.min(C, b);
        await o(T), _++;
      }
  }
  function f(c) {
    const h = c.headers.get("retry-after") || "";
    if (!h)
      return 0;
    const p = Number(h);
    if (Number.isInteger(p))
      return p * 1e3;
    const l = Date.parse(h);
    if (Number.isInteger(l)) {
      const m = l - Date.now();
      return m > 0 ? Math.ceil(m) : 0;
    }
    return 0;
  }
  async function o(c) {
    return new Promise((h) => setTimeout(h, c));
  }
  return Qs;
}
var vw;
function Rn() {
  if (vw) return wa;
  vw = 1;
  var t = wa && wa.__classPrivateFieldSet || function(C, T, O, A, M) {
    if (A === "m") throw new TypeError("Private method is not writable");
    if (A === "a" && !M) throw new TypeError("Private accessor was defined without a setter");
    if (typeof T == "function" ? C !== T || !M : !T.has(C)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return A === "a" ? M.call(C, O) : M ? M.value = O : T.set(C, O), O;
  }, e = wa && wa.__classPrivateFieldGet || function(C, T, O, A) {
    if (O === "a" && !A) throw new TypeError("Private accessor was defined without a getter");
    if (typeof T == "function" ? C !== T || !A : !T.has(C)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return O === "m" ? A : O === "a" ? A.call(C) : A ? A.value : T.get(C);
  }, n, a, r;
  Object.defineProperty(wa, "__esModule", { value: !0 }), wa.ClientSDK = void 0;
  const i = /* @__PURE__ */ GD(), s = /* @__PURE__ */ BR(), u = /* @__PURE__ */ Vn(), d = /* @__PURE__ */ ZR(), f = /* @__PURE__ */ o_(), o = /* @__PURE__ */ Ne(), c = /* @__PURE__ */ HR(), h = /* @__PURE__ */ vp(), p = /* @__PURE__ */ eq(), l = typeof globalThis > "u" ? null : globalThis, b = typeof l == "object" && l != null && "importScripts" in l && typeof l.importScripts == "function" || typeof navigator < "u" && "serviceWorker" in navigator || typeof window == "object" && typeof window.document < "u";
  class g {
    constructor(T = {}) {
      n.set(this, void 0), a.set(this, void 0), r.set(this, void 0);
      const O = T;
      typeof O == "object" && O != null && "hooks" in O && O.hooks instanceof i.SDKHooks ? t(this, a, O.hooks, "f") : t(this, a, new i.SDKHooks(), "f"), this._options = { ...T, hooks: e(this, a, "f") };
      const A = (0, f.serverURLFromOptions)(T);
      A && (A.pathname = A.pathname.replace(/\/+$/, "") + "/");
      const { baseURL: M, client: I } = e(this, a, "f").sdkInit({
        baseURL: A,
        client: T.httpClient || new h.HTTPClient()
      });
      this._baseURL = M, t(this, n, I, "f"), t(this, r, T.debugLogger, "f"), !e(this, r, "f") && (0, c.env)().MISTRAL_DEBUG && t(this, r, console, "f");
    }
    _createRequest(T, O, A) {
      const { method: M, path: I, query: N, headers: v, security: F } = O, L = O.baseURL ?? this._baseURL;
      if (!L)
        return (0, u.ERR)(new s.InvalidRequestError("No base URL provided for operation"));
      const B = new URL(L), V = new URL(I, B);
      I && (B.pathname += B.pathname.endsWith("/") ? "" : "/", B.pathname += V.pathname.replace(/^\/+/, ""));
      let ue = N || "";
      const ie = [];
      for (const [Xe, Ft] of Object.entries(F?.queryParams || {})) {
        const zn = (0, o.encodeForm)(Xe, Ft, { charEncoding: "percent" });
        typeof zn < "u" && ie.push(zn);
      }
      if (ie.length && (ue += `&${ie.join("&")}`), ue) {
        const Xe = ue.startsWith("&") ? ue.slice(1) : ue;
        B.search = `?${Xe}`;
      }
      const ut = new Headers(v), ha = F?.basic.username, Nt = F?.basic.password;
      if (ha != null || Nt != null) {
        const Xe = (0, d.stringToBase64)([ha || "", Nt || ""].join(":"));
        ut.set("Authorization", `Basic ${Xe}`);
      }
      const cc = new Headers(F?.headers || {});
      for (const [Xe, Ft] of cc)
        ut.set(Xe, Ft);
      let Tt = ut.get("cookie") || "";
      for (const [Xe, Ft] of Object.entries(F?.cookies || {}))
        Tt += `; ${Xe}=${Ft}`;
      Tt = Tt.startsWith("; ") ? Tt.slice(2) : Tt, ut.set("cookie", Tt);
      const Je = new Headers(A?.fetchOptions?.headers);
      for (const [Xe, Ft] of Je)
        ut.set(Xe, Ft);
      b || ut.set(O.uaHeader ?? "user-agent", f.SDK_METADATA.userAgent);
      let Le = A?.fetchOptions;
      if (!Le?.signal && O.timeoutMs && O.timeoutMs > 0) {
        const Xe = AbortSignal.timeout(O.timeoutMs);
        Le ? Le.signal = Xe : Le = { signal: Xe };
      }
      O.body instanceof ReadableStream && (Le || (Le = {}), Object.assign(Le, { duplex: "half" }));
      let Xt;
      try {
        Xt = e(this, a, "f").beforeCreateRequest(T, {
          url: B,
          options: {
            ...Le,
            body: O.body ?? null,
            headers: ut,
            method: M
          }
        });
      } catch (Xe) {
        return (0, u.ERR)(new s.UnexpectedClientError("Create request hook failed to execute", {
          cause: Xe
        }));
      }
      return (0, u.OK)(new Request(Xt.url, Xt.options));
    }
    async _do(T, O) {
      const { context: A, errorCodes: M } = O;
      return (0, p.retry)(async () => {
        const I = await e(this, a, "f").beforeRequest(A, T.clone());
        await P(e(this, r, "f"), I).catch((v) => e(this, r, "f")?.log("Failed to log request:", v));
        let N = await e(this, n, "f").request(I);
        try {
          if ((0, h.matchStatusCode)(N, M)) {
            const v = await e(this, a, "f").afterError(A, N, null);
            if (v.error)
              throw v.error;
            N = v.response || N;
          } else
            N = await e(this, a, "f").afterSuccess(A, N);
        } finally {
          await R(e(this, r, "f"), N, I).catch((v) => e(this, r, "f")?.log("Failed to log response:", v));
        }
        return N;
      }, { config: O.retryConfig, statusCodes: O.retryCodes }).then((I) => (0, u.OK)(I), (I) => {
        switch (!0) {
          case (0, h.isAbortError)(I):
            return (0, u.ERR)(new s.RequestAbortedError("Request aborted by client", {
              cause: I
            }));
          case (0, h.isTimeoutError)(I):
            return (0, u.ERR)(new s.RequestTimeoutError("Request timed out", { cause: I }));
          case (0, h.isConnectionError)(I):
            return (0, u.ERR)(new s.ConnectionError("Unable to make request", { cause: I }));
          default:
            return (0, u.ERR)(new s.UnexpectedClientError("Unexpected HTTP client error", {
              cause: I
            }));
        }
      });
    }
  }
  wa.ClientSDK = g, n = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  const _ = /^application\/(?:.{0,100}\+)?json/;
  async function P(C, T) {
    if (!C)
      return;
    const O = T.headers.get("content-type"), A = O?.split(";")[0] || "";
    C.group(`> Request: ${T.method} ${T.url}`), C.group("Headers:");
    for (const [M, I] of T.headers.entries())
      C.log(`${M}: ${I}`);
    switch (C.groupEnd(), C.group("Body:"), !0) {
      case _.test(A):
        C.log(await T.clone().json());
        break;
      case A.startsWith("text/"):
        C.log(await T.clone().text());
        break;
      case A === "multipart/form-data": {
        const M = await T.clone().formData();
        for (const [I, N] of M) {
          const v = N instanceof Blob ? "<Blob>" : N;
          C.log(`${I}: ${v}`);
        }
        break;
      }
      default:
        C.log(`<${O}>`);
        break;
    }
    C.groupEnd(), C.groupEnd();
  }
  async function R(C, T, O) {
    if (!C)
      return;
    const A = T.headers.get("content-type"), M = A?.split(";")[0] || "";
    C.group(`< Response: ${O.method} ${O.url}`), C.log("Status Code:", T.status, T.statusText), C.group("Headers:");
    for (const [I, N] of T.headers.entries())
      C.log(`${I}: ${N}`);
    switch (C.groupEnd(), C.group("Body:"), !0) {
      case ((0, h.matchContentType)(T, "application/json") || _.test(M)):
        C.log(await T.clone().json());
        break;
      case (0, h.matchContentType)(T, "text/event-stream"):
        C.log(`<${A}>`);
        break;
      case (0, h.matchContentType)(T, "text/*"):
        C.log(await T.clone().text());
        break;
      case (0, h.matchContentType)(T, "multipart/form-data"): {
        const I = await T.clone().formData();
        for (const [N, v] of I) {
          const F = v instanceof Blob ? "<Blob>" : v;
          C.log(`${N}: ${F}`);
        }
        break;
      }
      default:
        C.log(`<${A}>`);
        break;
    }
    C.groupEnd(), C.groupEnd();
  }
  return wa;
}
var Mc = {}, vr = {}, ht = {}, Ac = {}, ww;
function GR() {
  if (ww) return Ac;
  ww = 1, Object.defineProperty(Ac, "__esModule", { value: !0 }), Ac.SDKError = void 0;
  class t extends Error {
    constructor(n, a, r = "") {
      const i = a.status, s = a.headers.get("content-type") || "", u = r.length > 0 ? `
${r}` : "";
      super(`${n}: Status ${i} Content-Type ${s} Body ${u}`), this.rawResponse = a, this.body = r, this.statusCode = i, this.contentType = s, this.name = "SDKError";
    }
  }
  return Ac.SDKError = t, Ac;
}
var pu = {}, Sw;
function wp() {
  if (Sw) return pu;
  Sw = 1, Object.defineProperty(pu, "__esModule", { value: !0 }), pu.EventStream = void 0, pu.discardSentinel = d;
  const t = 10, e = 13, n = /* @__PURE__ */ new Set([t, e]), a = [
    new Uint8Array([e, t, e, t]),
    new Uint8Array([e, e]),
    new Uint8Array([t, t])
  ];
  class r {
    constructor(c) {
      this.stream = c.stream, this.decoder = c.decoder;
    }
    async *[Symbol.asyncIterator]() {
      const c = this.stream.getReader();
      let h = new Uint8Array([]), p = 0;
      try {
        for (; ; ) {
          const { done: l, value: m } = await c.read();
          if (l)
            break;
          const b = new Uint8Array(h.length + m.length);
          b.set(h), b.set(m, h.length), h = b;
          for (let g = p; g < h.length; g++) {
            const _ = i(h, g);
            if (_ == null)
              continue;
            const P = h.slice(p, g);
            p = g + _.length;
            const R = u(P, this.decoder);
            R != null && (yield R);
          }
          p > 0 && (h = h.slice(p), p = 0);
        }
        if (h.length > 0) {
          const l = u(h, this.decoder);
          l != null && (yield l);
        }
      } catch (l) {
        if (l instanceof Error && l.name === "AbortError")
          return;
        throw l;
      } finally {
        c.releaseLock();
      }
    }
  }
  pu.EventStream = r;
  function i(o, c) {
    const h = o[c], p = o[c + 1];
    if (h == null || p == null || !n.has(h) || !n.has(p))
      return null;
    for (const l of a) {
      const m = s(c, o, l);
      if (m != null)
        return m;
    }
    return null;
  }
  function s(o, c, h) {
    if (h.length > c.length - o)
      return null;
    for (let p = 0; p < h.length; p++)
      if (c[o + p] !== h[p])
        return null;
    return h;
  }
  function u(o, c) {
    if (!o.length)
      return null;
    const l = new TextDecoder().decode(o).split(/\r?\n|\r/g);
    let m = !1;
    const b = {};
    for (const g of l) {
      if (!g)
        continue;
      const _ = g.indexOf(":");
      if (_ === 0)
        continue;
      const P = _ > 0 ? g.substring(0, _) : "";
      let R = _ > 0 ? g.substring(_ + 1) : "";
      switch (R.charAt(0) === " " && (R = R.substring(1)), P) {
        case "event": {
          m = !0, b.event = R;
          break;
        }
        case "data": {
          m = !0, b.data ?? (b.data = ""), b.data += R + `
`;
          break;
        }
        case "id": {
          m = !0, b.id = R;
          break;
        }
        case "retry": {
          const C = parseInt(R, 10);
          Number.isNaN(C) || (m = !0, b.retry = C);
          break;
        }
      }
    }
    return m ? (b.data != null && (b.data = b.data.slice(0, -1)), c(b)) : null;
  }
  function d(o, c) {
    return new ReadableStream({
      async start(h) {
        let p = new Uint8Array([]), l = 0, m = !1, b = !1;
        const g = o.getReader();
        try {
          for (; !m; ) {
            const _ = await g.read(), P = _.value;
            if (m = m || _.done, b || typeof P > "u")
              continue;
            const R = new Uint8Array(p.length + P.length);
            R.set(p), R.set(P, p.length), p = R;
            for (let C = l; C < p.length; C++) {
              const T = i(p, C);
              if (T == null)
                continue;
              const O = l, A = p.slice(O, C);
              l = C + T.length, u(A, f)?.data === c ? (h.enqueue(p.slice(0, O)), b = !0) : (h.enqueue(p.slice(0, l)), p = p.slice(l), l = 0);
            }
          }
        } catch (_) {
          h.error(_);
        } finally {
          h.close(), g.releaseLock();
        }
      }
    });
  }
  function f(o) {
    return o;
  }
  return pu;
}
var mu = {}, En = {}, Ow;
function WR() {
  if (Ow) return En;
  Ow = 1;
  var t = En && En.__createBinding || (Object.create ? function(s, u, d, f) {
    f === void 0 && (f = d);
    var o = Object.getOwnPropertyDescriptor(u, d);
    (!o || ("get" in o ? !u.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
      return u[d];
    } }), Object.defineProperty(s, f, o);
  } : function(s, u, d, f) {
    f === void 0 && (f = d), s[f] = u[d];
  }), e = En && En.__setModuleDefault || (Object.create ? function(s, u) {
    Object.defineProperty(s, "default", { enumerable: !0, value: u });
  } : function(s, u) {
    s.default = u;
  }), n = En && En.__importStar || function(s) {
    if (s && s.__esModule) return s;
    var u = {};
    if (s != null) for (var d in s) d !== "default" && Object.prototype.hasOwnProperty.call(s, d) && t(u, s, d);
    return e(u, s), u;
  };
  Object.defineProperty(En, "__esModule", { value: !0 }), En.SDKValidationError = void 0, En.formatZodError = i;
  const a = n(/* @__PURE__ */ H());
  class r extends Error {
    constructor(u, d, f) {
      super(`${u}: ${d}`), this.name = "SDKValidationError", this.cause = d, this.rawValue = f, this.rawMessage = u;
    }
    /**
     * Return a pretty-formatted error message if the underlying validation error
     * is a ZodError or some other recognized error type, otherwise return the
     * default error message.
     */
    pretty() {
      return this.cause instanceof a.ZodError ? `${this.rawMessage}
${i(this.cause)}` : this.toString();
    }
  }
  En.SDKValidationError = r;
  function i(s, u = 0) {
    let d = "  ".repeat(u);
    d = u > 0 ? `${d}` : d, d += " ".repeat(u);
    let f = "";
    const o = (p) => f += `
${d}${p}`, c = s.issues.length, h = c === 1 ? `${c} issue found` : `${c} issues found`;
    c && o(` ${h}:`);
    for (const p of s.issues) {
      let l = p.path.join(".");
      switch (l = l ? `<root>.${l}` : "<root>", o(`  [${l}]: ${p.message} (${p.code})`), p.code) {
        case "invalid_literal":
        case "invalid_type": {
          o(`     Want: ${p.expected}`), o(`      Got: ${p.received}`);
          break;
        }
        case "unrecognized_keys": {
          o(`     Keys: ${p.keys.join(", ")}`);
          break;
        }
        case "invalid_enum_value": {
          o(`     Allowed: ${p.options.join(", ")}`), o(`         Got: ${p.received}`);
          break;
        }
        case "invalid_union_discriminator": {
          o(`     Allowed: ${p.options.join(", ")}`);
          break;
        }
        case "invalid_union": {
          const m = p.unionErrors.length;
          o(`    Attemped to deserialize into one of ${m} union members:`), p.unionErrors.forEach((b, g) => {
            o(`    Member ${g + 1} of ${m}`), o(`${i(b, u + 1)}`);
          });
        }
      }
    }
    return s.issues.length && o("*"), f.slice(1);
  }
  return En;
}
var jw;
function Z() {
  if (jw) return mu;
  jw = 1, Object.defineProperty(mu, "__esModule", { value: !0 }), mu.parse = a, mu.safeParse = r, mu.collectExtraKeys = i;
  const t = /* @__PURE__ */ H(), e = /* @__PURE__ */ WR(), n = /* @__PURE__ */ Vn();
  function a(s, u, d) {
    try {
      return u(s);
    } catch (f) {
      throw f instanceof t.ZodError ? new e.SDKValidationError(d, f, s) : f;
    }
  }
  function r(s, u, d) {
    try {
      return (0, n.OK)(u(s));
    } catch (f) {
      return (0, n.ERR)(new e.SDKValidationError(d, f, s));
    }
  }
  function i(s, u, d) {
    return s.transform((f) => {
      const o = {}, { shape: c } = s;
      for (const [h] of Object.entries(f)) {
        if (h in c)
          continue;
        const p = f[h];
        typeof p > "u" || (o[h] = p, delete f[h]);
      }
      return d && Object.keys(o).length === 0 ? f : { ...f, [u]: o };
    });
  }
  return mu;
}
var Pw;
function Fe() {
  if (Pw) return ht;
  Pw = 1, Object.defineProperty(ht, "__esModule", { value: !0 }), ht.jsonErr = s, ht.json = u, ht.textErr = d, ht.text = f, ht.bytesErr = o, ht.bytes = c, ht.streamErr = h, ht.stream = p, ht.sseErr = l, ht.sse = m, ht.nilErr = b, ht.nil = g, ht.fail = _, ht.match = P, ht.unpackHeaders = C, ht.discardResponseBody = T;
  const t = /* @__PURE__ */ GR(), e = /* @__PURE__ */ wp(), n = /* @__PURE__ */ vp(), a = /* @__PURE__ */ KR(), r = /* @__PURE__ */ Z(), i = {
    json: "application/json",
    text: "text/plain",
    bytes: "application/octet-stream",
    stream: "application/octet-stream",
    sse: "text/event-stream",
    nil: "*",
    fail: "*"
  };
  function s(O, A, M) {
    return { ...M, err: !0, enc: "json", codes: O, schema: A };
  }
  function u(O, A, M) {
    return { ...M, enc: "json", codes: O, schema: A };
  }
  function d(O, A, M) {
    return { ...M, err: !0, enc: "text", codes: O, schema: A };
  }
  function f(O, A, M) {
    return { ...M, enc: "text", codes: O, schema: A };
  }
  function o(O, A, M) {
    return { ...M, err: !0, enc: "bytes", codes: O, schema: A };
  }
  function c(O, A, M) {
    return { ...M, enc: "bytes", codes: O, schema: A };
  }
  function h(O, A, M) {
    return { ...M, err: !0, enc: "stream", codes: O, schema: A };
  }
  function p(O, A, M) {
    return { ...M, enc: "stream", codes: O, schema: A };
  }
  function l(O, A, M) {
    return { ...M, err: !0, enc: "sse", codes: O, schema: A };
  }
  function m(O, A, M) {
    return { ...M, enc: "sse", codes: O, schema: A };
  }
  function b(O, A, M) {
    return { ...M, err: !0, enc: "nil", codes: O, schema: A };
  }
  function g(O, A, M) {
    return { ...M, enc: "nil", codes: O, schema: A };
  }
  function _(O) {
    return { enc: "fail", codes: O };
  }
  function P(...O) {
    return async function(M, I) {
      let N, v;
      for (const V of O) {
        const { codes: ue } = V, ie = "ctype" in V ? V.ctype : i[V.enc];
        if (ie && (0, n.matchResponse)(M, ue, ie)) {
          v = V;
          break;
        } else if (!ie && (0, n.matchStatusCode)(M, ue)) {
          v = V;
          break;
        }
      }
      if (!v) {
        const V = await M.text();
        return [{
          ok: !1,
          error: new t.SDKError("Unexpected API response status or content-type", M, V)
        }, V];
      }
      const F = v.enc;
      switch (F) {
        case "json":
          N = await M.json();
          break;
        case "bytes":
          N = new Uint8Array(await M.arrayBuffer());
          break;
        case "stream":
          N = M.body;
          break;
        case "text":
          N = await M.text();
          break;
        case "sse":
          N = M.body && v.sseSentinel ? (0, e.discardSentinel)(M.body, v.sseSentinel) : M.body;
          break;
        case "nil":
          N = await T(M);
          break;
        case "fail":
          N = await M.text();
          break;
        default:
          throw new Error(`Unsupported response type: ${F}`);
      }
      if (v.enc === "fail")
        return [{
          ok: !1,
          error: new t.SDKError("API error occurred", M, typeof N == "string" ? N : "")
        }, N];
      const L = v.key || I?.resultKey;
      let B;
      if ("err" in v ? B = {
        ...I?.extraFields,
        ...v.hdrs ? { Headers: C(M.headers) } : null,
        ...(0, a.isPlainObject)(N) ? N : null
      } : L ? B = {
        ...I?.extraFields,
        ...v.hdrs ? { Headers: C(M.headers) } : null,
        [L]: N
      } : v.hdrs ? B = {
        ...I?.extraFields,
        ...v.hdrs ? { Headers: C(M.headers) } : null,
        ...(0, a.isPlainObject)(N) ? N : null
      } : B = N, "err" in v) {
        const V = (0, r.safeParse)(B, (ue) => v.schema.parse(ue), "Response validation failed");
        return [V.ok ? { ok: !1, error: V.value } : V, N];
      } else
        return [
          (0, r.safeParse)(B, (V) => v.schema.parse(V), "Response validation failed"),
          N
        ];
    };
  }
  const R = /, */;
  function C(O) {
    const A = {};
    for (const [M, I] of O.entries())
      A[M] = I.split(R);
    return A;
  }
  async function T(O) {
    const A = O.body?.getReader();
    if (A != null)
      try {
        let M = !1;
        for (; !M; )
          M = (await A.read()).done;
      } finally {
        A.releaseLock();
      }
  }
  return ht;
}
var ja = {}, Cw;
function X() {
  if (Cw) return ja;
  Cw = 1, Object.defineProperty(ja, "__esModule", { value: !0 }), ja.invariant = e, ja.remap = n, ja.combineSignals = a, ja.abortSignalAny = r, ja.compactMap = i, ja.allRequired = s;
  class t extends Error {
    constructor(d) {
      super(d), this.name = "InvariantError";
    }
  }
  function e(u, d) {
    if (!u)
      throw new t(d);
  }
  function n(u, d) {
    let f = {};
    if (!Object.keys(d).length)
      return f = u, f;
    for (const [o, c] of Object.entries(u)) {
      const h = d[o];
      h !== null && (f[h ?? o] = c);
    }
    return f;
  }
  function a(...u) {
    const d = [];
    for (const f of u)
      f && d.push(f);
    switch (d.length) {
      case 0:
      case 1:
        return d[0] || null;
      default:
        return "any" in AbortSignal && typeof AbortSignal.any == "function" ? AbortSignal.any(d) : r(d);
    }
  }
  function r(u) {
    const d = new AbortController(), f = d.signal;
    if (!u.length)
      return d.signal;
    if (u.length === 1)
      return u[0] || d.signal;
    for (const p of u)
      if (p.aborted)
        return p;
    function o() {
      d.abort(this.reason), h();
    }
    const c = [];
    function h() {
      for (const p of c) {
        const l = p.deref();
        l && l.removeEventListener("abort", o);
      }
    }
    for (const p of u)
      c.push(new WeakRef(p)), p.addEventListener("abort", o);
    return f;
  }
  function i(u) {
    const d = {};
    for (const [f, o] of Object.entries(u))
      typeof o < "u" && (d[f] = o);
    return d;
  }
  function s(u) {
    if (!Object.values(u).every((d) => d == null))
      return u;
  }
  return ja;
}
var wr = {}, Rw;
function ke() {
  if (Rw) return wr;
  Rw = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.SecurityError = wr.SecurityErrorCode = void 0, wr.resolveSecurity = a, wr.resolveGlobalSecurity = s, wr.extractSecurity = u;
  const t = /* @__PURE__ */ HR();
  var e;
  (function(d) {
    d.Incomplete = "incomplete", d.UnrecognisedSecurityType = "unrecognized_security_type";
  })(e || (wr.SecurityErrorCode = e = {}));
  class n extends Error {
    constructor(f, o) {
      super(o), this.code = f, this.name = "SecurityError";
    }
    static incomplete() {
      return new n(e.Incomplete, "Security requirements not met in order to perform the operation");
    }
    static unrecognizedType(f) {
      return new n(e.UnrecognisedSecurityType, `Unrecognised security type: ${f}`);
    }
  }
  wr.SecurityError = n;
  function a(...d) {
    const f = {
      basic: {},
      headers: {},
      queryParams: {},
      cookies: {},
      oauth2: { type: "none" }
    }, o = d.find((c) => c.every((h) => {
      if (h.value == null)
        return !1;
      if (h.type === "http:basic")
        return h.value.username != null || h.value.password != null;
      if (h.type === "http:custom")
        return null;
      if (h.type === "oauth2:password")
        return typeof h.value == "string" && !!h.value;
      if (h.type === "oauth2:client_credentials")
        return h.value.clientID != null || h.value.clientSecret != null;
      if (typeof h.value == "string")
        return !!h.value;
      throw new Error(`Unrecognized security type: ${h.type} (value type: ${typeof h.value})`);
    }));
    return o == null ? null : (o.forEach((c) => {
      if (c.value == null)
        return;
      const { type: h } = c;
      switch (h) {
        case "apiKey:header":
          f.headers[c.fieldName] = c.value;
          break;
        case "apiKey:query":
          f.queryParams[c.fieldName] = c.value;
          break;
        case "apiKey:cookie":
          f.cookies[c.fieldName] = c.value;
          break;
        case "http:basic":
          r(f, c);
          break;
        case "http:custom":
          break;
        case "http:bearer":
          i(f, c);
          break;
        case "oauth2":
          i(f, c);
          break;
        case "oauth2:password":
          i(f, c);
          break;
        case "oauth2:client_credentials":
          break;
        case "openIdConnect":
          i(f, c);
          break;
        default:
          throw n.unrecognizedType(h);
      }
    }), f);
  }
  function r(d, f) {
    f.value != null && (d.basic = f.value);
  }
  function i(d, f) {
    if (typeof f.value != "string" || !f.value)
      return;
    let o = f.value;
    o.slice(0, 7).toLowerCase() !== "bearer " && (o = `Bearer ${o}`), d.headers[f.fieldName] = o;
  }
  function s(d) {
    return a([
      {
        fieldName: "Authorization",
        type: "http:bearer",
        value: d?.apiKey ?? (0, t.env)().MISTRAL_API_KEY
      }
    ]);
  }
  async function u(d) {
    if (d != null)
      return typeof d == "function" ? d() : d;
  }
  return wr;
}
var Co = {}, Pa = {}, Ca = {}, Ra = {}, Ta = {}, Tw;
function l_() {
  return Tw || (Tw = 1, function(t) {
    var e = Ta && Ta.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = Ta && Ta.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Ta && Ta.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.DocumentURLChunk$ = t.DocumentURLChunk$outboundSchema = t.DocumentURLChunk$inboundSchema = t.DocumentURLChunkType$ = t.DocumentURLChunkType$outboundSchema = t.DocumentURLChunkType$inboundSchema = t.DocumentURLChunkType = void 0, t.documentURLChunkToJSON = f, t.documentURLChunkFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.DocumentURLChunkType = {
      DocumentUrl: "document_url"
    }, t.DocumentURLChunkType$inboundSchema = r.nativeEnum(t.DocumentURLChunkType), t.DocumentURLChunkType$outboundSchema = t.DocumentURLChunkType$inboundSchema;
    var u;
    (function(c) {
      c.inboundSchema = t.DocumentURLChunkType$inboundSchema, c.outboundSchema = t.DocumentURLChunkType$outboundSchema;
    })(u || (t.DocumentURLChunkType$ = u = {})), t.DocumentURLChunk$inboundSchema = r.object({
      document_url: r.string(),
      document_name: r.nullable(r.string()).optional(),
      type: t.DocumentURLChunkType$inboundSchema.default("document_url")
    }).transform((c) => (0, i.remap)(c, {
      document_url: "documentUrl",
      document_name: "documentName"
    })), t.DocumentURLChunk$outboundSchema = r.object({
      documentUrl: r.string(),
      documentName: r.nullable(r.string()).optional(),
      type: t.DocumentURLChunkType$outboundSchema.default("document_url")
    }).transform((c) => (0, i.remap)(c, {
      documentUrl: "document_url",
      documentName: "document_name"
    }));
    var d;
    (function(c) {
      c.inboundSchema = t.DocumentURLChunk$inboundSchema, c.outboundSchema = t.DocumentURLChunk$outboundSchema;
    })(d || (t.DocumentURLChunk$ = d = {}));
    function f(c) {
      return JSON.stringify(t.DocumentURLChunk$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, s.safeParse)(c, (h) => t.DocumentURLChunk$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'DocumentURLChunk' from JSON");
    }
  }(Ta)), Ta;
}
var $a = {}, Ma = {}, $w;
function XR() {
  return $w || ($w = 1, function(t) {
    var e = Ma && Ma.__createBinding || (Object.create ? function(f, o, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(o, c);
      (!p || ("get" in p ? !o.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return o[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, o, c, h) {
      h === void 0 && (h = c), f[h] = o[c];
    }), n = Ma && Ma.__setModuleDefault || (Object.create ? function(f, o) {
      Object.defineProperty(f, "default", { enumerable: !0, value: o });
    } : function(f, o) {
      f.default = o;
    }), a = Ma && Ma.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var o = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(o, f, c);
      return n(o, f), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ImageURL$ = t.ImageURL$outboundSchema = t.ImageURL$inboundSchema = void 0, t.imageURLToJSON = u, t.imageURLFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.ImageURL$inboundSchema = r.object({
      url: r.string(),
      detail: r.nullable(r.string()).optional()
    }), t.ImageURL$outboundSchema = r.object({
      url: r.string(),
      detail: r.nullable(r.string()).optional()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.ImageURL$inboundSchema, f.outboundSchema = t.ImageURL$outboundSchema;
    })(s || (t.ImageURL$ = s = {}));
    function u(f) {
      return JSON.stringify(t.ImageURL$outboundSchema.parse(f));
    }
    function d(f) {
      return (0, i.safeParse)(f, (o) => t.ImageURL$inboundSchema.parse(JSON.parse(o)), "Failed to parse 'ImageURL' from JSON");
    }
  }(Ma)), Ma;
}
var Mw;
function d_() {
  return Mw || (Mw = 1, function(t) {
    var e = $a && $a.__createBinding || (Object.create ? function(m, b, g, _) {
      _ === void 0 && (_ = g);
      var P = Object.getOwnPropertyDescriptor(b, g);
      (!P || ("get" in P ? !b.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
        return b[g];
      } }), Object.defineProperty(m, _, P);
    } : function(m, b, g, _) {
      _ === void 0 && (_ = g), m[_] = b[g];
    }), n = $a && $a.__setModuleDefault || (Object.create ? function(m, b) {
      Object.defineProperty(m, "default", { enumerable: !0, value: b });
    } : function(m, b) {
      m.default = b;
    }), a = $a && $a.__importStar || function(m) {
      if (m && m.__esModule) return m;
      var b = {};
      if (m != null) for (var g in m) g !== "default" && Object.prototype.hasOwnProperty.call(m, g) && e(b, m, g);
      return n(b, m), b;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ImageURLChunk$ = t.ImageURLChunk$outboundSchema = t.ImageURLChunk$inboundSchema = t.ImageURLChunkType$ = t.ImageURLChunkType$outboundSchema = t.ImageURLChunkType$inboundSchema = t.ImageURLChunkImageURL$ = t.ImageURLChunkImageURL$outboundSchema = t.ImageURLChunkImageURL$inboundSchema = t.ImageURLChunkType = void 0, t.imageURLChunkImageURLToJSON = f, t.imageURLChunkImageURLFromJSON = o, t.imageURLChunkToJSON = p, t.imageURLChunkFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ XR();
    t.ImageURLChunkType = {
      ImageUrl: "image_url"
    }, t.ImageURLChunkImageURL$inboundSchema = r.union([u.ImageURL$inboundSchema, r.string()]), t.ImageURLChunkImageURL$outboundSchema = r.union([u.ImageURL$outboundSchema, r.string()]);
    var d;
    (function(m) {
      m.inboundSchema = t.ImageURLChunkImageURL$inboundSchema, m.outboundSchema = t.ImageURLChunkImageURL$outboundSchema;
    })(d || (t.ImageURLChunkImageURL$ = d = {}));
    function f(m) {
      return JSON.stringify(t.ImageURLChunkImageURL$outboundSchema.parse(m));
    }
    function o(m) {
      return (0, s.safeParse)(m, (b) => t.ImageURLChunkImageURL$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'ImageURLChunkImageURL' from JSON");
    }
    t.ImageURLChunkType$inboundSchema = r.nativeEnum(t.ImageURLChunkType), t.ImageURLChunkType$outboundSchema = t.ImageURLChunkType$inboundSchema;
    var c;
    (function(m) {
      m.inboundSchema = t.ImageURLChunkType$inboundSchema, m.outboundSchema = t.ImageURLChunkType$outboundSchema;
    })(c || (t.ImageURLChunkType$ = c = {})), t.ImageURLChunk$inboundSchema = r.object({
      image_url: r.union([u.ImageURL$inboundSchema, r.string()]),
      type: t.ImageURLChunkType$inboundSchema.default("image_url")
    }).transform((m) => (0, i.remap)(m, {
      image_url: "imageUrl"
    })), t.ImageURLChunk$outboundSchema = r.object({
      imageUrl: r.union([u.ImageURL$outboundSchema, r.string()]),
      type: t.ImageURLChunkType$outboundSchema.default("image_url")
    }).transform((m) => (0, i.remap)(m, {
      imageUrl: "image_url"
    }));
    var h;
    (function(m) {
      m.inboundSchema = t.ImageURLChunk$inboundSchema, m.outboundSchema = t.ImageURLChunk$outboundSchema;
    })(h || (t.ImageURLChunk$ = h = {}));
    function p(m) {
      return JSON.stringify(t.ImageURLChunk$outboundSchema.parse(m));
    }
    function l(m) {
      return (0, s.safeParse)(m, (b) => t.ImageURLChunk$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'ImageURLChunk' from JSON");
    }
  }($a)), $a;
}
var Aa = {}, Aw;
function QR() {
  return Aw || (Aw = 1, function(t) {
    var e = Aa && Aa.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = Aa && Aa.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Aa && Aa.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ReferenceChunk$ = t.ReferenceChunk$outboundSchema = t.ReferenceChunk$inboundSchema = t.ReferenceChunkType$ = t.ReferenceChunkType$outboundSchema = t.ReferenceChunkType$inboundSchema = t.ReferenceChunkType = void 0, t.referenceChunkToJSON = f, t.referenceChunkFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.ReferenceChunkType = {
      Reference: "reference"
    }, t.ReferenceChunkType$inboundSchema = r.nativeEnum(t.ReferenceChunkType), t.ReferenceChunkType$outboundSchema = t.ReferenceChunkType$inboundSchema;
    var u;
    (function(c) {
      c.inboundSchema = t.ReferenceChunkType$inboundSchema, c.outboundSchema = t.ReferenceChunkType$outboundSchema;
    })(u || (t.ReferenceChunkType$ = u = {})), t.ReferenceChunk$inboundSchema = r.object({
      reference_ids: r.array(r.number().int()),
      type: t.ReferenceChunkType$inboundSchema.default("reference")
    }).transform((c) => (0, i.remap)(c, {
      reference_ids: "referenceIds"
    })), t.ReferenceChunk$outboundSchema = r.object({
      referenceIds: r.array(r.number().int()),
      type: t.ReferenceChunkType$outboundSchema.default("reference")
    }).transform((c) => (0, i.remap)(c, {
      referenceIds: "reference_ids"
    }));
    var d;
    (function(c) {
      c.inboundSchema = t.ReferenceChunk$inboundSchema, c.outboundSchema = t.ReferenceChunk$outboundSchema;
    })(d || (t.ReferenceChunk$ = d = {}));
    function f(c) {
      return JSON.stringify(t.ReferenceChunk$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, s.safeParse)(c, (h) => t.ReferenceChunk$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'ReferenceChunk' from JSON");
    }
  }(Aa)), Aa;
}
var Ea = {}, Ew;
function f_() {
  return Ew || (Ew = 1, function(t) {
    var e = Ea && Ea.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Ea && Ea.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Ea && Ea.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.TextChunk$ = t.TextChunk$outboundSchema = t.TextChunk$inboundSchema = t.TextChunkType$ = t.TextChunkType$outboundSchema = t.TextChunkType$inboundSchema = t.TextChunkType = void 0, t.textChunkToJSON = d, t.textChunkFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.TextChunkType = {
      Text: "text"
    }, t.TextChunkType$inboundSchema = r.nativeEnum(t.TextChunkType), t.TextChunkType$outboundSchema = t.TextChunkType$inboundSchema;
    var s;
    (function(o) {
      o.inboundSchema = t.TextChunkType$inboundSchema, o.outboundSchema = t.TextChunkType$outboundSchema;
    })(s || (t.TextChunkType$ = s = {})), t.TextChunk$inboundSchema = r.object({
      text: r.string(),
      type: t.TextChunkType$inboundSchema.default("text")
    }), t.TextChunk$outboundSchema = r.object({
      text: r.string(),
      type: t.TextChunkType$outboundSchema.default("text")
    });
    var u;
    (function(o) {
      o.inboundSchema = t.TextChunk$inboundSchema, o.outboundSchema = t.TextChunk$outboundSchema;
    })(u || (t.TextChunk$ = u = {}));
    function d(o) {
      return JSON.stringify(t.TextChunk$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, i.safeParse)(o, (c) => t.TextChunk$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'TextChunk' from JSON");
    }
  }(Ea)), Ea;
}
var Iw;
function qd() {
  return Iw || (Iw = 1, function(t) {
    var e = Ra && Ra.__createBinding || (Object.create ? function(p, l, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(l, m);
      (!g || ("get" in g ? !l.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return l[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, l, m, b) {
      b === void 0 && (b = m), p[b] = l[m];
    }), n = Ra && Ra.__setModuleDefault || (Object.create ? function(p, l) {
      Object.defineProperty(p, "default", { enumerable: !0, value: l });
    } : function(p, l) {
      p.default = l;
    }), a = Ra && Ra.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var l = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(l, p, m);
      return n(l, p), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ContentChunk$ = t.ContentChunk$outboundSchema = t.ContentChunk$inboundSchema = void 0, t.contentChunkToJSON = c, t.contentChunkFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ l_(), u = /* @__PURE__ */ d_(), d = /* @__PURE__ */ QR(), f = /* @__PURE__ */ f_();
    t.ContentChunk$inboundSchema = r.union([
      u.ImageURLChunk$inboundSchema.and(r.object({ type: r.literal("image_url") }).transform((p) => ({
        type: p.type
      }))),
      f.TextChunk$inboundSchema.and(r.object({ type: r.literal("text") }).transform((p) => ({ type: p.type }))),
      d.ReferenceChunk$inboundSchema.and(r.object({ type: r.literal("reference") }).transform((p) => ({
        type: p.type
      }))),
      s.DocumentURLChunk$inboundSchema.and(r.object({ type: r.literal("document_url") }).transform((p) => ({
        type: p.type
      })))
    ]), t.ContentChunk$outboundSchema = r.union([
      u.ImageURLChunk$outboundSchema.and(r.object({ type: r.literal("image_url") }).transform((p) => ({
        type: p.type
      }))),
      f.TextChunk$outboundSchema.and(r.object({ type: r.literal("text") }).transform((p) => ({ type: p.type }))),
      d.ReferenceChunk$outboundSchema.and(r.object({ type: r.literal("reference") }).transform((p) => ({
        type: p.type
      }))),
      s.DocumentURLChunk$outboundSchema.and(r.object({ type: r.literal("document_url") }).transform((p) => ({
        type: p.type
      })))
    ]);
    var o;
    (function(p) {
      p.inboundSchema = t.ContentChunk$inboundSchema, p.outboundSchema = t.ContentChunk$outboundSchema;
    })(o || (t.ContentChunk$ = o = {}));
    function c(p) {
      return JSON.stringify(t.ContentChunk$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, i.safeParse)(p, (l) => t.ContentChunk$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'ContentChunk' from JSON");
    }
  }(Ra)), Ra;
}
var Ia = {}, Na = {}, Nw;
function YR() {
  return Nw || (Nw = 1, function(t) {
    var e = Na && Na.__createBinding || (Object.create ? function(h, p, l, m) {
      m === void 0 && (m = l);
      var b = Object.getOwnPropertyDescriptor(p, l);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[l];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, l, m) {
      m === void 0 && (m = l), h[m] = p[l];
    }), n = Na && Na.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = Na && Na.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var l in h) l !== "default" && Object.prototype.hasOwnProperty.call(h, l) && e(p, h, l);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FunctionCall$ = t.FunctionCall$outboundSchema = t.FunctionCall$inboundSchema = t.Arguments$ = t.Arguments$outboundSchema = t.Arguments$inboundSchema = void 0, t.argumentsToJSON = u, t.argumentsFromJSON = d, t.functionCallToJSON = o, t.functionCallFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.Arguments$inboundSchema = r.union([r.record(r.any()), r.string()]), t.Arguments$outboundSchema = r.union([r.record(r.any()), r.string()]);
    var s;
    (function(h) {
      h.inboundSchema = t.Arguments$inboundSchema, h.outboundSchema = t.Arguments$outboundSchema;
    })(s || (t.Arguments$ = s = {}));
    function u(h) {
      return JSON.stringify(t.Arguments$outboundSchema.parse(h));
    }
    function d(h) {
      return (0, i.safeParse)(h, (p) => t.Arguments$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'Arguments' from JSON");
    }
    t.FunctionCall$inboundSchema = r.object({
      name: r.string(),
      arguments: r.union([r.record(r.any()), r.string()])
    }), t.FunctionCall$outboundSchema = r.object({
      name: r.string(),
      arguments: r.union([r.record(r.any()), r.string()])
    });
    var f;
    (function(h) {
      h.inboundSchema = t.FunctionCall$inboundSchema, h.outboundSchema = t.FunctionCall$outboundSchema;
    })(f || (t.FunctionCall$ = f = {}));
    function o(h) {
      return JSON.stringify(t.FunctionCall$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, i.safeParse)(h, (p) => t.FunctionCall$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'FunctionCall' from JSON");
    }
  }(Na)), Na;
}
var Fa = {}, qf = {}, Fw;
function eu() {
  if (Fw) return qf;
  Fw = 1, Object.defineProperty(qf, "__esModule", { value: !0 }), qf.catchUnrecognizedEnum = t;
  function t(e) {
    return e;
  }
  return qf;
}
var kw;
function Sp() {
  return kw || (kw = 1, function(t) {
    var e = Fa && Fa.__createBinding || (Object.create ? function(u, d, f, o) {
      o === void 0 && (o = f);
      var c = Object.getOwnPropertyDescriptor(d, f);
      (!c || ("get" in c ? !d.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return d[f];
      } }), Object.defineProperty(u, o, c);
    } : function(u, d, f, o) {
      o === void 0 && (o = f), u[o] = d[f];
    }), n = Fa && Fa.__setModuleDefault || (Object.create ? function(u, d) {
      Object.defineProperty(u, "default", { enumerable: !0, value: d });
    } : function(u, d) {
      u.default = d;
    }), a = Fa && Fa.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var d = {};
      if (u != null) for (var f in u) f !== "default" && Object.prototype.hasOwnProperty.call(u, f) && e(d, u, f);
      return n(d, u), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ToolTypes$ = t.ToolTypes$outboundSchema = t.ToolTypes$inboundSchema = t.ToolTypes = void 0;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ eu();
    t.ToolTypes = {
      Function: "function"
    }, t.ToolTypes$inboundSchema = r.union([
      r.nativeEnum(t.ToolTypes),
      r.string().transform(i.catchUnrecognizedEnum)
    ]), t.ToolTypes$outboundSchema = r.union([
      r.nativeEnum(t.ToolTypes),
      r.string().and(r.custom())
    ]);
    var s;
    (function(u) {
      u.inboundSchema = t.ToolTypes$inboundSchema, u.outboundSchema = t.ToolTypes$outboundSchema;
    })(s || (t.ToolTypes$ = s = {}));
  }(Fa)), Fa;
}
var Dw;
function h_() {
  return Dw || (Dw = 1, function(t) {
    var e = Ia && Ia.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = Ia && Ia.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Ia && Ia.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ToolCall$ = t.ToolCall$outboundSchema = t.ToolCall$inboundSchema = void 0, t.toolCallToJSON = f, t.toolCallFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ YR(), u = /* @__PURE__ */ Sp();
    t.ToolCall$inboundSchema = r.object({
      id: r.string().default("null"),
      type: u.ToolTypes$inboundSchema.optional(),
      function: s.FunctionCall$inboundSchema,
      index: r.number().int().default(0)
    }), t.ToolCall$outboundSchema = r.object({
      id: r.string().default("null"),
      type: u.ToolTypes$outboundSchema.optional(),
      function: s.FunctionCall$outboundSchema,
      index: r.number().int().default(0)
    });
    var d;
    (function(c) {
      c.inboundSchema = t.ToolCall$inboundSchema, c.outboundSchema = t.ToolCall$outboundSchema;
    })(d || (t.ToolCall$ = d = {}));
    function f(c) {
      return JSON.stringify(t.ToolCall$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, i.safeParse)(c, (h) => t.ToolCall$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'ToolCall' from JSON");
    }
  }(Ia)), Ia;
}
var qw;
function tu() {
  return qw || (qw = 1, function(t) {
    var e = Ca && Ca.__createBinding || (Object.create ? function(b, g, _, P) {
      P === void 0 && (P = _);
      var R = Object.getOwnPropertyDescriptor(g, _);
      (!R || ("get" in R ? !g.__esModule : R.writable || R.configurable)) && (R = { enumerable: !0, get: function() {
        return g[_];
      } }), Object.defineProperty(b, P, R);
    } : function(b, g, _, P) {
      P === void 0 && (P = _), b[P] = g[_];
    }), n = Ca && Ca.__setModuleDefault || (Object.create ? function(b, g) {
      Object.defineProperty(b, "default", { enumerable: !0, value: g });
    } : function(b, g) {
      b.default = g;
    }), a = Ca && Ca.__importStar || function(b) {
      if (b && b.__esModule) return b;
      var g = {};
      if (b != null) for (var _ in b) _ !== "default" && Object.prototype.hasOwnProperty.call(b, _) && e(g, b, _);
      return n(g, b), g;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.AssistantMessage$ = t.AssistantMessage$outboundSchema = t.AssistantMessage$inboundSchema = t.AssistantMessageRole$ = t.AssistantMessageRole$outboundSchema = t.AssistantMessageRole$inboundSchema = t.AssistantMessageContent$ = t.AssistantMessageContent$outboundSchema = t.AssistantMessageContent$inboundSchema = t.AssistantMessageRole = void 0, t.assistantMessageContentToJSON = o, t.assistantMessageContentFromJSON = c, t.assistantMessageToJSON = l, t.assistantMessageFromJSON = m;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ qd(), d = /* @__PURE__ */ h_();
    t.AssistantMessageRole = {
      Assistant: "assistant"
    }, t.AssistantMessageContent$inboundSchema = r.union([r.string(), r.array(u.ContentChunk$inboundSchema)]), t.AssistantMessageContent$outboundSchema = r.union([r.string(), r.array(u.ContentChunk$outboundSchema)]);
    var f;
    (function(b) {
      b.inboundSchema = t.AssistantMessageContent$inboundSchema, b.outboundSchema = t.AssistantMessageContent$outboundSchema;
    })(f || (t.AssistantMessageContent$ = f = {}));
    function o(b) {
      return JSON.stringify(t.AssistantMessageContent$outboundSchema.parse(b));
    }
    function c(b) {
      return (0, s.safeParse)(b, (g) => t.AssistantMessageContent$inboundSchema.parse(JSON.parse(g)), "Failed to parse 'AssistantMessageContent' from JSON");
    }
    t.AssistantMessageRole$inboundSchema = r.nativeEnum(t.AssistantMessageRole), t.AssistantMessageRole$outboundSchema = t.AssistantMessageRole$inboundSchema;
    var h;
    (function(b) {
      b.inboundSchema = t.AssistantMessageRole$inboundSchema, b.outboundSchema = t.AssistantMessageRole$outboundSchema;
    })(h || (t.AssistantMessageRole$ = h = {})), t.AssistantMessage$inboundSchema = r.object({
      content: r.nullable(r.union([r.string(), r.array(u.ContentChunk$inboundSchema)])).optional(),
      tool_calls: r.nullable(r.array(d.ToolCall$inboundSchema)).optional(),
      prefix: r.boolean().default(!1),
      role: t.AssistantMessageRole$inboundSchema.default("assistant")
    }).transform((b) => (0, i.remap)(b, {
      tool_calls: "toolCalls"
    })), t.AssistantMessage$outboundSchema = r.object({
      content: r.nullable(r.union([r.string(), r.array(u.ContentChunk$outboundSchema)])).optional(),
      toolCalls: r.nullable(r.array(d.ToolCall$outboundSchema)).optional(),
      prefix: r.boolean().default(!1),
      role: t.AssistantMessageRole$outboundSchema.default("assistant")
    }).transform((b) => (0, i.remap)(b, {
      toolCalls: "tool_calls"
    }));
    var p;
    (function(b) {
      b.inboundSchema = t.AssistantMessage$inboundSchema, b.outboundSchema = t.AssistantMessage$outboundSchema;
    })(p || (t.AssistantMessage$ = p = {}));
    function l(b) {
      return JSON.stringify(t.AssistantMessage$outboundSchema.parse(b));
    }
    function m(b) {
      return (0, s.safeParse)(b, (g) => t.AssistantMessage$inboundSchema.parse(JSON.parse(g)), "Failed to parse 'AssistantMessage' from JSON");
    }
  }(Ca)), Ca;
}
var ka = {}, Jw;
function Jd() {
  return Jw || (Jw = 1, function(t) {
    var e = ka && ka.__createBinding || (Object.create ? function(f, o, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(o, c);
      (!p || ("get" in p ? !o.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return o[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, o, c, h) {
      h === void 0 && (h = c), f[h] = o[c];
    }), n = ka && ka.__setModuleDefault || (Object.create ? function(f, o) {
      Object.defineProperty(f, "default", { enumerable: !0, value: o });
    } : function(f, o) {
      f.default = o;
    }), a = ka && ka.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var o = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(o, f, c);
      return n(o, f), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Prediction$ = t.Prediction$outboundSchema = t.Prediction$inboundSchema = void 0, t.predictionToJSON = u, t.predictionFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.Prediction$inboundSchema = r.object({
      type: r.literal("content").default("content"),
      content: r.string().default("")
    }), t.Prediction$outboundSchema = r.object({
      type: r.literal("content").default("content"),
      content: r.string().default("")
    });
    var s;
    (function(f) {
      f.inboundSchema = t.Prediction$inboundSchema, f.outboundSchema = t.Prediction$outboundSchema;
    })(s || (t.Prediction$ = s = {}));
    function u(f) {
      return JSON.stringify(t.Prediction$outboundSchema.parse(f));
    }
    function d(f) {
      return (0, i.safeParse)(f, (o) => t.Prediction$inboundSchema.parse(JSON.parse(o)), "Failed to parse 'Prediction' from JSON");
    }
  }(ka)), ka;
}
var Da = {}, qa = {}, Lw;
function eT() {
  return Lw || (Lw = 1, function(t) {
    var e = qa && qa.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = qa && qa.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = qa && qa.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JsonSchema$ = t.JsonSchema$outboundSchema = t.JsonSchema$inboundSchema = void 0, t.jsonSchemaToJSON = d, t.jsonSchemaFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JsonSchema$inboundSchema = r.object({
      name: r.string(),
      description: r.nullable(r.string()).optional(),
      schema: r.record(r.any()),
      strict: r.boolean().default(!1)
    }).transform((o) => (0, i.remap)(o, {
      schema: "schemaDefinition"
    })), t.JsonSchema$outboundSchema = r.object({
      name: r.string(),
      description: r.nullable(r.string()).optional(),
      schemaDefinition: r.record(r.any()),
      strict: r.boolean().default(!1)
    }).transform((o) => (0, i.remap)(o, {
      schemaDefinition: "schema"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.JsonSchema$inboundSchema, o.outboundSchema = t.JsonSchema$outboundSchema;
    })(u || (t.JsonSchema$ = u = {}));
    function d(o) {
      return JSON.stringify(t.JsonSchema$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.JsonSchema$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JsonSchema' from JSON");
    }
  }(qa)), qa;
}
var Ja = {}, Uw;
function tT() {
  return Uw || (Uw = 1, function(t) {
    var e = Ja && Ja.__createBinding || (Object.create ? function(s, u, d, f) {
      f === void 0 && (f = d);
      var o = Object.getOwnPropertyDescriptor(u, d);
      (!o || ("get" in o ? !u.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
        return u[d];
      } }), Object.defineProperty(s, f, o);
    } : function(s, u, d, f) {
      f === void 0 && (f = d), s[f] = u[d];
    }), n = Ja && Ja.__setModuleDefault || (Object.create ? function(s, u) {
      Object.defineProperty(s, "default", { enumerable: !0, value: u });
    } : function(s, u) {
      s.default = u;
    }), a = Ja && Ja.__importStar || function(s) {
      if (s && s.__esModule) return s;
      var u = {};
      if (s != null) for (var d in s) d !== "default" && Object.prototype.hasOwnProperty.call(s, d) && e(u, s, d);
      return n(u, s), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ResponseFormats$ = t.ResponseFormats$outboundSchema = t.ResponseFormats$inboundSchema = t.ResponseFormats = void 0;
    const r = a(/* @__PURE__ */ H());
    t.ResponseFormats = {
      Text: "text",
      JsonObject: "json_object",
      JsonSchema: "json_schema"
    }, t.ResponseFormats$inboundSchema = r.nativeEnum(t.ResponseFormats), t.ResponseFormats$outboundSchema = t.ResponseFormats$inboundSchema;
    var i;
    (function(s) {
      s.inboundSchema = t.ResponseFormats$inboundSchema, s.outboundSchema = t.ResponseFormats$outboundSchema;
    })(i || (t.ResponseFormats$ = i = {}));
  }(Ja)), Ja;
}
var Bw;
function Ld() {
  return Bw || (Bw = 1, function(t) {
    var e = Da && Da.__createBinding || (Object.create ? function(h, p, l, m) {
      m === void 0 && (m = l);
      var b = Object.getOwnPropertyDescriptor(p, l);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[l];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, l, m) {
      m === void 0 && (m = l), h[m] = p[l];
    }), n = Da && Da.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = Da && Da.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var l in h) l !== "default" && Object.prototype.hasOwnProperty.call(h, l) && e(p, h, l);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ResponseFormat$ = t.ResponseFormat$outboundSchema = t.ResponseFormat$inboundSchema = void 0, t.responseFormatToJSON = o, t.responseFormatFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ eT(), d = /* @__PURE__ */ tT();
    t.ResponseFormat$inboundSchema = r.object({
      type: d.ResponseFormats$inboundSchema.optional(),
      json_schema: r.nullable(u.JsonSchema$inboundSchema).optional()
    }).transform((h) => (0, i.remap)(h, {
      json_schema: "jsonSchema"
    })), t.ResponseFormat$outboundSchema = r.object({
      type: d.ResponseFormats$outboundSchema.optional(),
      jsonSchema: r.nullable(u.JsonSchema$outboundSchema).optional()
    }).transform((h) => (0, i.remap)(h, {
      jsonSchema: "json_schema"
    }));
    var f;
    (function(h) {
      h.inboundSchema = t.ResponseFormat$inboundSchema, h.outboundSchema = t.ResponseFormat$outboundSchema;
    })(f || (t.ResponseFormat$ = f = {}));
    function o(h) {
      return JSON.stringify(t.ResponseFormat$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, s.safeParse)(h, (p) => t.ResponseFormat$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'ResponseFormat' from JSON");
    }
  }(Da)), Da;
}
var La = {}, xw;
function nc() {
  return xw || (xw = 1, function(t) {
    var e = La && La.__createBinding || (Object.create ? function(l, m, b, g) {
      g === void 0 && (g = b);
      var _ = Object.getOwnPropertyDescriptor(m, b);
      (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
        return m[b];
      } }), Object.defineProperty(l, g, _);
    } : function(l, m, b, g) {
      g === void 0 && (g = b), l[g] = m[b];
    }), n = La && La.__setModuleDefault || (Object.create ? function(l, m) {
      Object.defineProperty(l, "default", { enumerable: !0, value: m });
    } : function(l, m) {
      l.default = m;
    }), a = La && La.__importStar || function(l) {
      if (l && l.__esModule) return l;
      var m = {};
      if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && e(m, l, b);
      return n(m, l), m;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SystemMessage$ = t.SystemMessage$outboundSchema = t.SystemMessage$inboundSchema = t.Role$ = t.Role$outboundSchema = t.Role$inboundSchema = t.SystemMessageContent$ = t.SystemMessageContent$outboundSchema = t.SystemMessageContent$inboundSchema = t.Role = void 0, t.systemMessageContentToJSON = d, t.systemMessageContentFromJSON = f, t.systemMessageToJSON = h, t.systemMessageFromJSON = p;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ f_();
    t.Role = {
      System: "system"
    }, t.SystemMessageContent$inboundSchema = r.union([r.string(), r.array(s.TextChunk$inboundSchema)]), t.SystemMessageContent$outboundSchema = r.union([r.string(), r.array(s.TextChunk$outboundSchema)]);
    var u;
    (function(l) {
      l.inboundSchema = t.SystemMessageContent$inboundSchema, l.outboundSchema = t.SystemMessageContent$outboundSchema;
    })(u || (t.SystemMessageContent$ = u = {}));
    function d(l) {
      return JSON.stringify(t.SystemMessageContent$outboundSchema.parse(l));
    }
    function f(l) {
      return (0, i.safeParse)(l, (m) => t.SystemMessageContent$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'SystemMessageContent' from JSON");
    }
    t.Role$inboundSchema = r.nativeEnum(t.Role), t.Role$outboundSchema = t.Role$inboundSchema;
    var o;
    (function(l) {
      l.inboundSchema = t.Role$inboundSchema, l.outboundSchema = t.Role$outboundSchema;
    })(o || (t.Role$ = o = {})), t.SystemMessage$inboundSchema = r.object({
      content: r.union([r.string(), r.array(s.TextChunk$inboundSchema)]),
      role: t.Role$inboundSchema.default("system")
    }), t.SystemMessage$outboundSchema = r.object({
      content: r.union([r.string(), r.array(s.TextChunk$outboundSchema)]),
      role: t.Role$outboundSchema.default("system")
    });
    var c;
    (function(l) {
      l.inboundSchema = t.SystemMessage$inboundSchema, l.outboundSchema = t.SystemMessage$outboundSchema;
    })(c || (t.SystemMessage$ = c = {}));
    function h(l) {
      return JSON.stringify(t.SystemMessage$outboundSchema.parse(l));
    }
    function p(l) {
      return (0, i.safeParse)(l, (m) => t.SystemMessage$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'SystemMessage' from JSON");
    }
  }(La)), La;
}
var Ua = {}, Ba = {}, Vw;
function nT() {
  return Vw || (Vw = 1, function(t) {
    var e = Ba && Ba.__createBinding || (Object.create ? function(f, o, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(o, c);
      (!p || ("get" in p ? !o.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return o[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, o, c, h) {
      h === void 0 && (h = c), f[h] = o[c];
    }), n = Ba && Ba.__setModuleDefault || (Object.create ? function(f, o) {
      Object.defineProperty(f, "default", { enumerable: !0, value: o });
    } : function(f, o) {
      f.default = o;
    }), a = Ba && Ba.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var o = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(o, f, c);
      return n(o, f), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FunctionT$ = t.FunctionT$outboundSchema = t.FunctionT$inboundSchema = void 0, t.functionToJSON = u, t.functionFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.FunctionT$inboundSchema = r.object({
      name: r.string(),
      description: r.string().default(""),
      strict: r.boolean().default(!1),
      parameters: r.record(r.any())
    }), t.FunctionT$outboundSchema = r.object({
      name: r.string(),
      description: r.string().default(""),
      strict: r.boolean().default(!1),
      parameters: r.record(r.any())
    });
    var s;
    (function(f) {
      f.inboundSchema = t.FunctionT$inboundSchema, f.outboundSchema = t.FunctionT$outboundSchema;
    })(s || (t.FunctionT$ = s = {}));
    function u(f) {
      return JSON.stringify(t.FunctionT$outboundSchema.parse(f));
    }
    function d(f) {
      return (0, i.safeParse)(f, (o) => t.FunctionT$inboundSchema.parse(JSON.parse(o)), "Failed to parse 'FunctionT' from JSON");
    }
  }(Ba)), Ba;
}
var zw;
function Ud() {
  return zw || (zw = 1, function(t) {
    var e = Ua && Ua.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = Ua && Ua.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Ua && Ua.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Tool$ = t.Tool$outboundSchema = t.Tool$inboundSchema = void 0, t.toolToJSON = f, t.toolFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ nT(), u = /* @__PURE__ */ Sp();
    t.Tool$inboundSchema = r.object({
      type: u.ToolTypes$inboundSchema.optional(),
      function: s.FunctionT$inboundSchema
    }), t.Tool$outboundSchema = r.object({
      type: u.ToolTypes$outboundSchema.optional(),
      function: s.FunctionT$outboundSchema
    });
    var d;
    (function(c) {
      c.inboundSchema = t.Tool$inboundSchema, c.outboundSchema = t.Tool$outboundSchema;
    })(d || (t.Tool$ = d = {}));
    function f(c) {
      return JSON.stringify(t.Tool$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, i.safeParse)(c, (h) => t.Tool$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'Tool' from JSON");
    }
  }(Ua)), Ua;
}
var xa = {}, Va = {}, Zw;
function rT() {
  return Zw || (Zw = 1, function(t) {
    var e = Va && Va.__createBinding || (Object.create ? function(f, o, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(o, c);
      (!p || ("get" in p ? !o.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return o[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, o, c, h) {
      h === void 0 && (h = c), f[h] = o[c];
    }), n = Va && Va.__setModuleDefault || (Object.create ? function(f, o) {
      Object.defineProperty(f, "default", { enumerable: !0, value: o });
    } : function(f, o) {
      f.default = o;
    }), a = Va && Va.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var o = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(o, f, c);
      return n(o, f), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FunctionName$ = t.FunctionName$outboundSchema = t.FunctionName$inboundSchema = void 0, t.functionNameToJSON = u, t.functionNameFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.FunctionName$inboundSchema = r.object({
      name: r.string()
    }), t.FunctionName$outboundSchema = r.object({
      name: r.string()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.FunctionName$inboundSchema, f.outboundSchema = t.FunctionName$outboundSchema;
    })(s || (t.FunctionName$ = s = {}));
    function u(f) {
      return JSON.stringify(t.FunctionName$outboundSchema.parse(f));
    }
    function d(f) {
      return (0, i.safeParse)(f, (o) => t.FunctionName$inboundSchema.parse(JSON.parse(o)), "Failed to parse 'FunctionName' from JSON");
    }
  }(Va)), Va;
}
var Kw;
function Bd() {
  return Kw || (Kw = 1, function(t) {
    var e = xa && xa.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = xa && xa.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = xa && xa.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ToolChoice$ = t.ToolChoice$outboundSchema = t.ToolChoice$inboundSchema = void 0, t.toolChoiceToJSON = f, t.toolChoiceFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ rT(), u = /* @__PURE__ */ Sp();
    t.ToolChoice$inboundSchema = r.object({
      type: u.ToolTypes$inboundSchema.optional(),
      function: s.FunctionName$inboundSchema
    }), t.ToolChoice$outboundSchema = r.object({
      type: u.ToolTypes$outboundSchema.optional(),
      function: s.FunctionName$outboundSchema
    });
    var d;
    (function(c) {
      c.inboundSchema = t.ToolChoice$inboundSchema, c.outboundSchema = t.ToolChoice$outboundSchema;
    })(d || (t.ToolChoice$ = d = {}));
    function f(c) {
      return JSON.stringify(t.ToolChoice$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, i.safeParse)(c, (h) => t.ToolChoice$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'ToolChoice' from JSON");
    }
  }(xa)), xa;
}
var za = {}, Hw;
function xd() {
  return Hw || (Hw = 1, function(t) {
    var e = za && za.__createBinding || (Object.create ? function(s, u, d, f) {
      f === void 0 && (f = d);
      var o = Object.getOwnPropertyDescriptor(u, d);
      (!o || ("get" in o ? !u.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
        return u[d];
      } }), Object.defineProperty(s, f, o);
    } : function(s, u, d, f) {
      f === void 0 && (f = d), s[f] = u[d];
    }), n = za && za.__setModuleDefault || (Object.create ? function(s, u) {
      Object.defineProperty(s, "default", { enumerable: !0, value: u });
    } : function(s, u) {
      s.default = u;
    }), a = za && za.__importStar || function(s) {
      if (s && s.__esModule) return s;
      var u = {};
      if (s != null) for (var d in s) d !== "default" && Object.prototype.hasOwnProperty.call(s, d) && e(u, s, d);
      return n(u, s), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ToolChoiceEnum$ = t.ToolChoiceEnum$outboundSchema = t.ToolChoiceEnum$inboundSchema = t.ToolChoiceEnum = void 0;
    const r = a(/* @__PURE__ */ H());
    t.ToolChoiceEnum = {
      Auto: "auto",
      None: "none",
      Any: "any",
      Required: "required"
    }, t.ToolChoiceEnum$inboundSchema = r.nativeEnum(t.ToolChoiceEnum), t.ToolChoiceEnum$outboundSchema = t.ToolChoiceEnum$inboundSchema;
    var i;
    (function(s) {
      s.inboundSchema = t.ToolChoiceEnum$inboundSchema, s.outboundSchema = t.ToolChoiceEnum$outboundSchema;
    })(i || (t.ToolChoiceEnum$ = i = {}));
  }(za)), za;
}
var Za = {}, Gw;
function rc() {
  return Gw || (Gw = 1, function(t) {
    var e = Za && Za.__createBinding || (Object.create ? function(m, b, g, _) {
      _ === void 0 && (_ = g);
      var P = Object.getOwnPropertyDescriptor(b, g);
      (!P || ("get" in P ? !b.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
        return b[g];
      } }), Object.defineProperty(m, _, P);
    } : function(m, b, g, _) {
      _ === void 0 && (_ = g), m[_] = b[g];
    }), n = Za && Za.__setModuleDefault || (Object.create ? function(m, b) {
      Object.defineProperty(m, "default", { enumerable: !0, value: b });
    } : function(m, b) {
      m.default = b;
    }), a = Za && Za.__importStar || function(m) {
      if (m && m.__esModule) return m;
      var b = {};
      if (m != null) for (var g in m) g !== "default" && Object.prototype.hasOwnProperty.call(m, g) && e(b, m, g);
      return n(b, m), b;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ToolMessage$ = t.ToolMessage$outboundSchema = t.ToolMessage$inboundSchema = t.ToolMessageRole$ = t.ToolMessageRole$outboundSchema = t.ToolMessageRole$inboundSchema = t.ToolMessageContent$ = t.ToolMessageContent$outboundSchema = t.ToolMessageContent$inboundSchema = t.ToolMessageRole = void 0, t.toolMessageContentToJSON = f, t.toolMessageContentFromJSON = o, t.toolMessageToJSON = p, t.toolMessageFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ qd();
    t.ToolMessageRole = {
      Tool: "tool"
    }, t.ToolMessageContent$inboundSchema = r.union([r.string(), r.array(u.ContentChunk$inboundSchema)]), t.ToolMessageContent$outboundSchema = r.union([r.string(), r.array(u.ContentChunk$outboundSchema)]);
    var d;
    (function(m) {
      m.inboundSchema = t.ToolMessageContent$inboundSchema, m.outboundSchema = t.ToolMessageContent$outboundSchema;
    })(d || (t.ToolMessageContent$ = d = {}));
    function f(m) {
      return JSON.stringify(t.ToolMessageContent$outboundSchema.parse(m));
    }
    function o(m) {
      return (0, s.safeParse)(m, (b) => t.ToolMessageContent$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'ToolMessageContent' from JSON");
    }
    t.ToolMessageRole$inboundSchema = r.nativeEnum(t.ToolMessageRole), t.ToolMessageRole$outboundSchema = t.ToolMessageRole$inboundSchema;
    var c;
    (function(m) {
      m.inboundSchema = t.ToolMessageRole$inboundSchema, m.outboundSchema = t.ToolMessageRole$outboundSchema;
    })(c || (t.ToolMessageRole$ = c = {})), t.ToolMessage$inboundSchema = r.object({
      content: r.nullable(r.union([r.string(), r.array(u.ContentChunk$inboundSchema)])),
      tool_call_id: r.nullable(r.string()).optional(),
      name: r.nullable(r.string()).optional(),
      role: t.ToolMessageRole$inboundSchema.default("tool")
    }).transform((m) => (0, i.remap)(m, {
      tool_call_id: "toolCallId"
    })), t.ToolMessage$outboundSchema = r.object({
      content: r.nullable(r.union([r.string(), r.array(u.ContentChunk$outboundSchema)])),
      toolCallId: r.nullable(r.string()).optional(),
      name: r.nullable(r.string()).optional(),
      role: t.ToolMessageRole$outboundSchema.default("tool")
    }).transform((m) => (0, i.remap)(m, {
      toolCallId: "tool_call_id"
    }));
    var h;
    (function(m) {
      m.inboundSchema = t.ToolMessage$inboundSchema, m.outboundSchema = t.ToolMessage$outboundSchema;
    })(h || (t.ToolMessage$ = h = {}));
    function p(m) {
      return JSON.stringify(t.ToolMessage$outboundSchema.parse(m));
    }
    function l(m) {
      return (0, s.safeParse)(m, (b) => t.ToolMessage$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'ToolMessage' from JSON");
    }
  }(Za)), Za;
}
var Ka = {}, Ww;
function ac() {
  return Ww || (Ww = 1, function(t) {
    var e = Ka && Ka.__createBinding || (Object.create ? function(l, m, b, g) {
      g === void 0 && (g = b);
      var _ = Object.getOwnPropertyDescriptor(m, b);
      (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
        return m[b];
      } }), Object.defineProperty(l, g, _);
    } : function(l, m, b, g) {
      g === void 0 && (g = b), l[g] = m[b];
    }), n = Ka && Ka.__setModuleDefault || (Object.create ? function(l, m) {
      Object.defineProperty(l, "default", { enumerable: !0, value: m });
    } : function(l, m) {
      l.default = m;
    }), a = Ka && Ka.__importStar || function(l) {
      if (l && l.__esModule) return l;
      var m = {};
      if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && e(m, l, b);
      return n(m, l), m;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.UserMessage$ = t.UserMessage$outboundSchema = t.UserMessage$inboundSchema = t.UserMessageRole$ = t.UserMessageRole$outboundSchema = t.UserMessageRole$inboundSchema = t.UserMessageContent$ = t.UserMessageContent$outboundSchema = t.UserMessageContent$inboundSchema = t.UserMessageRole = void 0, t.userMessageContentToJSON = d, t.userMessageContentFromJSON = f, t.userMessageToJSON = h, t.userMessageFromJSON = p;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ qd();
    t.UserMessageRole = {
      User: "user"
    }, t.UserMessageContent$inboundSchema = r.union([r.string(), r.array(s.ContentChunk$inboundSchema)]), t.UserMessageContent$outboundSchema = r.union([r.string(), r.array(s.ContentChunk$outboundSchema)]);
    var u;
    (function(l) {
      l.inboundSchema = t.UserMessageContent$inboundSchema, l.outboundSchema = t.UserMessageContent$outboundSchema;
    })(u || (t.UserMessageContent$ = u = {}));
    function d(l) {
      return JSON.stringify(t.UserMessageContent$outboundSchema.parse(l));
    }
    function f(l) {
      return (0, i.safeParse)(l, (m) => t.UserMessageContent$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'UserMessageContent' from JSON");
    }
    t.UserMessageRole$inboundSchema = r.nativeEnum(t.UserMessageRole), t.UserMessageRole$outboundSchema = t.UserMessageRole$inboundSchema;
    var o;
    (function(l) {
      l.inboundSchema = t.UserMessageRole$inboundSchema, l.outboundSchema = t.UserMessageRole$outboundSchema;
    })(o || (t.UserMessageRole$ = o = {})), t.UserMessage$inboundSchema = r.object({
      content: r.nullable(r.union([r.string(), r.array(s.ContentChunk$inboundSchema)])),
      role: t.UserMessageRole$inboundSchema.default("user")
    }), t.UserMessage$outboundSchema = r.object({
      content: r.nullable(r.union([r.string(), r.array(s.ContentChunk$outboundSchema)])),
      role: t.UserMessageRole$outboundSchema.default("user")
    });
    var c;
    (function(l) {
      l.inboundSchema = t.UserMessage$inboundSchema, l.outboundSchema = t.UserMessage$outboundSchema;
    })(c || (t.UserMessage$ = c = {}));
    function h(l) {
      return JSON.stringify(t.UserMessage$outboundSchema.parse(l));
    }
    function p(l) {
      return (0, i.safeParse)(l, (m) => t.UserMessage$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'UserMessage' from JSON");
    }
  }(Ka)), Ka;
}
var Xw;
function tq() {
  return Xw || (Xw = 1, function(t) {
    var e = Pa && Pa.__createBinding || (Object.create ? function(v, F, L, B) {
      B === void 0 && (B = L);
      var V = Object.getOwnPropertyDescriptor(F, L);
      (!V || ("get" in V ? !F.__esModule : V.writable || V.configurable)) && (V = { enumerable: !0, get: function() {
        return F[L];
      } }), Object.defineProperty(v, B, V);
    } : function(v, F, L, B) {
      B === void 0 && (B = L), v[B] = F[L];
    }), n = Pa && Pa.__setModuleDefault || (Object.create ? function(v, F) {
      Object.defineProperty(v, "default", { enumerable: !0, value: F });
    } : function(v, F) {
      v.default = F;
    }), a = Pa && Pa.__importStar || function(v) {
      if (v && v.__esModule) return v;
      var F = {};
      if (v != null) for (var L in v) L !== "default" && Object.prototype.hasOwnProperty.call(v, L) && e(F, v, L);
      return n(F, v), F;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.AgentsCompletionRequest$ = t.AgentsCompletionRequest$outboundSchema = t.AgentsCompletionRequest$inboundSchema = t.AgentsCompletionRequestToolChoice$ = t.AgentsCompletionRequestToolChoice$outboundSchema = t.AgentsCompletionRequestToolChoice$inboundSchema = t.AgentsCompletionRequestMessages$ = t.AgentsCompletionRequestMessages$outboundSchema = t.AgentsCompletionRequestMessages$inboundSchema = t.AgentsCompletionRequestStop$ = t.AgentsCompletionRequestStop$outboundSchema = t.AgentsCompletionRequestStop$inboundSchema = void 0, t.agentsCompletionRequestStopToJSON = g, t.agentsCompletionRequestStopFromJSON = _, t.agentsCompletionRequestMessagesToJSON = R, t.agentsCompletionRequestMessagesFromJSON = C, t.agentsCompletionRequestToolChoiceToJSON = O, t.agentsCompletionRequestToolChoiceFromJSON = A, t.agentsCompletionRequestToJSON = I, t.agentsCompletionRequestFromJSON = N;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ tu(), d = /* @__PURE__ */ Jd(), f = /* @__PURE__ */ Ld(), o = /* @__PURE__ */ nc(), c = /* @__PURE__ */ Ud(), h = /* @__PURE__ */ Bd(), p = /* @__PURE__ */ xd(), l = /* @__PURE__ */ rc(), m = /* @__PURE__ */ ac();
    t.AgentsCompletionRequestStop$inboundSchema = r.union([r.string(), r.array(r.string())]), t.AgentsCompletionRequestStop$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var b;
    (function(v) {
      v.inboundSchema = t.AgentsCompletionRequestStop$inboundSchema, v.outboundSchema = t.AgentsCompletionRequestStop$outboundSchema;
    })(b || (t.AgentsCompletionRequestStop$ = b = {}));
    function g(v) {
      return JSON.stringify(t.AgentsCompletionRequestStop$outboundSchema.parse(v));
    }
    function _(v) {
      return (0, s.safeParse)(v, (F) => t.AgentsCompletionRequestStop$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'AgentsCompletionRequestStop' from JSON");
    }
    t.AgentsCompletionRequestMessages$inboundSchema = r.union([
      o.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
        role: v.role
      }))),
      m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({ role: v.role }))),
      u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
        role: v.role
      }))),
      l.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({ role: v.role })))
    ]), t.AgentsCompletionRequestMessages$outboundSchema = r.union([
      o.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
        role: v.role
      }))),
      m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({ role: v.role }))),
      u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
        role: v.role
      }))),
      l.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({ role: v.role })))
    ]);
    var P;
    (function(v) {
      v.inboundSchema = t.AgentsCompletionRequestMessages$inboundSchema, v.outboundSchema = t.AgentsCompletionRequestMessages$outboundSchema;
    })(P || (t.AgentsCompletionRequestMessages$ = P = {}));
    function R(v) {
      return JSON.stringify(t.AgentsCompletionRequestMessages$outboundSchema.parse(v));
    }
    function C(v) {
      return (0, s.safeParse)(v, (F) => t.AgentsCompletionRequestMessages$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'AgentsCompletionRequestMessages' from JSON");
    }
    t.AgentsCompletionRequestToolChoice$inboundSchema = r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]), t.AgentsCompletionRequestToolChoice$outboundSchema = r.union([h.ToolChoice$outboundSchema, p.ToolChoiceEnum$outboundSchema]);
    var T;
    (function(v) {
      v.inboundSchema = t.AgentsCompletionRequestToolChoice$inboundSchema, v.outboundSchema = t.AgentsCompletionRequestToolChoice$outboundSchema;
    })(T || (t.AgentsCompletionRequestToolChoice$ = T = {}));
    function O(v) {
      return JSON.stringify(t.AgentsCompletionRequestToolChoice$outboundSchema.parse(v));
    }
    function A(v) {
      return (0, s.safeParse)(v, (F) => t.AgentsCompletionRequestToolChoice$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'AgentsCompletionRequestToolChoice' from JSON");
    }
    t.AgentsCompletionRequest$inboundSchema = r.object({
      max_tokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!1),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      random_seed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        o.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
          role: v.role
        }))),
        m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({
          role: v.role
        }))),
        u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
          role: v.role
        }))),
        l.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({
          role: v.role
        })))
      ])),
      response_format: f.ResponseFormat$inboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$inboundSchema)).optional(),
      tool_choice: r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]).optional(),
      presence_penalty: r.number().optional(),
      frequency_penalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: d.Prediction$inboundSchema.optional(),
      agent_id: r.string()
    }).transform((v) => (0, i.remap)(v, {
      max_tokens: "maxTokens",
      random_seed: "randomSeed",
      response_format: "responseFormat",
      tool_choice: "toolChoice",
      presence_penalty: "presencePenalty",
      frequency_penalty: "frequencyPenalty",
      agent_id: "agentId"
    })), t.AgentsCompletionRequest$outboundSchema = r.object({
      maxTokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!1),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      randomSeed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        o.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
          role: v.role
        }))),
        m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({
          role: v.role
        }))),
        u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
          role: v.role
        }))),
        l.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({
          role: v.role
        })))
      ])),
      responseFormat: f.ResponseFormat$outboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$outboundSchema)).optional(),
      toolChoice: r.union([
        h.ToolChoice$outboundSchema,
        p.ToolChoiceEnum$outboundSchema
      ]).optional(),
      presencePenalty: r.number().optional(),
      frequencyPenalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: d.Prediction$outboundSchema.optional(),
      agentId: r.string()
    }).transform((v) => (0, i.remap)(v, {
      maxTokens: "max_tokens",
      randomSeed: "random_seed",
      responseFormat: "response_format",
      toolChoice: "tool_choice",
      presencePenalty: "presence_penalty",
      frequencyPenalty: "frequency_penalty",
      agentId: "agent_id"
    }));
    var M;
    (function(v) {
      v.inboundSchema = t.AgentsCompletionRequest$inboundSchema, v.outboundSchema = t.AgentsCompletionRequest$outboundSchema;
    })(M || (t.AgentsCompletionRequest$ = M = {}));
    function I(v) {
      return JSON.stringify(t.AgentsCompletionRequest$outboundSchema.parse(v));
    }
    function N(v) {
      return (0, s.safeParse)(v, (F) => t.AgentsCompletionRequest$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'AgentsCompletionRequest' from JSON");
    }
  }(Pa)), Pa;
}
var Ha = {}, Qw;
function nq() {
  return Qw || (Qw = 1, function(t) {
    var e = Ha && Ha.__createBinding || (Object.create ? function(v, F, L, B) {
      B === void 0 && (B = L);
      var V = Object.getOwnPropertyDescriptor(F, L);
      (!V || ("get" in V ? !F.__esModule : V.writable || V.configurable)) && (V = { enumerable: !0, get: function() {
        return F[L];
      } }), Object.defineProperty(v, B, V);
    } : function(v, F, L, B) {
      B === void 0 && (B = L), v[B] = F[L];
    }), n = Ha && Ha.__setModuleDefault || (Object.create ? function(v, F) {
      Object.defineProperty(v, "default", { enumerable: !0, value: F });
    } : function(v, F) {
      v.default = F;
    }), a = Ha && Ha.__importStar || function(v) {
      if (v && v.__esModule) return v;
      var F = {};
      if (v != null) for (var L in v) L !== "default" && Object.prototype.hasOwnProperty.call(v, L) && e(F, v, L);
      return n(F, v), F;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.AgentsCompletionStreamRequest$ = t.AgentsCompletionStreamRequest$outboundSchema = t.AgentsCompletionStreamRequest$inboundSchema = t.AgentsCompletionStreamRequestToolChoice$ = t.AgentsCompletionStreamRequestToolChoice$outboundSchema = t.AgentsCompletionStreamRequestToolChoice$inboundSchema = t.AgentsCompletionStreamRequestMessages$ = t.AgentsCompletionStreamRequestMessages$outboundSchema = t.AgentsCompletionStreamRequestMessages$inboundSchema = t.AgentsCompletionStreamRequestStop$ = t.AgentsCompletionStreamRequestStop$outboundSchema = t.AgentsCompletionStreamRequestStop$inboundSchema = void 0, t.agentsCompletionStreamRequestStopToJSON = g, t.agentsCompletionStreamRequestStopFromJSON = _, t.agentsCompletionStreamRequestMessagesToJSON = R, t.agentsCompletionStreamRequestMessagesFromJSON = C, t.agentsCompletionStreamRequestToolChoiceToJSON = O, t.agentsCompletionStreamRequestToolChoiceFromJSON = A, t.agentsCompletionStreamRequestToJSON = I, t.agentsCompletionStreamRequestFromJSON = N;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ tu(), d = /* @__PURE__ */ Jd(), f = /* @__PURE__ */ Ld(), o = /* @__PURE__ */ nc(), c = /* @__PURE__ */ Ud(), h = /* @__PURE__ */ Bd(), p = /* @__PURE__ */ xd(), l = /* @__PURE__ */ rc(), m = /* @__PURE__ */ ac();
    t.AgentsCompletionStreamRequestStop$inboundSchema = r.union([r.string(), r.array(r.string())]), t.AgentsCompletionStreamRequestStop$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var b;
    (function(v) {
      v.inboundSchema = t.AgentsCompletionStreamRequestStop$inboundSchema, v.outboundSchema = t.AgentsCompletionStreamRequestStop$outboundSchema;
    })(b || (t.AgentsCompletionStreamRequestStop$ = b = {}));
    function g(v) {
      return JSON.stringify(t.AgentsCompletionStreamRequestStop$outboundSchema.parse(v));
    }
    function _(v) {
      return (0, s.safeParse)(v, (F) => t.AgentsCompletionStreamRequestStop$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'AgentsCompletionStreamRequestStop' from JSON");
    }
    t.AgentsCompletionStreamRequestMessages$inboundSchema = r.union([
      o.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
        role: v.role
      }))),
      m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({ role: v.role }))),
      u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
        role: v.role
      }))),
      l.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({ role: v.role })))
    ]), t.AgentsCompletionStreamRequestMessages$outboundSchema = r.union([
      o.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
        role: v.role
      }))),
      m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({ role: v.role }))),
      u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
        role: v.role
      }))),
      l.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({ role: v.role })))
    ]);
    var P;
    (function(v) {
      v.inboundSchema = t.AgentsCompletionStreamRequestMessages$inboundSchema, v.outboundSchema = t.AgentsCompletionStreamRequestMessages$outboundSchema;
    })(P || (t.AgentsCompletionStreamRequestMessages$ = P = {}));
    function R(v) {
      return JSON.stringify(t.AgentsCompletionStreamRequestMessages$outboundSchema.parse(v));
    }
    function C(v) {
      return (0, s.safeParse)(v, (F) => t.AgentsCompletionStreamRequestMessages$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'AgentsCompletionStreamRequestMessages' from JSON");
    }
    t.AgentsCompletionStreamRequestToolChoice$inboundSchema = r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]), t.AgentsCompletionStreamRequestToolChoice$outboundSchema = r.union([h.ToolChoice$outboundSchema, p.ToolChoiceEnum$outboundSchema]);
    var T;
    (function(v) {
      v.inboundSchema = t.AgentsCompletionStreamRequestToolChoice$inboundSchema, v.outboundSchema = t.AgentsCompletionStreamRequestToolChoice$outboundSchema;
    })(T || (t.AgentsCompletionStreamRequestToolChoice$ = T = {}));
    function O(v) {
      return JSON.stringify(t.AgentsCompletionStreamRequestToolChoice$outboundSchema.parse(v));
    }
    function A(v) {
      return (0, s.safeParse)(v, (F) => t.AgentsCompletionStreamRequestToolChoice$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'AgentsCompletionStreamRequestToolChoice' from JSON");
    }
    t.AgentsCompletionStreamRequest$inboundSchema = r.object({
      max_tokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!0),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      random_seed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        o.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
          role: v.role
        }))),
        m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({
          role: v.role
        }))),
        u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
          role: v.role
        }))),
        l.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({
          role: v.role
        })))
      ])),
      response_format: f.ResponseFormat$inboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$inboundSchema)).optional(),
      tool_choice: r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]).optional(),
      presence_penalty: r.number().optional(),
      frequency_penalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: d.Prediction$inboundSchema.optional(),
      agent_id: r.string()
    }).transform((v) => (0, i.remap)(v, {
      max_tokens: "maxTokens",
      random_seed: "randomSeed",
      response_format: "responseFormat",
      tool_choice: "toolChoice",
      presence_penalty: "presencePenalty",
      frequency_penalty: "frequencyPenalty",
      agent_id: "agentId"
    })), t.AgentsCompletionStreamRequest$outboundSchema = r.object({
      maxTokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!0),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      randomSeed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        o.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
          role: v.role
        }))),
        m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({
          role: v.role
        }))),
        u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
          role: v.role
        }))),
        l.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({
          role: v.role
        })))
      ])),
      responseFormat: f.ResponseFormat$outboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$outboundSchema)).optional(),
      toolChoice: r.union([
        h.ToolChoice$outboundSchema,
        p.ToolChoiceEnum$outboundSchema
      ]).optional(),
      presencePenalty: r.number().optional(),
      frequencyPenalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: d.Prediction$outboundSchema.optional(),
      agentId: r.string()
    }).transform((v) => (0, i.remap)(v, {
      maxTokens: "max_tokens",
      randomSeed: "random_seed",
      responseFormat: "response_format",
      toolChoice: "tool_choice",
      presencePenalty: "presence_penalty",
      frequencyPenalty: "frequency_penalty",
      agentId: "agent_id"
    }));
    var M;
    (function(v) {
      v.inboundSchema = t.AgentsCompletionStreamRequest$inboundSchema, v.outboundSchema = t.AgentsCompletionStreamRequest$outboundSchema;
    })(M || (t.AgentsCompletionStreamRequest$ = M = {}));
    function I(v) {
      return JSON.stringify(t.AgentsCompletionStreamRequest$outboundSchema.parse(v));
    }
    function N(v) {
      return (0, s.safeParse)(v, (F) => t.AgentsCompletionStreamRequest$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'AgentsCompletionStreamRequest' from JSON");
    }
  }(Ha)), Ha;
}
var Ga = {}, Yw;
function aT() {
  return Yw || (Yw = 1, function(t) {
    var e = Ga && Ga.__createBinding || (Object.create ? function(u, d, f, o) {
      o === void 0 && (o = f);
      var c = Object.getOwnPropertyDescriptor(d, f);
      (!c || ("get" in c ? !d.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return d[f];
      } }), Object.defineProperty(u, o, c);
    } : function(u, d, f, o) {
      o === void 0 && (o = f), u[o] = d[f];
    }), n = Ga && Ga.__setModuleDefault || (Object.create ? function(u, d) {
      Object.defineProperty(u, "default", { enumerable: !0, value: d });
    } : function(u, d) {
      u.default = d;
    }), a = Ga && Ga.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var d = {};
      if (u != null) for (var f in u) f !== "default" && Object.prototype.hasOwnProperty.call(u, f) && e(d, u, f);
      return n(d, u), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ApiEndpoint$ = t.ApiEndpoint$outboundSchema = t.ApiEndpoint$inboundSchema = t.ApiEndpoint = void 0;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ eu();
    t.ApiEndpoint = {
      RootV1ChatCompletions: "/v1/chat/completions",
      RootV1Embeddings: "/v1/embeddings",
      RootV1FimCompletions: "/v1/fim/completions",
      RootV1Moderations: "/v1/moderations",
      RootV1ChatModerations: "/v1/chat/moderations"
    }, t.ApiEndpoint$inboundSchema = r.union([
      r.nativeEnum(t.ApiEndpoint),
      r.string().transform(i.catchUnrecognizedEnum)
    ]), t.ApiEndpoint$outboundSchema = r.union([
      r.nativeEnum(t.ApiEndpoint),
      r.string().and(r.custom())
    ]);
    var s;
    (function(u) {
      u.inboundSchema = t.ApiEndpoint$inboundSchema, u.outboundSchema = t.ApiEndpoint$outboundSchema;
    })(s || (t.ApiEndpoint$ = s = {}));
  }(Ga)), Ga;
}
var Wa = {}, eS;
function rq() {
  return eS || (eS = 1, function(t) {
    var e = Wa && Wa.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Wa && Wa.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Wa && Wa.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ArchiveFTModelOut$ = t.ArchiveFTModelOut$outboundSchema = t.ArchiveFTModelOut$inboundSchema = t.ArchiveFTModelOutObject$ = t.ArchiveFTModelOutObject$outboundSchema = t.ArchiveFTModelOutObject$inboundSchema = t.ArchiveFTModelOutObject = void 0, t.archiveFTModelOutToJSON = d, t.archiveFTModelOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.ArchiveFTModelOutObject = {
      Model: "model"
    }, t.ArchiveFTModelOutObject$inboundSchema = r.nativeEnum(t.ArchiveFTModelOutObject), t.ArchiveFTModelOutObject$outboundSchema = t.ArchiveFTModelOutObject$inboundSchema;
    var s;
    (function(o) {
      o.inboundSchema = t.ArchiveFTModelOutObject$inboundSchema, o.outboundSchema = t.ArchiveFTModelOutObject$outboundSchema;
    })(s || (t.ArchiveFTModelOutObject$ = s = {})), t.ArchiveFTModelOut$inboundSchema = r.object({
      id: r.string(),
      object: r.literal("model").default("model"),
      archived: r.boolean().default(!0)
    }), t.ArchiveFTModelOut$outboundSchema = r.object({
      id: r.string(),
      object: r.literal("model").default("model"),
      archived: r.boolean().default(!0)
    });
    var u;
    (function(o) {
      o.inboundSchema = t.ArchiveFTModelOut$inboundSchema, o.outboundSchema = t.ArchiveFTModelOut$outboundSchema;
    })(u || (t.ArchiveFTModelOut$ = u = {}));
    function d(o) {
      return JSON.stringify(t.ArchiveFTModelOut$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, i.safeParse)(o, (c) => t.ArchiveFTModelOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'ArchiveFTModelOut' from JSON");
    }
  }(Wa)), Wa;
}
var Xa = {}, Qa = {}, tS;
function p_() {
  return tS || (tS = 1, function(t) {
    var e = Qa && Qa.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Qa && Qa.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Qa && Qa.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ModelCapabilities$ = t.ModelCapabilities$outboundSchema = t.ModelCapabilities$inboundSchema = void 0, t.modelCapabilitiesToJSON = d, t.modelCapabilitiesFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.ModelCapabilities$inboundSchema = r.object({
      completion_chat: r.boolean().default(!0),
      completion_fim: r.boolean().default(!1),
      function_calling: r.boolean().default(!0),
      fine_tuning: r.boolean().default(!1),
      vision: r.boolean().default(!1)
    }).transform((o) => (0, i.remap)(o, {
      completion_chat: "completionChat",
      completion_fim: "completionFim",
      function_calling: "functionCalling",
      fine_tuning: "fineTuning"
    })), t.ModelCapabilities$outboundSchema = r.object({
      completionChat: r.boolean().default(!0),
      completionFim: r.boolean().default(!1),
      functionCalling: r.boolean().default(!0),
      fineTuning: r.boolean().default(!1),
      vision: r.boolean().default(!1)
    }).transform((o) => (0, i.remap)(o, {
      completionChat: "completion_chat",
      completionFim: "completion_fim",
      functionCalling: "function_calling",
      fineTuning: "fine_tuning"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.ModelCapabilities$inboundSchema, o.outboundSchema = t.ModelCapabilities$outboundSchema;
    })(u || (t.ModelCapabilities$ = u = {}));
    function d(o) {
      return JSON.stringify(t.ModelCapabilities$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.ModelCapabilities$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'ModelCapabilities' from JSON");
    }
  }(Qa)), Qa;
}
var nS;
function iT() {
  return nS || (nS = 1, function(t) {
    var e = Xa && Xa.__createBinding || (Object.create ? function(h, p, l, m) {
      m === void 0 && (m = l);
      var b = Object.getOwnPropertyDescriptor(p, l);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[l];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, l, m) {
      m === void 0 && (m = l), h[m] = p[l];
    }), n = Xa && Xa.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = Xa && Xa.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var l in h) l !== "default" && Object.prototype.hasOwnProperty.call(h, l) && e(p, h, l);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseModelCard$ = t.BaseModelCard$outboundSchema = t.BaseModelCard$inboundSchema = t.Type$ = t.Type$outboundSchema = t.Type$inboundSchema = t.Type = void 0, t.baseModelCardToJSON = o, t.baseModelCardFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ p_();
    t.Type = {
      Base: "base"
    }, t.Type$inboundSchema = r.nativeEnum(t.Type), t.Type$outboundSchema = t.Type$inboundSchema;
    var d;
    (function(h) {
      h.inboundSchema = t.Type$inboundSchema, h.outboundSchema = t.Type$outboundSchema;
    })(d || (t.Type$ = d = {})), t.BaseModelCard$inboundSchema = r.object({
      id: r.string(),
      object: r.string().default("model"),
      created: r.number().int().optional(),
      owned_by: r.string().default("mistralai"),
      capabilities: u.ModelCapabilities$inboundSchema,
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional(),
      max_context_length: r.number().int().default(32768),
      aliases: r.array(r.string()).optional(),
      deprecation: r.nullable(r.string().datetime({ offset: !0 }).transform((h) => new Date(h))).optional(),
      default_model_temperature: r.nullable(r.number()).optional(),
      type: r.literal("base").default("base")
    }).transform((h) => (0, i.remap)(h, {
      owned_by: "ownedBy",
      max_context_length: "maxContextLength",
      default_model_temperature: "defaultModelTemperature"
    })), t.BaseModelCard$outboundSchema = r.object({
      id: r.string(),
      object: r.string().default("model"),
      created: r.number().int().optional(),
      ownedBy: r.string().default("mistralai"),
      capabilities: u.ModelCapabilities$outboundSchema,
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional(),
      maxContextLength: r.number().int().default(32768),
      aliases: r.array(r.string()).optional(),
      deprecation: r.nullable(r.date().transform((h) => h.toISOString())).optional(),
      defaultModelTemperature: r.nullable(r.number()).optional(),
      type: r.literal("base").default("base")
    }).transform((h) => (0, i.remap)(h, {
      ownedBy: "owned_by",
      maxContextLength: "max_context_length",
      defaultModelTemperature: "default_model_temperature"
    }));
    var f;
    (function(h) {
      h.inboundSchema = t.BaseModelCard$inboundSchema, h.outboundSchema = t.BaseModelCard$outboundSchema;
    })(f || (t.BaseModelCard$ = f = {}));
    function o(h) {
      return JSON.stringify(t.BaseModelCard$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, s.safeParse)(h, (p) => t.BaseModelCard$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'BaseModelCard' from JSON");
    }
  }(Xa)), Xa;
}
var Ya = {}, rS;
function sT() {
  return rS || (rS = 1, function(t) {
    var e = Ya && Ya.__createBinding || (Object.create ? function(f, o, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(o, c);
      (!p || ("get" in p ? !o.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return o[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, o, c, h) {
      h === void 0 && (h = c), f[h] = o[c];
    }), n = Ya && Ya.__setModuleDefault || (Object.create ? function(f, o) {
      Object.defineProperty(f, "default", { enumerable: !0, value: o });
    } : function(f, o) {
      f.default = o;
    }), a = Ya && Ya.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var o = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(o, f, c);
      return n(o, f), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.BatchError$ = t.BatchError$outboundSchema = t.BatchError$inboundSchema = void 0, t.batchErrorToJSON = u, t.batchErrorFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.BatchError$inboundSchema = r.object({
      message: r.string(),
      count: r.number().int().default(1)
    }), t.BatchError$outboundSchema = r.object({
      message: r.string(),
      count: r.number().int().default(1)
    });
    var s;
    (function(f) {
      f.inboundSchema = t.BatchError$inboundSchema, f.outboundSchema = t.BatchError$outboundSchema;
    })(s || (t.BatchError$ = s = {}));
    function u(f) {
      return JSON.stringify(t.BatchError$outboundSchema.parse(f));
    }
    function d(f) {
      return (0, i.safeParse)(f, (o) => t.BatchError$inboundSchema.parse(JSON.parse(o)), "Failed to parse 'BatchError' from JSON");
    }
  }(Ya)), Ya;
}
var ei = {}, aS;
function aq() {
  return aS || (aS = 1, function(t) {
    var e = ei && ei.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = ei && ei.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = ei && ei.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.BatchJobIn$ = t.BatchJobIn$outboundSchema = t.BatchJobIn$inboundSchema = void 0, t.batchJobInToJSON = f, t.batchJobInFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ aT();
    t.BatchJobIn$inboundSchema = r.object({
      input_files: r.array(r.string()),
      endpoint: u.ApiEndpoint$inboundSchema,
      model: r.string(),
      metadata: r.nullable(r.record(r.string())).optional(),
      timeout_hours: r.number().int().default(24)
    }).transform((c) => (0, i.remap)(c, {
      input_files: "inputFiles",
      timeout_hours: "timeoutHours"
    })), t.BatchJobIn$outboundSchema = r.object({
      inputFiles: r.array(r.string()),
      endpoint: u.ApiEndpoint$outboundSchema,
      model: r.string(),
      metadata: r.nullable(r.record(r.string())).optional(),
      timeoutHours: r.number().int().default(24)
    }).transform((c) => (0, i.remap)(c, {
      inputFiles: "input_files",
      timeoutHours: "timeout_hours"
    }));
    var d;
    (function(c) {
      c.inboundSchema = t.BatchJobIn$inboundSchema, c.outboundSchema = t.BatchJobIn$outboundSchema;
    })(d || (t.BatchJobIn$ = d = {}));
    function f(c) {
      return JSON.stringify(t.BatchJobIn$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, s.safeParse)(c, (h) => t.BatchJobIn$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'BatchJobIn' from JSON");
    }
  }(ei)), ei;
}
var ti = {}, ni = {}, iS;
function oT() {
  return iS || (iS = 1, function(t) {
    var e = ni && ni.__createBinding || (Object.create ? function(s, u, d, f) {
      f === void 0 && (f = d);
      var o = Object.getOwnPropertyDescriptor(u, d);
      (!o || ("get" in o ? !u.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
        return u[d];
      } }), Object.defineProperty(s, f, o);
    } : function(s, u, d, f) {
      f === void 0 && (f = d), s[f] = u[d];
    }), n = ni && ni.__setModuleDefault || (Object.create ? function(s, u) {
      Object.defineProperty(s, "default", { enumerable: !0, value: u });
    } : function(s, u) {
      s.default = u;
    }), a = ni && ni.__importStar || function(s) {
      if (s && s.__esModule) return s;
      var u = {};
      if (s != null) for (var d in s) d !== "default" && Object.prototype.hasOwnProperty.call(s, d) && e(u, s, d);
      return n(u, s), u;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.BatchJobStatus$ = t.BatchJobStatus$outboundSchema = t.BatchJobStatus$inboundSchema = t.BatchJobStatus = void 0;
    const r = a(/* @__PURE__ */ H());
    t.BatchJobStatus = {
      Queued: "QUEUED",
      Running: "RUNNING",
      Success: "SUCCESS",
      Failed: "FAILED",
      TimeoutExceeded: "TIMEOUT_EXCEEDED",
      CancellationRequested: "CANCELLATION_REQUESTED",
      Cancelled: "CANCELLED"
    }, t.BatchJobStatus$inboundSchema = r.nativeEnum(t.BatchJobStatus), t.BatchJobStatus$outboundSchema = t.BatchJobStatus$inboundSchema;
    var i;
    (function(s) {
      s.inboundSchema = t.BatchJobStatus$inboundSchema, s.outboundSchema = t.BatchJobStatus$outboundSchema;
    })(i || (t.BatchJobStatus$ = i = {}));
  }(ni)), ni;
}
var sS;
function uT() {
  return sS || (sS = 1, function(t) {
    var e = ti && ti.__createBinding || (Object.create ? function(p, l, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(l, m);
      (!g || ("get" in g ? !l.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return l[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, l, m, b) {
      b === void 0 && (b = m), p[b] = l[m];
    }), n = ti && ti.__setModuleDefault || (Object.create ? function(p, l) {
      Object.defineProperty(p, "default", { enumerable: !0, value: l });
    } : function(p, l) {
      p.default = l;
    }), a = ti && ti.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var l = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(l, p, m);
      return n(l, p), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.BatchJobOut$ = t.BatchJobOut$outboundSchema = t.BatchJobOut$inboundSchema = t.BatchJobOutObject$ = t.BatchJobOutObject$outboundSchema = t.BatchJobOutObject$inboundSchema = t.BatchJobOutObject = void 0, t.batchJobOutToJSON = c, t.batchJobOutFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ sT(), d = /* @__PURE__ */ oT();
    t.BatchJobOutObject = {
      Batch: "batch"
    }, t.BatchJobOutObject$inboundSchema = r.nativeEnum(t.BatchJobOutObject), t.BatchJobOutObject$outboundSchema = t.BatchJobOutObject$inboundSchema;
    var f;
    (function(p) {
      p.inboundSchema = t.BatchJobOutObject$inboundSchema, p.outboundSchema = t.BatchJobOutObject$outboundSchema;
    })(f || (t.BatchJobOutObject$ = f = {})), t.BatchJobOut$inboundSchema = r.object({
      id: r.string(),
      object: r.literal("batch").default("batch"),
      input_files: r.array(r.string()),
      metadata: r.nullable(r.record(r.any())).optional(),
      endpoint: r.string(),
      model: r.string(),
      output_file: r.nullable(r.string()).optional(),
      error_file: r.nullable(r.string()).optional(),
      errors: r.array(u.BatchError$inboundSchema),
      status: d.BatchJobStatus$inboundSchema,
      created_at: r.number().int(),
      total_requests: r.number().int(),
      completed_requests: r.number().int(),
      succeeded_requests: r.number().int(),
      failed_requests: r.number().int(),
      started_at: r.nullable(r.number().int()).optional(),
      completed_at: r.nullable(r.number().int()).optional()
    }).transform((p) => (0, i.remap)(p, {
      input_files: "inputFiles",
      output_file: "outputFile",
      error_file: "errorFile",
      created_at: "createdAt",
      total_requests: "totalRequests",
      completed_requests: "completedRequests",
      succeeded_requests: "succeededRequests",
      failed_requests: "failedRequests",
      started_at: "startedAt",
      completed_at: "completedAt"
    })), t.BatchJobOut$outboundSchema = r.object({
      id: r.string(),
      object: r.literal("batch").default("batch"),
      inputFiles: r.array(r.string()),
      metadata: r.nullable(r.record(r.any())).optional(),
      endpoint: r.string(),
      model: r.string(),
      outputFile: r.nullable(r.string()).optional(),
      errorFile: r.nullable(r.string()).optional(),
      errors: r.array(u.BatchError$outboundSchema),
      status: d.BatchJobStatus$outboundSchema,
      createdAt: r.number().int(),
      totalRequests: r.number().int(),
      completedRequests: r.number().int(),
      succeededRequests: r.number().int(),
      failedRequests: r.number().int(),
      startedAt: r.nullable(r.number().int()).optional(),
      completedAt: r.nullable(r.number().int()).optional()
    }).transform((p) => (0, i.remap)(p, {
      inputFiles: "input_files",
      outputFile: "output_file",
      errorFile: "error_file",
      createdAt: "created_at",
      totalRequests: "total_requests",
      completedRequests: "completed_requests",
      succeededRequests: "succeeded_requests",
      failedRequests: "failed_requests",
      startedAt: "started_at",
      completedAt: "completed_at"
    }));
    var o;
    (function(p) {
      p.inboundSchema = t.BatchJobOut$inboundSchema, p.outboundSchema = t.BatchJobOut$outboundSchema;
    })(o || (t.BatchJobOut$ = o = {}));
    function c(p) {
      return JSON.stringify(t.BatchJobOut$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (l) => t.BatchJobOut$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'BatchJobOut' from JSON");
    }
  }(ti)), ti;
}
var ri = {}, oS;
function iq() {
  return oS || (oS = 1, function(t) {
    var e = ri && ri.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = ri && ri.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = ri && ri.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.BatchJobsOut$ = t.BatchJobsOut$outboundSchema = t.BatchJobsOut$inboundSchema = t.BatchJobsOutObject$ = t.BatchJobsOutObject$outboundSchema = t.BatchJobsOutObject$inboundSchema = t.BatchJobsOutObject = void 0, t.batchJobsOutToJSON = f, t.batchJobsOutFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ uT();
    t.BatchJobsOutObject = {
      List: "list"
    }, t.BatchJobsOutObject$inboundSchema = r.nativeEnum(t.BatchJobsOutObject), t.BatchJobsOutObject$outboundSchema = t.BatchJobsOutObject$inboundSchema;
    var u;
    (function(c) {
      c.inboundSchema = t.BatchJobsOutObject$inboundSchema, c.outboundSchema = t.BatchJobsOutObject$outboundSchema;
    })(u || (t.BatchJobsOutObject$ = u = {})), t.BatchJobsOut$inboundSchema = r.object({
      data: r.array(s.BatchJobOut$inboundSchema).optional(),
      object: r.literal("list").default("list"),
      total: r.number().int()
    }), t.BatchJobsOut$outboundSchema = r.object({
      data: r.array(s.BatchJobOut$outboundSchema).optional(),
      object: r.literal("list").default("list"),
      total: r.number().int()
    });
    var d;
    (function(c) {
      c.inboundSchema = t.BatchJobsOut$inboundSchema, c.outboundSchema = t.BatchJobsOut$outboundSchema;
    })(d || (t.BatchJobsOut$ = d = {}));
    function f(c) {
      return JSON.stringify(t.BatchJobsOut$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, i.safeParse)(c, (h) => t.BatchJobsOut$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'BatchJobsOut' from JSON");
    }
  }(ri)), ri;
}
var ai = {}, uS;
function m_() {
  return uS || (uS = 1, function(t) {
    var e = ai && ai.__createBinding || (Object.create ? function(p, l, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(l, m);
      (!g || ("get" in g ? !l.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return l[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, l, m, b) {
      b === void 0 && (b = m), p[b] = l[m];
    }), n = ai && ai.__setModuleDefault || (Object.create ? function(p, l) {
      Object.defineProperty(p, "default", { enumerable: !0, value: l });
    } : function(p, l) {
      p.default = l;
    }), a = ai && ai.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var l = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(l, p, m);
      return n(l, p), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ChatCompletionChoice$ = t.ChatCompletionChoice$outboundSchema = t.ChatCompletionChoice$inboundSchema = t.FinishReason$ = t.FinishReason$outboundSchema = t.FinishReason$inboundSchema = t.FinishReason = void 0, t.chatCompletionChoiceToJSON = c, t.chatCompletionChoiceFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ eu(), d = /* @__PURE__ */ tu();
    t.FinishReason = {
      Stop: "stop",
      Length: "length",
      ModelLength: "model_length",
      Error: "error",
      ToolCalls: "tool_calls"
    }, t.FinishReason$inboundSchema = r.union([
      r.nativeEnum(t.FinishReason),
      r.string().transform(u.catchUnrecognizedEnum)
    ]), t.FinishReason$outboundSchema = r.union([
      r.nativeEnum(t.FinishReason),
      r.string().and(r.custom())
    ]);
    var f;
    (function(p) {
      p.inboundSchema = t.FinishReason$inboundSchema, p.outboundSchema = t.FinishReason$outboundSchema;
    })(f || (t.FinishReason$ = f = {})), t.ChatCompletionChoice$inboundSchema = r.object({
      index: r.number().int(),
      message: d.AssistantMessage$inboundSchema,
      finish_reason: t.FinishReason$inboundSchema
    }).transform((p) => (0, i.remap)(p, {
      finish_reason: "finishReason"
    })), t.ChatCompletionChoice$outboundSchema = r.object({
      index: r.number().int(),
      message: d.AssistantMessage$outboundSchema,
      finishReason: t.FinishReason$outboundSchema
    }).transform((p) => (0, i.remap)(p, {
      finishReason: "finish_reason"
    }));
    var o;
    (function(p) {
      p.inboundSchema = t.ChatCompletionChoice$inboundSchema, p.outboundSchema = t.ChatCompletionChoice$outboundSchema;
    })(o || (t.ChatCompletionChoice$ = o = {}));
    function c(p) {
      return JSON.stringify(t.ChatCompletionChoice$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (l) => t.ChatCompletionChoice$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'ChatCompletionChoice' from JSON");
    }
  }(ai)), ai;
}
var ii = {}, cS;
function sq() {
  return cS || (cS = 1, function(t) {
    var e = ii && ii.__createBinding || (Object.create ? function(v, F, L, B) {
      B === void 0 && (B = L);
      var V = Object.getOwnPropertyDescriptor(F, L);
      (!V || ("get" in V ? !F.__esModule : V.writable || V.configurable)) && (V = { enumerable: !0, get: function() {
        return F[L];
      } }), Object.defineProperty(v, B, V);
    } : function(v, F, L, B) {
      B === void 0 && (B = L), v[B] = F[L];
    }), n = ii && ii.__setModuleDefault || (Object.create ? function(v, F) {
      Object.defineProperty(v, "default", { enumerable: !0, value: F });
    } : function(v, F) {
      v.default = F;
    }), a = ii && ii.__importStar || function(v) {
      if (v && v.__esModule) return v;
      var F = {};
      if (v != null) for (var L in v) L !== "default" && Object.prototype.hasOwnProperty.call(v, L) && e(F, v, L);
      return n(F, v), F;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ChatCompletionRequest$ = t.ChatCompletionRequest$outboundSchema = t.ChatCompletionRequest$inboundSchema = t.ChatCompletionRequestToolChoice$ = t.ChatCompletionRequestToolChoice$outboundSchema = t.ChatCompletionRequestToolChoice$inboundSchema = t.Messages$ = t.Messages$outboundSchema = t.Messages$inboundSchema = t.Stop$ = t.Stop$outboundSchema = t.Stop$inboundSchema = void 0, t.stopToJSON = g, t.stopFromJSON = _, t.messagesToJSON = R, t.messagesFromJSON = C, t.chatCompletionRequestToolChoiceToJSON = O, t.chatCompletionRequestToolChoiceFromJSON = A, t.chatCompletionRequestToJSON = I, t.chatCompletionRequestFromJSON = N;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ tu(), d = /* @__PURE__ */ Jd(), f = /* @__PURE__ */ Ld(), o = /* @__PURE__ */ nc(), c = /* @__PURE__ */ Ud(), h = /* @__PURE__ */ Bd(), p = /* @__PURE__ */ xd(), l = /* @__PURE__ */ rc(), m = /* @__PURE__ */ ac();
    t.Stop$inboundSchema = r.union([r.string(), r.array(r.string())]), t.Stop$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var b;
    (function(v) {
      v.inboundSchema = t.Stop$inboundSchema, v.outboundSchema = t.Stop$outboundSchema;
    })(b || (t.Stop$ = b = {}));
    function g(v) {
      return JSON.stringify(t.Stop$outboundSchema.parse(v));
    }
    function _(v) {
      return (0, s.safeParse)(v, (F) => t.Stop$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'Stop' from JSON");
    }
    t.Messages$inboundSchema = r.union([
      o.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
        role: v.role
      }))),
      m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({ role: v.role }))),
      u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
        role: v.role
      }))),
      l.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({ role: v.role })))
    ]), t.Messages$outboundSchema = r.union([
      o.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
        role: v.role
      }))),
      m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({ role: v.role }))),
      u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
        role: v.role
      }))),
      l.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({ role: v.role })))
    ]);
    var P;
    (function(v) {
      v.inboundSchema = t.Messages$inboundSchema, v.outboundSchema = t.Messages$outboundSchema;
    })(P || (t.Messages$ = P = {}));
    function R(v) {
      return JSON.stringify(t.Messages$outboundSchema.parse(v));
    }
    function C(v) {
      return (0, s.safeParse)(v, (F) => t.Messages$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'Messages' from JSON");
    }
    t.ChatCompletionRequestToolChoice$inboundSchema = r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]), t.ChatCompletionRequestToolChoice$outboundSchema = r.union([h.ToolChoice$outboundSchema, p.ToolChoiceEnum$outboundSchema]);
    var T;
    (function(v) {
      v.inboundSchema = t.ChatCompletionRequestToolChoice$inboundSchema, v.outboundSchema = t.ChatCompletionRequestToolChoice$outboundSchema;
    })(T || (t.ChatCompletionRequestToolChoice$ = T = {}));
    function O(v) {
      return JSON.stringify(t.ChatCompletionRequestToolChoice$outboundSchema.parse(v));
    }
    function A(v) {
      return (0, s.safeParse)(v, (F) => t.ChatCompletionRequestToolChoice$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'ChatCompletionRequestToolChoice' from JSON");
    }
    t.ChatCompletionRequest$inboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      top_p: r.number().optional(),
      max_tokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!1),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      random_seed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        o.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
          role: v.role
        }))),
        m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({
          role: v.role
        }))),
        u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
          role: v.role
        }))),
        l.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({
          role: v.role
        })))
      ])),
      response_format: f.ResponseFormat$inboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$inboundSchema)).optional(),
      tool_choice: r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]).optional(),
      presence_penalty: r.number().optional(),
      frequency_penalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: d.Prediction$inboundSchema.optional(),
      safe_prompt: r.boolean().optional()
    }).transform((v) => (0, i.remap)(v, {
      top_p: "topP",
      max_tokens: "maxTokens",
      random_seed: "randomSeed",
      response_format: "responseFormat",
      tool_choice: "toolChoice",
      presence_penalty: "presencePenalty",
      frequency_penalty: "frequencyPenalty",
      safe_prompt: "safePrompt"
    })), t.ChatCompletionRequest$outboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      topP: r.number().optional(),
      maxTokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!1),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      randomSeed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        o.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
          role: v.role
        }))),
        m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({
          role: v.role
        }))),
        u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
          role: v.role
        }))),
        l.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({
          role: v.role
        })))
      ])),
      responseFormat: f.ResponseFormat$outboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$outboundSchema)).optional(),
      toolChoice: r.union([
        h.ToolChoice$outboundSchema,
        p.ToolChoiceEnum$outboundSchema
      ]).optional(),
      presencePenalty: r.number().optional(),
      frequencyPenalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: d.Prediction$outboundSchema.optional(),
      safePrompt: r.boolean().optional()
    }).transform((v) => (0, i.remap)(v, {
      topP: "top_p",
      maxTokens: "max_tokens",
      randomSeed: "random_seed",
      responseFormat: "response_format",
      toolChoice: "tool_choice",
      presencePenalty: "presence_penalty",
      frequencyPenalty: "frequency_penalty",
      safePrompt: "safe_prompt"
    }));
    var M;
    (function(v) {
      v.inboundSchema = t.ChatCompletionRequest$inboundSchema, v.outboundSchema = t.ChatCompletionRequest$outboundSchema;
    })(M || (t.ChatCompletionRequest$ = M = {}));
    function I(v) {
      return JSON.stringify(t.ChatCompletionRequest$outboundSchema.parse(v));
    }
    function N(v) {
      return (0, s.safeParse)(v, (F) => t.ChatCompletionRequest$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'ChatCompletionRequest' from JSON");
    }
  }(ii)), ii;
}
var si = {}, oi = {}, lS;
function Vd() {
  return lS || (lS = 1, function(t) {
    var e = oi && oi.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = oi && oi.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = oi && oi.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.UsageInfo$ = t.UsageInfo$outboundSchema = t.UsageInfo$inboundSchema = void 0, t.usageInfoToJSON = d, t.usageInfoFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.UsageInfo$inboundSchema = r.object({
      prompt_tokens: r.number().int(),
      completion_tokens: r.number().int(),
      total_tokens: r.number().int()
    }).transform((o) => (0, i.remap)(o, {
      prompt_tokens: "promptTokens",
      completion_tokens: "completionTokens",
      total_tokens: "totalTokens"
    })), t.UsageInfo$outboundSchema = r.object({
      promptTokens: r.number().int(),
      completionTokens: r.number().int(),
      totalTokens: r.number().int()
    }).transform((o) => (0, i.remap)(o, {
      promptTokens: "prompt_tokens",
      completionTokens: "completion_tokens",
      totalTokens: "total_tokens"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.UsageInfo$inboundSchema, o.outboundSchema = t.UsageInfo$outboundSchema;
    })(u || (t.UsageInfo$ = u = {}));
    function d(o) {
      return JSON.stringify(t.UsageInfo$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.UsageInfo$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'UsageInfo' from JSON");
    }
  }(oi)), oi;
}
var dS;
function oq() {
  return dS || (dS = 1, function(t) {
    var e = si && si.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = si && si.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = si && si.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ChatCompletionResponse$ = t.ChatCompletionResponse$outboundSchema = t.ChatCompletionResponse$inboundSchema = void 0, t.chatCompletionResponseToJSON = f, t.chatCompletionResponseFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ m_(), u = /* @__PURE__ */ Vd();
    t.ChatCompletionResponse$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      model: r.string(),
      usage: u.UsageInfo$inboundSchema,
      created: r.number().int().optional(),
      choices: r.array(s.ChatCompletionChoice$inboundSchema).optional()
    }), t.ChatCompletionResponse$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      model: r.string(),
      usage: u.UsageInfo$outboundSchema,
      created: r.number().int().optional(),
      choices: r.array(s.ChatCompletionChoice$outboundSchema).optional()
    });
    var d;
    (function(c) {
      c.inboundSchema = t.ChatCompletionResponse$inboundSchema, c.outboundSchema = t.ChatCompletionResponse$outboundSchema;
    })(d || (t.ChatCompletionResponse$ = d = {}));
    function f(c) {
      return JSON.stringify(t.ChatCompletionResponse$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, i.safeParse)(c, (h) => t.ChatCompletionResponse$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'ChatCompletionResponse' from JSON");
    }
  }(si)), si;
}
var ui = {}, fS;
function uq() {
  return fS || (fS = 1, function(t) {
    var e = ui && ui.__createBinding || (Object.create ? function(v, F, L, B) {
      B === void 0 && (B = L);
      var V = Object.getOwnPropertyDescriptor(F, L);
      (!V || ("get" in V ? !F.__esModule : V.writable || V.configurable)) && (V = { enumerable: !0, get: function() {
        return F[L];
      } }), Object.defineProperty(v, B, V);
    } : function(v, F, L, B) {
      B === void 0 && (B = L), v[B] = F[L];
    }), n = ui && ui.__setModuleDefault || (Object.create ? function(v, F) {
      Object.defineProperty(v, "default", { enumerable: !0, value: F });
    } : function(v, F) {
      v.default = F;
    }), a = ui && ui.__importStar || function(v) {
      if (v && v.__esModule) return v;
      var F = {};
      if (v != null) for (var L in v) L !== "default" && Object.prototype.hasOwnProperty.call(v, L) && e(F, v, L);
      return n(F, v), F;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ChatCompletionStreamRequest$ = t.ChatCompletionStreamRequest$outboundSchema = t.ChatCompletionStreamRequest$inboundSchema = t.ChatCompletionStreamRequestToolChoice$ = t.ChatCompletionStreamRequestToolChoice$outboundSchema = t.ChatCompletionStreamRequestToolChoice$inboundSchema = t.ChatCompletionStreamRequestMessages$ = t.ChatCompletionStreamRequestMessages$outboundSchema = t.ChatCompletionStreamRequestMessages$inboundSchema = t.ChatCompletionStreamRequestStop$ = t.ChatCompletionStreamRequestStop$outboundSchema = t.ChatCompletionStreamRequestStop$inboundSchema = void 0, t.chatCompletionStreamRequestStopToJSON = g, t.chatCompletionStreamRequestStopFromJSON = _, t.chatCompletionStreamRequestMessagesToJSON = R, t.chatCompletionStreamRequestMessagesFromJSON = C, t.chatCompletionStreamRequestToolChoiceToJSON = O, t.chatCompletionStreamRequestToolChoiceFromJSON = A, t.chatCompletionStreamRequestToJSON = I, t.chatCompletionStreamRequestFromJSON = N;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ tu(), d = /* @__PURE__ */ Jd(), f = /* @__PURE__ */ Ld(), o = /* @__PURE__ */ nc(), c = /* @__PURE__ */ Ud(), h = /* @__PURE__ */ Bd(), p = /* @__PURE__ */ xd(), l = /* @__PURE__ */ rc(), m = /* @__PURE__ */ ac();
    t.ChatCompletionStreamRequestStop$inboundSchema = r.union([r.string(), r.array(r.string())]), t.ChatCompletionStreamRequestStop$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var b;
    (function(v) {
      v.inboundSchema = t.ChatCompletionStreamRequestStop$inboundSchema, v.outboundSchema = t.ChatCompletionStreamRequestStop$outboundSchema;
    })(b || (t.ChatCompletionStreamRequestStop$ = b = {}));
    function g(v) {
      return JSON.stringify(t.ChatCompletionStreamRequestStop$outboundSchema.parse(v));
    }
    function _(v) {
      return (0, s.safeParse)(v, (F) => t.ChatCompletionStreamRequestStop$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'ChatCompletionStreamRequestStop' from JSON");
    }
    t.ChatCompletionStreamRequestMessages$inboundSchema = r.union([
      o.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
        role: v.role
      }))),
      m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({ role: v.role }))),
      u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
        role: v.role
      }))),
      l.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({ role: v.role })))
    ]), t.ChatCompletionStreamRequestMessages$outboundSchema = r.union([
      o.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
        role: v.role
      }))),
      m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({ role: v.role }))),
      u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
        role: v.role
      }))),
      l.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({ role: v.role })))
    ]);
    var P;
    (function(v) {
      v.inboundSchema = t.ChatCompletionStreamRequestMessages$inboundSchema, v.outboundSchema = t.ChatCompletionStreamRequestMessages$outboundSchema;
    })(P || (t.ChatCompletionStreamRequestMessages$ = P = {}));
    function R(v) {
      return JSON.stringify(t.ChatCompletionStreamRequestMessages$outboundSchema.parse(v));
    }
    function C(v) {
      return (0, s.safeParse)(v, (F) => t.ChatCompletionStreamRequestMessages$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'ChatCompletionStreamRequestMessages' from JSON");
    }
    t.ChatCompletionStreamRequestToolChoice$inboundSchema = r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]), t.ChatCompletionStreamRequestToolChoice$outboundSchema = r.union([h.ToolChoice$outboundSchema, p.ToolChoiceEnum$outboundSchema]);
    var T;
    (function(v) {
      v.inboundSchema = t.ChatCompletionStreamRequestToolChoice$inboundSchema, v.outboundSchema = t.ChatCompletionStreamRequestToolChoice$outboundSchema;
    })(T || (t.ChatCompletionStreamRequestToolChoice$ = T = {}));
    function O(v) {
      return JSON.stringify(t.ChatCompletionStreamRequestToolChoice$outboundSchema.parse(v));
    }
    function A(v) {
      return (0, s.safeParse)(v, (F) => t.ChatCompletionStreamRequestToolChoice$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'ChatCompletionStreamRequestToolChoice' from JSON");
    }
    t.ChatCompletionStreamRequest$inboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      top_p: r.number().optional(),
      max_tokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!0),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      random_seed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        o.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
          role: v.role
        }))),
        m.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({
          role: v.role
        }))),
        u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
          role: v.role
        }))),
        l.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({
          role: v.role
        })))
      ])),
      response_format: f.ResponseFormat$inboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$inboundSchema)).optional(),
      tool_choice: r.union([h.ToolChoice$inboundSchema, p.ToolChoiceEnum$inboundSchema]).optional(),
      presence_penalty: r.number().optional(),
      frequency_penalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: d.Prediction$inboundSchema.optional(),
      safe_prompt: r.boolean().optional()
    }).transform((v) => (0, i.remap)(v, {
      top_p: "topP",
      max_tokens: "maxTokens",
      random_seed: "randomSeed",
      response_format: "responseFormat",
      tool_choice: "toolChoice",
      presence_penalty: "presencePenalty",
      frequency_penalty: "frequencyPenalty",
      safe_prompt: "safePrompt"
    })), t.ChatCompletionStreamRequest$outboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      topP: r.number().optional(),
      maxTokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!0),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      randomSeed: r.nullable(r.number().int()).optional(),
      messages: r.array(r.union([
        o.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((v) => ({
          role: v.role
        }))),
        m.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((v) => ({
          role: v.role
        }))),
        u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((v) => ({
          role: v.role
        }))),
        l.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((v) => ({
          role: v.role
        })))
      ])),
      responseFormat: f.ResponseFormat$outboundSchema.optional(),
      tools: r.nullable(r.array(c.Tool$outboundSchema)).optional(),
      toolChoice: r.union([
        h.ToolChoice$outboundSchema,
        p.ToolChoiceEnum$outboundSchema
      ]).optional(),
      presencePenalty: r.number().optional(),
      frequencyPenalty: r.number().optional(),
      n: r.nullable(r.number().int()).optional(),
      prediction: d.Prediction$outboundSchema.optional(),
      safePrompt: r.boolean().optional()
    }).transform((v) => (0, i.remap)(v, {
      topP: "top_p",
      maxTokens: "max_tokens",
      randomSeed: "random_seed",
      responseFormat: "response_format",
      toolChoice: "tool_choice",
      presencePenalty: "presence_penalty",
      frequencyPenalty: "frequency_penalty",
      safePrompt: "safe_prompt"
    }));
    var M;
    (function(v) {
      v.inboundSchema = t.ChatCompletionStreamRequest$inboundSchema, v.outboundSchema = t.ChatCompletionStreamRequest$outboundSchema;
    })(M || (t.ChatCompletionStreamRequest$ = M = {}));
    function I(v) {
      return JSON.stringify(t.ChatCompletionStreamRequest$outboundSchema.parse(v));
    }
    function N(v) {
      return (0, s.safeParse)(v, (F) => t.ChatCompletionStreamRequest$inboundSchema.parse(JSON.parse(F)), "Failed to parse 'ChatCompletionStreamRequest' from JSON");
    }
  }(ui)), ui;
}
var ci = {}, hS;
function cq() {
  return hS || (hS = 1, function(t) {
    var e = ci && ci.__createBinding || (Object.create ? function(O, A, M, I) {
      I === void 0 && (I = M);
      var N = Object.getOwnPropertyDescriptor(A, M);
      (!N || ("get" in N ? !A.__esModule : N.writable || N.configurable)) && (N = { enumerable: !0, get: function() {
        return A[M];
      } }), Object.defineProperty(O, I, N);
    } : function(O, A, M, I) {
      I === void 0 && (I = M), O[I] = A[M];
    }), n = ci && ci.__setModuleDefault || (Object.create ? function(O, A) {
      Object.defineProperty(O, "default", { enumerable: !0, value: A });
    } : function(O, A) {
      O.default = A;
    }), a = ci && ci.__importStar || function(O) {
      if (O && O.__esModule) return O;
      var A = {};
      if (O != null) for (var M in O) M !== "default" && Object.prototype.hasOwnProperty.call(O, M) && e(A, O, M);
      return n(A, O), A;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ChatModerationRequest$ = t.ChatModerationRequest$outboundSchema = t.ChatModerationRequest$inboundSchema = t.ChatModerationRequestInputs$ = t.ChatModerationRequestInputs$outboundSchema = t.ChatModerationRequestInputs$inboundSchema = t.One$ = t.One$outboundSchema = t.One$inboundSchema = t.Two$ = t.Two$outboundSchema = t.Two$inboundSchema = void 0, t.twoToJSON = h, t.twoFromJSON = p, t.oneToJSON = m, t.oneFromJSON = b, t.chatModerationRequestInputsToJSON = _, t.chatModerationRequestInputsFromJSON = P, t.chatModerationRequestToJSON = C, t.chatModerationRequestFromJSON = T;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ tu(), d = /* @__PURE__ */ nc(), f = /* @__PURE__ */ rc(), o = /* @__PURE__ */ ac();
    t.Two$inboundSchema = r.union([
      d.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
        role: O.role
      }))),
      o.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
        role: O.role
      }))),
      u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
        role: O.role
      }))),
      f.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
        role: O.role
      })))
    ]), t.Two$outboundSchema = r.union([
      d.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
        role: O.role
      }))),
      o.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
        role: O.role
      }))),
      u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
        role: O.role
      }))),
      f.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
        role: O.role
      })))
    ]);
    var c;
    (function(O) {
      O.inboundSchema = t.Two$inboundSchema, O.outboundSchema = t.Two$outboundSchema;
    })(c || (t.Two$ = c = {}));
    function h(O) {
      return JSON.stringify(t.Two$outboundSchema.parse(O));
    }
    function p(O) {
      return (0, s.safeParse)(O, (A) => t.Two$inboundSchema.parse(JSON.parse(A)), "Failed to parse 'Two' from JSON");
    }
    t.One$inboundSchema = r.union([
      d.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
        role: O.role
      }))),
      o.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
        role: O.role
      }))),
      u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
        role: O.role
      }))),
      f.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
        role: O.role
      })))
    ]), t.One$outboundSchema = r.union([
      d.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
        role: O.role
      }))),
      o.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
        role: O.role
      }))),
      u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
        role: O.role
      }))),
      f.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
        role: O.role
      })))
    ]);
    var l;
    (function(O) {
      O.inboundSchema = t.One$inboundSchema, O.outboundSchema = t.One$outboundSchema;
    })(l || (t.One$ = l = {}));
    function m(O) {
      return JSON.stringify(t.One$outboundSchema.parse(O));
    }
    function b(O) {
      return (0, s.safeParse)(O, (A) => t.One$inboundSchema.parse(JSON.parse(A)), "Failed to parse 'One' from JSON");
    }
    t.ChatModerationRequestInputs$inboundSchema = r.union([
      r.array(r.union([
        d.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
          role: O.role
        }))),
        o.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
          role: O.role
        }))),
        u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
          role: O.role
        }))),
        f.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
          role: O.role
        })))
      ])),
      r.array(r.array(r.union([
        d.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
          role: O.role
        }))),
        o.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
          role: O.role
        }))),
        u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
          role: O.role
        }))),
        f.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
          role: O.role
        })))
      ])))
    ]), t.ChatModerationRequestInputs$outboundSchema = r.union([
      r.array(r.union([
        d.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
          role: O.role
        }))),
        o.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
          role: O.role
        }))),
        u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
          role: O.role
        }))),
        f.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
          role: O.role
        })))
      ])),
      r.array(r.array(r.union([
        d.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
          role: O.role
        }))),
        o.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
          role: O.role
        }))),
        u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
          role: O.role
        }))),
        f.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
          role: O.role
        })))
      ])))
    ]);
    var g;
    (function(O) {
      O.inboundSchema = t.ChatModerationRequestInputs$inboundSchema, O.outboundSchema = t.ChatModerationRequestInputs$outboundSchema;
    })(g || (t.ChatModerationRequestInputs$ = g = {}));
    function _(O) {
      return JSON.stringify(t.ChatModerationRequestInputs$outboundSchema.parse(O));
    }
    function P(O) {
      return (0, s.safeParse)(O, (A) => t.ChatModerationRequestInputs$inboundSchema.parse(JSON.parse(A)), "Failed to parse 'ChatModerationRequestInputs' from JSON");
    }
    t.ChatModerationRequest$inboundSchema = r.object({
      model: r.string(),
      input: r.union([
        r.array(r.union([
          d.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
            role: O.role
          }))),
          o.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
            role: O.role
          }))),
          u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
            role: O.role
          }))),
          f.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
            role: O.role
          })))
        ])),
        r.array(r.array(r.union([
          d.SystemMessage$inboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
            role: O.role
          }))),
          o.UserMessage$inboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
            role: O.role
          }))),
          u.AssistantMessage$inboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
            role: O.role
          }))),
          f.ToolMessage$inboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
            role: O.role
          })))
        ])))
      ]),
      truncate_for_context_length: r.boolean().default(!1)
    }).transform((O) => (0, i.remap)(O, {
      input: "inputs",
      truncate_for_context_length: "truncateForContextLength"
    })), t.ChatModerationRequest$outboundSchema = r.object({
      model: r.string(),
      inputs: r.union([
        r.array(r.union([
          d.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
            role: O.role
          }))),
          o.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
            role: O.role
          }))),
          u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
            role: O.role
          }))),
          f.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
            role: O.role
          })))
        ])),
        r.array(r.array(r.union([
          d.SystemMessage$outboundSchema.and(r.object({ role: r.literal("system") }).transform((O) => ({
            role: O.role
          }))),
          o.UserMessage$outboundSchema.and(r.object({ role: r.literal("user") }).transform((O) => ({
            role: O.role
          }))),
          u.AssistantMessage$outboundSchema.and(r.object({ role: r.literal("assistant") }).transform((O) => ({
            role: O.role
          }))),
          f.ToolMessage$outboundSchema.and(r.object({ role: r.literal("tool") }).transform((O) => ({
            role: O.role
          })))
        ])))
      ]),
      truncateForContextLength: r.boolean().default(!1)
    }).transform((O) => (0, i.remap)(O, {
      inputs: "input",
      truncateForContextLength: "truncate_for_context_length"
    }));
    var R;
    (function(O) {
      O.inboundSchema = t.ChatModerationRequest$inboundSchema, O.outboundSchema = t.ChatModerationRequest$outboundSchema;
    })(R || (t.ChatModerationRequest$ = R = {}));
    function C(O) {
      return JSON.stringify(t.ChatModerationRequest$outboundSchema.parse(O));
    }
    function T(O) {
      return (0, s.safeParse)(O, (A) => t.ChatModerationRequest$inboundSchema.parse(JSON.parse(A)), "Failed to parse 'ChatModerationRequest' from JSON");
    }
  }(ci)), ci;
}
var li = {}, di = {}, pS;
function cT() {
  return pS || (pS = 1, function(t) {
    var e = di && di.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = di && di.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = di && di.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.MetricOut$ = t.MetricOut$outboundSchema = t.MetricOut$inboundSchema = void 0, t.metricOutToJSON = d, t.metricOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.MetricOut$inboundSchema = r.object({
      train_loss: r.nullable(r.number()).optional(),
      valid_loss: r.nullable(r.number()).optional(),
      valid_mean_token_accuracy: r.nullable(r.number()).optional()
    }).transform((o) => (0, i.remap)(o, {
      train_loss: "trainLoss",
      valid_loss: "validLoss",
      valid_mean_token_accuracy: "validMeanTokenAccuracy"
    })), t.MetricOut$outboundSchema = r.object({
      trainLoss: r.nullable(r.number()).optional(),
      validLoss: r.nullable(r.number()).optional(),
      validMeanTokenAccuracy: r.nullable(r.number()).optional()
    }).transform((o) => (0, i.remap)(o, {
      trainLoss: "train_loss",
      validLoss: "valid_loss",
      validMeanTokenAccuracy: "valid_mean_token_accuracy"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.MetricOut$inboundSchema, o.outboundSchema = t.MetricOut$outboundSchema;
    })(u || (t.MetricOut$ = u = {}));
    function d(o) {
      return JSON.stringify(t.MetricOut$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.MetricOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'MetricOut' from JSON");
    }
  }(di)), di;
}
var mS;
function lT() {
  return mS || (mS = 1, function(t) {
    var e = li && li.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = li && li.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = li && li.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CheckpointOut$ = t.CheckpointOut$outboundSchema = t.CheckpointOut$inboundSchema = void 0, t.checkpointOutToJSON = f, t.checkpointOutFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ cT();
    t.CheckpointOut$inboundSchema = r.object({
      metrics: u.MetricOut$inboundSchema,
      step_number: r.number().int(),
      created_at: r.number().int()
    }).transform((c) => (0, i.remap)(c, {
      step_number: "stepNumber",
      created_at: "createdAt"
    })), t.CheckpointOut$outboundSchema = r.object({
      metrics: u.MetricOut$outboundSchema,
      stepNumber: r.number().int(),
      createdAt: r.number().int()
    }).transform((c) => (0, i.remap)(c, {
      stepNumber: "step_number",
      createdAt: "created_at"
    }));
    var d;
    (function(c) {
      c.inboundSchema = t.CheckpointOut$inboundSchema, c.outboundSchema = t.CheckpointOut$outboundSchema;
    })(d || (t.CheckpointOut$ = d = {}));
    function f(c) {
      return JSON.stringify(t.CheckpointOut$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, s.safeParse)(c, (h) => t.CheckpointOut$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'CheckpointOut' from JSON");
    }
  }(li)), li;
}
var fi = {}, bS;
function dT() {
  return bS || (bS = 1, function(t) {
    var e = fi && fi.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = fi && fi.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = fi && fi.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ClassificationObject$ = t.ClassificationObject$outboundSchema = t.ClassificationObject$inboundSchema = void 0, t.classificationObjectToJSON = d, t.classificationObjectFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.ClassificationObject$inboundSchema = r.object({
      categories: r.record(r.boolean()).optional(),
      category_scores: r.record(r.number()).optional()
    }).transform((o) => (0, i.remap)(o, {
      category_scores: "categoryScores"
    })), t.ClassificationObject$outboundSchema = r.object({
      categories: r.record(r.boolean()).optional(),
      categoryScores: r.record(r.number()).optional()
    }).transform((o) => (0, i.remap)(o, {
      categoryScores: "category_scores"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.ClassificationObject$inboundSchema, o.outboundSchema = t.ClassificationObject$outboundSchema;
    })(u || (t.ClassificationObject$ = u = {}));
    function d(o) {
      return JSON.stringify(t.ClassificationObject$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.ClassificationObject$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'ClassificationObject' from JSON");
    }
  }(fi)), fi;
}
var hi = {}, gS;
function lq() {
  return gS || (gS = 1, function(t) {
    var e = hi && hi.__createBinding || (Object.create ? function(p, l, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(l, m);
      (!g || ("get" in g ? !l.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return l[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, l, m, b) {
      b === void 0 && (b = m), p[b] = l[m];
    }), n = hi && hi.__setModuleDefault || (Object.create ? function(p, l) {
      Object.defineProperty(p, "default", { enumerable: !0, value: l });
    } : function(p, l) {
      p.default = l;
    }), a = hi && hi.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var l = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(l, p, m);
      return n(l, p), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ClassificationRequest$ = t.ClassificationRequest$outboundSchema = t.ClassificationRequest$inboundSchema = t.ClassificationRequestInputs$ = t.ClassificationRequestInputs$outboundSchema = t.ClassificationRequestInputs$inboundSchema = void 0, t.classificationRequestInputsToJSON = d, t.classificationRequestInputsFromJSON = f, t.classificationRequestToJSON = c, t.classificationRequestFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.ClassificationRequestInputs$inboundSchema = r.union([r.string(), r.array(r.string())]), t.ClassificationRequestInputs$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var u;
    (function(p) {
      p.inboundSchema = t.ClassificationRequestInputs$inboundSchema, p.outboundSchema = t.ClassificationRequestInputs$outboundSchema;
    })(u || (t.ClassificationRequestInputs$ = u = {}));
    function d(p) {
      return JSON.stringify(t.ClassificationRequestInputs$outboundSchema.parse(p));
    }
    function f(p) {
      return (0, s.safeParse)(p, (l) => t.ClassificationRequestInputs$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'ClassificationRequestInputs' from JSON");
    }
    t.ClassificationRequest$inboundSchema = r.object({
      model: r.string(),
      input: r.union([r.string(), r.array(r.string())])
    }).transform((p) => (0, i.remap)(p, {
      input: "inputs"
    })), t.ClassificationRequest$outboundSchema = r.object({
      model: r.string(),
      inputs: r.union([r.string(), r.array(r.string())])
    }).transform((p) => (0, i.remap)(p, {
      inputs: "input"
    }));
    var o;
    (function(p) {
      p.inboundSchema = t.ClassificationRequest$inboundSchema, p.outboundSchema = t.ClassificationRequest$outboundSchema;
    })(o || (t.ClassificationRequest$ = o = {}));
    function c(p) {
      return JSON.stringify(t.ClassificationRequest$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (l) => t.ClassificationRequest$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'ClassificationRequest' from JSON");
    }
  }(hi)), hi;
}
var pi = {}, _S;
function dq() {
  return _S || (_S = 1, function(t) {
    var e = pi && pi.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = pi && pi.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = pi && pi.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ClassificationResponse$ = t.ClassificationResponse$outboundSchema = t.ClassificationResponse$inboundSchema = void 0, t.classificationResponseToJSON = d, t.classificationResponseFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ dT();
    t.ClassificationResponse$inboundSchema = r.object({
      id: r.string().optional(),
      model: r.string().optional(),
      results: r.array(s.ClassificationObject$inboundSchema).optional()
    }), t.ClassificationResponse$outboundSchema = r.object({
      id: r.string().optional(),
      model: r.string().optional(),
      results: r.array(s.ClassificationObject$outboundSchema).optional()
    });
    var u;
    (function(o) {
      o.inboundSchema = t.ClassificationResponse$inboundSchema, o.outboundSchema = t.ClassificationResponse$outboundSchema;
    })(u || (t.ClassificationResponse$ = u = {}));
    function d(o) {
      return JSON.stringify(t.ClassificationResponse$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, i.safeParse)(o, (c) => t.ClassificationResponse$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'ClassificationResponse' from JSON");
    }
  }(pi)), pi;
}
var mi = {}, bi = {}, gi = {}, yS;
function fT() {
  return yS || (yS = 1, function(t) {
    var e = gi && gi.__createBinding || (Object.create ? function(m, b, g, _) {
      _ === void 0 && (_ = g);
      var P = Object.getOwnPropertyDescriptor(b, g);
      (!P || ("get" in P ? !b.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
        return b[g];
      } }), Object.defineProperty(m, _, P);
    } : function(m, b, g, _) {
      _ === void 0 && (_ = g), m[_] = b[g];
    }), n = gi && gi.__setModuleDefault || (Object.create ? function(m, b) {
      Object.defineProperty(m, "default", { enumerable: !0, value: b });
    } : function(m, b) {
      m.default = b;
    }), a = gi && gi.__importStar || function(m) {
      if (m && m.__esModule) return m;
      var b = {};
      if (m != null) for (var g in m) g !== "default" && Object.prototype.hasOwnProperty.call(m, g) && e(b, m, g);
      return n(b, m), b;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.DeltaMessage$ = t.DeltaMessage$outboundSchema = t.DeltaMessage$inboundSchema = t.Content$ = t.Content$outboundSchema = t.Content$inboundSchema = void 0, t.contentToJSON = o, t.contentFromJSON = c, t.deltaMessageToJSON = p, t.deltaMessageFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ qd(), d = /* @__PURE__ */ h_();
    t.Content$inboundSchema = r.union([r.string(), r.array(u.ContentChunk$inboundSchema)]), t.Content$outboundSchema = r.union([r.string(), r.array(u.ContentChunk$outboundSchema)]);
    var f;
    (function(m) {
      m.inboundSchema = t.Content$inboundSchema, m.outboundSchema = t.Content$outboundSchema;
    })(f || (t.Content$ = f = {}));
    function o(m) {
      return JSON.stringify(t.Content$outboundSchema.parse(m));
    }
    function c(m) {
      return (0, s.safeParse)(m, (b) => t.Content$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'Content' from JSON");
    }
    t.DeltaMessage$inboundSchema = r.object({
      role: r.nullable(r.string()).optional(),
      content: r.nullable(r.union([r.string(), r.array(u.ContentChunk$inboundSchema)])).optional(),
      tool_calls: r.nullable(r.array(d.ToolCall$inboundSchema)).optional()
    }).transform((m) => (0, i.remap)(m, {
      tool_calls: "toolCalls"
    })), t.DeltaMessage$outboundSchema = r.object({
      role: r.nullable(r.string()).optional(),
      content: r.nullable(r.union([r.string(), r.array(u.ContentChunk$outboundSchema)])).optional(),
      toolCalls: r.nullable(r.array(d.ToolCall$outboundSchema)).optional()
    }).transform((m) => (0, i.remap)(m, {
      toolCalls: "tool_calls"
    }));
    var h;
    (function(m) {
      m.inboundSchema = t.DeltaMessage$inboundSchema, m.outboundSchema = t.DeltaMessage$outboundSchema;
    })(h || (t.DeltaMessage$ = h = {}));
    function p(m) {
      return JSON.stringify(t.DeltaMessage$outboundSchema.parse(m));
    }
    function l(m) {
      return (0, s.safeParse)(m, (b) => t.DeltaMessage$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'DeltaMessage' from JSON");
    }
  }(gi)), gi;
}
var vS;
function hT() {
  return vS || (vS = 1, function(t) {
    var e = bi && bi.__createBinding || (Object.create ? function(p, l, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(l, m);
      (!g || ("get" in g ? !l.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return l[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, l, m, b) {
      b === void 0 && (b = m), p[b] = l[m];
    }), n = bi && bi.__setModuleDefault || (Object.create ? function(p, l) {
      Object.defineProperty(p, "default", { enumerable: !0, value: l });
    } : function(p, l) {
      p.default = l;
    }), a = bi && bi.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var l = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(l, p, m);
      return n(l, p), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CompletionResponseStreamChoice$ = t.CompletionResponseStreamChoice$outboundSchema = t.CompletionResponseStreamChoice$inboundSchema = t.CompletionResponseStreamChoiceFinishReason$ = t.CompletionResponseStreamChoiceFinishReason$outboundSchema = t.CompletionResponseStreamChoiceFinishReason$inboundSchema = t.CompletionResponseStreamChoiceFinishReason = void 0, t.completionResponseStreamChoiceToJSON = c, t.completionResponseStreamChoiceFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ eu(), d = /* @__PURE__ */ fT();
    t.CompletionResponseStreamChoiceFinishReason = {
      Stop: "stop",
      Length: "length",
      Error: "error",
      ToolCalls: "tool_calls"
    }, t.CompletionResponseStreamChoiceFinishReason$inboundSchema = r.union([
      r.nativeEnum(t.CompletionResponseStreamChoiceFinishReason),
      r.string().transform(u.catchUnrecognizedEnum)
    ]), t.CompletionResponseStreamChoiceFinishReason$outboundSchema = r.union([
      r.nativeEnum(t.CompletionResponseStreamChoiceFinishReason),
      r.string().and(r.custom())
    ]);
    var f;
    (function(p) {
      p.inboundSchema = t.CompletionResponseStreamChoiceFinishReason$inboundSchema, p.outboundSchema = t.CompletionResponseStreamChoiceFinishReason$outboundSchema;
    })(f || (t.CompletionResponseStreamChoiceFinishReason$ = f = {})), t.CompletionResponseStreamChoice$inboundSchema = r.object({
      index: r.number().int(),
      delta: d.DeltaMessage$inboundSchema,
      finish_reason: r.nullable(t.CompletionResponseStreamChoiceFinishReason$inboundSchema)
    }).transform((p) => (0, i.remap)(p, {
      finish_reason: "finishReason"
    })), t.CompletionResponseStreamChoice$outboundSchema = r.object({
      index: r.number().int(),
      delta: d.DeltaMessage$outboundSchema,
      finishReason: r.nullable(t.CompletionResponseStreamChoiceFinishReason$outboundSchema)
    }).transform((p) => (0, i.remap)(p, {
      finishReason: "finish_reason"
    }));
    var o;
    (function(p) {
      p.inboundSchema = t.CompletionResponseStreamChoice$inboundSchema, p.outboundSchema = t.CompletionResponseStreamChoice$outboundSchema;
    })(o || (t.CompletionResponseStreamChoice$ = o = {}));
    function c(p) {
      return JSON.stringify(t.CompletionResponseStreamChoice$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (l) => t.CompletionResponseStreamChoice$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'CompletionResponseStreamChoice' from JSON");
    }
  }(bi)), bi;
}
var wS;
function pT() {
  return wS || (wS = 1, function(t) {
    var e = mi && mi.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = mi && mi.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = mi && mi.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CompletionChunk$ = t.CompletionChunk$outboundSchema = t.CompletionChunk$inboundSchema = void 0, t.completionChunkToJSON = f, t.completionChunkFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ hT(), u = /* @__PURE__ */ Vd();
    t.CompletionChunk$inboundSchema = r.object({
      id: r.string(),
      object: r.string().optional(),
      created: r.number().int().optional(),
      model: r.string(),
      usage: u.UsageInfo$inboundSchema.optional(),
      choices: r.array(s.CompletionResponseStreamChoice$inboundSchema)
    }), t.CompletionChunk$outboundSchema = r.object({
      id: r.string(),
      object: r.string().optional(),
      created: r.number().int().optional(),
      model: r.string(),
      usage: u.UsageInfo$outboundSchema.optional(),
      choices: r.array(s.CompletionResponseStreamChoice$outboundSchema)
    });
    var d;
    (function(c) {
      c.inboundSchema = t.CompletionChunk$inboundSchema, c.outboundSchema = t.CompletionChunk$outboundSchema;
    })(d || (t.CompletionChunk$ = d = {}));
    function f(c) {
      return JSON.stringify(t.CompletionChunk$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, i.safeParse)(c, (h) => t.CompletionChunk$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'CompletionChunk' from JSON");
    }
  }(mi)), mi;
}
var _i = {}, SS;
function fq() {
  return SS || (SS = 1, function(t) {
    var e = _i && _i.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = _i && _i.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = _i && _i.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CompletionEvent$ = t.CompletionEvent$outboundSchema = t.CompletionEvent$inboundSchema = void 0, t.completionEventToJSON = d, t.completionEventFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ pT();
    t.CompletionEvent$inboundSchema = r.object({
      data: r.string().transform((o, c) => {
        try {
          return JSON.parse(o);
        } catch (h) {
          return c.addIssue({
            code: r.ZodIssueCode.custom,
            message: `malformed json: ${h}`
          }), r.NEVER;
        }
      }).pipe(s.CompletionChunk$inboundSchema)
    }), t.CompletionEvent$outboundSchema = r.object({
      data: s.CompletionChunk$outboundSchema
    });
    var u;
    (function(o) {
      o.inboundSchema = t.CompletionEvent$inboundSchema, o.outboundSchema = t.CompletionEvent$outboundSchema;
    })(u || (t.CompletionEvent$ = u = {}));
    function d(o) {
      return JSON.stringify(t.CompletionEvent$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, i.safeParse)(o, (c) => t.CompletionEvent$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'CompletionEvent' from JSON");
    }
  }(_i)), _i;
}
var yi = {}, OS;
function hq() {
  return OS || (OS = 1, function(t) {
    var e = yi && yi.__createBinding || (Object.create ? function(f, o, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(o, c);
      (!p || ("get" in p ? !o.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return o[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, o, c, h) {
      h === void 0 && (h = c), f[h] = o[c];
    }), n = yi && yi.__setModuleDefault || (Object.create ? function(f, o) {
      Object.defineProperty(f, "default", { enumerable: !0, value: o });
    } : function(f, o) {
      f.default = o;
    }), a = yi && yi.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var o = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(o, f, c);
      return n(o, f), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.DeleteFileOut$ = t.DeleteFileOut$outboundSchema = t.DeleteFileOut$inboundSchema = void 0, t.deleteFileOutToJSON = u, t.deleteFileOutFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.DeleteFileOut$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      deleted: r.boolean()
    }), t.DeleteFileOut$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      deleted: r.boolean()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.DeleteFileOut$inboundSchema, f.outboundSchema = t.DeleteFileOut$outboundSchema;
    })(s || (t.DeleteFileOut$ = s = {}));
    function u(f) {
      return JSON.stringify(t.DeleteFileOut$outboundSchema.parse(f));
    }
    function d(f) {
      return (0, i.safeParse)(f, (o) => t.DeleteFileOut$inboundSchema.parse(JSON.parse(o)), "Failed to parse 'DeleteFileOut' from JSON");
    }
  }(yi)), yi;
}
var vi = {}, jS;
function pq() {
  return jS || (jS = 1, function(t) {
    var e = vi && vi.__createBinding || (Object.create ? function(f, o, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(o, c);
      (!p || ("get" in p ? !o.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return o[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, o, c, h) {
      h === void 0 && (h = c), f[h] = o[c];
    }), n = vi && vi.__setModuleDefault || (Object.create ? function(f, o) {
      Object.defineProperty(f, "default", { enumerable: !0, value: o });
    } : function(f, o) {
      f.default = o;
    }), a = vi && vi.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var o = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(o, f, c);
      return n(o, f), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.DeleteModelOut$ = t.DeleteModelOut$outboundSchema = t.DeleteModelOut$inboundSchema = void 0, t.deleteModelOutToJSON = u, t.deleteModelOutFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.DeleteModelOut$inboundSchema = r.object({
      id: r.string(),
      object: r.string().default("model"),
      deleted: r.boolean().default(!0)
    }), t.DeleteModelOut$outboundSchema = r.object({
      id: r.string(),
      object: r.string().default("model"),
      deleted: r.boolean().default(!0)
    });
    var s;
    (function(f) {
      f.inboundSchema = t.DeleteModelOut$inboundSchema, f.outboundSchema = t.DeleteModelOut$outboundSchema;
    })(s || (t.DeleteModelOut$ = s = {}));
    function u(f) {
      return JSON.stringify(t.DeleteModelOut$outboundSchema.parse(f));
    }
    function d(f) {
      return (0, i.safeParse)(f, (o) => t.DeleteModelOut$inboundSchema.parse(JSON.parse(o)), "Failed to parse 'DeleteModelOut' from JSON");
    }
  }(vi)), vi;
}
var wi = {}, Si = {}, PS;
function mT() {
  return PS || (PS = 1, function(t) {
    var e = Si && Si.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Si && Si.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Si && Si.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.EventOut$ = t.EventOut$outboundSchema = t.EventOut$inboundSchema = void 0, t.eventOutToJSON = d, t.eventOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.EventOut$inboundSchema = r.object({
      name: r.string(),
      data: r.nullable(r.record(r.any())).optional(),
      created_at: r.number().int()
    }).transform((o) => (0, i.remap)(o, {
      created_at: "createdAt"
    })), t.EventOut$outboundSchema = r.object({
      name: r.string(),
      data: r.nullable(r.record(r.any())).optional(),
      createdAt: r.number().int()
    }).transform((o) => (0, i.remap)(o, {
      createdAt: "created_at"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.EventOut$inboundSchema, o.outboundSchema = t.EventOut$outboundSchema;
    })(u || (t.EventOut$ = u = {}));
    function d(o) {
      return JSON.stringify(t.EventOut$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.EventOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'EventOut' from JSON");
    }
  }(Si)), Si;
}
var Oi = {}, CS;
function b_() {
  return CS || (CS = 1, function(t) {
    var e = Oi && Oi.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = Oi && Oi.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Oi && Oi.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.GithubRepositoryOut$ = t.GithubRepositoryOut$outboundSchema = t.GithubRepositoryOut$inboundSchema = t.GithubRepositoryOutType$ = t.GithubRepositoryOutType$outboundSchema = t.GithubRepositoryOutType$inboundSchema = t.GithubRepositoryOutType = void 0, t.githubRepositoryOutToJSON = f, t.githubRepositoryOutFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.GithubRepositoryOutType = {
      Github: "github"
    }, t.GithubRepositoryOutType$inboundSchema = r.nativeEnum(t.GithubRepositoryOutType), t.GithubRepositoryOutType$outboundSchema = t.GithubRepositoryOutType$inboundSchema;
    var u;
    (function(c) {
      c.inboundSchema = t.GithubRepositoryOutType$inboundSchema, c.outboundSchema = t.GithubRepositoryOutType$outboundSchema;
    })(u || (t.GithubRepositoryOutType$ = u = {})), t.GithubRepositoryOut$inboundSchema = r.object({
      type: r.literal("github").default("github"),
      name: r.string(),
      owner: r.string(),
      ref: r.nullable(r.string()).optional(),
      weight: r.number().default(1),
      commit_id: r.string()
    }).transform((c) => (0, i.remap)(c, {
      commit_id: "commitId"
    })), t.GithubRepositoryOut$outboundSchema = r.object({
      type: r.literal("github").default("github"),
      name: r.string(),
      owner: r.string(),
      ref: r.nullable(r.string()).optional(),
      weight: r.number().default(1),
      commitId: r.string()
    }).transform((c) => (0, i.remap)(c, {
      commitId: "commit_id"
    }));
    var d;
    (function(c) {
      c.inboundSchema = t.GithubRepositoryOut$inboundSchema, c.outboundSchema = t.GithubRepositoryOut$outboundSchema;
    })(d || (t.GithubRepositoryOut$ = d = {}));
    function f(c) {
      return JSON.stringify(t.GithubRepositoryOut$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, s.safeParse)(c, (h) => t.GithubRepositoryOut$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'GithubRepositoryOut' from JSON");
    }
  }(Oi)), Oi;
}
var ji = {}, RS;
function g_() {
  return RS || (RS = 1, function(t) {
    var e = ji && ji.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = ji && ji.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = ji && ji.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobMetadataOut$ = t.JobMetadataOut$outboundSchema = t.JobMetadataOut$inboundSchema = void 0, t.jobMetadataOutToJSON = d, t.jobMetadataOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobMetadataOut$inboundSchema = r.object({
      expected_duration_seconds: r.nullable(r.number().int()).optional(),
      cost: r.nullable(r.number()).optional(),
      cost_currency: r.nullable(r.string()).optional(),
      train_tokens_per_step: r.nullable(r.number().int()).optional(),
      train_tokens: r.nullable(r.number().int()).optional(),
      data_tokens: r.nullable(r.number().int()).optional(),
      estimated_start_time: r.nullable(r.number().int()).optional()
    }).transform((o) => (0, i.remap)(o, {
      expected_duration_seconds: "expectedDurationSeconds",
      cost_currency: "costCurrency",
      train_tokens_per_step: "trainTokensPerStep",
      train_tokens: "trainTokens",
      data_tokens: "dataTokens",
      estimated_start_time: "estimatedStartTime"
    })), t.JobMetadataOut$outboundSchema = r.object({
      expectedDurationSeconds: r.nullable(r.number().int()).optional(),
      cost: r.nullable(r.number()).optional(),
      costCurrency: r.nullable(r.string()).optional(),
      trainTokensPerStep: r.nullable(r.number().int()).optional(),
      trainTokens: r.nullable(r.number().int()).optional(),
      dataTokens: r.nullable(r.number().int()).optional(),
      estimatedStartTime: r.nullable(r.number().int()).optional()
    }).transform((o) => (0, i.remap)(o, {
      expectedDurationSeconds: "expected_duration_seconds",
      costCurrency: "cost_currency",
      trainTokensPerStep: "train_tokens_per_step",
      trainTokens: "train_tokens",
      dataTokens: "data_tokens",
      estimatedStartTime: "estimated_start_time"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.JobMetadataOut$inboundSchema, o.outboundSchema = t.JobMetadataOut$outboundSchema;
    })(u || (t.JobMetadataOut$ = u = {}));
    function d(o) {
      return JSON.stringify(t.JobMetadataOut$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.JobMetadataOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobMetadataOut' from JSON");
    }
  }(ji)), ji;
}
var Pi = {}, TS;
function __() {
  return TS || (TS = 1, function(t) {
    var e = Pi && Pi.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Pi && Pi.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Pi && Pi.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.TrainingParameters$ = t.TrainingParameters$outboundSchema = t.TrainingParameters$inboundSchema = void 0, t.trainingParametersToJSON = d, t.trainingParametersFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.TrainingParameters$inboundSchema = r.object({
      training_steps: r.nullable(r.number().int()).optional(),
      learning_rate: r.number().default(1e-4),
      weight_decay: r.nullable(r.number()).optional(),
      warmup_fraction: r.nullable(r.number()).optional(),
      epochs: r.nullable(r.number()).optional(),
      fim_ratio: r.nullable(r.number()).optional(),
      seq_len: r.nullable(r.number().int()).optional()
    }).transform((o) => (0, i.remap)(o, {
      training_steps: "trainingSteps",
      learning_rate: "learningRate",
      weight_decay: "weightDecay",
      warmup_fraction: "warmupFraction",
      fim_ratio: "fimRatio",
      seq_len: "seqLen"
    })), t.TrainingParameters$outboundSchema = r.object({
      trainingSteps: r.nullable(r.number().int()).optional(),
      learningRate: r.number().default(1e-4),
      weightDecay: r.nullable(r.number()).optional(),
      warmupFraction: r.nullable(r.number()).optional(),
      epochs: r.nullable(r.number()).optional(),
      fimRatio: r.nullable(r.number()).optional(),
      seqLen: r.nullable(r.number().int()).optional()
    }).transform((o) => (0, i.remap)(o, {
      trainingSteps: "training_steps",
      learningRate: "learning_rate",
      weightDecay: "weight_decay",
      warmupFraction: "warmup_fraction",
      fimRatio: "fim_ratio",
      seqLen: "seq_len"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.TrainingParameters$inboundSchema, o.outboundSchema = t.TrainingParameters$outboundSchema;
    })(u || (t.TrainingParameters$ = u = {}));
    function d(o) {
      return JSON.stringify(t.TrainingParameters$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.TrainingParameters$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'TrainingParameters' from JSON");
    }
  }(Pi)), Pi;
}
var Ci = {}, $S;
function y_() {
  return $S || ($S = 1, function(t) {
    var e = Ci && Ci.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = Ci && Ci.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Ci && Ci.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.WandbIntegrationOut$ = t.WandbIntegrationOut$outboundSchema = t.WandbIntegrationOut$inboundSchema = t.WandbIntegrationOutType$ = t.WandbIntegrationOutType$outboundSchema = t.WandbIntegrationOutType$inboundSchema = t.WandbIntegrationOutType = void 0, t.wandbIntegrationOutToJSON = f, t.wandbIntegrationOutFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.WandbIntegrationOutType = {
      Wandb: "wandb"
    }, t.WandbIntegrationOutType$inboundSchema = r.nativeEnum(t.WandbIntegrationOutType), t.WandbIntegrationOutType$outboundSchema = t.WandbIntegrationOutType$inboundSchema;
    var u;
    (function(c) {
      c.inboundSchema = t.WandbIntegrationOutType$inboundSchema, c.outboundSchema = t.WandbIntegrationOutType$outboundSchema;
    })(u || (t.WandbIntegrationOutType$ = u = {})), t.WandbIntegrationOut$inboundSchema = r.object({
      type: r.literal("wandb").default("wandb"),
      project: r.string(),
      name: r.nullable(r.string()).optional(),
      run_name: r.nullable(r.string()).optional()
    }).transform((c) => (0, i.remap)(c, {
      run_name: "runName"
    })), t.WandbIntegrationOut$outboundSchema = r.object({
      type: r.literal("wandb").default("wandb"),
      project: r.string(),
      name: r.nullable(r.string()).optional(),
      runName: r.nullable(r.string()).optional()
    }).transform((c) => (0, i.remap)(c, {
      runName: "run_name"
    }));
    var d;
    (function(c) {
      c.inboundSchema = t.WandbIntegrationOut$inboundSchema, c.outboundSchema = t.WandbIntegrationOut$outboundSchema;
    })(d || (t.WandbIntegrationOut$ = d = {}));
    function f(c) {
      return JSON.stringify(t.WandbIntegrationOut$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, s.safeParse)(c, (h) => t.WandbIntegrationOut$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'WandbIntegrationOut' from JSON");
    }
  }(Ci)), Ci;
}
var MS;
function mq() {
  return MS || (MS = 1, function(t) {
    var e = wi && wi.__createBinding || (Object.create ? function(A, M, I, N) {
      N === void 0 && (N = I);
      var v = Object.getOwnPropertyDescriptor(M, I);
      (!v || ("get" in v ? !M.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
        return M[I];
      } }), Object.defineProperty(A, N, v);
    } : function(A, M, I, N) {
      N === void 0 && (N = I), A[N] = M[I];
    }), n = wi && wi.__setModuleDefault || (Object.create ? function(A, M) {
      Object.defineProperty(A, "default", { enumerable: !0, value: M });
    } : function(A, M) {
      A.default = M;
    }), a = wi && wi.__importStar || function(A) {
      if (A && A.__esModule) return A;
      var M = {};
      if (A != null) for (var I in A) I !== "default" && Object.prototype.hasOwnProperty.call(A, I) && e(M, A, I);
      return n(M, A), M;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.DetailedJobOut$ = t.DetailedJobOut$outboundSchema = t.DetailedJobOut$inboundSchema = t.DetailedJobOutRepositories$ = t.DetailedJobOutRepositories$outboundSchema = t.DetailedJobOutRepositories$inboundSchema = t.DetailedJobOutIntegrations$ = t.DetailedJobOutIntegrations$outboundSchema = t.DetailedJobOutIntegrations$inboundSchema = t.DetailedJobOutObject$ = t.DetailedJobOutObject$outboundSchema = t.DetailedJobOutObject$inboundSchema = t.DetailedJobOutStatus$ = t.DetailedJobOutStatus$outboundSchema = t.DetailedJobOutStatus$inboundSchema = t.DetailedJobOutObject = t.DetailedJobOutStatus = void 0, t.detailedJobOutIntegrationsToJSON = b, t.detailedJobOutIntegrationsFromJSON = g, t.detailedJobOutRepositoriesToJSON = P, t.detailedJobOutRepositoriesFromJSON = R, t.detailedJobOutToJSON = T, t.detailedJobOutFromJSON = O;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ lT(), d = /* @__PURE__ */ mT(), f = /* @__PURE__ */ b_(), o = /* @__PURE__ */ g_(), c = /* @__PURE__ */ __(), h = /* @__PURE__ */ y_();
    t.DetailedJobOutStatus = {
      Queued: "QUEUED",
      Started: "STARTED",
      Validating: "VALIDATING",
      Validated: "VALIDATED",
      Running: "RUNNING",
      FailedValidation: "FAILED_VALIDATION",
      Failed: "FAILED",
      Success: "SUCCESS",
      Cancelled: "CANCELLED",
      CancellationRequested: "CANCELLATION_REQUESTED"
    }, t.DetailedJobOutObject = {
      Job: "job"
    }, t.DetailedJobOutStatus$inboundSchema = r.nativeEnum(t.DetailedJobOutStatus), t.DetailedJobOutStatus$outboundSchema = t.DetailedJobOutStatus$inboundSchema;
    var p;
    (function(A) {
      A.inboundSchema = t.DetailedJobOutStatus$inboundSchema, A.outboundSchema = t.DetailedJobOutStatus$outboundSchema;
    })(p || (t.DetailedJobOutStatus$ = p = {})), t.DetailedJobOutObject$inboundSchema = r.nativeEnum(t.DetailedJobOutObject), t.DetailedJobOutObject$outboundSchema = t.DetailedJobOutObject$inboundSchema;
    var l;
    (function(A) {
      A.inboundSchema = t.DetailedJobOutObject$inboundSchema, A.outboundSchema = t.DetailedJobOutObject$outboundSchema;
    })(l || (t.DetailedJobOutObject$ = l = {})), t.DetailedJobOutIntegrations$inboundSchema = h.WandbIntegrationOut$inboundSchema, t.DetailedJobOutIntegrations$outboundSchema = h.WandbIntegrationOut$outboundSchema;
    var m;
    (function(A) {
      A.inboundSchema = t.DetailedJobOutIntegrations$inboundSchema, A.outboundSchema = t.DetailedJobOutIntegrations$outboundSchema;
    })(m || (t.DetailedJobOutIntegrations$ = m = {}));
    function b(A) {
      return JSON.stringify(t.DetailedJobOutIntegrations$outboundSchema.parse(A));
    }
    function g(A) {
      return (0, s.safeParse)(A, (M) => t.DetailedJobOutIntegrations$inboundSchema.parse(JSON.parse(M)), "Failed to parse 'DetailedJobOutIntegrations' from JSON");
    }
    t.DetailedJobOutRepositories$inboundSchema = f.GithubRepositoryOut$inboundSchema, t.DetailedJobOutRepositories$outboundSchema = f.GithubRepositoryOut$outboundSchema;
    var _;
    (function(A) {
      A.inboundSchema = t.DetailedJobOutRepositories$inboundSchema, A.outboundSchema = t.DetailedJobOutRepositories$outboundSchema;
    })(_ || (t.DetailedJobOutRepositories$ = _ = {}));
    function P(A) {
      return JSON.stringify(t.DetailedJobOutRepositories$outboundSchema.parse(A));
    }
    function R(A) {
      return (0, s.safeParse)(A, (M) => t.DetailedJobOutRepositories$inboundSchema.parse(JSON.parse(M)), "Failed to parse 'DetailedJobOutRepositories' from JSON");
    }
    t.DetailedJobOut$inboundSchema = r.object({
      id: r.string(),
      auto_start: r.boolean(),
      hyperparameters: c.TrainingParameters$inboundSchema,
      model: r.string(),
      status: t.DetailedJobOutStatus$inboundSchema,
      job_type: r.string(),
      created_at: r.number().int(),
      modified_at: r.number().int(),
      training_files: r.array(r.string()),
      validation_files: r.nullable(r.array(r.string())).optional(),
      object: r.literal("job").default("job"),
      fine_tuned_model: r.nullable(r.string()).optional(),
      suffix: r.nullable(r.string()).optional(),
      integrations: r.nullable(r.array(h.WandbIntegrationOut$inboundSchema)).optional(),
      trained_tokens: r.nullable(r.number().int()).optional(),
      repositories: r.array(f.GithubRepositoryOut$inboundSchema).optional(),
      metadata: r.nullable(o.JobMetadataOut$inboundSchema).optional(),
      events: r.array(d.EventOut$inboundSchema).optional(),
      checkpoints: r.array(u.CheckpointOut$inboundSchema).optional()
    }).transform((A) => (0, i.remap)(A, {
      auto_start: "autoStart",
      job_type: "jobType",
      created_at: "createdAt",
      modified_at: "modifiedAt",
      training_files: "trainingFiles",
      validation_files: "validationFiles",
      fine_tuned_model: "fineTunedModel",
      trained_tokens: "trainedTokens"
    })), t.DetailedJobOut$outboundSchema = r.object({
      id: r.string(),
      autoStart: r.boolean(),
      hyperparameters: c.TrainingParameters$outboundSchema,
      model: r.string(),
      status: t.DetailedJobOutStatus$outboundSchema,
      jobType: r.string(),
      createdAt: r.number().int(),
      modifiedAt: r.number().int(),
      trainingFiles: r.array(r.string()),
      validationFiles: r.nullable(r.array(r.string())).optional(),
      object: r.literal("job").default("job"),
      fineTunedModel: r.nullable(r.string()).optional(),
      suffix: r.nullable(r.string()).optional(),
      integrations: r.nullable(r.array(h.WandbIntegrationOut$outboundSchema)).optional(),
      trainedTokens: r.nullable(r.number().int()).optional(),
      repositories: r.array(f.GithubRepositoryOut$outboundSchema).optional(),
      metadata: r.nullable(o.JobMetadataOut$outboundSchema).optional(),
      events: r.array(d.EventOut$outboundSchema).optional(),
      checkpoints: r.array(u.CheckpointOut$outboundSchema).optional()
    }).transform((A) => (0, i.remap)(A, {
      autoStart: "auto_start",
      jobType: "job_type",
      createdAt: "created_at",
      modifiedAt: "modified_at",
      trainingFiles: "training_files",
      validationFiles: "validation_files",
      fineTunedModel: "fine_tuned_model",
      trainedTokens: "trained_tokens"
    }));
    var C;
    (function(A) {
      A.inboundSchema = t.DetailedJobOut$inboundSchema, A.outboundSchema = t.DetailedJobOut$outboundSchema;
    })(C || (t.DetailedJobOut$ = C = {}));
    function T(A) {
      return JSON.stringify(t.DetailedJobOut$outboundSchema.parse(A));
    }
    function O(A) {
      return (0, s.safeParse)(A, (M) => t.DetailedJobOut$inboundSchema.parse(JSON.parse(M)), "Failed to parse 'DetailedJobOut' from JSON");
    }
  }(wi)), wi;
}
var Ri = {}, AS;
function bq() {
  return AS || (AS = 1, function(t) {
    var e = Ri && Ri.__createBinding || (Object.create ? function(p, l, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(l, m);
      (!g || ("get" in g ? !l.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return l[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, l, m, b) {
      b === void 0 && (b = m), p[b] = l[m];
    }), n = Ri && Ri.__setModuleDefault || (Object.create ? function(p, l) {
      Object.defineProperty(p, "default", { enumerable: !0, value: l });
    } : function(p, l) {
      p.default = l;
    }), a = Ri && Ri.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var l = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(l, p, m);
      return n(l, p), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.EmbeddingRequest$ = t.EmbeddingRequest$outboundSchema = t.EmbeddingRequest$inboundSchema = t.Inputs$ = t.Inputs$outboundSchema = t.Inputs$inboundSchema = void 0, t.inputsToJSON = d, t.inputsFromJSON = f, t.embeddingRequestToJSON = c, t.embeddingRequestFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.Inputs$inboundSchema = r.union([r.string(), r.array(r.string())]), t.Inputs$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var u;
    (function(p) {
      p.inboundSchema = t.Inputs$inboundSchema, p.outboundSchema = t.Inputs$outboundSchema;
    })(u || (t.Inputs$ = u = {}));
    function d(p) {
      return JSON.stringify(t.Inputs$outboundSchema.parse(p));
    }
    function f(p) {
      return (0, s.safeParse)(p, (l) => t.Inputs$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'Inputs' from JSON");
    }
    t.EmbeddingRequest$inboundSchema = r.object({
      model: r.string().default("mistral-embed"),
      input: r.union([r.string(), r.array(r.string())])
    }).transform((p) => (0, i.remap)(p, {
      input: "inputs"
    })), t.EmbeddingRequest$outboundSchema = r.object({
      model: r.string().default("mistral-embed"),
      inputs: r.union([r.string(), r.array(r.string())])
    }).transform((p) => (0, i.remap)(p, {
      inputs: "input"
    }));
    var o;
    (function(p) {
      p.inboundSchema = t.EmbeddingRequest$inboundSchema, p.outboundSchema = t.EmbeddingRequest$outboundSchema;
    })(o || (t.EmbeddingRequest$ = o = {}));
    function c(p) {
      return JSON.stringify(t.EmbeddingRequest$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (l) => t.EmbeddingRequest$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'EmbeddingRequest' from JSON");
    }
  }(Ri)), Ri;
}
var Ti = {}, $i = {}, ES;
function bT() {
  return ES || (ES = 1, function(t) {
    var e = $i && $i.__createBinding || (Object.create ? function(f, o, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(o, c);
      (!p || ("get" in p ? !o.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return o[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, o, c, h) {
      h === void 0 && (h = c), f[h] = o[c];
    }), n = $i && $i.__setModuleDefault || (Object.create ? function(f, o) {
      Object.defineProperty(f, "default", { enumerable: !0, value: o });
    } : function(f, o) {
      f.default = o;
    }), a = $i && $i.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var o = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(o, f, c);
      return n(o, f), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.EmbeddingResponseData$ = t.EmbeddingResponseData$outboundSchema = t.EmbeddingResponseData$inboundSchema = void 0, t.embeddingResponseDataToJSON = u, t.embeddingResponseDataFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.EmbeddingResponseData$inboundSchema = r.object({
      object: r.string().optional(),
      embedding: r.array(r.number()).optional(),
      index: r.number().int().optional()
    }), t.EmbeddingResponseData$outboundSchema = r.object({
      object: r.string().optional(),
      embedding: r.array(r.number()).optional(),
      index: r.number().int().optional()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.EmbeddingResponseData$inboundSchema, f.outboundSchema = t.EmbeddingResponseData$outboundSchema;
    })(s || (t.EmbeddingResponseData$ = s = {}));
    function u(f) {
      return JSON.stringify(t.EmbeddingResponseData$outboundSchema.parse(f));
    }
    function d(f) {
      return (0, i.safeParse)(f, (o) => t.EmbeddingResponseData$inboundSchema.parse(JSON.parse(o)), "Failed to parse 'EmbeddingResponseData' from JSON");
    }
  }($i)), $i;
}
var IS;
function gq() {
  return IS || (IS = 1, function(t) {
    var e = Ti && Ti.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = Ti && Ti.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Ti && Ti.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.EmbeddingResponse$ = t.EmbeddingResponse$outboundSchema = t.EmbeddingResponse$inboundSchema = void 0, t.embeddingResponseToJSON = f, t.embeddingResponseFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ bT(), u = /* @__PURE__ */ Vd();
    t.EmbeddingResponse$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      model: r.string(),
      usage: u.UsageInfo$inboundSchema,
      data: r.array(s.EmbeddingResponseData$inboundSchema)
    }), t.EmbeddingResponse$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      model: r.string(),
      usage: u.UsageInfo$outboundSchema,
      data: r.array(s.EmbeddingResponseData$outboundSchema)
    });
    var d;
    (function(c) {
      c.inboundSchema = t.EmbeddingResponse$inboundSchema, c.outboundSchema = t.EmbeddingResponse$outboundSchema;
    })(d || (t.EmbeddingResponse$ = d = {}));
    function f(c) {
      return JSON.stringify(t.EmbeddingResponse$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, i.safeParse)(c, (h) => t.EmbeddingResponse$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'EmbeddingResponse' from JSON");
    }
  }(Ti)), Ti;
}
var Mi = {}, NS;
function Op() {
  return NS || (NS = 1, function(t) {
    var e = Mi && Mi.__createBinding || (Object.create ? function(u, d, f, o) {
      o === void 0 && (o = f);
      var c = Object.getOwnPropertyDescriptor(d, f);
      (!c || ("get" in c ? !d.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return d[f];
      } }), Object.defineProperty(u, o, c);
    } : function(u, d, f, o) {
      o === void 0 && (o = f), u[o] = d[f];
    }), n = Mi && Mi.__setModuleDefault || (Object.create ? function(u, d) {
      Object.defineProperty(u, "default", { enumerable: !0, value: d });
    } : function(u, d) {
      u.default = d;
    }), a = Mi && Mi.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var d = {};
      if (u != null) for (var f in u) f !== "default" && Object.prototype.hasOwnProperty.call(u, f) && e(d, u, f);
      return n(d, u), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilePurpose$ = t.FilePurpose$outboundSchema = t.FilePurpose$inboundSchema = t.FilePurpose = void 0;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ eu();
    t.FilePurpose = {
      FineTune: "fine-tune",
      Batch: "batch",
      Ocr: "ocr"
    }, t.FilePurpose$inboundSchema = r.union([
      r.nativeEnum(t.FilePurpose),
      r.string().transform(i.catchUnrecognizedEnum)
    ]), t.FilePurpose$outboundSchema = r.union([
      r.nativeEnum(t.FilePurpose),
      r.string().and(r.custom())
    ]);
    var s;
    (function(u) {
      u.inboundSchema = t.FilePurpose$inboundSchema, u.outboundSchema = t.FilePurpose$outboundSchema;
    })(s || (t.FilePurpose$ = s = {}));
  }(Mi)), Mi;
}
var Ai = {}, Ei = {}, FS;
function jp() {
  return FS || (FS = 1, function(t) {
    var e = Ei && Ei.__createBinding || (Object.create ? function(u, d, f, o) {
      o === void 0 && (o = f);
      var c = Object.getOwnPropertyDescriptor(d, f);
      (!c || ("get" in c ? !d.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return d[f];
      } }), Object.defineProperty(u, o, c);
    } : function(u, d, f, o) {
      o === void 0 && (o = f), u[o] = d[f];
    }), n = Ei && Ei.__setModuleDefault || (Object.create ? function(u, d) {
      Object.defineProperty(u, "default", { enumerable: !0, value: d });
    } : function(u, d) {
      u.default = d;
    }), a = Ei && Ei.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var d = {};
      if (u != null) for (var f in u) f !== "default" && Object.prototype.hasOwnProperty.call(u, f) && e(d, u, f);
      return n(d, u), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SampleType$ = t.SampleType$outboundSchema = t.SampleType$inboundSchema = t.SampleType = void 0;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ eu();
    t.SampleType = {
      Pretrain: "pretrain",
      Instruct: "instruct",
      BatchRequest: "batch_request",
      BatchResult: "batch_result",
      BatchError: "batch_error"
    }, t.SampleType$inboundSchema = r.union([
      r.nativeEnum(t.SampleType),
      r.string().transform(i.catchUnrecognizedEnum)
    ]), t.SampleType$outboundSchema = r.union([
      r.nativeEnum(t.SampleType),
      r.string().and(r.custom())
    ]);
    var s;
    (function(u) {
      u.inboundSchema = t.SampleType$inboundSchema, u.outboundSchema = t.SampleType$outboundSchema;
    })(s || (t.SampleType$ = s = {}));
  }(Ei)), Ei;
}
var Ii = {}, kS;
function Pp() {
  return kS || (kS = 1, function(t) {
    var e = Ii && Ii.__createBinding || (Object.create ? function(u, d, f, o) {
      o === void 0 && (o = f);
      var c = Object.getOwnPropertyDescriptor(d, f);
      (!c || ("get" in c ? !d.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return d[f];
      } }), Object.defineProperty(u, o, c);
    } : function(u, d, f, o) {
      o === void 0 && (o = f), u[o] = d[f];
    }), n = Ii && Ii.__setModuleDefault || (Object.create ? function(u, d) {
      Object.defineProperty(u, "default", { enumerable: !0, value: d });
    } : function(u, d) {
      u.default = d;
    }), a = Ii && Ii.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var d = {};
      if (u != null) for (var f in u) f !== "default" && Object.prototype.hasOwnProperty.call(u, f) && e(d, u, f);
      return n(d, u), d;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Source$ = t.Source$outboundSchema = t.Source$inboundSchema = t.Source = void 0;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ eu();
    t.Source = {
      Upload: "upload",
      Repository: "repository",
      Mistral: "mistral"
    }, t.Source$inboundSchema = r.union([
      r.nativeEnum(t.Source),
      r.string().transform(i.catchUnrecognizedEnum)
    ]), t.Source$outboundSchema = r.union([
      r.nativeEnum(t.Source),
      r.string().and(r.custom())
    ]);
    var s;
    (function(u) {
      u.inboundSchema = t.Source$inboundSchema, u.outboundSchema = t.Source$outboundSchema;
    })(s || (t.Source$ = s = {}));
  }(Ii)), Ii;
}
var DS;
function gT() {
  return DS || (DS = 1, function(t) {
    var e = Ai && Ai.__createBinding || (Object.create ? function(p, l, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(l, m);
      (!g || ("get" in g ? !l.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return l[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, l, m, b) {
      b === void 0 && (b = m), p[b] = l[m];
    }), n = Ai && Ai.__setModuleDefault || (Object.create ? function(p, l) {
      Object.defineProperty(p, "default", { enumerable: !0, value: l });
    } : function(p, l) {
      p.default = l;
    }), a = Ai && Ai.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var l = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(l, p, m);
      return n(l, p), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FileSchema$ = t.FileSchema$outboundSchema = t.FileSchema$inboundSchema = void 0, t.fileSchemaToJSON = c, t.fileSchemaFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ Op(), d = /* @__PURE__ */ jp(), f = /* @__PURE__ */ Pp();
    t.FileSchema$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      bytes: r.number().int(),
      created_at: r.number().int(),
      filename: r.string(),
      purpose: u.FilePurpose$inboundSchema,
      sample_type: d.SampleType$inboundSchema,
      num_lines: r.nullable(r.number().int()).optional(),
      source: f.Source$inboundSchema
    }).transform((p) => (0, i.remap)(p, {
      bytes: "sizeBytes",
      created_at: "createdAt",
      sample_type: "sampleType",
      num_lines: "numLines"
    })), t.FileSchema$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      sizeBytes: r.number().int(),
      createdAt: r.number().int(),
      filename: r.string(),
      purpose: u.FilePurpose$outboundSchema,
      sampleType: d.SampleType$outboundSchema,
      numLines: r.nullable(r.number().int()).optional(),
      source: f.Source$outboundSchema
    }).transform((p) => (0, i.remap)(p, {
      sizeBytes: "bytes",
      createdAt: "created_at",
      sampleType: "sample_type",
      numLines: "num_lines"
    }));
    var o;
    (function(p) {
      p.inboundSchema = t.FileSchema$inboundSchema, p.outboundSchema = t.FileSchema$outboundSchema;
    })(o || (t.FileSchema$ = o = {}));
    function c(p) {
      return JSON.stringify(t.FileSchema$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (l) => t.FileSchema$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'FileSchema' from JSON");
    }
  }(Ai)), Ai;
}
var Ni = {}, qS;
function _q() {
  return qS || (qS = 1, function(t) {
    var e = Ni && Ni.__createBinding || (Object.create ? function(f, o, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(o, c);
      (!p || ("get" in p ? !o.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return o[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, o, c, h) {
      h === void 0 && (h = c), f[h] = o[c];
    }), n = Ni && Ni.__setModuleDefault || (Object.create ? function(f, o) {
      Object.defineProperty(f, "default", { enumerable: !0, value: o });
    } : function(f, o) {
      f.default = o;
    }), a = Ni && Ni.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var o = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(o, f, c);
      return n(o, f), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FileSignedURL$ = t.FileSignedURL$outboundSchema = t.FileSignedURL$inboundSchema = void 0, t.fileSignedURLToJSON = u, t.fileSignedURLFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.FileSignedURL$inboundSchema = r.object({
      url: r.string()
    }), t.FileSignedURL$outboundSchema = r.object({
      url: r.string()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.FileSignedURL$inboundSchema, f.outboundSchema = t.FileSignedURL$outboundSchema;
    })(s || (t.FileSignedURL$ = s = {}));
    function u(f) {
      return JSON.stringify(t.FileSignedURL$outboundSchema.parse(f));
    }
    function d(f) {
      return (0, i.safeParse)(f, (o) => t.FileSignedURL$inboundSchema.parse(JSON.parse(o)), "Failed to parse 'FileSignedURL' from JSON");
    }
  }(Ni)), Ni;
}
var Fi = {}, JS;
function yq() {
  return JS || (JS = 1, function(t) {
    var e = Fi && Fi.__createBinding || (Object.create ? function(p, l, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(l, m);
      (!g || ("get" in g ? !l.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return l[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, l, m, b) {
      b === void 0 && (b = m), p[b] = l[m];
    }), n = Fi && Fi.__setModuleDefault || (Object.create ? function(p, l) {
      Object.defineProperty(p, "default", { enumerable: !0, value: l });
    } : function(p, l) {
      p.default = l;
    }), a = Fi && Fi.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var l = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(l, p, m);
      return n(l, p), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FIMCompletionRequest$ = t.FIMCompletionRequest$outboundSchema = t.FIMCompletionRequest$inboundSchema = t.FIMCompletionRequestStop$ = t.FIMCompletionRequestStop$outboundSchema = t.FIMCompletionRequestStop$inboundSchema = void 0, t.fimCompletionRequestStopToJSON = d, t.fimCompletionRequestStopFromJSON = f, t.fimCompletionRequestToJSON = c, t.fimCompletionRequestFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FIMCompletionRequestStop$inboundSchema = r.union([r.string(), r.array(r.string())]), t.FIMCompletionRequestStop$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var u;
    (function(p) {
      p.inboundSchema = t.FIMCompletionRequestStop$inboundSchema, p.outboundSchema = t.FIMCompletionRequestStop$outboundSchema;
    })(u || (t.FIMCompletionRequestStop$ = u = {}));
    function d(p) {
      return JSON.stringify(t.FIMCompletionRequestStop$outboundSchema.parse(p));
    }
    function f(p) {
      return (0, s.safeParse)(p, (l) => t.FIMCompletionRequestStop$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'FIMCompletionRequestStop' from JSON");
    }
    t.FIMCompletionRequest$inboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      top_p: r.number().default(1),
      max_tokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!1),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      random_seed: r.nullable(r.number().int()).optional(),
      prompt: r.string(),
      suffix: r.nullable(r.string()).optional(),
      min_tokens: r.nullable(r.number().int()).optional()
    }).transform((p) => (0, i.remap)(p, {
      top_p: "topP",
      max_tokens: "maxTokens",
      random_seed: "randomSeed",
      min_tokens: "minTokens"
    })), t.FIMCompletionRequest$outboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      topP: r.number().default(1),
      maxTokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!1),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      randomSeed: r.nullable(r.number().int()).optional(),
      prompt: r.string(),
      suffix: r.nullable(r.string()).optional(),
      minTokens: r.nullable(r.number().int()).optional()
    }).transform((p) => (0, i.remap)(p, {
      topP: "top_p",
      maxTokens: "max_tokens",
      randomSeed: "random_seed",
      minTokens: "min_tokens"
    }));
    var o;
    (function(p) {
      p.inboundSchema = t.FIMCompletionRequest$inboundSchema, p.outboundSchema = t.FIMCompletionRequest$outboundSchema;
    })(o || (t.FIMCompletionRequest$ = o = {}));
    function c(p) {
      return JSON.stringify(t.FIMCompletionRequest$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (l) => t.FIMCompletionRequest$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'FIMCompletionRequest' from JSON");
    }
  }(Fi)), Fi;
}
var ki = {}, LS;
function vq() {
  return LS || (LS = 1, function(t) {
    var e = ki && ki.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = ki && ki.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = ki && ki.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FIMCompletionResponse$ = t.FIMCompletionResponse$outboundSchema = t.FIMCompletionResponse$inboundSchema = void 0, t.fimCompletionResponseToJSON = f, t.fimCompletionResponseFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ m_(), u = /* @__PURE__ */ Vd();
    t.FIMCompletionResponse$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      model: r.string(),
      usage: u.UsageInfo$inboundSchema,
      created: r.number().int().optional(),
      choices: r.array(s.ChatCompletionChoice$inboundSchema).optional()
    }), t.FIMCompletionResponse$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      model: r.string(),
      usage: u.UsageInfo$outboundSchema,
      created: r.number().int().optional(),
      choices: r.array(s.ChatCompletionChoice$outboundSchema).optional()
    });
    var d;
    (function(c) {
      c.inboundSchema = t.FIMCompletionResponse$inboundSchema, c.outboundSchema = t.FIMCompletionResponse$outboundSchema;
    })(d || (t.FIMCompletionResponse$ = d = {}));
    function f(c) {
      return JSON.stringify(t.FIMCompletionResponse$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, i.safeParse)(c, (h) => t.FIMCompletionResponse$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'FIMCompletionResponse' from JSON");
    }
  }(ki)), ki;
}
var Di = {}, US;
function wq() {
  return US || (US = 1, function(t) {
    var e = Di && Di.__createBinding || (Object.create ? function(p, l, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(l, m);
      (!g || ("get" in g ? !l.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return l[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, l, m, b) {
      b === void 0 && (b = m), p[b] = l[m];
    }), n = Di && Di.__setModuleDefault || (Object.create ? function(p, l) {
      Object.defineProperty(p, "default", { enumerable: !0, value: l });
    } : function(p, l) {
      p.default = l;
    }), a = Di && Di.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var l = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(l, p, m);
      return n(l, p), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FIMCompletionStreamRequest$ = t.FIMCompletionStreamRequest$outboundSchema = t.FIMCompletionStreamRequest$inboundSchema = t.FIMCompletionStreamRequestStop$ = t.FIMCompletionStreamRequestStop$outboundSchema = t.FIMCompletionStreamRequestStop$inboundSchema = void 0, t.fimCompletionStreamRequestStopToJSON = d, t.fimCompletionStreamRequestStopFromJSON = f, t.fimCompletionStreamRequestToJSON = c, t.fimCompletionStreamRequestFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FIMCompletionStreamRequestStop$inboundSchema = r.union([r.string(), r.array(r.string())]), t.FIMCompletionStreamRequestStop$outboundSchema = r.union([r.string(), r.array(r.string())]);
    var u;
    (function(p) {
      p.inboundSchema = t.FIMCompletionStreamRequestStop$inboundSchema, p.outboundSchema = t.FIMCompletionStreamRequestStop$outboundSchema;
    })(u || (t.FIMCompletionStreamRequestStop$ = u = {}));
    function d(p) {
      return JSON.stringify(t.FIMCompletionStreamRequestStop$outboundSchema.parse(p));
    }
    function f(p) {
      return (0, s.safeParse)(p, (l) => t.FIMCompletionStreamRequestStop$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'FIMCompletionStreamRequestStop' from JSON");
    }
    t.FIMCompletionStreamRequest$inboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      top_p: r.number().default(1),
      max_tokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!0),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      random_seed: r.nullable(r.number().int()).optional(),
      prompt: r.string(),
      suffix: r.nullable(r.string()).optional(),
      min_tokens: r.nullable(r.number().int()).optional()
    }).transform((p) => (0, i.remap)(p, {
      top_p: "topP",
      max_tokens: "maxTokens",
      random_seed: "randomSeed",
      min_tokens: "minTokens"
    })), t.FIMCompletionStreamRequest$outboundSchema = r.object({
      model: r.string(),
      temperature: r.nullable(r.number()).optional(),
      topP: r.number().default(1),
      maxTokens: r.nullable(r.number().int()).optional(),
      stream: r.boolean().default(!0),
      stop: r.union([r.string(), r.array(r.string())]).optional(),
      randomSeed: r.nullable(r.number().int()).optional(),
      prompt: r.string(),
      suffix: r.nullable(r.string()).optional(),
      minTokens: r.nullable(r.number().int()).optional()
    }).transform((p) => (0, i.remap)(p, {
      topP: "top_p",
      maxTokens: "max_tokens",
      randomSeed: "random_seed",
      minTokens: "min_tokens"
    }));
    var o;
    (function(p) {
      p.inboundSchema = t.FIMCompletionStreamRequest$inboundSchema, p.outboundSchema = t.FIMCompletionStreamRequest$outboundSchema;
    })(o || (t.FIMCompletionStreamRequest$ = o = {}));
    function c(p) {
      return JSON.stringify(t.FIMCompletionStreamRequest$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (l) => t.FIMCompletionStreamRequest$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'FIMCompletionStreamRequest' from JSON");
    }
  }(Di)), Di;
}
var qi = {}, BS;
function _T() {
  return BS || (BS = 1, function(t) {
    var e = qi && qi.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = qi && qi.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = qi && qi.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FTModelCapabilitiesOut$ = t.FTModelCapabilitiesOut$outboundSchema = t.FTModelCapabilitiesOut$inboundSchema = void 0, t.ftModelCapabilitiesOutToJSON = d, t.ftModelCapabilitiesOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FTModelCapabilitiesOut$inboundSchema = r.object({
      completion_chat: r.boolean().default(!0),
      completion_fim: r.boolean().default(!1),
      function_calling: r.boolean().default(!1),
      fine_tuning: r.boolean().default(!1)
    }).transform((o) => (0, i.remap)(o, {
      completion_chat: "completionChat",
      completion_fim: "completionFim",
      function_calling: "functionCalling",
      fine_tuning: "fineTuning"
    })), t.FTModelCapabilitiesOut$outboundSchema = r.object({
      completionChat: r.boolean().default(!0),
      completionFim: r.boolean().default(!1),
      functionCalling: r.boolean().default(!1),
      fineTuning: r.boolean().default(!1)
    }).transform((o) => (0, i.remap)(o, {
      completionChat: "completion_chat",
      completionFim: "completion_fim",
      functionCalling: "function_calling",
      fineTuning: "fine_tuning"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.FTModelCapabilitiesOut$inboundSchema, o.outboundSchema = t.FTModelCapabilitiesOut$outboundSchema;
    })(u || (t.FTModelCapabilitiesOut$ = u = {}));
    function d(o) {
      return JSON.stringify(t.FTModelCapabilitiesOut$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.FTModelCapabilitiesOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'FTModelCapabilitiesOut' from JSON");
    }
  }(qi)), qi;
}
var Ji = {}, xS;
function yT() {
  return xS || (xS = 1, function(t) {
    var e = Ji && Ji.__createBinding || (Object.create ? function(h, p, l, m) {
      m === void 0 && (m = l);
      var b = Object.getOwnPropertyDescriptor(p, l);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[l];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, l, m) {
      m === void 0 && (m = l), h[m] = p[l];
    }), n = Ji && Ji.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = Ji && Ji.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var l in h) l !== "default" && Object.prototype.hasOwnProperty.call(h, l) && e(p, h, l);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FTModelCard$ = t.FTModelCard$outboundSchema = t.FTModelCard$inboundSchema = t.FTModelCardType$ = t.FTModelCardType$outboundSchema = t.FTModelCardType$inboundSchema = t.FTModelCardType = void 0, t.ftModelCardToJSON = o, t.ftModelCardFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ p_();
    t.FTModelCardType = {
      FineTuned: "fine-tuned"
    }, t.FTModelCardType$inboundSchema = r.nativeEnum(t.FTModelCardType), t.FTModelCardType$outboundSchema = t.FTModelCardType$inboundSchema;
    var d;
    (function(h) {
      h.inboundSchema = t.FTModelCardType$inboundSchema, h.outboundSchema = t.FTModelCardType$outboundSchema;
    })(d || (t.FTModelCardType$ = d = {})), t.FTModelCard$inboundSchema = r.object({
      id: r.string(),
      object: r.string().default("model"),
      created: r.number().int().optional(),
      owned_by: r.string().default("mistralai"),
      capabilities: u.ModelCapabilities$inboundSchema,
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional(),
      max_context_length: r.number().int().default(32768),
      aliases: r.array(r.string()).optional(),
      deprecation: r.nullable(r.string().datetime({ offset: !0 }).transform((h) => new Date(h))).optional(),
      default_model_temperature: r.nullable(r.number()).optional(),
      type: r.literal("fine-tuned").default("fine-tuned"),
      job: r.string(),
      root: r.string(),
      archived: r.boolean().default(!1)
    }).transform((h) => (0, i.remap)(h, {
      owned_by: "ownedBy",
      max_context_length: "maxContextLength",
      default_model_temperature: "defaultModelTemperature"
    })), t.FTModelCard$outboundSchema = r.object({
      id: r.string(),
      object: r.string().default("model"),
      created: r.number().int().optional(),
      ownedBy: r.string().default("mistralai"),
      capabilities: u.ModelCapabilities$outboundSchema,
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional(),
      maxContextLength: r.number().int().default(32768),
      aliases: r.array(r.string()).optional(),
      deprecation: r.nullable(r.date().transform((h) => h.toISOString())).optional(),
      defaultModelTemperature: r.nullable(r.number()).optional(),
      type: r.literal("fine-tuned").default("fine-tuned"),
      job: r.string(),
      root: r.string(),
      archived: r.boolean().default(!1)
    }).transform((h) => (0, i.remap)(h, {
      ownedBy: "owned_by",
      maxContextLength: "max_context_length",
      defaultModelTemperature: "default_model_temperature"
    }));
    var f;
    (function(h) {
      h.inboundSchema = t.FTModelCard$inboundSchema, h.outboundSchema = t.FTModelCard$outboundSchema;
    })(f || (t.FTModelCard$ = f = {}));
    function o(h) {
      return JSON.stringify(t.FTModelCard$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, s.safeParse)(h, (p) => t.FTModelCard$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'FTModelCard' from JSON");
    }
  }(Ji)), Ji;
}
var Li = {}, VS;
function Sq() {
  return VS || (VS = 1, function(t) {
    var e = Li && Li.__createBinding || (Object.create ? function(h, p, l, m) {
      m === void 0 && (m = l);
      var b = Object.getOwnPropertyDescriptor(p, l);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[l];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, l, m) {
      m === void 0 && (m = l), h[m] = p[l];
    }), n = Li && Li.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = Li && Li.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var l in h) l !== "default" && Object.prototype.hasOwnProperty.call(h, l) && e(p, h, l);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FTModelOut$ = t.FTModelOut$outboundSchema = t.FTModelOut$inboundSchema = t.FTModelOutObject$ = t.FTModelOutObject$outboundSchema = t.FTModelOutObject$inboundSchema = t.FTModelOutObject = void 0, t.ftModelOutToJSON = o, t.ftModelOutFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ _T();
    t.FTModelOutObject = {
      Model: "model"
    }, t.FTModelOutObject$inboundSchema = r.nativeEnum(t.FTModelOutObject), t.FTModelOutObject$outboundSchema = t.FTModelOutObject$inboundSchema;
    var d;
    (function(h) {
      h.inboundSchema = t.FTModelOutObject$inboundSchema, h.outboundSchema = t.FTModelOutObject$outboundSchema;
    })(d || (t.FTModelOutObject$ = d = {})), t.FTModelOut$inboundSchema = r.object({
      id: r.string(),
      object: r.literal("model").default("model"),
      created: r.number().int(),
      owned_by: r.string(),
      root: r.string(),
      archived: r.boolean(),
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional(),
      capabilities: u.FTModelCapabilitiesOut$inboundSchema,
      max_context_length: r.number().int().default(32768),
      aliases: r.array(r.string()).optional(),
      job: r.string()
    }).transform((h) => (0, i.remap)(h, {
      owned_by: "ownedBy",
      max_context_length: "maxContextLength"
    })), t.FTModelOut$outboundSchema = r.object({
      id: r.string(),
      object: r.literal("model").default("model"),
      created: r.number().int(),
      ownedBy: r.string(),
      root: r.string(),
      archived: r.boolean(),
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional(),
      capabilities: u.FTModelCapabilitiesOut$outboundSchema,
      maxContextLength: r.number().int().default(32768),
      aliases: r.array(r.string()).optional(),
      job: r.string()
    }).transform((h) => (0, i.remap)(h, {
      ownedBy: "owned_by",
      maxContextLength: "max_context_length"
    }));
    var f;
    (function(h) {
      h.inboundSchema = t.FTModelOut$inboundSchema, h.outboundSchema = t.FTModelOut$outboundSchema;
    })(f || (t.FTModelOut$ = f = {}));
    function o(h) {
      return JSON.stringify(t.FTModelOut$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, s.safeParse)(h, (p) => t.FTModelOut$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'FTModelOut' from JSON");
    }
  }(Li)), Li;
}
var Ui = {}, zS;
function vT() {
  return zS || (zS = 1, function(t) {
    var e = Ui && Ui.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Ui && Ui.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Ui && Ui.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.GithubRepositoryIn$ = t.GithubRepositoryIn$outboundSchema = t.GithubRepositoryIn$inboundSchema = t.GithubRepositoryInType$ = t.GithubRepositoryInType$outboundSchema = t.GithubRepositoryInType$inboundSchema = t.GithubRepositoryInType = void 0, t.githubRepositoryInToJSON = d, t.githubRepositoryInFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.GithubRepositoryInType = {
      Github: "github"
    }, t.GithubRepositoryInType$inboundSchema = r.nativeEnum(t.GithubRepositoryInType), t.GithubRepositoryInType$outboundSchema = t.GithubRepositoryInType$inboundSchema;
    var s;
    (function(o) {
      o.inboundSchema = t.GithubRepositoryInType$inboundSchema, o.outboundSchema = t.GithubRepositoryInType$outboundSchema;
    })(s || (t.GithubRepositoryInType$ = s = {})), t.GithubRepositoryIn$inboundSchema = r.object({
      type: r.literal("github").default("github"),
      name: r.string(),
      owner: r.string(),
      ref: r.nullable(r.string()).optional(),
      weight: r.number().default(1),
      token: r.string()
    }), t.GithubRepositoryIn$outboundSchema = r.object({
      type: r.literal("github").default("github"),
      name: r.string(),
      owner: r.string(),
      ref: r.nullable(r.string()).optional(),
      weight: r.number().default(1),
      token: r.string()
    });
    var u;
    (function(o) {
      o.inboundSchema = t.GithubRepositoryIn$inboundSchema, o.outboundSchema = t.GithubRepositoryIn$outboundSchema;
    })(u || (t.GithubRepositoryIn$ = u = {}));
    function d(o) {
      return JSON.stringify(t.GithubRepositoryIn$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, i.safeParse)(o, (c) => t.GithubRepositoryIn$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'GithubRepositoryIn' from JSON");
    }
  }(Ui)), Ui;
}
var Bi = {}, xi = {}, ZS;
function wT() {
  return ZS || (ZS = 1, function(t) {
    var e = xi && xi.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = xi && xi.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = xi && xi.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.TrainingFile$ = t.TrainingFile$outboundSchema = t.TrainingFile$inboundSchema = void 0, t.trainingFileToJSON = d, t.trainingFileFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.TrainingFile$inboundSchema = r.object({
      file_id: r.string(),
      weight: r.number().default(1)
    }).transform((o) => (0, i.remap)(o, {
      file_id: "fileId"
    })), t.TrainingFile$outboundSchema = r.object({
      fileId: r.string(),
      weight: r.number().default(1)
    }).transform((o) => (0, i.remap)(o, {
      fileId: "file_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.TrainingFile$inboundSchema, o.outboundSchema = t.TrainingFile$outboundSchema;
    })(u || (t.TrainingFile$ = u = {}));
    function d(o) {
      return JSON.stringify(t.TrainingFile$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.TrainingFile$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'TrainingFile' from JSON");
    }
  }(xi)), xi;
}
var Vi = {}, KS;
function ST() {
  return KS || (KS = 1, function(t) {
    var e = Vi && Vi.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Vi && Vi.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Vi && Vi.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.TrainingParametersIn$ = t.TrainingParametersIn$outboundSchema = t.TrainingParametersIn$inboundSchema = void 0, t.trainingParametersInToJSON = d, t.trainingParametersInFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.TrainingParametersIn$inboundSchema = r.object({
      training_steps: r.nullable(r.number().int()).optional(),
      learning_rate: r.number().default(1e-4),
      weight_decay: r.nullable(r.number()).optional(),
      warmup_fraction: r.nullable(r.number()).optional(),
      epochs: r.nullable(r.number()).optional(),
      fim_ratio: r.nullable(r.number()).optional(),
      seq_len: r.nullable(r.number().int()).optional()
    }).transform((o) => (0, i.remap)(o, {
      training_steps: "trainingSteps",
      learning_rate: "learningRate",
      weight_decay: "weightDecay",
      warmup_fraction: "warmupFraction",
      fim_ratio: "fimRatio",
      seq_len: "seqLen"
    })), t.TrainingParametersIn$outboundSchema = r.object({
      trainingSteps: r.nullable(r.number().int()).optional(),
      learningRate: r.number().default(1e-4),
      weightDecay: r.nullable(r.number()).optional(),
      warmupFraction: r.nullable(r.number()).optional(),
      epochs: r.nullable(r.number()).optional(),
      fimRatio: r.nullable(r.number()).optional(),
      seqLen: r.nullable(r.number().int()).optional()
    }).transform((o) => (0, i.remap)(o, {
      trainingSteps: "training_steps",
      learningRate: "learning_rate",
      weightDecay: "weight_decay",
      warmupFraction: "warmup_fraction",
      fimRatio: "fim_ratio",
      seqLen: "seq_len"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.TrainingParametersIn$inboundSchema, o.outboundSchema = t.TrainingParametersIn$outboundSchema;
    })(u || (t.TrainingParametersIn$ = u = {}));
    function d(o) {
      return JSON.stringify(t.TrainingParametersIn$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.TrainingParametersIn$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'TrainingParametersIn' from JSON");
    }
  }(Vi)), Vi;
}
var zi = {}, HS;
function OT() {
  return HS || (HS = 1, function(t) {
    var e = zi && zi.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = zi && zi.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = zi && zi.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.WandbIntegration$ = t.WandbIntegration$outboundSchema = t.WandbIntegration$inboundSchema = t.WandbIntegrationType$ = t.WandbIntegrationType$outboundSchema = t.WandbIntegrationType$inboundSchema = t.WandbIntegrationType = void 0, t.wandbIntegrationToJSON = f, t.wandbIntegrationFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.WandbIntegrationType = {
      Wandb: "wandb"
    }, t.WandbIntegrationType$inboundSchema = r.nativeEnum(t.WandbIntegrationType), t.WandbIntegrationType$outboundSchema = t.WandbIntegrationType$inboundSchema;
    var u;
    (function(c) {
      c.inboundSchema = t.WandbIntegrationType$inboundSchema, c.outboundSchema = t.WandbIntegrationType$outboundSchema;
    })(u || (t.WandbIntegrationType$ = u = {})), t.WandbIntegration$inboundSchema = r.object({
      type: r.literal("wandb").default("wandb"),
      project: r.string(),
      name: r.nullable(r.string()).optional(),
      api_key: r.string(),
      run_name: r.nullable(r.string()).optional()
    }).transform((c) => (0, i.remap)(c, {
      api_key: "apiKey",
      run_name: "runName"
    })), t.WandbIntegration$outboundSchema = r.object({
      type: r.literal("wandb").default("wandb"),
      project: r.string(),
      name: r.nullable(r.string()).optional(),
      apiKey: r.string(),
      runName: r.nullable(r.string()).optional()
    }).transform((c) => (0, i.remap)(c, {
      apiKey: "api_key",
      runName: "run_name"
    }));
    var d;
    (function(c) {
      c.inboundSchema = t.WandbIntegration$inboundSchema, c.outboundSchema = t.WandbIntegration$outboundSchema;
    })(d || (t.WandbIntegration$ = d = {}));
    function f(c) {
      return JSON.stringify(t.WandbIntegration$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, s.safeParse)(c, (h) => t.WandbIntegration$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'WandbIntegration' from JSON");
    }
  }(zi)), zi;
}
var GS;
function Oq() {
  return GS || (GS = 1, function(t) {
    var e = Bi && Bi.__createBinding || (Object.create ? function(R, C, T, O) {
      O === void 0 && (O = T);
      var A = Object.getOwnPropertyDescriptor(C, T);
      (!A || ("get" in A ? !C.__esModule : A.writable || A.configurable)) && (A = { enumerable: !0, get: function() {
        return C[T];
      } }), Object.defineProperty(R, O, A);
    } : function(R, C, T, O) {
      O === void 0 && (O = T), R[O] = C[T];
    }), n = Bi && Bi.__setModuleDefault || (Object.create ? function(R, C) {
      Object.defineProperty(R, "default", { enumerable: !0, value: C });
    } : function(R, C) {
      R.default = C;
    }), a = Bi && Bi.__importStar || function(R) {
      if (R && R.__esModule) return R;
      var C = {};
      if (R != null) for (var T in R) T !== "default" && Object.prototype.hasOwnProperty.call(R, T) && e(C, R, T);
      return n(C, R), C;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobIn$ = t.JobIn$outboundSchema = t.JobIn$inboundSchema = t.JobInRepositories$ = t.JobInRepositories$outboundSchema = t.JobInRepositories$inboundSchema = t.JobInIntegrations$ = t.JobInIntegrations$outboundSchema = t.JobInIntegrations$inboundSchema = void 0, t.jobInIntegrationsToJSON = h, t.jobInIntegrationsFromJSON = p, t.jobInRepositoriesToJSON = m, t.jobInRepositoriesFromJSON = b, t.jobInToJSON = _, t.jobInFromJSON = P;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ vT(), d = /* @__PURE__ */ wT(), f = /* @__PURE__ */ ST(), o = /* @__PURE__ */ OT();
    t.JobInIntegrations$inboundSchema = o.WandbIntegration$inboundSchema, t.JobInIntegrations$outboundSchema = o.WandbIntegration$outboundSchema;
    var c;
    (function(R) {
      R.inboundSchema = t.JobInIntegrations$inboundSchema, R.outboundSchema = t.JobInIntegrations$outboundSchema;
    })(c || (t.JobInIntegrations$ = c = {}));
    function h(R) {
      return JSON.stringify(t.JobInIntegrations$outboundSchema.parse(R));
    }
    function p(R) {
      return (0, s.safeParse)(R, (C) => t.JobInIntegrations$inboundSchema.parse(JSON.parse(C)), "Failed to parse 'JobInIntegrations' from JSON");
    }
    t.JobInRepositories$inboundSchema = u.GithubRepositoryIn$inboundSchema, t.JobInRepositories$outboundSchema = u.GithubRepositoryIn$outboundSchema;
    var l;
    (function(R) {
      R.inboundSchema = t.JobInRepositories$inboundSchema, R.outboundSchema = t.JobInRepositories$outboundSchema;
    })(l || (t.JobInRepositories$ = l = {}));
    function m(R) {
      return JSON.stringify(t.JobInRepositories$outboundSchema.parse(R));
    }
    function b(R) {
      return (0, s.safeParse)(R, (C) => t.JobInRepositories$inboundSchema.parse(JSON.parse(C)), "Failed to parse 'JobInRepositories' from JSON");
    }
    t.JobIn$inboundSchema = r.object({
      model: r.string(),
      training_files: r.array(d.TrainingFile$inboundSchema).optional(),
      validation_files: r.nullable(r.array(r.string())).optional(),
      hyperparameters: f.TrainingParametersIn$inboundSchema,
      suffix: r.nullable(r.string()).optional(),
      integrations: r.nullable(r.array(o.WandbIntegration$inboundSchema)).optional(),
      repositories: r.array(u.GithubRepositoryIn$inboundSchema).optional(),
      auto_start: r.boolean().optional()
    }).transform((R) => (0, i.remap)(R, {
      training_files: "trainingFiles",
      validation_files: "validationFiles",
      auto_start: "autoStart"
    })), t.JobIn$outboundSchema = r.object({
      model: r.string(),
      trainingFiles: r.array(d.TrainingFile$outboundSchema).optional(),
      validationFiles: r.nullable(r.array(r.string())).optional(),
      hyperparameters: f.TrainingParametersIn$outboundSchema,
      suffix: r.nullable(r.string()).optional(),
      integrations: r.nullable(r.array(o.WandbIntegration$outboundSchema)).optional(),
      repositories: r.array(u.GithubRepositoryIn$outboundSchema).optional(),
      autoStart: r.boolean().optional()
    }).transform((R) => (0, i.remap)(R, {
      trainingFiles: "training_files",
      validationFiles: "validation_files",
      autoStart: "auto_start"
    }));
    var g;
    (function(R) {
      R.inboundSchema = t.JobIn$inboundSchema, R.outboundSchema = t.JobIn$outboundSchema;
    })(g || (t.JobIn$ = g = {}));
    function _(R) {
      return JSON.stringify(t.JobIn$outboundSchema.parse(R));
    }
    function P(R) {
      return (0, s.safeParse)(R, (C) => t.JobIn$inboundSchema.parse(JSON.parse(C)), "Failed to parse 'JobIn' from JSON");
    }
  }(Bi)), Bi;
}
var Zi = {}, WS;
function jT() {
  return WS || (WS = 1, function(t) {
    var e = Zi && Zi.__createBinding || (Object.create ? function(T, O, A, M) {
      M === void 0 && (M = A);
      var I = Object.getOwnPropertyDescriptor(O, A);
      (!I || ("get" in I ? !O.__esModule : I.writable || I.configurable)) && (I = { enumerable: !0, get: function() {
        return O[A];
      } }), Object.defineProperty(T, M, I);
    } : function(T, O, A, M) {
      M === void 0 && (M = A), T[M] = O[A];
    }), n = Zi && Zi.__setModuleDefault || (Object.create ? function(T, O) {
      Object.defineProperty(T, "default", { enumerable: !0, value: O });
    } : function(T, O) {
      T.default = O;
    }), a = Zi && Zi.__importStar || function(T) {
      if (T && T.__esModule) return T;
      var O = {};
      if (T != null) for (var A in T) A !== "default" && Object.prototype.hasOwnProperty.call(T, A) && e(O, T, A);
      return n(O, T), O;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobOut$ = t.JobOut$outboundSchema = t.JobOut$inboundSchema = t.Repositories$ = t.Repositories$outboundSchema = t.Repositories$inboundSchema = t.Integrations$ = t.Integrations$outboundSchema = t.Integrations$inboundSchema = t.ObjectT$ = t.ObjectT$outboundSchema = t.ObjectT$inboundSchema = t.Status$ = t.Status$outboundSchema = t.Status$inboundSchema = t.ObjectT = t.Status = void 0, t.integrationsToJSON = l, t.integrationsFromJSON = m, t.repositoriesToJSON = g, t.repositoriesFromJSON = _, t.jobOutToJSON = R, t.jobOutFromJSON = C;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ b_(), d = /* @__PURE__ */ g_(), f = /* @__PURE__ */ __(), o = /* @__PURE__ */ y_();
    t.Status = {
      Queued: "QUEUED",
      Started: "STARTED",
      Validating: "VALIDATING",
      Validated: "VALIDATED",
      Running: "RUNNING",
      FailedValidation: "FAILED_VALIDATION",
      Failed: "FAILED",
      Success: "SUCCESS",
      Cancelled: "CANCELLED",
      CancellationRequested: "CANCELLATION_REQUESTED"
    }, t.ObjectT = {
      Job: "job"
    }, t.Status$inboundSchema = r.nativeEnum(t.Status), t.Status$outboundSchema = t.Status$inboundSchema;
    var c;
    (function(T) {
      T.inboundSchema = t.Status$inboundSchema, T.outboundSchema = t.Status$outboundSchema;
    })(c || (t.Status$ = c = {})), t.ObjectT$inboundSchema = r.nativeEnum(t.ObjectT), t.ObjectT$outboundSchema = t.ObjectT$inboundSchema;
    var h;
    (function(T) {
      T.inboundSchema = t.ObjectT$inboundSchema, T.outboundSchema = t.ObjectT$outboundSchema;
    })(h || (t.ObjectT$ = h = {})), t.Integrations$inboundSchema = o.WandbIntegrationOut$inboundSchema, t.Integrations$outboundSchema = o.WandbIntegrationOut$outboundSchema;
    var p;
    (function(T) {
      T.inboundSchema = t.Integrations$inboundSchema, T.outboundSchema = t.Integrations$outboundSchema;
    })(p || (t.Integrations$ = p = {}));
    function l(T) {
      return JSON.stringify(t.Integrations$outboundSchema.parse(T));
    }
    function m(T) {
      return (0, s.safeParse)(T, (O) => t.Integrations$inboundSchema.parse(JSON.parse(O)), "Failed to parse 'Integrations' from JSON");
    }
    t.Repositories$inboundSchema = u.GithubRepositoryOut$inboundSchema, t.Repositories$outboundSchema = u.GithubRepositoryOut$outboundSchema;
    var b;
    (function(T) {
      T.inboundSchema = t.Repositories$inboundSchema, T.outboundSchema = t.Repositories$outboundSchema;
    })(b || (t.Repositories$ = b = {}));
    function g(T) {
      return JSON.stringify(t.Repositories$outboundSchema.parse(T));
    }
    function _(T) {
      return (0, s.safeParse)(T, (O) => t.Repositories$inboundSchema.parse(JSON.parse(O)), "Failed to parse 'Repositories' from JSON");
    }
    t.JobOut$inboundSchema = r.object({
      id: r.string(),
      auto_start: r.boolean(),
      hyperparameters: f.TrainingParameters$inboundSchema,
      model: r.string(),
      status: t.Status$inboundSchema,
      job_type: r.string(),
      created_at: r.number().int(),
      modified_at: r.number().int(),
      training_files: r.array(r.string()),
      validation_files: r.nullable(r.array(r.string())).optional(),
      object: r.literal("job").default("job"),
      fine_tuned_model: r.nullable(r.string()).optional(),
      suffix: r.nullable(r.string()).optional(),
      integrations: r.nullable(r.array(o.WandbIntegrationOut$inboundSchema)).optional(),
      trained_tokens: r.nullable(r.number().int()).optional(),
      repositories: r.array(u.GithubRepositoryOut$inboundSchema).optional(),
      metadata: r.nullable(d.JobMetadataOut$inboundSchema).optional()
    }).transform((T) => (0, i.remap)(T, {
      auto_start: "autoStart",
      job_type: "jobType",
      created_at: "createdAt",
      modified_at: "modifiedAt",
      training_files: "trainingFiles",
      validation_files: "validationFiles",
      fine_tuned_model: "fineTunedModel",
      trained_tokens: "trainedTokens"
    })), t.JobOut$outboundSchema = r.object({
      id: r.string(),
      autoStart: r.boolean(),
      hyperparameters: f.TrainingParameters$outboundSchema,
      model: r.string(),
      status: t.Status$outboundSchema,
      jobType: r.string(),
      createdAt: r.number().int(),
      modifiedAt: r.number().int(),
      trainingFiles: r.array(r.string()),
      validationFiles: r.nullable(r.array(r.string())).optional(),
      object: r.literal("job").default("job"),
      fineTunedModel: r.nullable(r.string()).optional(),
      suffix: r.nullable(r.string()).optional(),
      integrations: r.nullable(r.array(o.WandbIntegrationOut$outboundSchema)).optional(),
      trainedTokens: r.nullable(r.number().int()).optional(),
      repositories: r.array(u.GithubRepositoryOut$outboundSchema).optional(),
      metadata: r.nullable(d.JobMetadataOut$outboundSchema).optional()
    }).transform((T) => (0, i.remap)(T, {
      autoStart: "auto_start",
      jobType: "job_type",
      createdAt: "created_at",
      modifiedAt: "modified_at",
      trainingFiles: "training_files",
      validationFiles: "validation_files",
      fineTunedModel: "fine_tuned_model",
      trainedTokens: "trained_tokens"
    }));
    var P;
    (function(T) {
      T.inboundSchema = t.JobOut$inboundSchema, T.outboundSchema = t.JobOut$outboundSchema;
    })(P || (t.JobOut$ = P = {}));
    function R(T) {
      return JSON.stringify(t.JobOut$outboundSchema.parse(T));
    }
    function C(T) {
      return (0, s.safeParse)(T, (O) => t.JobOut$inboundSchema.parse(JSON.parse(O)), "Failed to parse 'JobOut' from JSON");
    }
  }(Zi)), Zi;
}
var Ki = {}, XS;
function jq() {
  return XS || (XS = 1, function(t) {
    var e = Ki && Ki.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = Ki && Ki.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Ki && Ki.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsOut$ = t.JobsOut$outboundSchema = t.JobsOut$inboundSchema = t.JobsOutObject$ = t.JobsOutObject$outboundSchema = t.JobsOutObject$inboundSchema = t.JobsOutObject = void 0, t.jobsOutToJSON = f, t.jobsOutFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ jT();
    t.JobsOutObject = {
      List: "list"
    }, t.JobsOutObject$inboundSchema = r.nativeEnum(t.JobsOutObject), t.JobsOutObject$outboundSchema = t.JobsOutObject$inboundSchema;
    var u;
    (function(c) {
      c.inboundSchema = t.JobsOutObject$inboundSchema, c.outboundSchema = t.JobsOutObject$outboundSchema;
    })(u || (t.JobsOutObject$ = u = {})), t.JobsOut$inboundSchema = r.object({
      data: r.array(s.JobOut$inboundSchema).optional(),
      object: r.literal("list").default("list"),
      total: r.number().int()
    }), t.JobsOut$outboundSchema = r.object({
      data: r.array(s.JobOut$outboundSchema).optional(),
      object: r.literal("list").default("list"),
      total: r.number().int()
    });
    var d;
    (function(c) {
      c.inboundSchema = t.JobsOut$inboundSchema, c.outboundSchema = t.JobsOut$outboundSchema;
    })(d || (t.JobsOut$ = d = {}));
    function f(c) {
      return JSON.stringify(t.JobsOut$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, i.safeParse)(c, (h) => t.JobsOut$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'JobsOut' from JSON");
    }
  }(Ki)), Ki;
}
var Hi = {}, QS;
function Pq() {
  return QS || (QS = 1, function(t) {
    var e = Hi && Hi.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = Hi && Hi.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Hi && Hi.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.LegacyJobMetadataOut$ = t.LegacyJobMetadataOut$outboundSchema = t.LegacyJobMetadataOut$inboundSchema = t.LegacyJobMetadataOutObject$ = t.LegacyJobMetadataOutObject$outboundSchema = t.LegacyJobMetadataOutObject$inboundSchema = t.LegacyJobMetadataOutObject = void 0, t.legacyJobMetadataOutToJSON = f, t.legacyJobMetadataOutFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.LegacyJobMetadataOutObject = {
      JobMetadata: "job.metadata"
    }, t.LegacyJobMetadataOutObject$inboundSchema = r.nativeEnum(t.LegacyJobMetadataOutObject), t.LegacyJobMetadataOutObject$outboundSchema = t.LegacyJobMetadataOutObject$inboundSchema;
    var u;
    (function(c) {
      c.inboundSchema = t.LegacyJobMetadataOutObject$inboundSchema, c.outboundSchema = t.LegacyJobMetadataOutObject$outboundSchema;
    })(u || (t.LegacyJobMetadataOutObject$ = u = {})), t.LegacyJobMetadataOut$inboundSchema = r.object({
      expected_duration_seconds: r.nullable(r.number().int()).optional(),
      cost: r.nullable(r.number()).optional(),
      cost_currency: r.nullable(r.string()).optional(),
      train_tokens_per_step: r.nullable(r.number().int()).optional(),
      train_tokens: r.nullable(r.number().int()).optional(),
      data_tokens: r.nullable(r.number().int()).optional(),
      estimated_start_time: r.nullable(r.number().int()).optional(),
      deprecated: r.boolean().default(!0),
      details: r.string(),
      epochs: r.nullable(r.number()).optional(),
      training_steps: r.nullable(r.number().int()).optional(),
      object: r.literal("job.metadata").default("job.metadata")
    }).transform((c) => (0, i.remap)(c, {
      expected_duration_seconds: "expectedDurationSeconds",
      cost_currency: "costCurrency",
      train_tokens_per_step: "trainTokensPerStep",
      train_tokens: "trainTokens",
      data_tokens: "dataTokens",
      estimated_start_time: "estimatedStartTime",
      training_steps: "trainingSteps"
    })), t.LegacyJobMetadataOut$outboundSchema = r.object({
      expectedDurationSeconds: r.nullable(r.number().int()).optional(),
      cost: r.nullable(r.number()).optional(),
      costCurrency: r.nullable(r.string()).optional(),
      trainTokensPerStep: r.nullable(r.number().int()).optional(),
      trainTokens: r.nullable(r.number().int()).optional(),
      dataTokens: r.nullable(r.number().int()).optional(),
      estimatedStartTime: r.nullable(r.number().int()).optional(),
      deprecated: r.boolean().default(!0),
      details: r.string(),
      epochs: r.nullable(r.number()).optional(),
      trainingSteps: r.nullable(r.number().int()).optional(),
      object: r.literal("job.metadata").default("job.metadata")
    }).transform((c) => (0, i.remap)(c, {
      expectedDurationSeconds: "expected_duration_seconds",
      costCurrency: "cost_currency",
      trainTokensPerStep: "train_tokens_per_step",
      trainTokens: "train_tokens",
      dataTokens: "data_tokens",
      estimatedStartTime: "estimated_start_time",
      trainingSteps: "training_steps"
    }));
    var d;
    (function(c) {
      c.inboundSchema = t.LegacyJobMetadataOut$inboundSchema, c.outboundSchema = t.LegacyJobMetadataOut$outboundSchema;
    })(d || (t.LegacyJobMetadataOut$ = d = {}));
    function f(c) {
      return JSON.stringify(t.LegacyJobMetadataOut$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, s.safeParse)(c, (h) => t.LegacyJobMetadataOut$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'LegacyJobMetadataOut' from JSON");
    }
  }(Hi)), Hi;
}
var Gi = {}, YS;
function Cq() {
  return YS || (YS = 1, function(t) {
    var e = Gi && Gi.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Gi && Gi.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Gi && Gi.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ListFilesOut$ = t.ListFilesOut$outboundSchema = t.ListFilesOut$inboundSchema = void 0, t.listFilesOutToJSON = d, t.listFilesOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ gT();
    t.ListFilesOut$inboundSchema = r.object({
      data: r.array(s.FileSchema$inboundSchema),
      object: r.string(),
      total: r.number().int()
    }), t.ListFilesOut$outboundSchema = r.object({
      data: r.array(s.FileSchema$outboundSchema),
      object: r.string(),
      total: r.number().int()
    });
    var u;
    (function(o) {
      o.inboundSchema = t.ListFilesOut$inboundSchema, o.outboundSchema = t.ListFilesOut$outboundSchema;
    })(u || (t.ListFilesOut$ = u = {}));
    function d(o) {
      return JSON.stringify(t.ListFilesOut$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, i.safeParse)(o, (c) => t.ListFilesOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'ListFilesOut' from JSON");
    }
  }(Gi)), Gi;
}
var Wi = {}, eO;
function Rq() {
  return eO || (eO = 1, function(t) {
    var e = Wi && Wi.__createBinding || (Object.create ? function(l, m, b, g) {
      g === void 0 && (g = b);
      var _ = Object.getOwnPropertyDescriptor(m, b);
      (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
        return m[b];
      } }), Object.defineProperty(l, g, _);
    } : function(l, m, b, g) {
      g === void 0 && (g = b), l[g] = m[b];
    }), n = Wi && Wi.__setModuleDefault || (Object.create ? function(l, m) {
      Object.defineProperty(l, "default", { enumerable: !0, value: m });
    } : function(l, m) {
      l.default = m;
    }), a = Wi && Wi.__importStar || function(l) {
      if (l && l.__esModule) return l;
      var m = {};
      if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && e(m, l, b);
      return n(m, l), m;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ModelList$ = t.ModelList$outboundSchema = t.ModelList$inboundSchema = t.Data$ = t.Data$outboundSchema = t.Data$inboundSchema = void 0, t.dataToJSON = f, t.dataFromJSON = o, t.modelListToJSON = h, t.modelListFromJSON = p;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ iT(), u = /* @__PURE__ */ yT();
    t.Data$inboundSchema = r.union([
      s.BaseModelCard$inboundSchema.and(r.object({ type: r.literal("base") }).transform((l) => ({
        type: l.type
      }))),
      u.FTModelCard$inboundSchema.and(r.object({ type: r.literal("fine-tuned") }).transform((l) => ({
        type: l.type
      })))
    ]), t.Data$outboundSchema = r.union([
      s.BaseModelCard$outboundSchema.and(r.object({ type: r.literal("base") }).transform((l) => ({
        type: l.type
      }))),
      u.FTModelCard$outboundSchema.and(r.object({ type: r.literal("fine-tuned") }).transform((l) => ({
        type: l.type
      })))
    ]);
    var d;
    (function(l) {
      l.inboundSchema = t.Data$inboundSchema, l.outboundSchema = t.Data$outboundSchema;
    })(d || (t.Data$ = d = {}));
    function f(l) {
      return JSON.stringify(t.Data$outboundSchema.parse(l));
    }
    function o(l) {
      return (0, i.safeParse)(l, (m) => t.Data$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'Data' from JSON");
    }
    t.ModelList$inboundSchema = r.object({
      object: r.string().default("list"),
      data: r.array(r.union([
        s.BaseModelCard$inboundSchema.and(r.object({ type: r.literal("base") }).transform((l) => ({
          type: l.type
        }))),
        u.FTModelCard$inboundSchema.and(r.object({ type: r.literal("fine-tuned") }).transform((l) => ({
          type: l.type
        })))
      ])).optional()
    }), t.ModelList$outboundSchema = r.object({
      object: r.string().default("list"),
      data: r.array(r.union([
        s.BaseModelCard$outboundSchema.and(r.object({ type: r.literal("base") }).transform((l) => ({
          type: l.type
        }))),
        u.FTModelCard$outboundSchema.and(r.object({ type: r.literal("fine-tuned") }).transform((l) => ({
          type: l.type
        })))
      ])).optional()
    });
    var c;
    (function(l) {
      l.inboundSchema = t.ModelList$inboundSchema, l.outboundSchema = t.ModelList$outboundSchema;
    })(c || (t.ModelList$ = c = {}));
    function h(l) {
      return JSON.stringify(t.ModelList$outboundSchema.parse(l));
    }
    function p(l) {
      return (0, i.safeParse)(l, (m) => t.ModelList$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'ModelList' from JSON");
    }
  }(Wi)), Wi;
}
var Xi = {}, tO;
function PT() {
  return tO || (tO = 1, function(t) {
    var e = Xi && Xi.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Xi && Xi.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Xi && Xi.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.OCRImageObject$ = t.OCRImageObject$outboundSchema = t.OCRImageObject$inboundSchema = void 0, t.ocrImageObjectToJSON = d, t.ocrImageObjectFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.OCRImageObject$inboundSchema = r.object({
      id: r.string(),
      top_left_x: r.nullable(r.number().int()),
      top_left_y: r.nullable(r.number().int()),
      bottom_right_x: r.nullable(r.number().int()),
      bottom_right_y: r.nullable(r.number().int()),
      image_base64: r.nullable(r.string()).optional()
    }).transform((o) => (0, i.remap)(o, {
      top_left_x: "topLeftX",
      top_left_y: "topLeftY",
      bottom_right_x: "bottomRightX",
      bottom_right_y: "bottomRightY",
      image_base64: "imageBase64"
    })), t.OCRImageObject$outboundSchema = r.object({
      id: r.string(),
      topLeftX: r.nullable(r.number().int()),
      topLeftY: r.nullable(r.number().int()),
      bottomRightX: r.nullable(r.number().int()),
      bottomRightY: r.nullable(r.number().int()),
      imageBase64: r.nullable(r.string()).optional()
    }).transform((o) => (0, i.remap)(o, {
      topLeftX: "top_left_x",
      topLeftY: "top_left_y",
      bottomRightX: "bottom_right_x",
      bottomRightY: "bottom_right_y",
      imageBase64: "image_base64"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.OCRImageObject$inboundSchema, o.outboundSchema = t.OCRImageObject$outboundSchema;
    })(u || (t.OCRImageObject$ = u = {}));
    function d(o) {
      return JSON.stringify(t.OCRImageObject$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.OCRImageObject$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'OCRImageObject' from JSON");
    }
  }(Xi)), Xi;
}
var Qi = {}, nO;
function CT() {
  return nO || (nO = 1, function(t) {
    var e = Qi && Qi.__createBinding || (Object.create ? function(f, o, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(o, c);
      (!p || ("get" in p ? !o.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return o[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, o, c, h) {
      h === void 0 && (h = c), f[h] = o[c];
    }), n = Qi && Qi.__setModuleDefault || (Object.create ? function(f, o) {
      Object.defineProperty(f, "default", { enumerable: !0, value: o });
    } : function(f, o) {
      f.default = o;
    }), a = Qi && Qi.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var o = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(o, f, c);
      return n(o, f), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.OCRPageDimensions$ = t.OCRPageDimensions$outboundSchema = t.OCRPageDimensions$inboundSchema = void 0, t.ocrPageDimensionsToJSON = u, t.ocrPageDimensionsFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.OCRPageDimensions$inboundSchema = r.object({
      dpi: r.number().int(),
      height: r.number().int(),
      width: r.number().int()
    }), t.OCRPageDimensions$outboundSchema = r.object({
      dpi: r.number().int(),
      height: r.number().int(),
      width: r.number().int()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.OCRPageDimensions$inboundSchema, f.outboundSchema = t.OCRPageDimensions$outboundSchema;
    })(s || (t.OCRPageDimensions$ = s = {}));
    function u(f) {
      return JSON.stringify(t.OCRPageDimensions$outboundSchema.parse(f));
    }
    function d(f) {
      return (0, i.safeParse)(f, (o) => t.OCRPageDimensions$inboundSchema.parse(JSON.parse(o)), "Failed to parse 'OCRPageDimensions' from JSON");
    }
  }(Qi)), Qi;
}
var Yi = {}, rO;
function RT() {
  return rO || (rO = 1, function(t) {
    var e = Yi && Yi.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = Yi && Yi.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Yi && Yi.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.OCRPageObject$ = t.OCRPageObject$outboundSchema = t.OCRPageObject$inboundSchema = void 0, t.ocrPageObjectToJSON = f, t.ocrPageObjectFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ PT(), u = /* @__PURE__ */ CT();
    t.OCRPageObject$inboundSchema = r.object({
      index: r.number().int(),
      markdown: r.string(),
      images: r.array(s.OCRImageObject$inboundSchema),
      dimensions: r.nullable(u.OCRPageDimensions$inboundSchema)
    }), t.OCRPageObject$outboundSchema = r.object({
      index: r.number().int(),
      markdown: r.string(),
      images: r.array(s.OCRImageObject$outboundSchema),
      dimensions: r.nullable(u.OCRPageDimensions$outboundSchema)
    });
    var d;
    (function(c) {
      c.inboundSchema = t.OCRPageObject$inboundSchema, c.outboundSchema = t.OCRPageObject$outboundSchema;
    })(d || (t.OCRPageObject$ = d = {}));
    function f(c) {
      return JSON.stringify(t.OCRPageObject$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, i.safeParse)(c, (h) => t.OCRPageObject$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'OCRPageObject' from JSON");
    }
  }(Yi)), Yi;
}
var es = {}, aO;
function Tq() {
  return aO || (aO = 1, function(t) {
    var e = es && es.__createBinding || (Object.create ? function(m, b, g, _) {
      _ === void 0 && (_ = g);
      var P = Object.getOwnPropertyDescriptor(b, g);
      (!P || ("get" in P ? !b.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
        return b[g];
      } }), Object.defineProperty(m, _, P);
    } : function(m, b, g, _) {
      _ === void 0 && (_ = g), m[_] = b[g];
    }), n = es && es.__setModuleDefault || (Object.create ? function(m, b) {
      Object.defineProperty(m, "default", { enumerable: !0, value: b });
    } : function(m, b) {
      m.default = b;
    }), a = es && es.__importStar || function(m) {
      if (m && m.__esModule) return m;
      var b = {};
      if (m != null) for (var g in m) g !== "default" && Object.prototype.hasOwnProperty.call(m, g) && e(b, m, g);
      return n(b, m), b;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.OCRRequest$ = t.OCRRequest$outboundSchema = t.OCRRequest$inboundSchema = t.Document$ = t.Document$outboundSchema = t.Document$inboundSchema = void 0, t.documentToJSON = o, t.documentFromJSON = c, t.ocrRequestToJSON = p, t.ocrRequestFromJSON = l;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ l_(), d = /* @__PURE__ */ d_();
    t.Document$inboundSchema = r.union([d.ImageURLChunk$inboundSchema, u.DocumentURLChunk$inboundSchema]), t.Document$outboundSchema = r.union([d.ImageURLChunk$outboundSchema, u.DocumentURLChunk$outboundSchema]);
    var f;
    (function(m) {
      m.inboundSchema = t.Document$inboundSchema, m.outboundSchema = t.Document$outboundSchema;
    })(f || (t.Document$ = f = {}));
    function o(m) {
      return JSON.stringify(t.Document$outboundSchema.parse(m));
    }
    function c(m) {
      return (0, s.safeParse)(m, (b) => t.Document$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'Document' from JSON");
    }
    t.OCRRequest$inboundSchema = r.object({
      model: r.nullable(r.string()),
      id: r.string().optional(),
      document: r.union([
        d.ImageURLChunk$inboundSchema,
        u.DocumentURLChunk$inboundSchema
      ]),
      pages: r.nullable(r.array(r.number().int())).optional(),
      include_image_base64: r.nullable(r.boolean()).optional(),
      image_limit: r.nullable(r.number().int()).optional(),
      image_min_size: r.nullable(r.number().int()).optional()
    }).transform((m) => (0, i.remap)(m, {
      include_image_base64: "includeImageBase64",
      image_limit: "imageLimit",
      image_min_size: "imageMinSize"
    })), t.OCRRequest$outboundSchema = r.object({
      model: r.nullable(r.string()),
      id: r.string().optional(),
      document: r.union([
        d.ImageURLChunk$outboundSchema,
        u.DocumentURLChunk$outboundSchema
      ]),
      pages: r.nullable(r.array(r.number().int())).optional(),
      includeImageBase64: r.nullable(r.boolean()).optional(),
      imageLimit: r.nullable(r.number().int()).optional(),
      imageMinSize: r.nullable(r.number().int()).optional()
    }).transform((m) => (0, i.remap)(m, {
      includeImageBase64: "include_image_base64",
      imageLimit: "image_limit",
      imageMinSize: "image_min_size"
    }));
    var h;
    (function(m) {
      m.inboundSchema = t.OCRRequest$inboundSchema, m.outboundSchema = t.OCRRequest$outboundSchema;
    })(h || (t.OCRRequest$ = h = {}));
    function p(m) {
      return JSON.stringify(t.OCRRequest$outboundSchema.parse(m));
    }
    function l(m) {
      return (0, s.safeParse)(m, (b) => t.OCRRequest$inboundSchema.parse(JSON.parse(b)), "Failed to parse 'OCRRequest' from JSON");
    }
  }(es)), es;
}
var ts = {}, ns = {}, iO;
function TT() {
  return iO || (iO = 1, function(t) {
    var e = ns && ns.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = ns && ns.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = ns && ns.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.OCRUsageInfo$ = t.OCRUsageInfo$outboundSchema = t.OCRUsageInfo$inboundSchema = void 0, t.ocrUsageInfoToJSON = d, t.ocrUsageInfoFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.OCRUsageInfo$inboundSchema = r.object({
      pages_processed: r.number().int(),
      doc_size_bytes: r.nullable(r.number().int()).optional()
    }).transform((o) => (0, i.remap)(o, {
      pages_processed: "pagesProcessed",
      doc_size_bytes: "docSizeBytes"
    })), t.OCRUsageInfo$outboundSchema = r.object({
      pagesProcessed: r.number().int(),
      docSizeBytes: r.nullable(r.number().int()).optional()
    }).transform((o) => (0, i.remap)(o, {
      pagesProcessed: "pages_processed",
      docSizeBytes: "doc_size_bytes"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.OCRUsageInfo$inboundSchema, o.outboundSchema = t.OCRUsageInfo$outboundSchema;
    })(u || (t.OCRUsageInfo$ = u = {}));
    function d(o) {
      return JSON.stringify(t.OCRUsageInfo$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.OCRUsageInfo$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'OCRUsageInfo' from JSON");
    }
  }(ns)), ns;
}
var sO;
function $q() {
  return sO || (sO = 1, function(t) {
    var e = ts && ts.__createBinding || (Object.create ? function(h, p, l, m) {
      m === void 0 && (m = l);
      var b = Object.getOwnPropertyDescriptor(p, l);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[l];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, l, m) {
      m === void 0 && (m = l), h[m] = p[l];
    }), n = ts && ts.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = ts && ts.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var l in h) l !== "default" && Object.prototype.hasOwnProperty.call(h, l) && e(p, h, l);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.OCRResponse$ = t.OCRResponse$outboundSchema = t.OCRResponse$inboundSchema = void 0, t.ocrResponseToJSON = o, t.ocrResponseFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ RT(), d = /* @__PURE__ */ TT();
    t.OCRResponse$inboundSchema = r.object({
      pages: r.array(u.OCRPageObject$inboundSchema),
      model: r.string(),
      usage_info: d.OCRUsageInfo$inboundSchema
    }).transform((h) => (0, i.remap)(h, {
      usage_info: "usageInfo"
    })), t.OCRResponse$outboundSchema = r.object({
      pages: r.array(u.OCRPageObject$outboundSchema),
      model: r.string(),
      usageInfo: d.OCRUsageInfo$outboundSchema
    }).transform((h) => (0, i.remap)(h, {
      usageInfo: "usage_info"
    }));
    var f;
    (function(h) {
      h.inboundSchema = t.OCRResponse$inboundSchema, h.outboundSchema = t.OCRResponse$outboundSchema;
    })(f || (t.OCRResponse$ = f = {}));
    function o(h) {
      return JSON.stringify(t.OCRResponse$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, s.safeParse)(h, (p) => t.OCRResponse$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'OCRResponse' from JSON");
    }
  }(ts)), ts;
}
var rs = {}, oO;
function Mq() {
  return oO || (oO = 1, function(t) {
    var e = rs && rs.__createBinding || (Object.create ? function(p, l, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(l, m);
      (!g || ("get" in g ? !l.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return l[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, l, m, b) {
      b === void 0 && (b = m), p[b] = l[m];
    }), n = rs && rs.__setModuleDefault || (Object.create ? function(p, l) {
      Object.defineProperty(p, "default", { enumerable: !0, value: l });
    } : function(p, l) {
      p.default = l;
    }), a = rs && rs.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var l = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(l, p, m);
      return n(l, p), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.RetrieveFileOut$ = t.RetrieveFileOut$outboundSchema = t.RetrieveFileOut$inboundSchema = void 0, t.retrieveFileOutToJSON = c, t.retrieveFileOutFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ Op(), d = /* @__PURE__ */ jp(), f = /* @__PURE__ */ Pp();
    t.RetrieveFileOut$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      bytes: r.number().int(),
      created_at: r.number().int(),
      filename: r.string(),
      purpose: u.FilePurpose$inboundSchema,
      sample_type: d.SampleType$inboundSchema,
      num_lines: r.nullable(r.number().int()).optional(),
      source: f.Source$inboundSchema,
      deleted: r.boolean()
    }).transform((p) => (0, i.remap)(p, {
      bytes: "sizeBytes",
      created_at: "createdAt",
      sample_type: "sampleType",
      num_lines: "numLines"
    })), t.RetrieveFileOut$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      sizeBytes: r.number().int(),
      createdAt: r.number().int(),
      filename: r.string(),
      purpose: u.FilePurpose$outboundSchema,
      sampleType: d.SampleType$outboundSchema,
      numLines: r.nullable(r.number().int()).optional(),
      source: f.Source$outboundSchema,
      deleted: r.boolean()
    }).transform((p) => (0, i.remap)(p, {
      sizeBytes: "bytes",
      createdAt: "created_at",
      sampleType: "sample_type",
      numLines: "num_lines"
    }));
    var o;
    (function(p) {
      p.inboundSchema = t.RetrieveFileOut$inboundSchema, p.outboundSchema = t.RetrieveFileOut$outboundSchema;
    })(o || (t.RetrieveFileOut$ = o = {}));
    function c(p) {
      return JSON.stringify(t.RetrieveFileOut$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (l) => t.RetrieveFileOut$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'RetrieveFileOut' from JSON");
    }
  }(rs)), rs;
}
var as = {}, uO;
function Aq() {
  return uO || (uO = 1, function(t) {
    var e = as && as.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = as && as.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = as && as.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Security$ = t.Security$outboundSchema = t.Security$inboundSchema = void 0, t.securityToJSON = d, t.securityFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.Security$inboundSchema = r.object({
      ApiKey: r.string().optional()
    }).transform((o) => (0, i.remap)(o, {
      ApiKey: "apiKey"
    })), t.Security$outboundSchema = r.object({
      apiKey: r.string().optional()
    }).transform((o) => (0, i.remap)(o, {
      apiKey: "ApiKey"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.Security$inboundSchema, o.outboundSchema = t.Security$outboundSchema;
    })(u || (t.Security$ = u = {}));
    function d(o) {
      return JSON.stringify(t.Security$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.Security$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'Security' from JSON");
    }
  }(as)), as;
}
var is = {}, cO;
function Eq() {
  return cO || (cO = 1, function(t) {
    var e = is && is.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = is && is.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = is && is.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.UnarchiveFTModelOut$ = t.UnarchiveFTModelOut$outboundSchema = t.UnarchiveFTModelOut$inboundSchema = t.UnarchiveFTModelOutObject$ = t.UnarchiveFTModelOutObject$outboundSchema = t.UnarchiveFTModelOutObject$inboundSchema = t.UnarchiveFTModelOutObject = void 0, t.unarchiveFTModelOutToJSON = d, t.unarchiveFTModelOutFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.UnarchiveFTModelOutObject = {
      Model: "model"
    }, t.UnarchiveFTModelOutObject$inboundSchema = r.nativeEnum(t.UnarchiveFTModelOutObject), t.UnarchiveFTModelOutObject$outboundSchema = t.UnarchiveFTModelOutObject$inboundSchema;
    var s;
    (function(o) {
      o.inboundSchema = t.UnarchiveFTModelOutObject$inboundSchema, o.outboundSchema = t.UnarchiveFTModelOutObject$outboundSchema;
    })(s || (t.UnarchiveFTModelOutObject$ = s = {})), t.UnarchiveFTModelOut$inboundSchema = r.object({
      id: r.string(),
      object: r.literal("model").default("model"),
      archived: r.boolean().default(!1)
    }), t.UnarchiveFTModelOut$outboundSchema = r.object({
      id: r.string(),
      object: r.literal("model").default("model"),
      archived: r.boolean().default(!1)
    });
    var u;
    (function(o) {
      o.inboundSchema = t.UnarchiveFTModelOut$inboundSchema, o.outboundSchema = t.UnarchiveFTModelOut$outboundSchema;
    })(u || (t.UnarchiveFTModelOut$ = u = {}));
    function d(o) {
      return JSON.stringify(t.UnarchiveFTModelOut$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, i.safeParse)(o, (c) => t.UnarchiveFTModelOut$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'UnarchiveFTModelOut' from JSON");
    }
  }(is)), is;
}
var ss = {}, lO;
function Iq() {
  return lO || (lO = 1, function(t) {
    var e = ss && ss.__createBinding || (Object.create ? function(f, o, c, h) {
      h === void 0 && (h = c);
      var p = Object.getOwnPropertyDescriptor(o, c);
      (!p || ("get" in p ? !o.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return o[c];
      } }), Object.defineProperty(f, h, p);
    } : function(f, o, c, h) {
      h === void 0 && (h = c), f[h] = o[c];
    }), n = ss && ss.__setModuleDefault || (Object.create ? function(f, o) {
      Object.defineProperty(f, "default", { enumerable: !0, value: o });
    } : function(f, o) {
      f.default = o;
    }), a = ss && ss.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var o = {};
      if (f != null) for (var c in f) c !== "default" && Object.prototype.hasOwnProperty.call(f, c) && e(o, f, c);
      return n(o, f), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.UpdateFTModelIn$ = t.UpdateFTModelIn$outboundSchema = t.UpdateFTModelIn$inboundSchema = void 0, t.updateFTModelInToJSON = u, t.updateFTModelInFromJSON = d;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.UpdateFTModelIn$inboundSchema = r.object({
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional()
    }), t.UpdateFTModelIn$outboundSchema = r.object({
      name: r.nullable(r.string()).optional(),
      description: r.nullable(r.string()).optional()
    });
    var s;
    (function(f) {
      f.inboundSchema = t.UpdateFTModelIn$inboundSchema, f.outboundSchema = t.UpdateFTModelIn$outboundSchema;
    })(s || (t.UpdateFTModelIn$ = s = {}));
    function u(f) {
      return JSON.stringify(t.UpdateFTModelIn$outboundSchema.parse(f));
    }
    function d(f) {
      return (0, i.safeParse)(f, (o) => t.UpdateFTModelIn$inboundSchema.parse(JSON.parse(o)), "Failed to parse 'UpdateFTModelIn' from JSON");
    }
  }(ss)), ss;
}
var os = {}, dO;
function Nq() {
  return dO || (dO = 1, function(t) {
    var e = os && os.__createBinding || (Object.create ? function(p, l, m, b) {
      b === void 0 && (b = m);
      var g = Object.getOwnPropertyDescriptor(l, m);
      (!g || ("get" in g ? !l.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return l[m];
      } }), Object.defineProperty(p, b, g);
    } : function(p, l, m, b) {
      b === void 0 && (b = m), p[b] = l[m];
    }), n = os && os.__setModuleDefault || (Object.create ? function(p, l) {
      Object.defineProperty(p, "default", { enumerable: !0, value: l });
    } : function(p, l) {
      p.default = l;
    }), a = os && os.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var l = {};
      if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && e(l, p, m);
      return n(l, p), l;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.UploadFileOut$ = t.UploadFileOut$outboundSchema = t.UploadFileOut$inboundSchema = void 0, t.uploadFileOutToJSON = c, t.uploadFileOutFromJSON = h;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ Op(), d = /* @__PURE__ */ jp(), f = /* @__PURE__ */ Pp();
    t.UploadFileOut$inboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      bytes: r.number().int(),
      created_at: r.number().int(),
      filename: r.string(),
      purpose: u.FilePurpose$inboundSchema,
      sample_type: d.SampleType$inboundSchema,
      num_lines: r.nullable(r.number().int()).optional(),
      source: f.Source$inboundSchema
    }).transform((p) => (0, i.remap)(p, {
      bytes: "sizeBytes",
      created_at: "createdAt",
      sample_type: "sampleType",
      num_lines: "numLines"
    })), t.UploadFileOut$outboundSchema = r.object({
      id: r.string(),
      object: r.string(),
      sizeBytes: r.number().int(),
      createdAt: r.number().int(),
      filename: r.string(),
      purpose: u.FilePurpose$outboundSchema,
      sampleType: d.SampleType$outboundSchema,
      numLines: r.nullable(r.number().int()).optional(),
      source: f.Source$outboundSchema
    }).transform((p) => (0, i.remap)(p, {
      sizeBytes: "bytes",
      createdAt: "created_at",
      sampleType: "sample_type",
      numLines: "num_lines"
    }));
    var o;
    (function(p) {
      p.inboundSchema = t.UploadFileOut$inboundSchema, p.outboundSchema = t.UploadFileOut$outboundSchema;
    })(o || (t.UploadFileOut$ = o = {}));
    function c(p) {
      return JSON.stringify(t.UploadFileOut$outboundSchema.parse(p));
    }
    function h(p) {
      return (0, s.safeParse)(p, (l) => t.UploadFileOut$inboundSchema.parse(JSON.parse(l)), "Failed to parse 'UploadFileOut' from JSON");
    }
  }(os)), os;
}
var us = {}, fO;
function Fq() {
  return fO || (fO = 1, function(t) {
    var e = us && us.__createBinding || (Object.create ? function(h, p, l, m) {
      m === void 0 && (m = l);
      var b = Object.getOwnPropertyDescriptor(p, l);
      (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return p[l];
      } }), Object.defineProperty(h, m, b);
    } : function(h, p, l, m) {
      m === void 0 && (m = l), h[m] = p[l];
    }), n = us && us.__setModuleDefault || (Object.create ? function(h, p) {
      Object.defineProperty(h, "default", { enumerable: !0, value: p });
    } : function(h, p) {
      h.default = p;
    }), a = us && us.__importStar || function(h) {
      if (h && h.__esModule) return h;
      var p = {};
      if (h != null) for (var l in h) l !== "default" && Object.prototype.hasOwnProperty.call(h, l) && e(p, h, l);
      return n(p, h), p;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ValidationError$ = t.ValidationError$outboundSchema = t.ValidationError$inboundSchema = t.Loc$ = t.Loc$outboundSchema = t.Loc$inboundSchema = void 0, t.locToJSON = u, t.locFromJSON = d, t.validationErrorToJSON = o, t.validationErrorFromJSON = c;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z();
    t.Loc$inboundSchema = r.union([r.string(), r.number().int()]), t.Loc$outboundSchema = r.union([r.string(), r.number().int()]);
    var s;
    (function(h) {
      h.inboundSchema = t.Loc$inboundSchema, h.outboundSchema = t.Loc$outboundSchema;
    })(s || (t.Loc$ = s = {}));
    function u(h) {
      return JSON.stringify(t.Loc$outboundSchema.parse(h));
    }
    function d(h) {
      return (0, i.safeParse)(h, (p) => t.Loc$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'Loc' from JSON");
    }
    t.ValidationError$inboundSchema = r.object({
      loc: r.array(r.union([r.string(), r.number().int()])),
      msg: r.string(),
      type: r.string()
    }), t.ValidationError$outboundSchema = r.object({
      loc: r.array(r.union([r.string(), r.number().int()])),
      msg: r.string(),
      type: r.string()
    });
    var f;
    (function(h) {
      h.inboundSchema = t.ValidationError$inboundSchema, h.outboundSchema = t.ValidationError$outboundSchema;
    })(f || (t.ValidationError$ = f = {}));
    function o(h) {
      return JSON.stringify(t.ValidationError$outboundSchema.parse(h));
    }
    function c(h) {
      return (0, i.safeParse)(h, (p) => t.ValidationError$inboundSchema.parse(JSON.parse(p)), "Failed to parse 'ValidationError' from JSON");
    }
  }(us)), us;
}
var hO;
function Oe() {
  return hO || (hO = 1, function(t) {
    var e = Co && Co.__createBinding || (Object.create ? function(a, r, i, s) {
      s === void 0 && (s = i);
      var u = Object.getOwnPropertyDescriptor(r, i);
      (!u || ("get" in u ? !r.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
        return r[i];
      } }), Object.defineProperty(a, s, u);
    } : function(a, r, i, s) {
      s === void 0 && (s = i), a[s] = r[i];
    }), n = Co && Co.__exportStar || function(a, r) {
      for (var i in a) i !== "default" && !Object.prototype.hasOwnProperty.call(r, i) && e(r, a, i);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(/* @__PURE__ */ tq(), t), n(/* @__PURE__ */ nq(), t), n(/* @__PURE__ */ aT(), t), n(/* @__PURE__ */ rq(), t), n(/* @__PURE__ */ tu(), t), n(/* @__PURE__ */ iT(), t), n(/* @__PURE__ */ sT(), t), n(/* @__PURE__ */ aq(), t), n(/* @__PURE__ */ uT(), t), n(/* @__PURE__ */ iq(), t), n(/* @__PURE__ */ oT(), t), n(/* @__PURE__ */ m_(), t), n(/* @__PURE__ */ sq(), t), n(/* @__PURE__ */ oq(), t), n(/* @__PURE__ */ uq(), t), n(/* @__PURE__ */ cq(), t), n(/* @__PURE__ */ lT(), t), n(/* @__PURE__ */ dT(), t), n(/* @__PURE__ */ lq(), t), n(/* @__PURE__ */ dq(), t), n(/* @__PURE__ */ pT(), t), n(/* @__PURE__ */ fq(), t), n(/* @__PURE__ */ hT(), t), n(/* @__PURE__ */ qd(), t), n(/* @__PURE__ */ hq(), t), n(/* @__PURE__ */ pq(), t), n(/* @__PURE__ */ fT(), t), n(/* @__PURE__ */ mq(), t), n(/* @__PURE__ */ l_(), t), n(/* @__PURE__ */ bq(), t), n(/* @__PURE__ */ gq(), t), n(/* @__PURE__ */ bT(), t), n(/* @__PURE__ */ mT(), t), n(/* @__PURE__ */ Op(), t), n(/* @__PURE__ */ gT(), t), n(/* @__PURE__ */ _q(), t), n(/* @__PURE__ */ yq(), t), n(/* @__PURE__ */ vq(), t), n(/* @__PURE__ */ wq(), t), n(/* @__PURE__ */ _T(), t), n(/* @__PURE__ */ yT(), t), n(/* @__PURE__ */ Sq(), t), n(/* @__PURE__ */ nT(), t), n(/* @__PURE__ */ YR(), t), n(/* @__PURE__ */ rT(), t), n(/* @__PURE__ */ vT(), t), n(/* @__PURE__ */ b_(), t), n(/* @__PURE__ */ XR(), t), n(/* @__PURE__ */ d_(), t), n(/* @__PURE__ */ Oq(), t), n(/* @__PURE__ */ g_(), t), n(/* @__PURE__ */ jT(), t), n(/* @__PURE__ */ jq(), t), n(/* @__PURE__ */ eT(), t), n(/* @__PURE__ */ Pq(), t), n(/* @__PURE__ */ Cq(), t), n(/* @__PURE__ */ cT(), t), n(/* @__PURE__ */ p_(), t), n(/* @__PURE__ */ Rq(), t), n(/* @__PURE__ */ PT(), t), n(/* @__PURE__ */ CT(), t), n(/* @__PURE__ */ RT(), t), n(/* @__PURE__ */ Tq(), t), n(/* @__PURE__ */ $q(), t), n(/* @__PURE__ */ TT(), t), n(/* @__PURE__ */ Jd(), t), n(/* @__PURE__ */ QR(), t), n(/* @__PURE__ */ Ld(), t), n(/* @__PURE__ */ tT(), t), n(/* @__PURE__ */ Mq(), t), n(/* @__PURE__ */ jp(), t), n(/* @__PURE__ */ Aq(), t), n(/* @__PURE__ */ Pp(), t), n(/* @__PURE__ */ nc(), t), n(/* @__PURE__ */ f_(), t), n(/* @__PURE__ */ Ud(), t), n(/* @__PURE__ */ h_(), t), n(/* @__PURE__ */ Bd(), t), n(/* @__PURE__ */ xd(), t), n(/* @__PURE__ */ rc(), t), n(/* @__PURE__ */ Sp(), t), n(/* @__PURE__ */ wT(), t), n(/* @__PURE__ */ __(), t), n(/* @__PURE__ */ ST(), t), n(/* @__PURE__ */ Eq(), t), n(/* @__PURE__ */ Iq(), t), n(/* @__PURE__ */ Nq(), t), n(/* @__PURE__ */ Vd(), t), n(/* @__PURE__ */ ac(), t), n(/* @__PURE__ */ Fq(), t), n(/* @__PURE__ */ OT(), t), n(/* @__PURE__ */ y_(), t);
  }(Co)), Co;
}
var Ro = {}, cs = {}, pO;
function kq() {
  return pO || (pO = 1, function(t) {
    var e = cs && cs.__createBinding || (Object.create ? function(d, f, o, c) {
      c === void 0 && (c = o);
      var h = Object.getOwnPropertyDescriptor(f, o);
      (!h || ("get" in h ? !f.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
        return f[o];
      } }), Object.defineProperty(d, c, h);
    } : function(d, f, o, c) {
      c === void 0 && (c = o), d[c] = f[o];
    }), n = cs && cs.__setModuleDefault || (Object.create ? function(d, f) {
      Object.defineProperty(d, "default", { enumerable: !0, value: f });
    } : function(d, f) {
      d.default = f;
    }), a = cs && cs.__importStar || function(d) {
      if (d && d.__esModule) return d;
      var f = {};
      if (d != null) for (var o in d) o !== "default" && Object.prototype.hasOwnProperty.call(d, o) && e(f, d, o);
      return n(f, d), f;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.HTTPValidationError$ = t.HTTPValidationError$outboundSchema = t.HTTPValidationError$inboundSchema = t.HTTPValidationError = void 0;
    const r = a(/* @__PURE__ */ H()), i = a(/* @__PURE__ */ Oe());
    class s extends Error {
      constructor(f) {
        const o = "message" in f && typeof f.message == "string" ? f.message : `API error occurred: ${JSON.stringify(f)}`;
        super(o), this.data$ = f, f.detail != null && (this.detail = f.detail), this.name = "HTTPValidationError";
      }
    }
    t.HTTPValidationError = s, t.HTTPValidationError$inboundSchema = r.object({
      detail: r.array(i.ValidationError$inboundSchema).optional()
    }).transform((d) => new s(d)), t.HTTPValidationError$outboundSchema = r.instanceof(s).transform((d) => d.data$).pipe(r.object({
      detail: r.array(i.ValidationError$outboundSchema).optional()
    }));
    var u;
    (function(d) {
      d.inboundSchema = t.HTTPValidationError$inboundSchema, d.outboundSchema = t.HTTPValidationError$outboundSchema;
    })(u || (t.HTTPValidationError$ = u = {}));
  }(cs)), cs;
}
var mO;
function Tn() {
  return mO || (mO = 1, function(t) {
    var e = Ro && Ro.__createBinding || (Object.create ? function(a, r, i, s) {
      s === void 0 && (s = i);
      var u = Object.getOwnPropertyDescriptor(r, i);
      (!u || ("get" in u ? !r.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
        return r[i];
      } }), Object.defineProperty(a, s, u);
    } : function(a, r, i, s) {
      s === void 0 && (s = i), a[s] = r[i];
    }), n = Ro && Ro.__exportStar || function(a, r) {
      for (var i in a) i !== "default" && !Object.prototype.hasOwnProperty.call(r, i) && e(r, a, i);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(/* @__PURE__ */ BR(), t), n(/* @__PURE__ */ kq(), t), n(/* @__PURE__ */ GR(), t), n(/* @__PURE__ */ WR(), t);
  }(Ro)), Ro;
}
var ls = {}, bO;
function De() {
  if (bO) return ls;
  bO = 1;
  var t = ls && ls.__classPrivateFieldSet || function(s, u, d, f, o) {
    if (f === "m") throw new TypeError("Private method is not writable");
    if (f === "a" && !o) throw new TypeError("Private accessor was defined without a setter");
    if (typeof u == "function" ? s !== u || !o : !u.has(s)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return f === "a" ? o.call(s, d) : o ? o.value = d : u.set(s, d), d;
  }, e = ls && ls.__classPrivateFieldGet || function(s, u, d, f) {
    if (d === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof u == "function" ? s !== u || !f : !u.has(s)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return d === "m" ? f : d === "a" ? f.call(s) : f ? f.value : u.get(s);
  }, n, a, r;
  Object.defineProperty(ls, "__esModule", { value: !0 }), ls.APIPromise = void 0;
  class i {
    constructor(u) {
      n.set(this, void 0), a.set(this, void 0), this[r] = "APIPromise", t(this, n, u instanceof Promise ? u : Promise.resolve(u), "f"), t(this, a, u instanceof Promise ? e(this, n, "f").then(([d]) => d) : Promise.resolve(u[0]), "f");
    }
    then(u, d) {
      return e(this, n, "f").then(u ? ([f]) => u(f) : void 0, d);
    }
    catch(u) {
      return e(this, a, "f").catch(u);
    }
    finally(u) {
      return e(this, a, "f").finally(u);
    }
    $inspect() {
      return e(this, n, "f");
    }
  }
  return ls.APIPromise = i, n = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap(), r = Symbol.toStringTag, ls;
}
var gO;
function Dq() {
  if (gO) return vr;
  gO = 1;
  var t = vr && vr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = vr && vr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = vr && vr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(vr, "__esModule", { value: !0 }), vr.agentsComplete = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ Tn()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.AgentsCompletionRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), R = (0, d.pathToFunc)("/v1/agents/completions")(), C = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, u.extractSecurity)(l._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, u.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "agents_completion_v1_agents_completions_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = l._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: R,
      headers: C,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, v = await l._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!v.ok)
      return [v, { status: "request-error", request: N }];
    const F = v.value, L = {
      HttpMeta: { Response: F, Request: N }
    }, [B] = await r.match(r.json(200, f.ChatCompletionResponse$inboundSchema), r.jsonErr(422, o.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(F, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: F }] : [B, { status: "complete", request: N, response: F }];
  }
  return vr;
}
var Sr = {}, _O;
function qq() {
  if (_O) return Sr;
  _O = 1;
  var t = Sr && Sr.__createBinding || (Object.create ? function(b, g, _, P) {
    P === void 0 && (P = _);
    var R = Object.getOwnPropertyDescriptor(g, _);
    (!R || ("get" in R ? !g.__esModule : R.writable || R.configurable)) && (R = { enumerable: !0, get: function() {
      return g[_];
    } }), Object.defineProperty(b, P, R);
  } : function(b, g, _, P) {
    P === void 0 && (P = _), b[P] = g[_];
  }), e = Sr && Sr.__setModuleDefault || (Object.create ? function(b, g) {
    Object.defineProperty(b, "default", { enumerable: !0, value: g });
  } : function(b, g) {
    b.default = g;
  }), n = Sr && Sr.__importStar || function(b) {
    if (b && b.__esModule) return b;
    var g = {};
    if (b != null) for (var _ in b) _ !== "default" && Object.prototype.hasOwnProperty.call(b, _) && t(g, b, _);
    return e(g, b), g;
  };
  Object.defineProperty(Sr, "__esModule", { value: !0 }), Sr.agentsStream = l;
  const a = n(/* @__PURE__ */ H()), r = /* @__PURE__ */ Ne(), i = /* @__PURE__ */ wp(), s = n(/* @__PURE__ */ Fe()), u = /* @__PURE__ */ X(), d = /* @__PURE__ */ Z(), f = /* @__PURE__ */ ke(), o = /* @__PURE__ */ Ee(), c = n(/* @__PURE__ */ Oe()), h = n(/* @__PURE__ */ Tn()), p = /* @__PURE__ */ De();
  function l(b, g, _) {
    return new p.APIPromise(m(b, g, _));
  }
  async function m(b, g, _) {
    const P = (0, d.safeParse)(g, (ie) => c.AgentsCompletionStreamRequest$outboundSchema.parse(ie), "Input validation failed");
    if (!P.ok)
      return [P, { status: "invalid" }];
    const R = P.value, C = (0, r.encodeJSON)("body", R, { explode: !0 }), T = (0, o.pathToFunc)("/v1/agents/completions#stream")(), O = new Headers((0, u.compactMap)({
      "Content-Type": "application/json",
      Accept: "text/event-stream"
    })), A = await (0, f.extractSecurity)(b._options.apiKey), M = A == null ? {} : { apiKey: A }, I = (0, f.resolveGlobalSecurity)(M), N = {
      baseURL: _?.serverURL ?? b._baseURL ?? "",
      operationID: "stream_agents",
      oAuth2Scopes: [],
      resolvedSecurity: I,
      securitySource: b._options.apiKey,
      retryConfig: _?.retries || b._options.retryConfig || { strategy: "none" },
      retryCodes: _?.retryCodes || ["429", "500", "502", "503", "504"]
    }, v = b._createRequest(N, {
      security: I,
      method: "POST",
      baseURL: _?.serverURL,
      path: T,
      headers: O,
      body: C,
      timeoutMs: _?.timeoutMs || b._options.timeoutMs || -1
    }, _);
    if (!v.ok)
      return [v, { status: "invalid" }];
    const F = v.value, L = await b._do(F, {
      context: N,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: N.retryConfig,
      retryCodes: N.retryCodes
    });
    if (!L.ok)
      return [L, { status: "request-error", request: F }];
    const B = L.value, V = {
      HttpMeta: { Response: B, Request: F }
    }, [ue] = await s.match(s.sse(200, a.instanceof(ReadableStream).transform((ie) => new i.EventStream({
      stream: ie,
      decoder(ut) {
        return c.CompletionEvent$inboundSchema.parse(ut);
      }
    })), { sseSentinel: "[DONE]" }), s.jsonErr(422, h.HTTPValidationError$inboundSchema), s.fail("4XX"), s.fail("5XX"))(B, { extraFields: V });
    return ue.ok ? [ue, { status: "complete", request: F, response: B }] : [ue, { status: "complete", request: F, response: B }];
  }
  return Sr;
}
var yO;
function Jq() {
  if (yO) return Mc;
  yO = 1, Object.defineProperty(Mc, "__esModule", { value: !0 }), Mc.Agents = void 0;
  const t = /* @__PURE__ */ Dq(), e = /* @__PURE__ */ qq(), n = /* @__PURE__ */ Rn(), a = /* @__PURE__ */ Vn();
  class r extends n.ClientSDK {
    /**
     * Agents Completion
     */
    async complete(s, u) {
      return (0, a.unwrapAsync)((0, t.agentsComplete)(this, s, u));
    }
    /**
     * Stream Agents completion
     *
     * @remarks
     * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
     */
    async stream(s, u) {
      return (0, a.unwrapAsync)((0, e.agentsStream)(this, s, u));
    }
  }
  return Mc.Agents = r, Mc;
}
var Ec = {}, Ic = {}, Or = {}, To = {}, ds = {}, vO;
function Lq() {
  return vO || (vO = 1, function(t) {
    var e = ds && ds.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = ds && ds.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = ds && ds.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.DeleteModelV1ModelsModelIdDeleteRequest$ = t.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema = t.DeleteModelV1ModelsModelIdDeleteRequest$inboundSchema = void 0, t.deleteModelV1ModelsModelIdDeleteRequestToJSON = d, t.deleteModelV1ModelsModelIdDeleteRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.DeleteModelV1ModelsModelIdDeleteRequest$inboundSchema = r.object({
      model_id: r.string()
    }).transform((o) => (0, i.remap)(o, {
      model_id: "modelId"
    })), t.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema = r.object({
      modelId: r.string()
    }).transform((o) => (0, i.remap)(o, {
      modelId: "model_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.DeleteModelV1ModelsModelIdDeleteRequest$inboundSchema, o.outboundSchema = t.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema;
    })(u || (t.DeleteModelV1ModelsModelIdDeleteRequest$ = u = {}));
    function d(o) {
      return JSON.stringify(t.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.DeleteModelV1ModelsModelIdDeleteRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'DeleteModelV1ModelsModelIdDeleteRequest' from JSON");
    }
  }(ds)), ds;
}
var fs = {}, wO;
function Uq() {
  return wO || (wO = 1, function(t) {
    var e = fs && fs.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = fs && fs.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = fs && fs.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilesApiRoutesDeleteFileRequest$ = t.FilesApiRoutesDeleteFileRequest$outboundSchema = t.FilesApiRoutesDeleteFileRequest$inboundSchema = void 0, t.filesApiRoutesDeleteFileRequestToJSON = d, t.filesApiRoutesDeleteFileRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FilesApiRoutesDeleteFileRequest$inboundSchema = r.object({
      file_id: r.string()
    }).transform((o) => (0, i.remap)(o, {
      file_id: "fileId"
    })), t.FilesApiRoutesDeleteFileRequest$outboundSchema = r.object({
      fileId: r.string()
    }).transform((o) => (0, i.remap)(o, {
      fileId: "file_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.FilesApiRoutesDeleteFileRequest$inboundSchema, o.outboundSchema = t.FilesApiRoutesDeleteFileRequest$outboundSchema;
    })(u || (t.FilesApiRoutesDeleteFileRequest$ = u = {}));
    function d(o) {
      return JSON.stringify(t.FilesApiRoutesDeleteFileRequest$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.FilesApiRoutesDeleteFileRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'FilesApiRoutesDeleteFileRequest' from JSON");
    }
  }(fs)), fs;
}
var hs = {}, SO;
function Bq() {
  return SO || (SO = 1, function(t) {
    var e = hs && hs.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = hs && hs.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = hs && hs.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilesApiRoutesDownloadFileRequest$ = t.FilesApiRoutesDownloadFileRequest$outboundSchema = t.FilesApiRoutesDownloadFileRequest$inboundSchema = void 0, t.filesApiRoutesDownloadFileRequestToJSON = d, t.filesApiRoutesDownloadFileRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FilesApiRoutesDownloadFileRequest$inboundSchema = r.object({
      file_id: r.string()
    }).transform((o) => (0, i.remap)(o, {
      file_id: "fileId"
    })), t.FilesApiRoutesDownloadFileRequest$outboundSchema = r.object({
      fileId: r.string()
    }).transform((o) => (0, i.remap)(o, {
      fileId: "file_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.FilesApiRoutesDownloadFileRequest$inboundSchema, o.outboundSchema = t.FilesApiRoutesDownloadFileRequest$outboundSchema;
    })(u || (t.FilesApiRoutesDownloadFileRequest$ = u = {}));
    function d(o) {
      return JSON.stringify(t.FilesApiRoutesDownloadFileRequest$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.FilesApiRoutesDownloadFileRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'FilesApiRoutesDownloadFileRequest' from JSON");
    }
  }(hs)), hs;
}
var ps = {}, OO;
function xq() {
  return OO || (OO = 1, function(t) {
    var e = ps && ps.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = ps && ps.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = ps && ps.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilesApiRoutesGetSignedUrlRequest$ = t.FilesApiRoutesGetSignedUrlRequest$outboundSchema = t.FilesApiRoutesGetSignedUrlRequest$inboundSchema = void 0, t.filesApiRoutesGetSignedUrlRequestToJSON = d, t.filesApiRoutesGetSignedUrlRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FilesApiRoutesGetSignedUrlRequest$inboundSchema = r.object({
      file_id: r.string(),
      expiry: r.number().int().default(24)
    }).transform((o) => (0, i.remap)(o, {
      file_id: "fileId"
    })), t.FilesApiRoutesGetSignedUrlRequest$outboundSchema = r.object({
      fileId: r.string(),
      expiry: r.number().int().default(24)
    }).transform((o) => (0, i.remap)(o, {
      fileId: "file_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.FilesApiRoutesGetSignedUrlRequest$inboundSchema, o.outboundSchema = t.FilesApiRoutesGetSignedUrlRequest$outboundSchema;
    })(u || (t.FilesApiRoutesGetSignedUrlRequest$ = u = {}));
    function d(o) {
      return JSON.stringify(t.FilesApiRoutesGetSignedUrlRequest$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.FilesApiRoutesGetSignedUrlRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'FilesApiRoutesGetSignedUrlRequest' from JSON");
    }
  }(ps)), ps;
}
var ms = {}, jO;
function Vq() {
  return jO || (jO = 1, function(t) {
    var e = ms && ms.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = ms && ms.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = ms && ms.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilesApiRoutesListFilesRequest$ = t.FilesApiRoutesListFilesRequest$outboundSchema = t.FilesApiRoutesListFilesRequest$inboundSchema = void 0, t.filesApiRoutesListFilesRequestToJSON = f, t.filesApiRoutesListFilesRequestFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = a(/* @__PURE__ */ Oe());
    t.FilesApiRoutesListFilesRequest$inboundSchema = r.object({
      page: r.number().int().default(0),
      page_size: r.number().int().default(100),
      sample_type: r.nullable(r.array(u.SampleType$inboundSchema)).optional(),
      source: r.nullable(r.array(u.Source$inboundSchema)).optional(),
      search: r.nullable(r.string()).optional(),
      purpose: r.nullable(u.FilePurpose$inboundSchema).optional()
    }).transform((c) => (0, i.remap)(c, {
      page_size: "pageSize",
      sample_type: "sampleType"
    })), t.FilesApiRoutesListFilesRequest$outboundSchema = r.object({
      page: r.number().int().default(0),
      pageSize: r.number().int().default(100),
      sampleType: r.nullable(r.array(u.SampleType$outboundSchema)).optional(),
      source: r.nullable(r.array(u.Source$outboundSchema)).optional(),
      search: r.nullable(r.string()).optional(),
      purpose: r.nullable(u.FilePurpose$outboundSchema).optional()
    }).transform((c) => (0, i.remap)(c, {
      pageSize: "page_size",
      sampleType: "sample_type"
    }));
    var d;
    (function(c) {
      c.inboundSchema = t.FilesApiRoutesListFilesRequest$inboundSchema, c.outboundSchema = t.FilesApiRoutesListFilesRequest$outboundSchema;
    })(d || (t.FilesApiRoutesListFilesRequest$ = d = {}));
    function f(c) {
      return JSON.stringify(t.FilesApiRoutesListFilesRequest$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, s.safeParse)(c, (h) => t.FilesApiRoutesListFilesRequest$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'FilesApiRoutesListFilesRequest' from JSON");
    }
  }(ms)), ms;
}
var bs = {}, PO;
function zq() {
  return PO || (PO = 1, function(t) {
    var e = bs && bs.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = bs && bs.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = bs && bs.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilesApiRoutesRetrieveFileRequest$ = t.FilesApiRoutesRetrieveFileRequest$outboundSchema = t.FilesApiRoutesRetrieveFileRequest$inboundSchema = void 0, t.filesApiRoutesRetrieveFileRequestToJSON = d, t.filesApiRoutesRetrieveFileRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.FilesApiRoutesRetrieveFileRequest$inboundSchema = r.object({
      file_id: r.string()
    }).transform((o) => (0, i.remap)(o, {
      file_id: "fileId"
    })), t.FilesApiRoutesRetrieveFileRequest$outboundSchema = r.object({
      fileId: r.string()
    }).transform((o) => (0, i.remap)(o, {
      fileId: "file_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.FilesApiRoutesRetrieveFileRequest$inboundSchema, o.outboundSchema = t.FilesApiRoutesRetrieveFileRequest$outboundSchema;
    })(u || (t.FilesApiRoutesRetrieveFileRequest$ = u = {}));
    function d(o) {
      return JSON.stringify(t.FilesApiRoutesRetrieveFileRequest$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.FilesApiRoutesRetrieveFileRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'FilesApiRoutesRetrieveFileRequest' from JSON");
    }
  }(bs)), bs;
}
var gs = {}, In = {}, CO;
function $T() {
  if (CO) return In;
  CO = 1;
  var t = In && In.__createBinding || (Object.create ? function(i, s, u, d) {
    d === void 0 && (d = u);
    var f = Object.getOwnPropertyDescriptor(s, u);
    (!f || ("get" in f ? !s.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return s[u];
    } }), Object.defineProperty(i, d, f);
  } : function(i, s, u, d) {
    d === void 0 && (d = u), i[d] = s[u];
  }), e = In && In.__setModuleDefault || (Object.create ? function(i, s) {
    Object.defineProperty(i, "default", { enumerable: !0, value: s });
  } : function(i, s) {
    i.default = s;
  }), n = In && In.__importStar || function(i) {
    if (i && i.__esModule) return i;
    var s = {};
    if (i != null) for (var u in i) u !== "default" && Object.prototype.hasOwnProperty.call(i, u) && t(s, i, u);
    return e(s, i), s;
  };
  Object.defineProperty(In, "__esModule", { value: !0 }), In.blobLikeSchema = void 0, In.isBlobLike = r;
  const a = n(/* @__PURE__ */ H());
  In.blobLikeSchema = a.custom(r, {
    message: "expected a Blob, File or Blob-like object",
    fatal: !0
  });
  function r(i) {
    if (i instanceof Blob)
      return !0;
    if (typeof i != "object" || i == null || !(Symbol.toStringTag in i))
      return !1;
    const s = i[Symbol.toStringTag];
    return typeof s != "string" || s !== "Blob" && s !== "File" ? !1 : "stream" in i && typeof i.stream == "function";
  }
  return In;
}
var RO;
function Zq() {
  return RO || (RO = 1, function(t) {
    var e = gs && gs.__createBinding || (Object.create ? function(l, m, b, g) {
      g === void 0 && (g = b);
      var _ = Object.getOwnPropertyDescriptor(m, b);
      (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
        return m[b];
      } }), Object.defineProperty(l, g, _);
    } : function(l, m, b, g) {
      g === void 0 && (g = b), l[g] = m[b];
    }), n = gs && gs.__setModuleDefault || (Object.create ? function(l, m) {
      Object.defineProperty(l, "default", { enumerable: !0, value: m });
    } : function(l, m) {
      l.default = m;
    }), a = gs && gs.__importStar || function(l) {
      if (l && l.__esModule) return l;
      var m = {};
      if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && e(m, l, b);
      return n(m, l), m;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.FilesApiRoutesUploadFileMultiPartBodyParams$ = t.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema = t.FilesApiRoutesUploadFileMultiPartBodyParams$inboundSchema = t.FileT$ = t.FileT$outboundSchema = t.FileT$inboundSchema = void 0, t.fileToJSON = f, t.fileFromJSON = o, t.filesApiRoutesUploadFileMultiPartBodyParamsToJSON = h, t.filesApiRoutesUploadFileMultiPartBodyParamsFromJSON = p;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = /* @__PURE__ */ $T(), u = a(/* @__PURE__ */ Oe());
    t.FileT$inboundSchema = r.object({
      fileName: r.string(),
      content: r.union([
        r.instanceof(ReadableStream),
        r.instanceof(Blob),
        r.instanceof(ArrayBuffer),
        r.instanceof(Uint8Array)
      ])
    }), t.FileT$outboundSchema = r.object({
      fileName: r.string(),
      content: r.union([
        r.instanceof(ReadableStream),
        r.instanceof(Blob),
        r.instanceof(ArrayBuffer),
        r.instanceof(Uint8Array)
      ])
    });
    var d;
    (function(l) {
      l.inboundSchema = t.FileT$inboundSchema, l.outboundSchema = t.FileT$outboundSchema;
    })(d || (t.FileT$ = d = {}));
    function f(l) {
      return JSON.stringify(t.FileT$outboundSchema.parse(l));
    }
    function o(l) {
      return (0, i.safeParse)(l, (m) => t.FileT$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'FileT' from JSON");
    }
    t.FilesApiRoutesUploadFileMultiPartBodyParams$inboundSchema = r.object({
      file: r.lazy(() => t.FileT$inboundSchema),
      purpose: u.FilePurpose$inboundSchema.optional()
    }), t.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema = r.object({
      file: r.lazy(() => t.FileT$outboundSchema).or(s.blobLikeSchema),
      purpose: u.FilePurpose$outboundSchema.optional()
    });
    var c;
    (function(l) {
      l.inboundSchema = t.FilesApiRoutesUploadFileMultiPartBodyParams$inboundSchema, l.outboundSchema = t.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema;
    })(c || (t.FilesApiRoutesUploadFileMultiPartBodyParams$ = c = {}));
    function h(l) {
      return JSON.stringify(t.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema.parse(l));
    }
    function p(l) {
      return (0, i.safeParse)(l, (m) => t.FilesApiRoutesUploadFileMultiPartBodyParams$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'FilesApiRoutesUploadFileMultiPartBodyParams' from JSON");
    }
  }(gs)), gs;
}
var _s = {}, TO;
function Kq() {
  return TO || (TO = 1, function(t) {
    var e = _s && _s.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = _s && _s.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = _s && _s.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesBatchCancelBatchJobRequest$ = t.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema = t.JobsApiRoutesBatchCancelBatchJobRequest$inboundSchema = void 0, t.jobsApiRoutesBatchCancelBatchJobRequestToJSON = d, t.jobsApiRoutesBatchCancelBatchJobRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesBatchCancelBatchJobRequest$inboundSchema = r.object({
      job_id: r.string()
    }).transform((o) => (0, i.remap)(o, {
      job_id: "jobId"
    })), t.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema = r.object({
      jobId: r.string()
    }).transform((o) => (0, i.remap)(o, {
      jobId: "job_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.JobsApiRoutesBatchCancelBatchJobRequest$inboundSchema, o.outboundSchema = t.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema;
    })(u || (t.JobsApiRoutesBatchCancelBatchJobRequest$ = u = {}));
    function d(o) {
      return JSON.stringify(t.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.JobsApiRoutesBatchCancelBatchJobRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesBatchCancelBatchJobRequest' from JSON");
    }
  }(_s)), _s;
}
var ys = {}, $O;
function Hq() {
  return $O || ($O = 1, function(t) {
    var e = ys && ys.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = ys && ys.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = ys && ys.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesBatchGetBatchJobRequest$ = t.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema = t.JobsApiRoutesBatchGetBatchJobRequest$inboundSchema = void 0, t.jobsApiRoutesBatchGetBatchJobRequestToJSON = d, t.jobsApiRoutesBatchGetBatchJobRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesBatchGetBatchJobRequest$inboundSchema = r.object({
      job_id: r.string()
    }).transform((o) => (0, i.remap)(o, {
      job_id: "jobId"
    })), t.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema = r.object({
      jobId: r.string()
    }).transform((o) => (0, i.remap)(o, {
      jobId: "job_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.JobsApiRoutesBatchGetBatchJobRequest$inboundSchema, o.outboundSchema = t.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema;
    })(u || (t.JobsApiRoutesBatchGetBatchJobRequest$ = u = {}));
    function d(o) {
      return JSON.stringify(t.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.JobsApiRoutesBatchGetBatchJobRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesBatchGetBatchJobRequest' from JSON");
    }
  }(ys)), ys;
}
var vs = {}, MO;
function Gq() {
  return MO || (MO = 1, function(t) {
    var e = vs && vs.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = vs && vs.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = vs && vs.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesBatchGetBatchJobsRequest$ = t.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema = t.JobsApiRoutesBatchGetBatchJobsRequest$inboundSchema = void 0, t.jobsApiRoutesBatchGetBatchJobsRequestToJSON = f, t.jobsApiRoutesBatchGetBatchJobsRequestFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = a(/* @__PURE__ */ Oe());
    t.JobsApiRoutesBatchGetBatchJobsRequest$inboundSchema = r.object({
      page: r.number().int().default(0),
      page_size: r.number().int().default(100),
      model: r.nullable(r.string()).optional(),
      metadata: r.nullable(r.record(r.any())).optional(),
      created_after: r.nullable(r.string().datetime({ offset: !0 }).transform((c) => new Date(c))).optional(),
      created_by_me: r.boolean().default(!1),
      status: r.nullable(u.BatchJobStatus$inboundSchema).optional()
    }).transform((c) => (0, i.remap)(c, {
      page_size: "pageSize",
      created_after: "createdAfter",
      created_by_me: "createdByMe"
    })), t.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema = r.object({
      page: r.number().int().default(0),
      pageSize: r.number().int().default(100),
      model: r.nullable(r.string()).optional(),
      metadata: r.nullable(r.record(r.any())).optional(),
      createdAfter: r.nullable(r.date().transform((c) => c.toISOString())).optional(),
      createdByMe: r.boolean().default(!1),
      status: r.nullable(u.BatchJobStatus$outboundSchema).optional()
    }).transform((c) => (0, i.remap)(c, {
      pageSize: "page_size",
      createdAfter: "created_after",
      createdByMe: "created_by_me"
    }));
    var d;
    (function(c) {
      c.inboundSchema = t.JobsApiRoutesBatchGetBatchJobsRequest$inboundSchema, c.outboundSchema = t.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema;
    })(d || (t.JobsApiRoutesBatchGetBatchJobsRequest$ = d = {}));
    function f(c) {
      return JSON.stringify(t.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, s.safeParse)(c, (h) => t.JobsApiRoutesBatchGetBatchJobsRequest$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'JobsApiRoutesBatchGetBatchJobsRequest' from JSON");
    }
  }(vs)), vs;
}
var ws = {}, AO;
function Wq() {
  return AO || (AO = 1, function(t) {
    var e = ws && ws.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = ws && ws.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = ws && ws.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$ = t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema = t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$inboundSchema = void 0, t.jobsApiRoutesFineTuningArchiveFineTunedModelRequestToJSON = d, t.jobsApiRoutesFineTuningArchiveFineTunedModelRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$inboundSchema = r.object({
      model_id: r.string()
    }).transform((o) => (0, i.remap)(o, {
      model_id: "modelId"
    })), t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema = r.object({
      modelId: r.string()
    }).transform((o) => (0, i.remap)(o, {
      modelId: "model_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$inboundSchema, o.outboundSchema = t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema;
    })(u || (t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$ = u = {}));
    function d(o) {
      return JSON.stringify(t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesFineTuningArchiveFineTunedModelRequest' from JSON");
    }
  }(ws)), ws;
}
var Ss = {}, EO;
function Xq() {
  return EO || (EO = 1, function(t) {
    var e = Ss && Ss.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Ss && Ss.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Ss && Ss.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$ = t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema = t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$inboundSchema = void 0, t.jobsApiRoutesFineTuningCancelFineTuningJobRequestToJSON = d, t.jobsApiRoutesFineTuningCancelFineTuningJobRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$inboundSchema = r.object({
      job_id: r.string()
    }).transform((o) => (0, i.remap)(o, {
      job_id: "jobId"
    })), t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema = r.object({
      jobId: r.string()
    }).transform((o) => (0, i.remap)(o, {
      jobId: "job_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$inboundSchema, o.outboundSchema = t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema;
    })(u || (t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$ = u = {}));
    function d(o) {
      return JSON.stringify(t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.JobsApiRoutesFineTuningCancelFineTuningJobRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesFineTuningCancelFineTuningJobRequest' from JSON");
    }
  }(Ss)), Ss;
}
var Os = {}, IO;
function Qq() {
  return IO || (IO = 1, function(t) {
    var e = Os && Os.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Os && Os.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Os && Os.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$ = t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$outboundSchema = t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema = void 0, t.jobsApiRoutesFineTuningCreateFineTuningJobResponseToJSON = d, t.jobsApiRoutesFineTuningCreateFineTuningJobResponseFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ Z(), s = a(/* @__PURE__ */ Oe());
    t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema = r.union([
      s.LegacyJobMetadataOut$inboundSchema,
      s.JobOut$inboundSchema
    ]), t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$outboundSchema = r.union([
      s.LegacyJobMetadataOut$outboundSchema,
      s.JobOut$outboundSchema
    ]);
    var u;
    (function(o) {
      o.inboundSchema = t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema, o.outboundSchema = t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$outboundSchema;
    })(u || (t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$ = u = {}));
    function d(o) {
      return JSON.stringify(t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, i.safeParse)(o, (c) => t.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesFineTuningCreateFineTuningJobResponse' from JSON");
    }
  }(Os)), Os;
}
var js = {}, NO;
function Yq() {
  return NO || (NO = 1, function(t) {
    var e = js && js.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = js && js.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = js && js.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningGetFineTuningJobRequest$ = t.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema = t.JobsApiRoutesFineTuningGetFineTuningJobRequest$inboundSchema = void 0, t.jobsApiRoutesFineTuningGetFineTuningJobRequestToJSON = d, t.jobsApiRoutesFineTuningGetFineTuningJobRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesFineTuningGetFineTuningJobRequest$inboundSchema = r.object({
      job_id: r.string()
    }).transform((o) => (0, i.remap)(o, {
      job_id: "jobId"
    })), t.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema = r.object({
      jobId: r.string()
    }).transform((o) => (0, i.remap)(o, {
      jobId: "job_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.JobsApiRoutesFineTuningGetFineTuningJobRequest$inboundSchema, o.outboundSchema = t.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema;
    })(u || (t.JobsApiRoutesFineTuningGetFineTuningJobRequest$ = u = {}));
    function d(o) {
      return JSON.stringify(t.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.JobsApiRoutesFineTuningGetFineTuningJobRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesFineTuningGetFineTuningJobRequest' from JSON");
    }
  }(js)), js;
}
var Ps = {}, FO;
function eJ() {
  return FO || (FO = 1, function(t) {
    var e = Ps && Ps.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = Ps && Ps.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Ps && Ps.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$ = t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema = t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$inboundSchema = t.Status$ = t.Status$outboundSchema = t.Status$inboundSchema = t.Status = void 0, t.jobsApiRoutesFineTuningGetFineTuningJobsRequestToJSON = f, t.jobsApiRoutesFineTuningGetFineTuningJobsRequestFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.Status = {
      Queued: "QUEUED",
      Started: "STARTED",
      Validating: "VALIDATING",
      Validated: "VALIDATED",
      Running: "RUNNING",
      FailedValidation: "FAILED_VALIDATION",
      Failed: "FAILED",
      Success: "SUCCESS",
      Cancelled: "CANCELLED",
      CancellationRequested: "CANCELLATION_REQUESTED"
    }, t.Status$inboundSchema = r.nativeEnum(t.Status), t.Status$outboundSchema = t.Status$inboundSchema;
    var u;
    (function(c) {
      c.inboundSchema = t.Status$inboundSchema, c.outboundSchema = t.Status$outboundSchema;
    })(u || (t.Status$ = u = {})), t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$inboundSchema = r.object({
      page: r.number().int().default(0),
      page_size: r.number().int().default(100),
      model: r.nullable(r.string()).optional(),
      created_after: r.nullable(r.string().datetime({ offset: !0 }).transform((c) => new Date(c))).optional(),
      created_by_me: r.boolean().default(!1),
      status: r.nullable(t.Status$inboundSchema).optional(),
      wandb_project: r.nullable(r.string()).optional(),
      wandb_name: r.nullable(r.string()).optional(),
      suffix: r.nullable(r.string()).optional()
    }).transform((c) => (0, i.remap)(c, {
      page_size: "pageSize",
      created_after: "createdAfter",
      created_by_me: "createdByMe",
      wandb_project: "wandbProject",
      wandb_name: "wandbName"
    })), t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema = r.object({
      page: r.number().int().default(0),
      pageSize: r.number().int().default(100),
      model: r.nullable(r.string()).optional(),
      createdAfter: r.nullable(r.date().transform((c) => c.toISOString())).optional(),
      createdByMe: r.boolean().default(!1),
      status: r.nullable(t.Status$outboundSchema).optional(),
      wandbProject: r.nullable(r.string()).optional(),
      wandbName: r.nullable(r.string()).optional(),
      suffix: r.nullable(r.string()).optional()
    }).transform((c) => (0, i.remap)(c, {
      pageSize: "page_size",
      createdAfter: "created_after",
      createdByMe: "created_by_me",
      wandbProject: "wandb_project",
      wandbName: "wandb_name"
    }));
    var d;
    (function(c) {
      c.inboundSchema = t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$inboundSchema, c.outboundSchema = t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema;
    })(d || (t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$ = d = {}));
    function f(c) {
      return JSON.stringify(t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, s.safeParse)(c, (h) => t.JobsApiRoutesFineTuningGetFineTuningJobsRequest$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'JobsApiRoutesFineTuningGetFineTuningJobsRequest' from JSON");
    }
  }(Ps)), Ps;
}
var Cs = {}, kO;
function tJ() {
  return kO || (kO = 1, function(t) {
    var e = Cs && Cs.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Cs && Cs.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Cs && Cs.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningStartFineTuningJobRequest$ = t.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema = t.JobsApiRoutesFineTuningStartFineTuningJobRequest$inboundSchema = void 0, t.jobsApiRoutesFineTuningStartFineTuningJobRequestToJSON = d, t.jobsApiRoutesFineTuningStartFineTuningJobRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesFineTuningStartFineTuningJobRequest$inboundSchema = r.object({
      job_id: r.string()
    }).transform((o) => (0, i.remap)(o, {
      job_id: "jobId"
    })), t.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema = r.object({
      jobId: r.string()
    }).transform((o) => (0, i.remap)(o, {
      jobId: "job_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.JobsApiRoutesFineTuningStartFineTuningJobRequest$inboundSchema, o.outboundSchema = t.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema;
    })(u || (t.JobsApiRoutesFineTuningStartFineTuningJobRequest$ = u = {}));
    function d(o) {
      return JSON.stringify(t.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.JobsApiRoutesFineTuningStartFineTuningJobRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesFineTuningStartFineTuningJobRequest' from JSON");
    }
  }(Cs)), Cs;
}
var Rs = {}, DO;
function nJ() {
  return DO || (DO = 1, function(t) {
    var e = Rs && Rs.__createBinding || (Object.create ? function(o, c, h, p) {
      p === void 0 && (p = h);
      var l = Object.getOwnPropertyDescriptor(c, h);
      (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return c[h];
      } }), Object.defineProperty(o, p, l);
    } : function(o, c, h, p) {
      p === void 0 && (p = h), o[p] = c[h];
    }), n = Rs && Rs.__setModuleDefault || (Object.create ? function(o, c) {
      Object.defineProperty(o, "default", { enumerable: !0, value: c });
    } : function(o, c) {
      o.default = c;
    }), a = Rs && Rs.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var c = {};
      if (o != null) for (var h in o) h !== "default" && Object.prototype.hasOwnProperty.call(o, h) && e(c, o, h);
      return n(c, o), c;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$ = t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema = t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$inboundSchema = void 0, t.jobsApiRoutesFineTuningUnarchiveFineTunedModelRequestToJSON = d, t.jobsApiRoutesFineTuningUnarchiveFineTunedModelRequestFromJSON = f;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z();
    t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$inboundSchema = r.object({
      model_id: r.string()
    }).transform((o) => (0, i.remap)(o, {
      model_id: "modelId"
    })), t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema = r.object({
      modelId: r.string()
    }).transform((o) => (0, i.remap)(o, {
      modelId: "model_id"
    }));
    var u;
    (function(o) {
      o.inboundSchema = t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$inboundSchema, o.outboundSchema = t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema;
    })(u || (t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$ = u = {}));
    function d(o) {
      return JSON.stringify(t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema.parse(o));
    }
    function f(o) {
      return (0, s.safeParse)(o, (c) => t.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$inboundSchema.parse(JSON.parse(c)), "Failed to parse 'JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest' from JSON");
    }
  }(Rs)), Rs;
}
var Ts = {}, qO;
function rJ() {
  return qO || (qO = 1, function(t) {
    var e = Ts && Ts.__createBinding || (Object.create ? function(c, h, p, l) {
      l === void 0 && (l = p);
      var m = Object.getOwnPropertyDescriptor(h, p);
      (!m || ("get" in m ? !h.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return h[p];
      } }), Object.defineProperty(c, l, m);
    } : function(c, h, p, l) {
      l === void 0 && (l = p), c[l] = h[p];
    }), n = Ts && Ts.__setModuleDefault || (Object.create ? function(c, h) {
      Object.defineProperty(c, "default", { enumerable: !0, value: h });
    } : function(c, h) {
      c.default = h;
    }), a = Ts && Ts.__importStar || function(c) {
      if (c && c.__esModule) return c;
      var h = {};
      if (c != null) for (var p in c) p !== "default" && Object.prototype.hasOwnProperty.call(c, p) && e(h, c, p);
      return n(h, c), h;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$ = t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema = t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$inboundSchema = void 0, t.jobsApiRoutesFineTuningUpdateFineTunedModelRequestToJSON = f, t.jobsApiRoutesFineTuningUpdateFineTunedModelRequestFromJSON = o;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = a(/* @__PURE__ */ Oe());
    t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$inboundSchema = r.object({
      model_id: r.string(),
      UpdateFTModelIn: u.UpdateFTModelIn$inboundSchema
    }).transform((c) => (0, i.remap)(c, {
      model_id: "modelId",
      UpdateFTModelIn: "updateFTModelIn"
    })), t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema = r.object({
      modelId: r.string(),
      updateFTModelIn: u.UpdateFTModelIn$outboundSchema
    }).transform((c) => (0, i.remap)(c, {
      modelId: "model_id",
      updateFTModelIn: "UpdateFTModelIn"
    }));
    var d;
    (function(c) {
      c.inboundSchema = t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$inboundSchema, c.outboundSchema = t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema;
    })(d || (t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$ = d = {}));
    function f(c) {
      return JSON.stringify(t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema.parse(c));
    }
    function o(c) {
      return (0, s.safeParse)(c, (h) => t.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$inboundSchema.parse(JSON.parse(h)), "Failed to parse 'JobsApiRoutesFineTuningUpdateFineTunedModelRequest' from JSON");
    }
  }(Ts)), Ts;
}
var $s = {}, JO;
function aJ() {
  return JO || (JO = 1, function(t) {
    var e = $s && $s.__createBinding || (Object.create ? function(l, m, b, g) {
      g === void 0 && (g = b);
      var _ = Object.getOwnPropertyDescriptor(m, b);
      (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
        return m[b];
      } }), Object.defineProperty(l, g, _);
    } : function(l, m, b, g) {
      g === void 0 && (g = b), l[g] = m[b];
    }), n = $s && $s.__setModuleDefault || (Object.create ? function(l, m) {
      Object.defineProperty(l, "default", { enumerable: !0, value: m });
    } : function(l, m) {
      l.default = m;
    }), a = $s && $s.__importStar || function(l) {
      if (l && l.__esModule) return l;
      var m = {};
      if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && e(m, l, b);
      return n(m, l), m;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$ = t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$outboundSchema = t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema = t.RetrieveModelV1ModelsModelIdGetRequest$ = t.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema = t.RetrieveModelV1ModelsModelIdGetRequest$inboundSchema = void 0, t.retrieveModelV1ModelsModelIdGetRequestToJSON = f, t.retrieveModelV1ModelsModelIdGetRequestFromJSON = o, t.retrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGetToJSON = h, t.retrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGetFromJSON = p;
    const r = a(/* @__PURE__ */ H()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = a(/* @__PURE__ */ Oe());
    t.RetrieveModelV1ModelsModelIdGetRequest$inboundSchema = r.object({
      model_id: r.string()
    }).transform((l) => (0, i.remap)(l, {
      model_id: "modelId"
    })), t.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema = r.object({
      modelId: r.string()
    }).transform((l) => (0, i.remap)(l, {
      modelId: "model_id"
    }));
    var d;
    (function(l) {
      l.inboundSchema = t.RetrieveModelV1ModelsModelIdGetRequest$inboundSchema, l.outboundSchema = t.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema;
    })(d || (t.RetrieveModelV1ModelsModelIdGetRequest$ = d = {}));
    function f(l) {
      return JSON.stringify(t.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema.parse(l));
    }
    function o(l) {
      return (0, s.safeParse)(l, (m) => t.RetrieveModelV1ModelsModelIdGetRequest$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'RetrieveModelV1ModelsModelIdGetRequest' from JSON");
    }
    t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema = r.union([
      u.BaseModelCard$inboundSchema.and(r.object({ type: r.literal("base") }).transform((l) => ({
        type: l.type
      }))),
      u.FTModelCard$inboundSchema.and(r.object({ type: r.literal("fine-tuned") }).transform((l) => ({
        type: l.type
      })))
    ]), t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$outboundSchema = r.union([
      u.BaseModelCard$outboundSchema.and(r.object({ type: r.literal("base") }).transform((l) => ({
        type: l.type
      }))),
      u.FTModelCard$outboundSchema.and(r.object({ type: r.literal("fine-tuned") }).transform((l) => ({
        type: l.type
      })))
    ]);
    var c;
    (function(l) {
      l.inboundSchema = t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema, l.outboundSchema = t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$outboundSchema;
    })(c || (t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$ = c = {}));
    function h(l) {
      return JSON.stringify(t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$outboundSchema.parse(l));
    }
    function p(l) {
      return (0, s.safeParse)(l, (m) => t.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema.parse(JSON.parse(m)), "Failed to parse 'RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet' from JSON");
    }
  }($s)), $s;
}
var LO;
function yt() {
  return LO || (LO = 1, function(t) {
    var e = To && To.__createBinding || (Object.create ? function(a, r, i, s) {
      s === void 0 && (s = i);
      var u = Object.getOwnPropertyDescriptor(r, i);
      (!u || ("get" in u ? !r.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
        return r[i];
      } }), Object.defineProperty(a, s, u);
    } : function(a, r, i, s) {
      s === void 0 && (s = i), a[s] = r[i];
    }), n = To && To.__exportStar || function(a, r) {
      for (var i in a) i !== "default" && !Object.prototype.hasOwnProperty.call(r, i) && e(r, a, i);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(/* @__PURE__ */ Lq(), t), n(/* @__PURE__ */ Uq(), t), n(/* @__PURE__ */ Bq(), t), n(/* @__PURE__ */ xq(), t), n(/* @__PURE__ */ Vq(), t), n(/* @__PURE__ */ zq(), t), n(/* @__PURE__ */ Zq(), t), n(/* @__PURE__ */ Kq(), t), n(/* @__PURE__ */ Hq(), t), n(/* @__PURE__ */ Gq(), t), n(/* @__PURE__ */ Wq(), t), n(/* @__PURE__ */ Xq(), t), n(/* @__PURE__ */ Qq(), t), n(/* @__PURE__ */ Yq(), t), n(/* @__PURE__ */ eJ(), t), n(/* @__PURE__ */ tJ(), t), n(/* @__PURE__ */ nJ(), t), n(/* @__PURE__ */ rJ(), t), n(/* @__PURE__ */ aJ(), t);
  }(To)), To;
}
var UO;
function iJ() {
  if (UO) return Or;
  UO = 1;
  var t = Or && Or.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Or && Or.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Or && Or.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Or, "__esModule", { value: !0 }), Or.batchJobsCancel = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = {
      job_id: (0, a.encodeSimple)("job_id", _.job_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, d.pathToFunc)("/v1/batch/jobs/{job_id}/cancel")(R), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "jobs_api_routes_batch_cancel_batch_job",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "POST",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.BatchJobOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return Or;
}
var jr = {}, BO;
function sJ() {
  if (BO) return jr;
  BO = 1;
  var t = jr && jr.__createBinding || (Object.create ? function(p, l, m, b) {
    b === void 0 && (b = m);
    var g = Object.getOwnPropertyDescriptor(l, m);
    (!g || ("get" in g ? !l.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
      return l[m];
    } }), Object.defineProperty(p, b, g);
  } : function(p, l, m, b) {
    b === void 0 && (b = m), p[b] = l[m];
  }), e = jr && jr.__setModuleDefault || (Object.create ? function(p, l) {
    Object.defineProperty(p, "default", { enumerable: !0, value: l });
  } : function(p, l) {
    p.default = l;
  }), n = jr && jr.__importStar || function(p) {
    if (p && p.__esModule) return p;
    var l = {};
    if (p != null) for (var m in p) m !== "default" && Object.prototype.hasOwnProperty.call(p, m) && t(l, p, m);
    return e(l, p), l;
  };
  Object.defineProperty(jr, "__esModule", { value: !0 }), jr.batchJobsCreate = c;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = /* @__PURE__ */ De();
  function c(p, l, m) {
    return new o.APIPromise(h(p, l, m));
  }
  async function h(p, l, m) {
    const b = (0, s.safeParse)(l, (L) => f.BatchJobIn$outboundSchema.parse(L), "Input validation failed");
    if (!b.ok)
      return [b, { status: "invalid" }];
    const g = b.value, _ = (0, a.encodeJSON)("body", g, { explode: !0 }), P = (0, d.pathToFunc)("/v1/batch/jobs")(), R = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), C = await (0, u.extractSecurity)(p._options.apiKey), T = C == null ? {} : { apiKey: C }, O = (0, u.resolveGlobalSecurity)(T), A = {
      baseURL: m?.serverURL ?? p._baseURL ?? "",
      operationID: "jobs_api_routes_batch_create_batch_job",
      oAuth2Scopes: [],
      resolvedSecurity: O,
      securitySource: p._options.apiKey,
      retryConfig: m?.retries || p._options.retryConfig || { strategy: "none" },
      retryCodes: m?.retryCodes || ["429", "500", "502", "503", "504"]
    }, M = p._createRequest(A, {
      security: O,
      method: "POST",
      baseURL: m?.serverURL,
      path: P,
      headers: R,
      body: _,
      timeoutMs: m?.timeoutMs || p._options.timeoutMs || -1
    }, m);
    if (!M.ok)
      return [M, { status: "invalid" }];
    const I = M.value, N = await p._do(I, {
      context: A,
      errorCodes: ["4XX", "5XX"],
      retryConfig: A.retryConfig,
      retryCodes: A.retryCodes
    });
    if (!N.ok)
      return [N, { status: "request-error", request: I }];
    const v = N.value, [F] = await r.match(r.json(200, f.BatchJobOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(v);
    return F.ok ? [F, { status: "complete", request: I, response: v }] : [F, { status: "complete", request: I, response: v }];
  }
  return jr;
}
var Pr = {}, xO;
function oJ() {
  if (xO) return Pr;
  xO = 1;
  var t = Pr && Pr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Pr && Pr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Pr && Pr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.batchJobsGet = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = {
      job_id: (0, a.encodeSimple)("job_id", _.job_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, d.pathToFunc)("/v1/batch/jobs/{job_id}")(R), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "jobs_api_routes_batch_get_batch_job",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.BatchJobOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return Pr;
}
var Cr = {}, VO;
function uJ() {
  if (VO) return Cr;
  VO = 1;
  var t = Cr && Cr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Cr && Cr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Cr && Cr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.batchJobsList = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema.optional().parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = (0, d.pathToFunc)("/v1/batch/jobs")(), C = (0, a.encodeFormQuery)({
      created_after: _?.created_after,
      created_by_me: _?.created_by_me,
      metadata: _?.metadata,
      model: _?.model,
      page: _?.page,
      page_size: _?.page_size,
      status: _?.status
    }), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "jobs_api_routes_batch_get_batch_jobs",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      query: C,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.BatchJobsOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return Cr;
}
var zO;
function cJ() {
  if (zO) return Ic;
  zO = 1, Object.defineProperty(Ic, "__esModule", { value: !0 }), Ic.MistralJobs = void 0;
  const t = /* @__PURE__ */ iJ(), e = /* @__PURE__ */ sJ(), n = /* @__PURE__ */ oJ(), a = /* @__PURE__ */ uJ(), r = /* @__PURE__ */ Rn(), i = /* @__PURE__ */ Vn();
  class s extends r.ClientSDK {
    /**
     * Get Batch Jobs
     *
     * @remarks
     * Get a list of batch jobs for your organization and user.
     */
    async list(d, f) {
      return (0, i.unwrapAsync)((0, a.batchJobsList)(this, d, f));
    }
    /**
     * Create Batch Job
     *
     * @remarks
     * Create a new batch job, it will be queued for processing.
     */
    async create(d, f) {
      return (0, i.unwrapAsync)((0, e.batchJobsCreate)(this, d, f));
    }
    /**
     * Get Batch Job
     *
     * @remarks
     * Get a batch job details by its UUID.
     */
    async get(d, f) {
      return (0, i.unwrapAsync)((0, n.batchJobsGet)(this, d, f));
    }
    /**
     * Cancel Batch Job
     *
     * @remarks
     * Request the cancellation of a batch job.
     */
    async cancel(d, f) {
      return (0, i.unwrapAsync)((0, t.batchJobsCancel)(this, d, f));
    }
  }
  return Ic.MistralJobs = s, Ic;
}
var ZO;
function lJ() {
  if (ZO) return Ec;
  ZO = 1, Object.defineProperty(Ec, "__esModule", { value: !0 }), Ec.Batch = void 0;
  const t = /* @__PURE__ */ Rn(), e = /* @__PURE__ */ cJ();
  class n extends t.ClientSDK {
    get jobs() {
      return this._jobs ?? (this._jobs = new e.MistralJobs(this._options));
    }
  }
  return Ec.Batch = n, Ec;
}
var Nc = {}, Rr = {}, KO;
function dJ() {
  if (KO) return Rr;
  KO = 1;
  var t = Rr && Rr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Rr && Rr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Rr && Rr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.chatComplete = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ Tn()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.ChatCompletionRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), R = (0, d.pathToFunc)("/v1/chat/completions")(), C = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, u.extractSecurity)(l._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, u.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "chat_completion_v1_chat_completions_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = l._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: R,
      headers: C,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, v = await l._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!v.ok)
      return [v, { status: "request-error", request: N }];
    const F = v.value, L = {
      HttpMeta: { Response: F, Request: N }
    }, [B] = await r.match(r.json(200, f.ChatCompletionResponse$inboundSchema), r.jsonErr(422, o.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(F, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: F }] : [B, { status: "complete", request: N, response: F }];
  }
  return Rr;
}
var Tr = {}, HO;
function fJ() {
  if (HO) return Tr;
  HO = 1;
  var t = Tr && Tr.__createBinding || (Object.create ? function(b, g, _, P) {
    P === void 0 && (P = _);
    var R = Object.getOwnPropertyDescriptor(g, _);
    (!R || ("get" in R ? !g.__esModule : R.writable || R.configurable)) && (R = { enumerable: !0, get: function() {
      return g[_];
    } }), Object.defineProperty(b, P, R);
  } : function(b, g, _, P) {
    P === void 0 && (P = _), b[P] = g[_];
  }), e = Tr && Tr.__setModuleDefault || (Object.create ? function(b, g) {
    Object.defineProperty(b, "default", { enumerable: !0, value: g });
  } : function(b, g) {
    b.default = g;
  }), n = Tr && Tr.__importStar || function(b) {
    if (b && b.__esModule) return b;
    var g = {};
    if (b != null) for (var _ in b) _ !== "default" && Object.prototype.hasOwnProperty.call(b, _) && t(g, b, _);
    return e(g, b), g;
  };
  Object.defineProperty(Tr, "__esModule", { value: !0 }), Tr.chatStream = l;
  const a = n(/* @__PURE__ */ H()), r = /* @__PURE__ */ Ne(), i = /* @__PURE__ */ wp(), s = n(/* @__PURE__ */ Fe()), u = /* @__PURE__ */ X(), d = /* @__PURE__ */ Z(), f = /* @__PURE__ */ ke(), o = /* @__PURE__ */ Ee(), c = n(/* @__PURE__ */ Oe()), h = n(/* @__PURE__ */ Tn()), p = /* @__PURE__ */ De();
  function l(b, g, _) {
    return new p.APIPromise(m(b, g, _));
  }
  async function m(b, g, _) {
    const P = (0, d.safeParse)(g, (ie) => c.ChatCompletionStreamRequest$outboundSchema.parse(ie), "Input validation failed");
    if (!P.ok)
      return [P, { status: "invalid" }];
    const R = P.value, C = (0, r.encodeJSON)("body", R, { explode: !0 }), T = (0, o.pathToFunc)("/v1/chat/completions#stream")(), O = new Headers((0, u.compactMap)({
      "Content-Type": "application/json",
      Accept: "text/event-stream"
    })), A = await (0, f.extractSecurity)(b._options.apiKey), M = A == null ? {} : { apiKey: A }, I = (0, f.resolveGlobalSecurity)(M), N = {
      baseURL: _?.serverURL ?? b._baseURL ?? "",
      operationID: "stream_chat",
      oAuth2Scopes: [],
      resolvedSecurity: I,
      securitySource: b._options.apiKey,
      retryConfig: _?.retries || b._options.retryConfig || { strategy: "none" },
      retryCodes: _?.retryCodes || ["429", "500", "502", "503", "504"]
    }, v = b._createRequest(N, {
      security: I,
      method: "POST",
      baseURL: _?.serverURL,
      path: T,
      headers: O,
      body: C,
      timeoutMs: _?.timeoutMs || b._options.timeoutMs || -1
    }, _);
    if (!v.ok)
      return [v, { status: "invalid" }];
    const F = v.value, L = await b._do(F, {
      context: N,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: N.retryConfig,
      retryCodes: N.retryCodes
    });
    if (!L.ok)
      return [L, { status: "request-error", request: F }];
    const B = L.value, V = {
      HttpMeta: { Response: B, Request: F }
    }, [ue] = await s.match(s.sse(200, a.instanceof(ReadableStream).transform((ie) => new i.EventStream({
      stream: ie,
      decoder(ut) {
        return c.CompletionEvent$inboundSchema.parse(ut);
      }
    })), { sseSentinel: "[DONE]" }), s.jsonErr(422, h.HTTPValidationError$inboundSchema), s.fail("4XX"), s.fail("5XX"))(B, { extraFields: V });
    return ue.ok ? [ue, { status: "complete", request: F, response: B }] : [ue, { status: "complete", request: F, response: B }];
  }
  return Tr;
}
var bu = {}, $o = {}, Bm = {}, GO;
function v_() {
  return GO || (GO = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.getDefaultOptions = t.defaultOptions = t.jsonDescription = t.ignoreOverride = void 0, t.ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
    const e = (a, r) => {
      if (r.description)
        try {
          return {
            ...a,
            ...JSON.parse(r.description)
          };
        } catch {
        }
      return a;
    };
    t.jsonDescription = e, t.defaultOptions = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      allowedAdditionalProperties: !0,
      rejectedAdditionalProperties: !1,
      definitionPath: "definitions",
      target: "jsonSchema7",
      strictUnions: !1,
      definitions: {},
      errorMessages: !1,
      markdownDescription: !1,
      patternStrategy: "escape",
      applyRegexFlags: !1,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref"
    };
    const n = (a) => typeof a == "string" ? {
      ...t.defaultOptions,
      name: a
    } : {
      ...t.defaultOptions,
      ...a
    };
    t.getDefaultOptions = n;
  }(Bm)), Bm;
}
var Fc = {}, WO;
function MT() {
  if (WO) return Fc;
  WO = 1, Object.defineProperty(Fc, "__esModule", { value: !0 }), Fc.getRefs = void 0;
  const t = /* @__PURE__ */ v_(), e = (n) => {
    const a = (0, t.getDefaultOptions)(n), r = a.name !== void 0 ? [...a.basePath, a.definitionPath, a.name] : a.basePath;
    return {
      ...a,
      currentPath: r,
      propertyPath: void 0,
      seen: new Map(Object.entries(a.definitions).map(([i, s]) => [
        s._def,
        {
          def: s._def,
          path: [...a.basePath, a.definitionPath, i],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ]))
    };
  };
  return Fc.getRefs = e, Fc;
}
var Mo = {}, XO;
function nu() {
  if (XO) return Mo;
  XO = 1, Object.defineProperty(Mo, "__esModule", { value: !0 }), Mo.setResponseValueAndErrors = Mo.addErrorMessage = void 0;
  function t(n, a, r, i) {
    i?.errorMessages && r && (n.errorMessage = {
      ...n.errorMessage,
      [a]: r
    });
  }
  Mo.addErrorMessage = t;
  function e(n, a, r, i, s) {
    n[a] = r, t(n, a, i, s);
  }
  return Mo.setResponseValueAndErrors = e, Mo;
}
var kc = {}, Dc = {}, qc = {}, QO;
function AT() {
  if (QO) return qc;
  QO = 1, Object.defineProperty(qc, "__esModule", { value: !0 }), qc.parseAnyDef = void 0;
  function t() {
    return {};
  }
  return qc.parseAnyDef = t, qc;
}
var Jc = {}, YO;
function ET() {
  if (YO) return Jc;
  YO = 1, Object.defineProperty(Jc, "__esModule", { value: !0 }), Jc.parseArrayDef = void 0;
  const t = /* @__PURE__ */ H(), e = /* @__PURE__ */ nu(), n = /* @__PURE__ */ vt();
  function a(r, i) {
    const s = {
      type: "array"
    };
    return r.type?._def && r.type?._def?.typeName !== t.ZodFirstPartyTypeKind.ZodAny && (s.items = (0, n.parseDef)(r.type._def, {
      ...i,
      currentPath: [...i.currentPath, "items"]
    })), r.minLength && (0, e.setResponseValueAndErrors)(s, "minItems", r.minLength.value, r.minLength.message, i), r.maxLength && (0, e.setResponseValueAndErrors)(s, "maxItems", r.maxLength.value, r.maxLength.message, i), r.exactLength && ((0, e.setResponseValueAndErrors)(s, "minItems", r.exactLength.value, r.exactLength.message, i), (0, e.setResponseValueAndErrors)(s, "maxItems", r.exactLength.value, r.exactLength.message, i)), s;
  }
  return Jc.parseArrayDef = a, Jc;
}
var Lc = {}, e0;
function IT() {
  if (e0) return Lc;
  e0 = 1, Object.defineProperty(Lc, "__esModule", { value: !0 }), Lc.parseBigintDef = void 0;
  const t = /* @__PURE__ */ nu();
  function e(n, a) {
    const r = {
      type: "integer",
      format: "int64"
    };
    if (!n.checks)
      return r;
    for (const i of n.checks)
      switch (i.kind) {
        case "min":
          a.target === "jsonSchema7" ? i.inclusive ? (0, t.setResponseValueAndErrors)(r, "minimum", i.value, i.message, a) : (0, t.setResponseValueAndErrors)(r, "exclusiveMinimum", i.value, i.message, a) : (i.inclusive || (r.exclusiveMinimum = !0), (0, t.setResponseValueAndErrors)(r, "minimum", i.value, i.message, a));
          break;
        case "max":
          a.target === "jsonSchema7" ? i.inclusive ? (0, t.setResponseValueAndErrors)(r, "maximum", i.value, i.message, a) : (0, t.setResponseValueAndErrors)(r, "exclusiveMaximum", i.value, i.message, a) : (i.inclusive || (r.exclusiveMaximum = !0), (0, t.setResponseValueAndErrors)(r, "maximum", i.value, i.message, a));
          break;
        case "multipleOf":
          (0, t.setResponseValueAndErrors)(r, "multipleOf", i.value, i.message, a);
          break;
      }
    return r;
  }
  return Lc.parseBigintDef = e, Lc;
}
var Uc = {}, t0;
function NT() {
  if (t0) return Uc;
  t0 = 1, Object.defineProperty(Uc, "__esModule", { value: !0 }), Uc.parseBooleanDef = void 0;
  function t() {
    return {
      type: "boolean"
    };
  }
  return Uc.parseBooleanDef = t, Uc;
}
var Bc = {}, n0;
function w_() {
  if (n0) return Bc;
  n0 = 1, Object.defineProperty(Bc, "__esModule", { value: !0 }), Bc.parseBrandedDef = void 0;
  const t = /* @__PURE__ */ vt();
  function e(n, a) {
    return (0, t.parseDef)(n.type._def, a);
  }
  return Bc.parseBrandedDef = e, Bc;
}
var xc = {}, r0;
function FT() {
  if (r0) return xc;
  r0 = 1, Object.defineProperty(xc, "__esModule", { value: !0 }), xc.parseCatchDef = void 0;
  const t = /* @__PURE__ */ vt(), e = (n, a) => (0, t.parseDef)(n.innerType._def, a);
  return xc.parseCatchDef = e, xc;
}
var Vc = {}, a0;
function kT() {
  if (a0) return Vc;
  a0 = 1, Object.defineProperty(Vc, "__esModule", { value: !0 }), Vc.parseDateDef = void 0;
  const t = /* @__PURE__ */ nu();
  function e(a, r, i) {
    const s = i ?? r.dateStrategy;
    if (Array.isArray(s))
      return {
        anyOf: s.map((u, d) => e(a, r, u))
      };
    switch (s) {
      case "string":
      case "format:date-time":
        return {
          type: "string",
          format: "date-time"
        };
      case "format:date":
        return {
          type: "string",
          format: "date"
        };
      case "integer":
        return n(a, r);
    }
  }
  Vc.parseDateDef = e;
  const n = (a, r) => {
    const i = {
      type: "integer",
      format: "unix-time"
    };
    if (r.target === "openApi3")
      return i;
    for (const s of a.checks)
      switch (s.kind) {
        case "min":
          (0, t.setResponseValueAndErrors)(
            i,
            "minimum",
            s.value,
            // This is in milliseconds
            s.message,
            r
          );
          break;
        case "max":
          (0, t.setResponseValueAndErrors)(
            i,
            "maximum",
            s.value,
            // This is in milliseconds
            s.message,
            r
          );
          break;
      }
    return i;
  };
  return Vc;
}
var zc = {}, i0;
function DT() {
  if (i0) return zc;
  i0 = 1, Object.defineProperty(zc, "__esModule", { value: !0 }), zc.parseDefaultDef = void 0;
  const t = /* @__PURE__ */ vt();
  function e(n, a) {
    return {
      ...(0, t.parseDef)(n.innerType._def, a),
      default: n.defaultValue()
    };
  }
  return zc.parseDefaultDef = e, zc;
}
var Zc = {}, s0;
function qT() {
  if (s0) return Zc;
  s0 = 1, Object.defineProperty(Zc, "__esModule", { value: !0 }), Zc.parseEffectsDef = void 0;
  const t = /* @__PURE__ */ vt();
  function e(n, a) {
    return a.effectStrategy === "input" ? (0, t.parseDef)(n.schema._def, a) : {};
  }
  return Zc.parseEffectsDef = e, Zc;
}
var Kc = {}, o0;
function JT() {
  if (o0) return Kc;
  o0 = 1, Object.defineProperty(Kc, "__esModule", { value: !0 }), Kc.parseEnumDef = void 0;
  function t(e) {
    return {
      type: "string",
      enum: Array.from(e.values)
    };
  }
  return Kc.parseEnumDef = t, Kc;
}
var Hc = {}, u0;
function LT() {
  if (u0) return Hc;
  u0 = 1, Object.defineProperty(Hc, "__esModule", { value: !0 }), Hc.parseIntersectionDef = void 0;
  const t = /* @__PURE__ */ vt(), e = (a) => "type" in a && a.type === "string" ? !1 : "allOf" in a;
  function n(a, r) {
    const i = [
      (0, t.parseDef)(a.left._def, {
        ...r,
        currentPath: [...r.currentPath, "allOf", "0"]
      }),
      (0, t.parseDef)(a.right._def, {
        ...r,
        currentPath: [...r.currentPath, "allOf", "1"]
      })
    ].filter((d) => !!d);
    let s = r.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
    const u = [];
    return i.forEach((d) => {
      if (e(d))
        u.push(...d.allOf), d.unevaluatedProperties === void 0 && (s = void 0);
      else {
        let f = d;
        if ("additionalProperties" in d && d.additionalProperties === !1) {
          const { additionalProperties: o, ...c } = d;
          f = c;
        } else
          s = void 0;
        u.push(f);
      }
    }), u.length ? {
      allOf: u,
      ...s
    } : void 0;
  }
  return Hc.parseIntersectionDef = n, Hc;
}
var Gc = {}, c0;
function UT() {
  if (c0) return Gc;
  c0 = 1, Object.defineProperty(Gc, "__esModule", { value: !0 }), Gc.parseLiteralDef = void 0;
  function t(e, n) {
    const a = typeof e.value;
    return a !== "bigint" && a !== "number" && a !== "boolean" && a !== "string" ? {
      type: Array.isArray(e.value) ? "array" : "object"
    } : n.target === "openApi3" ? {
      type: a === "bigint" ? "integer" : a,
      enum: [e.value]
    } : {
      type: a === "bigint" ? "integer" : a,
      const: e.value
    };
  }
  return Gc.parseLiteralDef = t, Gc;
}
var Wc = {}, Xc = {}, xm = {}, l0;
function S_() {
  return l0 || (l0 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.parseStringDef = t.zodPatterns = void 0;
    const e = /* @__PURE__ */ nu();
    let n;
    t.zodPatterns = {
      /**
       * `c` was changed to `[cC]` to replicate /i flag
       */
      cuid: /^[cC][^\s-]{8,}$/,
      cuid2: /^[0-9a-z]+$/,
      ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
      /**
       * `a-z` was added to replicate /i flag
       */
      email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
      /**
       * Constructed a valid Unicode RegExp
       *
       * Lazily instantiate since this type of regex isn't supported
       * in all envs (e.g. React Native).
       *
       * See:
       * https://github.com/colinhacks/zod/issues/2433
       * Fix in Zod:
       * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
       */
      emoji: () => (n === void 0 && (n = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), n),
      /**
       * Unused
       */
      uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
      /**
       * Unused
       */
      ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
      /**
       * Unused
       */
      ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
      nanoid: /^[a-zA-Z0-9_-]{21}$/,
      jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };
    function a(o, c) {
      const h = {
        type: "string"
      };
      if (o.checks)
        for (const p of o.checks)
          switch (p.kind) {
            case "min":
              (0, e.setResponseValueAndErrors)(h, "minLength", typeof h.minLength == "number" ? Math.max(h.minLength, p.value) : p.value, p.message, c);
              break;
            case "max":
              (0, e.setResponseValueAndErrors)(h, "maxLength", typeof h.maxLength == "number" ? Math.min(h.maxLength, p.value) : p.value, p.message, c);
              break;
            case "email":
              switch (c.emailStrategy) {
                case "format:email":
                  u(h, "email", p.message, c);
                  break;
                case "format:idn-email":
                  u(h, "idn-email", p.message, c);
                  break;
                case "pattern:zod":
                  d(h, t.zodPatterns.email, p.message, c);
                  break;
              }
              break;
            case "url":
              u(h, "uri", p.message, c);
              break;
            case "uuid":
              u(h, "uuid", p.message, c);
              break;
            case "regex":
              d(h, p.regex, p.message, c);
              break;
            case "cuid":
              d(h, t.zodPatterns.cuid, p.message, c);
              break;
            case "cuid2":
              d(h, t.zodPatterns.cuid2, p.message, c);
              break;
            case "startsWith":
              d(h, RegExp(`^${r(p.value, c)}`), p.message, c);
              break;
            case "endsWith":
              d(h, RegExp(`${r(p.value, c)}$`), p.message, c);
              break;
            case "datetime":
              u(h, "date-time", p.message, c);
              break;
            case "date":
              u(h, "date", p.message, c);
              break;
            case "time":
              u(h, "time", p.message, c);
              break;
            case "duration":
              u(h, "duration", p.message, c);
              break;
            case "length":
              (0, e.setResponseValueAndErrors)(h, "minLength", typeof h.minLength == "number" ? Math.max(h.minLength, p.value) : p.value, p.message, c), (0, e.setResponseValueAndErrors)(h, "maxLength", typeof h.maxLength == "number" ? Math.min(h.maxLength, p.value) : p.value, p.message, c);
              break;
            case "includes": {
              d(h, RegExp(r(p.value, c)), p.message, c);
              break;
            }
            case "ip": {
              p.version !== "v6" && u(h, "ipv4", p.message, c), p.version !== "v4" && u(h, "ipv6", p.message, c);
              break;
            }
            case "base64url":
              d(h, t.zodPatterns.base64url, p.message, c);
              break;
            case "jwt":
              d(h, t.zodPatterns.jwt, p.message, c);
              break;
            case "cidr": {
              p.version !== "v6" && d(h, t.zodPatterns.ipv4Cidr, p.message, c), p.version !== "v4" && d(h, t.zodPatterns.ipv6Cidr, p.message, c);
              break;
            }
            case "emoji":
              d(h, t.zodPatterns.emoji(), p.message, c);
              break;
            case "ulid": {
              d(h, t.zodPatterns.ulid, p.message, c);
              break;
            }
            case "base64": {
              switch (c.base64Strategy) {
                case "format:binary": {
                  u(h, "binary", p.message, c);
                  break;
                }
                case "contentEncoding:base64": {
                  (0, e.setResponseValueAndErrors)(h, "contentEncoding", "base64", p.message, c);
                  break;
                }
                case "pattern:zod": {
                  d(h, t.zodPatterns.base64, p.message, c);
                  break;
                }
              }
              break;
            }
            case "nanoid":
              d(h, t.zodPatterns.nanoid, p.message, c);
          }
      return h;
    }
    t.parseStringDef = a;
    function r(o, c) {
      return c.patternStrategy === "escape" ? s(o) : o;
    }
    const i = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
    function s(o) {
      let c = "";
      for (let h = 0; h < o.length; h++)
        i.has(o[h]) || (c += "\\"), c += o[h];
      return c;
    }
    function u(o, c, h, p) {
      o.format || o.anyOf?.some((l) => l.format) ? (o.anyOf || (o.anyOf = []), o.format && (o.anyOf.push({
        format: o.format,
        ...o.errorMessage && p.errorMessages && {
          errorMessage: { format: o.errorMessage.format }
        }
      }), delete o.format, o.errorMessage && (delete o.errorMessage.format, Object.keys(o.errorMessage).length === 0 && delete o.errorMessage)), o.anyOf.push({
        format: c,
        ...h && p.errorMessages && { errorMessage: { format: h } }
      })) : (0, e.setResponseValueAndErrors)(o, "format", c, h, p);
    }
    function d(o, c, h, p) {
      o.pattern || o.allOf?.some((l) => l.pattern) ? (o.allOf || (o.allOf = []), o.pattern && (o.allOf.push({
        pattern: o.pattern,
        ...o.errorMessage && p.errorMessages && {
          errorMessage: { pattern: o.errorMessage.pattern }
        }
      }), delete o.pattern, o.errorMessage && (delete o.errorMessage.pattern, Object.keys(o.errorMessage).length === 0 && delete o.errorMessage)), o.allOf.push({
        pattern: f(c, p),
        ...h && p.errorMessages && { errorMessage: { pattern: h } }
      })) : (0, e.setResponseValueAndErrors)(o, "pattern", f(c, p), h, p);
    }
    function f(o, c) {
      if (!c.applyRegexFlags || !o.flags)
        return o.source;
      const h = {
        i: o.flags.includes("i"),
        m: o.flags.includes("m"),
        s: o.flags.includes("s")
        // `.` matches newlines
      }, p = h.i ? o.source.toLowerCase() : o.source;
      let l = "", m = !1, b = !1, g = !1;
      for (let _ = 0; _ < p.length; _++) {
        if (m) {
          l += p[_], m = !1;
          continue;
        }
        if (h.i) {
          if (b) {
            if (p[_].match(/[a-z]/)) {
              g ? (l += p[_], l += `${p[_ - 2]}-${p[_]}`.toUpperCase(), g = !1) : p[_ + 1] === "-" && p[_ + 2]?.match(/[a-z]/) ? (l += p[_], g = !0) : l += `${p[_]}${p[_].toUpperCase()}`;
              continue;
            }
          } else if (p[_].match(/[a-z]/)) {
            l += `[${p[_]}${p[_].toUpperCase()}]`;
            continue;
          }
        }
        if (h.m) {
          if (p[_] === "^") {
            l += `(^|(?<=[\r
]))`;
            continue;
          } else if (p[_] === "$") {
            l += `($|(?=[\r
]))`;
            continue;
          }
        }
        if (h.s && p[_] === ".") {
          l += b ? `${p[_]}\r
` : `[${p[_]}\r
]`;
          continue;
        }
        l += p[_], p[_] === "\\" ? m = !0 : b && p[_] === "]" ? b = !1 : !b && p[_] === "[" && (b = !0);
      }
      try {
        new RegExp(l);
      } catch {
        return console.warn(`Could not convert regex pattern at ${c.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), o.source;
      }
      return l;
    }
  }(xm)), xm;
}
var d0;
function O_() {
  if (d0) return Xc;
  d0 = 1, Object.defineProperty(Xc, "__esModule", { value: !0 }), Xc.parseRecordDef = void 0;
  const t = /* @__PURE__ */ H(), e = /* @__PURE__ */ vt(), n = /* @__PURE__ */ S_(), a = /* @__PURE__ */ w_();
  function r(i, s) {
    if (s.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."), s.target === "openApi3" && i.keyType?._def.typeName === t.ZodFirstPartyTypeKind.ZodEnum)
      return {
        type: "object",
        required: i.keyType._def.values,
        properties: i.keyType._def.values.reduce((d, f) => ({
          ...d,
          [f]: (0, e.parseDef)(i.valueType._def, {
            ...s,
            currentPath: [...s.currentPath, "properties", f]
          }) ?? {}
        }), {}),
        additionalProperties: s.rejectedAdditionalProperties
      };
    const u = {
      type: "object",
      additionalProperties: (0, e.parseDef)(i.valueType._def, {
        ...s,
        currentPath: [...s.currentPath, "additionalProperties"]
      }) ?? s.allowedAdditionalProperties
    };
    if (s.target === "openApi3")
      return u;
    if (i.keyType?._def.typeName === t.ZodFirstPartyTypeKind.ZodString && i.keyType._def.checks?.length) {
      const { type: d, ...f } = (0, n.parseStringDef)(i.keyType._def, s);
      return {
        ...u,
        propertyNames: f
      };
    } else {
      if (i.keyType?._def.typeName === t.ZodFirstPartyTypeKind.ZodEnum)
        return {
          ...u,
          propertyNames: {
            enum: i.keyType._def.values
          }
        };
      if (i.keyType?._def.typeName === t.ZodFirstPartyTypeKind.ZodBranded && i.keyType._def.type._def.typeName === t.ZodFirstPartyTypeKind.ZodString && i.keyType._def.type._def.checks?.length) {
        const { type: d, ...f } = (0, a.parseBrandedDef)(i.keyType._def, s);
        return {
          ...u,
          propertyNames: f
        };
      }
    }
    return u;
  }
  return Xc.parseRecordDef = r, Xc;
}
var f0;
function BT() {
  if (f0) return Wc;
  f0 = 1, Object.defineProperty(Wc, "__esModule", { value: !0 }), Wc.parseMapDef = void 0;
  const t = /* @__PURE__ */ vt(), e = /* @__PURE__ */ O_();
  function n(a, r) {
    if (r.mapStrategy === "record")
      return (0, e.parseRecordDef)(a, r);
    const i = (0, t.parseDef)(a.keyType._def, {
      ...r,
      currentPath: [...r.currentPath, "items", "items", "0"]
    }) || {}, s = (0, t.parseDef)(a.valueType._def, {
      ...r,
      currentPath: [...r.currentPath, "items", "items", "1"]
    }) || {};
    return {
      type: "array",
      maxItems: 125,
      items: {
        type: "array",
        items: [i, s],
        minItems: 2,
        maxItems: 2
      }
    };
  }
  return Wc.parseMapDef = n, Wc;
}
var Qc = {}, h0;
function xT() {
  if (h0) return Qc;
  h0 = 1, Object.defineProperty(Qc, "__esModule", { value: !0 }), Qc.parseNativeEnumDef = void 0;
  function t(e) {
    const n = e.values, r = Object.keys(e.values).filter((s) => typeof n[n[s]] != "number").map((s) => n[s]), i = Array.from(new Set(r.map((s) => typeof s)));
    return {
      type: i.length === 1 ? i[0] === "string" ? "string" : "number" : ["string", "number"],
      enum: r
    };
  }
  return Qc.parseNativeEnumDef = t, Qc;
}
var Yc = {}, p0;
function VT() {
  if (p0) return Yc;
  p0 = 1, Object.defineProperty(Yc, "__esModule", { value: !0 }), Yc.parseNeverDef = void 0;
  function t() {
    return {
      not: {}
    };
  }
  return Yc.parseNeverDef = t, Yc;
}
var el = {}, m0;
function zT() {
  if (m0) return el;
  m0 = 1, Object.defineProperty(el, "__esModule", { value: !0 }), el.parseNullDef = void 0;
  function t(e) {
    return e.target === "openApi3" ? {
      enum: ["null"],
      nullable: !0
    } : {
      type: "null"
    };
  }
  return el.parseNullDef = t, el;
}
var tl = {}, Vm = {}, b0;
function j_() {
  return b0 || (b0 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.parseUnionDef = t.primitiveMappings = void 0;
    const e = /* @__PURE__ */ vt();
    t.primitiveMappings = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    function n(r, i) {
      if (i.target === "openApi3")
        return a(r, i);
      const s = r.options instanceof Map ? Array.from(r.options.values()) : r.options;
      if (s.every((u) => u._def.typeName in t.primitiveMappings && (!u._def.checks || !u._def.checks.length))) {
        const u = s.reduce((d, f) => {
          const o = t.primitiveMappings[f._def.typeName];
          return o && !d.includes(o) ? [...d, o] : d;
        }, []);
        return {
          type: u.length > 1 ? u : u[0]
        };
      } else if (s.every((u) => u._def.typeName === "ZodLiteral" && !u.description)) {
        const u = s.reduce((d, f) => {
          const o = typeof f._def.value;
          switch (o) {
            case "string":
            case "number":
            case "boolean":
              return [...d, o];
            case "bigint":
              return [...d, "integer"];
            case "object":
              if (f._def.value === null)
                return [...d, "null"];
            case "symbol":
            case "undefined":
            case "function":
            default:
              return d;
          }
        }, []);
        if (u.length === s.length) {
          const d = u.filter((f, o, c) => c.indexOf(f) === o);
          return {
            type: d.length > 1 ? d : d[0],
            enum: s.reduce((f, o) => f.includes(o._def.value) ? f : [...f, o._def.value], [])
          };
        }
      } else if (s.every((u) => u._def.typeName === "ZodEnum"))
        return {
          type: "string",
          enum: s.reduce((u, d) => [
            ...u,
            ...d._def.values.filter((f) => !u.includes(f))
          ], [])
        };
      return a(r, i);
    }
    t.parseUnionDef = n;
    const a = (r, i) => {
      const s = (r.options instanceof Map ? Array.from(r.options.values()) : r.options).map((u, d) => (0, e.parseDef)(u._def, {
        ...i,
        currentPath: [...i.currentPath, "anyOf", `${d}`]
      })).filter((u) => !!u && (!i.strictUnions || typeof u == "object" && Object.keys(u).length > 0));
      return s.length ? { anyOf: s } : void 0;
    };
  }(Vm)), Vm;
}
var g0;
function ZT() {
  if (g0) return tl;
  g0 = 1, Object.defineProperty(tl, "__esModule", { value: !0 }), tl.parseNullableDef = void 0;
  const t = /* @__PURE__ */ vt(), e = /* @__PURE__ */ j_();
  function n(a, r) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(a.innerType._def.typeName) && (!a.innerType._def.checks || !a.innerType._def.checks.length))
      return r.target === "openApi3" ? {
        type: e.primitiveMappings[a.innerType._def.typeName],
        nullable: !0
      } : {
        type: [
          e.primitiveMappings[a.innerType._def.typeName],
          "null"
        ]
      };
    if (r.target === "openApi3") {
      const s = (0, t.parseDef)(a.innerType._def, {
        ...r,
        currentPath: [...r.currentPath]
      });
      return s && "$ref" in s ? { allOf: [s], nullable: !0 } : s && { ...s, nullable: !0 };
    }
    const i = (0, t.parseDef)(a.innerType._def, {
      ...r,
      currentPath: [...r.currentPath, "anyOf", "0"]
    });
    return i && { anyOf: [i, { type: "null" }] };
  }
  return tl.parseNullableDef = n, tl;
}
var nl = {}, _0;
function KT() {
  if (_0) return nl;
  _0 = 1, Object.defineProperty(nl, "__esModule", { value: !0 }), nl.parseNumberDef = void 0;
  const t = /* @__PURE__ */ nu();
  function e(n, a) {
    const r = {
      type: "number"
    };
    if (!n.checks)
      return r;
    for (const i of n.checks)
      switch (i.kind) {
        case "int":
          r.type = "integer", (0, t.addErrorMessage)(r, "type", i.message, a);
          break;
        case "min":
          a.target === "jsonSchema7" ? i.inclusive ? (0, t.setResponseValueAndErrors)(r, "minimum", i.value, i.message, a) : (0, t.setResponseValueAndErrors)(r, "exclusiveMinimum", i.value, i.message, a) : (i.inclusive || (r.exclusiveMinimum = !0), (0, t.setResponseValueAndErrors)(r, "minimum", i.value, i.message, a));
          break;
        case "max":
          a.target === "jsonSchema7" ? i.inclusive ? (0, t.setResponseValueAndErrors)(r, "maximum", i.value, i.message, a) : (0, t.setResponseValueAndErrors)(r, "exclusiveMaximum", i.value, i.message, a) : (i.inclusive || (r.exclusiveMaximum = !0), (0, t.setResponseValueAndErrors)(r, "maximum", i.value, i.message, a));
          break;
        case "multipleOf":
          (0, t.setResponseValueAndErrors)(r, "multipleOf", i.value, i.message, a);
          break;
      }
    return r;
  }
  return nl.parseNumberDef = e, nl;
}
var rl = {}, y0;
function HT() {
  if (y0) return rl;
  y0 = 1, Object.defineProperty(rl, "__esModule", { value: !0 }), rl.parseObjectDef = void 0;
  const t = /* @__PURE__ */ H(), e = /* @__PURE__ */ vt();
  function n(i, s) {
    const u = s.target === "openAi", d = {
      type: "object",
      properties: {}
    }, f = [], o = i.shape();
    for (const h in o) {
      let p = o[h];
      if (p === void 0 || p._def === void 0)
        continue;
      let l = r(p);
      l && u && (p instanceof t.ZodOptional && (p = p._def.innerType), p.isNullable() || (p = p.nullable()), l = !1);
      const m = (0, e.parseDef)(p._def, {
        ...s,
        currentPath: [...s.currentPath, "properties", h],
        propertyPath: [...s.currentPath, "properties", h]
      });
      m !== void 0 && (d.properties[h] = m, l || f.push(h));
    }
    f.length && (d.required = f);
    const c = a(i, s);
    return c !== void 0 && (d.additionalProperties = c), d;
  }
  rl.parseObjectDef = n;
  function a(i, s) {
    if (i.catchall._def.typeName !== "ZodNever")
      return (0, e.parseDef)(i.catchall._def, {
        ...s,
        currentPath: [...s.currentPath, "additionalProperties"]
      });
    switch (i.unknownKeys) {
      case "passthrough":
        return s.allowedAdditionalProperties;
      case "strict":
        return s.rejectedAdditionalProperties;
      case "strip":
        return s.removeAdditionalStrategy === "strict" ? s.allowedAdditionalProperties : s.rejectedAdditionalProperties;
    }
  }
  function r(i) {
    try {
      return i.isOptional();
    } catch {
      return !0;
    }
  }
  return rl;
}
var al = {}, v0;
function GT() {
  if (v0) return al;
  v0 = 1, Object.defineProperty(al, "__esModule", { value: !0 }), al.parseOptionalDef = void 0;
  const t = /* @__PURE__ */ vt(), e = (n, a) => {
    if (a.currentPath.toString() === a.propertyPath?.toString())
      return (0, t.parseDef)(n.innerType._def, a);
    const r = (0, t.parseDef)(n.innerType._def, {
      ...a,
      currentPath: [...a.currentPath, "anyOf", "1"]
    });
    return r ? {
      anyOf: [
        {
          not: {}
        },
        r
      ]
    } : {};
  };
  return al.parseOptionalDef = e, al;
}
var il = {}, w0;
function WT() {
  if (w0) return il;
  w0 = 1, Object.defineProperty(il, "__esModule", { value: !0 }), il.parsePipelineDef = void 0;
  const t = /* @__PURE__ */ vt(), e = (n, a) => {
    if (a.pipeStrategy === "input")
      return (0, t.parseDef)(n.in._def, a);
    if (a.pipeStrategy === "output")
      return (0, t.parseDef)(n.out._def, a);
    const r = (0, t.parseDef)(n.in._def, {
      ...a,
      currentPath: [...a.currentPath, "allOf", "0"]
    }), i = (0, t.parseDef)(n.out._def, {
      ...a,
      currentPath: [...a.currentPath, "allOf", r ? "1" : "0"]
    });
    return {
      allOf: [r, i].filter((s) => s !== void 0)
    };
  };
  return il.parsePipelineDef = e, il;
}
var sl = {}, S0;
function XT() {
  if (S0) return sl;
  S0 = 1, Object.defineProperty(sl, "__esModule", { value: !0 }), sl.parsePromiseDef = void 0;
  const t = /* @__PURE__ */ vt();
  function e(n, a) {
    return (0, t.parseDef)(n.type._def, a);
  }
  return sl.parsePromiseDef = e, sl;
}
var ol = {}, O0;
function QT() {
  if (O0) return ol;
  O0 = 1, Object.defineProperty(ol, "__esModule", { value: !0 }), ol.parseSetDef = void 0;
  const t = /* @__PURE__ */ nu(), e = /* @__PURE__ */ vt();
  function n(a, r) {
    const s = {
      type: "array",
      uniqueItems: !0,
      items: (0, e.parseDef)(a.valueType._def, {
        ...r,
        currentPath: [...r.currentPath, "items"]
      })
    };
    return a.minSize && (0, t.setResponseValueAndErrors)(s, "minItems", a.minSize.value, a.minSize.message, r), a.maxSize && (0, t.setResponseValueAndErrors)(s, "maxItems", a.maxSize.value, a.maxSize.message, r), s;
  }
  return ol.parseSetDef = n, ol;
}
var ul = {}, j0;
function YT() {
  if (j0) return ul;
  j0 = 1, Object.defineProperty(ul, "__esModule", { value: !0 }), ul.parseTupleDef = void 0;
  const t = /* @__PURE__ */ vt();
  function e(n, a) {
    return n.rest ? {
      type: "array",
      minItems: n.items.length,
      items: n.items.map((r, i) => (0, t.parseDef)(r._def, {
        ...a,
        currentPath: [...a.currentPath, "items", `${i}`]
      })).reduce((r, i) => i === void 0 ? r : [...r, i], []),
      additionalItems: (0, t.parseDef)(n.rest._def, {
        ...a,
        currentPath: [...a.currentPath, "additionalItems"]
      })
    } : {
      type: "array",
      minItems: n.items.length,
      maxItems: n.items.length,
      items: n.items.map((r, i) => (0, t.parseDef)(r._def, {
        ...a,
        currentPath: [...a.currentPath, "items", `${i}`]
      })).reduce((r, i) => i === void 0 ? r : [...r, i], [])
    };
  }
  return ul.parseTupleDef = e, ul;
}
var cl = {}, P0;
function e$() {
  if (P0) return cl;
  P0 = 1, Object.defineProperty(cl, "__esModule", { value: !0 }), cl.parseUndefinedDef = void 0;
  function t() {
    return {
      not: {}
    };
  }
  return cl.parseUndefinedDef = t, cl;
}
var ll = {}, C0;
function t$() {
  if (C0) return ll;
  C0 = 1, Object.defineProperty(ll, "__esModule", { value: !0 }), ll.parseUnknownDef = void 0;
  function t() {
    return {};
  }
  return ll.parseUnknownDef = t, ll;
}
var dl = {}, R0;
function n$() {
  if (R0) return dl;
  R0 = 1, Object.defineProperty(dl, "__esModule", { value: !0 }), dl.parseReadonlyDef = void 0;
  const t = /* @__PURE__ */ vt(), e = (n, a) => (0, t.parseDef)(n.innerType._def, a);
  return dl.parseReadonlyDef = e, dl;
}
var T0;
function r$() {
  if (T0) return Dc;
  T0 = 1, Object.defineProperty(Dc, "__esModule", { value: !0 }), Dc.selectParser = void 0;
  const t = /* @__PURE__ */ H(), e = /* @__PURE__ */ AT(), n = /* @__PURE__ */ ET(), a = /* @__PURE__ */ IT(), r = /* @__PURE__ */ NT(), i = /* @__PURE__ */ w_(), s = /* @__PURE__ */ FT(), u = /* @__PURE__ */ kT(), d = /* @__PURE__ */ DT(), f = /* @__PURE__ */ qT(), o = /* @__PURE__ */ JT(), c = /* @__PURE__ */ LT(), h = /* @__PURE__ */ UT(), p = /* @__PURE__ */ BT(), l = /* @__PURE__ */ xT(), m = /* @__PURE__ */ VT(), b = /* @__PURE__ */ zT(), g = /* @__PURE__ */ ZT(), _ = /* @__PURE__ */ KT(), P = /* @__PURE__ */ HT(), R = /* @__PURE__ */ GT(), C = /* @__PURE__ */ WT(), T = /* @__PURE__ */ XT(), O = /* @__PURE__ */ O_(), A = /* @__PURE__ */ QT(), M = /* @__PURE__ */ S_(), I = /* @__PURE__ */ YT(), N = /* @__PURE__ */ e$(), v = /* @__PURE__ */ j_(), F = /* @__PURE__ */ t$(), L = /* @__PURE__ */ n$(), B = (V, ue, ie) => {
    switch (ue) {
      case t.ZodFirstPartyTypeKind.ZodString:
        return (0, M.parseStringDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodNumber:
        return (0, _.parseNumberDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodObject:
        return (0, P.parseObjectDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodBigInt:
        return (0, a.parseBigintDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodBoolean:
        return (0, r.parseBooleanDef)();
      case t.ZodFirstPartyTypeKind.ZodDate:
        return (0, u.parseDateDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodUndefined:
        return (0, N.parseUndefinedDef)();
      case t.ZodFirstPartyTypeKind.ZodNull:
        return (0, b.parseNullDef)(ie);
      case t.ZodFirstPartyTypeKind.ZodArray:
        return (0, n.parseArrayDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodUnion:
      case t.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
        return (0, v.parseUnionDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodIntersection:
        return (0, c.parseIntersectionDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodTuple:
        return (0, I.parseTupleDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodRecord:
        return (0, O.parseRecordDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodLiteral:
        return (0, h.parseLiteralDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodEnum:
        return (0, o.parseEnumDef)(V);
      case t.ZodFirstPartyTypeKind.ZodNativeEnum:
        return (0, l.parseNativeEnumDef)(V);
      case t.ZodFirstPartyTypeKind.ZodNullable:
        return (0, g.parseNullableDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodOptional:
        return (0, R.parseOptionalDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodMap:
        return (0, p.parseMapDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodSet:
        return (0, A.parseSetDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodLazy:
        return () => V.getter()._def;
      case t.ZodFirstPartyTypeKind.ZodPromise:
        return (0, T.parsePromiseDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodNaN:
      case t.ZodFirstPartyTypeKind.ZodNever:
        return (0, m.parseNeverDef)();
      case t.ZodFirstPartyTypeKind.ZodEffects:
        return (0, f.parseEffectsDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodAny:
        return (0, e.parseAnyDef)();
      case t.ZodFirstPartyTypeKind.ZodUnknown:
        return (0, F.parseUnknownDef)();
      case t.ZodFirstPartyTypeKind.ZodDefault:
        return (0, d.parseDefaultDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodBranded:
        return (0, i.parseBrandedDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodReadonly:
        return (0, L.parseReadonlyDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodCatch:
        return (0, s.parseCatchDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodPipeline:
        return (0, C.parsePipelineDef)(V, ie);
      case t.ZodFirstPartyTypeKind.ZodFunction:
      case t.ZodFirstPartyTypeKind.ZodVoid:
      case t.ZodFirstPartyTypeKind.ZodSymbol:
        return;
      default:
        return /* @__PURE__ */ ((ut) => {
        })();
    }
  };
  return Dc.selectParser = B, Dc;
}
var $0;
function vt() {
  if ($0) return kc;
  $0 = 1, Object.defineProperty(kc, "__esModule", { value: !0 }), kc.parseDef = void 0;
  const t = /* @__PURE__ */ v_(), e = /* @__PURE__ */ r$();
  function n(s, u, d = !1) {
    const f = u.seen.get(s);
    if (u.override) {
      const p = u.override?.(s, u, f, d);
      if (p !== t.ignoreOverride)
        return p;
    }
    if (f && !d) {
      const p = a(f, u);
      if (p !== void 0)
        return p;
    }
    const o = { def: s, path: u.currentPath, jsonSchema: void 0 };
    u.seen.set(s, o);
    const c = (0, e.selectParser)(s, s.typeName, u), h = typeof c == "function" ? n(c(), u) : c;
    if (h && i(s, u, h), u.postProcess) {
      const p = u.postProcess(h, s, u);
      return o.jsonSchema = h, p;
    }
    return o.jsonSchema = h, h;
  }
  kc.parseDef = n;
  const a = (s, u) => {
    switch (u.$refStrategy) {
      case "root":
        return { $ref: s.path.join("/") };
      case "relative":
        return { $ref: r(u.currentPath, s.path) };
      case "none":
      case "seen":
        return s.path.length < u.currentPath.length && s.path.every((d, f) => u.currentPath[f] === d) ? (console.warn(`Recursive reference detected at ${u.currentPath.join("/")}! Defaulting to any`), {}) : u.$refStrategy === "seen" ? {} : void 0;
    }
  }, r = (s, u) => {
    let d = 0;
    for (; d < s.length && d < u.length && s[d] === u[d]; d++)
      ;
    return [(s.length - d).toString(), ...u.slice(d)].join("/");
  }, i = (s, u, d) => (s.description && (d.description = s.description, u.markdownDescription && (d.markdownDescription = s.description)), d);
  return kc;
}
var zm = {}, M0;
function hJ() {
  return M0 || (M0 = 1, Object.defineProperty(zm, "__esModule", { value: !0 })), zm;
}
var fl = {}, A0;
function E0() {
  if (A0) return fl;
  A0 = 1, Object.defineProperty(fl, "__esModule", { value: !0 }), fl.zodToJsonSchema = void 0;
  const t = /* @__PURE__ */ vt(), e = /* @__PURE__ */ MT(), n = (a, r) => {
    const i = (0, e.getRefs)(r), s = typeof r == "object" && r.definitions ? Object.entries(r.definitions).reduce((c, [h, p]) => ({
      ...c,
      [h]: (0, t.parseDef)(p._def, {
        ...i,
        currentPath: [...i.basePath, i.definitionPath, h]
      }, !0) ?? {}
    }), {}) : void 0, u = typeof r == "string" ? r : r?.nameStrategy === "title" ? void 0 : r?.name, d = (0, t.parseDef)(a._def, u === void 0 ? i : {
      ...i,
      currentPath: [...i.basePath, i.definitionPath, u]
    }, !1) ?? {}, f = typeof r == "object" && r.name !== void 0 && r.nameStrategy === "title" ? r.name : void 0;
    f !== void 0 && (d.title = f);
    const o = u === void 0 ? s ? {
      ...d,
      [i.definitionPath]: s
    } : d : {
      $ref: [
        ...i.$refStrategy === "relative" ? [] : i.basePath,
        i.definitionPath,
        u
      ].join("/"),
      [i.definitionPath]: {
        ...s,
        [u]: d
      }
    };
    return i.target === "jsonSchema7" ? o.$schema = "http://json-schema.org/draft-07/schema#" : (i.target === "jsonSchema2019-09" || i.target === "openAi") && (o.$schema = "https://json-schema.org/draft/2019-09/schema#"), i.target === "openAi" && ("anyOf" in o || "oneOf" in o || "allOf" in o || "type" in o && Array.isArray(o.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."), o;
  };
  return fl.zodToJsonSchema = n, fl;
}
var I0;
function pJ() {
  return I0 || (I0 = 1, function(t) {
    var e = $o && $o.__createBinding || (Object.create ? function(r, i, s, u) {
      u === void 0 && (u = s);
      var d = Object.getOwnPropertyDescriptor(i, s);
      (!d || ("get" in d ? !i.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return i[s];
      } }), Object.defineProperty(r, u, d);
    } : function(r, i, s, u) {
      u === void 0 && (u = s), r[u] = i[s];
    }), n = $o && $o.__exportStar || function(r, i) {
      for (var s in r) s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && e(i, r, s);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(/* @__PURE__ */ v_(), t), n(/* @__PURE__ */ MT(), t), n(/* @__PURE__ */ nu(), t), n(/* @__PURE__ */ vt(), t), n(/* @__PURE__ */ hJ(), t), n(/* @__PURE__ */ AT(), t), n(/* @__PURE__ */ ET(), t), n(/* @__PURE__ */ IT(), t), n(/* @__PURE__ */ NT(), t), n(/* @__PURE__ */ w_(), t), n(/* @__PURE__ */ FT(), t), n(/* @__PURE__ */ kT(), t), n(/* @__PURE__ */ DT(), t), n(/* @__PURE__ */ qT(), t), n(/* @__PURE__ */ JT(), t), n(/* @__PURE__ */ LT(), t), n(/* @__PURE__ */ UT(), t), n(/* @__PURE__ */ BT(), t), n(/* @__PURE__ */ xT(), t), n(/* @__PURE__ */ VT(), t), n(/* @__PURE__ */ zT(), t), n(/* @__PURE__ */ ZT(), t), n(/* @__PURE__ */ KT(), t), n(/* @__PURE__ */ HT(), t), n(/* @__PURE__ */ GT(), t), n(/* @__PURE__ */ WT(), t), n(/* @__PURE__ */ XT(), t), n(/* @__PURE__ */ n$(), t), n(/* @__PURE__ */ O_(), t), n(/* @__PURE__ */ QT(), t), n(/* @__PURE__ */ S_(), t), n(/* @__PURE__ */ YT(), t), n(/* @__PURE__ */ e$(), t), n(/* @__PURE__ */ j_(), t), n(/* @__PURE__ */ t$(), t), n(/* @__PURE__ */ r$(), t), n(/* @__PURE__ */ E0(), t);
    const a = /* @__PURE__ */ E0();
    t.default = a.zodToJsonSchema;
  }($o)), $o;
}
var N0;
function mJ() {
  if (N0) return bu;
  N0 = 1, Object.defineProperty(bu, "__esModule", { value: !0 }), bu.transformToChatCompletionRequest = e, bu.convertToParsedChatCompletionResponse = n, bu.responseFormatFromZodObject = a;
  const t = /* @__PURE__ */ pJ();
  function e(r) {
    const { responseFormat: i, ...s } = r, u = a(i);
    return {
      ...s,
      responseFormat: u
    };
  }
  function n(r, i) {
    if (r.choices === void 0 || r.choices.length === 0)
      return {
        ...r,
        choices: r.choices === void 0 ? void 0 : []
      };
    const s = [];
    for (const u of r.choices)
      u.message === null || typeof u.message > "u" ? s.push({ ...u, message: void 0 }) : u.message.content !== null && typeof u.message.content < "u" && !Array.isArray(u.message.content) && s.push({
        ...u,
        message: {
          ...u.message,
          parsed: i.safeParse(JSON.parse(u.message.content)).data
        }
      });
    return {
      ...r,
      choices: s
    };
  }
  function a(r) {
    return {
      type: "json_schema",
      jsonSchema: {
        name: "placeholderName",
        schemaDefinition: (0, t.zodToJsonSchema)(r),
        strict: !0
      }
    };
  }
  return bu;
}
var F0;
function bJ() {
  if (F0) return Nc;
  F0 = 1, Object.defineProperty(Nc, "__esModule", { value: !0 }), Nc.Chat = void 0;
  const t = /* @__PURE__ */ dJ(), e = /* @__PURE__ */ fJ(), n = /* @__PURE__ */ Rn(), a = /* @__PURE__ */ Vn(), r = /* @__PURE__ */ mJ();
  class i extends n.ClientSDK {
    // #region sdk-class-body
    /**
     * Chat Completion with the response parsed in the same format as the input requestFormat.
     *
     * @remarks
     * The response will be parsed back to the initial Zod object passed in the requestFormat field.
     */
    async parse(u, d) {
      const f = (0, r.transformToChatCompletionRequest)(u), o = await (0, a.unwrapAsync)((0, t.chatComplete)(this, f, d));
      return (0, r.convertToParsedChatCompletionResponse)(o, u.responseFormat);
    }
    /**
     * Stream chat completion with a parsed request input.
     *
     * @remarks
     * Unlike the .parse method, this method will return a stream of events containing the JSON response. It will not be parsed back to the initial Zod object.
     * If you need to parse the stream, see the examples/src/async_structured_outputs.ts file.
     */
    async parseStream(u, d) {
      const f = (0, r.transformToChatCompletionRequest)(u);
      return (0, a.unwrapAsync)((0, e.chatStream)(this, f, d));
    }
    // #endregion sdk-class-body
    /**
     * Chat Completion
     */
    async complete(u, d) {
      return (0, a.unwrapAsync)((0, t.chatComplete)(this, u, d));
    }
    /**
     * Stream chat completion
     *
     * @remarks
     * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
     */
    async stream(u, d) {
      return (0, a.unwrapAsync)((0, e.chatStream)(this, u, d));
    }
  }
  return Nc.Chat = i, Nc;
}
var hl = {}, $r = {}, k0;
function gJ() {
  if (k0) return $r;
  k0 = 1;
  var t = $r && $r.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = $r && $r.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = $r && $r.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty($r, "__esModule", { value: !0 }), $r.classifiersModerate = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ Tn()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.ClassificationRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), R = (0, d.pathToFunc)("/v1/moderations")(), C = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, u.extractSecurity)(l._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, u.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "moderations_v1_moderations_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = l._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: R,
      headers: C,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, v = await l._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!v.ok)
      return [v, { status: "request-error", request: N }];
    const F = v.value, L = {
      HttpMeta: { Response: F, Request: N }
    }, [B] = await r.match(r.json(200, f.ClassificationResponse$inboundSchema), r.jsonErr(422, o.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(F, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: F }] : [B, { status: "complete", request: N, response: F }];
  }
  return $r;
}
var Mr = {}, D0;
function _J() {
  if (D0) return Mr;
  D0 = 1;
  var t = Mr && Mr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Mr && Mr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Mr && Mr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.classifiersModerateChat = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ Tn()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.ChatModerationRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), R = (0, d.pathToFunc)("/v1/chat/moderations")(), C = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, u.extractSecurity)(l._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, u.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "moderations_chat_v1_chat_moderations_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = l._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: R,
      headers: C,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, v = await l._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!v.ok)
      return [v, { status: "request-error", request: N }];
    const F = v.value, L = {
      HttpMeta: { Response: F, Request: N }
    }, [B] = await r.match(r.json(200, f.ClassificationResponse$inboundSchema), r.jsonErr(422, o.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(F, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: F }] : [B, { status: "complete", request: N, response: F }];
  }
  return Mr;
}
var q0;
function yJ() {
  if (q0) return hl;
  q0 = 1, Object.defineProperty(hl, "__esModule", { value: !0 }), hl.Classifiers = void 0;
  const t = /* @__PURE__ */ gJ(), e = /* @__PURE__ */ _J(), n = /* @__PURE__ */ Rn(), a = /* @__PURE__ */ Vn();
  class r extends n.ClientSDK {
    /**
     * Moderations
     */
    async moderate(s, u) {
      return (0, a.unwrapAsync)((0, t.classifiersModerate)(this, s, u));
    }
    /**
     * Moderations Chat
     */
    async moderateChat(s, u) {
      return (0, a.unwrapAsync)((0, e.classifiersModerateChat)(this, s, u));
    }
  }
  return hl.Classifiers = r, hl;
}
var pl = {}, Ar = {}, J0;
function vJ() {
  if (J0) return Ar;
  J0 = 1;
  var t = Ar && Ar.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Ar && Ar.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Ar && Ar.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.embeddingsCreate = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ Tn()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.EmbeddingRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), R = (0, d.pathToFunc)("/v1/embeddings")(), C = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, u.extractSecurity)(l._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, u.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "embeddings_v1_embeddings_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = l._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: R,
      headers: C,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, v = await l._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!v.ok)
      return [v, { status: "request-error", request: N }];
    const F = v.value, L = {
      HttpMeta: { Response: F, Request: N }
    }, [B] = await r.match(r.json(200, f.EmbeddingResponse$inboundSchema), r.jsonErr(422, o.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(F, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: F }] : [B, { status: "complete", request: N, response: F }];
  }
  return Ar;
}
var L0;
function wJ() {
  if (L0) return pl;
  L0 = 1, Object.defineProperty(pl, "__esModule", { value: !0 }), pl.Embeddings = void 0;
  const t = /* @__PURE__ */ vJ(), e = /* @__PURE__ */ Rn(), n = /* @__PURE__ */ Vn();
  class a extends e.ClientSDK {
    /**
     * Embeddings
     *
     * @remarks
     * Embeddings
     */
    async create(i, s) {
      return (0, n.unwrapAsync)((0, t.embeddingsCreate)(this, i, s));
    }
  }
  return pl.Embeddings = a, pl;
}
var ml = {}, Er = {}, U0;
function SJ() {
  if (U0) return Er;
  U0 = 1;
  var t = Er && Er.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Er && Er.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Er && Er.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Er, "__esModule", { value: !0 }), Er.filesDelete = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.FilesApiRoutesDeleteFileRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = {
      file_id: (0, a.encodeSimple)("file_id", _.file_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, d.pathToFunc)("/v1/files/{file_id}")(R), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "files_api_routes_delete_file",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "DELETE",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.DeleteFileOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return Er;
}
var Ir = {}, B0;
function OJ() {
  if (B0) return Ir;
  B0 = 1;
  var t = Ir && Ir.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Ir && Ir.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Ir && Ir.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Ir, "__esModule", { value: !0 }), Ir.filesDownload = h;
  const a = n(/* @__PURE__ */ H()), r = /* @__PURE__ */ Ne(), i = n(/* @__PURE__ */ Fe()), s = /* @__PURE__ */ X(), u = /* @__PURE__ */ Z(), d = /* @__PURE__ */ ke(), f = /* @__PURE__ */ Ee(), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, u.safeParse)(m, (V) => o.FilesApiRoutesDownloadFileRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = {
      file_id: (0, r.encodeSimple)("file_id", _.file_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, f.pathToFunc)("/v1/files/{file_id}/content")(R), T = new Headers((0, s.compactMap)({
      Accept: "application/octet-stream"
    })), O = await (0, d.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, d.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "files_api_routes_download_file",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await i.match(i.stream(200, a.instanceof(ReadableStream)), i.fail("4XX"), i.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return Ir;
}
var Nr = {}, x0;
function jJ() {
  if (x0) return Nr;
  x0 = 1;
  var t = Nr && Nr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Nr && Nr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Nr && Nr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Nr, "__esModule", { value: !0 }), Nr.filesGetSignedUrl = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (ue) => o.FilesApiRoutesGetSignedUrlRequest$outboundSchema.parse(ue), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = {
      file_id: (0, a.encodeSimple)("file_id", _.file_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, d.pathToFunc)("/v1/files/{file_id}/url")(R), T = (0, a.encodeFormQuery)({
      expiry: _.expiry
    }), O = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), A = await (0, u.extractSecurity)(l._options.apiKey), M = A == null ? {} : { apiKey: A }, I = (0, u.resolveGlobalSecurity)(M), N = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "files_api_routes_get_signed_url",
      oAuth2Scopes: [],
      resolvedSecurity: I,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, v = l._createRequest(N, {
      security: I,
      method: "GET",
      baseURL: b?.serverURL,
      path: C,
      headers: O,
      query: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!v.ok)
      return [v, { status: "invalid" }];
    const F = v.value, L = await l._do(F, {
      context: N,
      errorCodes: ["4XX", "5XX"],
      retryConfig: N.retryConfig,
      retryCodes: N.retryCodes
    });
    if (!L.ok)
      return [L, { status: "request-error", request: F }];
    const B = L.value, [V] = await r.match(r.json(200, f.FileSignedURL$inboundSchema), r.fail("4XX"), r.fail("5XX"))(B);
    return V.ok ? [V, { status: "complete", request: F, response: B }] : [V, { status: "complete", request: F, response: B }];
  }
  return Nr;
}
var Fr = {}, V0;
function PJ() {
  if (V0) return Fr;
  V0 = 1;
  var t = Fr && Fr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Fr && Fr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Fr && Fr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Fr, "__esModule", { value: !0 }), Fr.filesList = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.FilesApiRoutesListFilesRequest$outboundSchema.optional().parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = (0, d.pathToFunc)("/v1/files")(), C = (0, a.encodeFormQuery)({
      page: _?.page,
      page_size: _?.page_size,
      purpose: _?.purpose,
      sample_type: _?.sample_type,
      search: _?.search,
      source: _?.source
    }), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "files_api_routes_list_files",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      query: C,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.ListFilesOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return Fr;
}
var kr = {}, z0;
function CJ() {
  if (z0) return kr;
  z0 = 1;
  var t = kr && kr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = kr && kr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = kr && kr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(kr, "__esModule", { value: !0 }), kr.filesRetrieve = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.FilesApiRoutesRetrieveFileRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = {
      file_id: (0, a.encodeSimple)("file_id", _.file_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, d.pathToFunc)("/v1/files/{file_id}")(R), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "files_api_routes_retrieve_file",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.RetrieveFileOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return kr;
}
var Dr = {}, Jf = {}, Z0;
function RJ() {
  if (Z0) return Jf;
  Z0 = 1, Object.defineProperty(Jf, "__esModule", { value: !0 }), Jf.isReadableStream = t;
  function t(e) {
    if (typeof e != "object" || e === null)
      return !1;
    const n = e;
    return typeof n.getReader == "function" && typeof n.cancel == "function" && typeof n.tee == "function";
  }
  return Jf;
}
var K0;
function TJ() {
  if (K0) return Dr;
  K0 = 1;
  var t = Dr && Dr.__createBinding || (Object.create ? function(g, _, P, R) {
    R === void 0 && (R = P);
    var C = Object.getOwnPropertyDescriptor(_, P);
    (!C || ("get" in C ? !_.__esModule : C.writable || C.configurable)) && (C = { enumerable: !0, get: function() {
      return _[P];
    } }), Object.defineProperty(g, R, C);
  } : function(g, _, P, R) {
    R === void 0 && (R = P), g[R] = _[P];
  }), e = Dr && Dr.__setModuleDefault || (Object.create ? function(g, _) {
    Object.defineProperty(g, "default", { enumerable: !0, value: _ });
  } : function(g, _) {
    g.default = _;
  }), n = Dr && Dr.__importStar || function(g) {
    if (g && g.__esModule) return g;
    var _ = {};
    if (g != null) for (var P in g) P !== "default" && Object.prototype.hasOwnProperty.call(g, P) && t(_, g, P);
    return e(_, g), _;
  };
  Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.filesUpload = m;
  const a = /* @__PURE__ */ Ne(), r = /* @__PURE__ */ UR(), i = n(/* @__PURE__ */ Fe()), s = /* @__PURE__ */ X(), u = /* @__PURE__ */ Z(), d = /* @__PURE__ */ ke(), f = /* @__PURE__ */ Ee(), o = n(/* @__PURE__ */ Oe()), c = n(/* @__PURE__ */ yt()), h = /* @__PURE__ */ De(), p = /* @__PURE__ */ $T(), l = /* @__PURE__ */ RJ();
  function m(g, _, P) {
    return new h.APIPromise(b(g, _, P));
  }
  async function b(g, _, P) {
    const R = (0, u.safeParse)(_, (ie) => c.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema.parse(ie), "Input validation failed");
    if (!R.ok)
      return [R, { status: "invalid" }];
    const C = R.value, T = new FormData();
    if ((0, p.isBlobLike)(C.file))
      (0, a.appendForm)(T, "file", C.file);
    else if ((0, l.isReadableStream)(C.file.content)) {
      const ie = await (0, r.readableStreamToArrayBuffer)(C.file.content), ut = new Blob([ie], { type: "application/octet-stream" });
      (0, a.appendForm)(T, "file", ut);
    } else
      (0, a.appendForm)(T, "file", new Blob([C.file.content], { type: "application/octet-stream" }), C.file.fileName);
    C.purpose !== void 0 && (0, a.appendForm)(T, "purpose", C.purpose);
    const O = (0, f.pathToFunc)("/v1/files")(), A = new Headers((0, s.compactMap)({
      Accept: "application/json"
    })), M = await (0, d.extractSecurity)(g._options.apiKey), I = M == null ? {} : { apiKey: M }, N = (0, d.resolveGlobalSecurity)(I), v = {
      baseURL: P?.serverURL ?? g._baseURL ?? "",
      operationID: "files_api_routes_upload_file",
      oAuth2Scopes: [],
      resolvedSecurity: N,
      securitySource: g._options.apiKey,
      retryConfig: P?.retries || g._options.retryConfig || { strategy: "none" },
      retryCodes: P?.retryCodes || ["429", "500", "502", "503", "504"]
    }, F = g._createRequest(v, {
      security: N,
      method: "POST",
      baseURL: P?.serverURL,
      path: O,
      headers: A,
      body: T,
      timeoutMs: P?.timeoutMs || g._options.timeoutMs || -1
    }, P);
    if (!F.ok)
      return [F, { status: "invalid" }];
    const L = F.value, B = await g._do(L, {
      context: v,
      errorCodes: ["4XX", "5XX"],
      retryConfig: v.retryConfig,
      retryCodes: v.retryCodes
    });
    if (!B.ok)
      return [B, { status: "request-error", request: L }];
    const V = B.value, [ue] = await i.match(i.json(200, o.UploadFileOut$inboundSchema), i.fail("4XX"), i.fail("5XX"))(V);
    return ue.ok ? [ue, { status: "complete", request: L, response: V }] : [ue, { status: "complete", request: L, response: V }];
  }
  return Dr;
}
var H0;
function $J() {
  if (H0) return ml;
  H0 = 1, Object.defineProperty(ml, "__esModule", { value: !0 }), ml.Files = void 0;
  const t = /* @__PURE__ */ SJ(), e = /* @__PURE__ */ OJ(), n = /* @__PURE__ */ jJ(), a = /* @__PURE__ */ PJ(), r = /* @__PURE__ */ CJ(), i = /* @__PURE__ */ TJ(), s = /* @__PURE__ */ Rn(), u = /* @__PURE__ */ Vn();
  class d extends s.ClientSDK {
    /**
     * Upload File
     *
     * @remarks
     * Upload a file that can be used across various endpoints.
     *
     * The size of individual files can be a maximum of 512 MB. The Fine-tuning API only supports .jsonl files.
     *
     * Please contact us if you need to increase these storage limits.
     */
    async upload(o, c) {
      return (0, u.unwrapAsync)((0, i.filesUpload)(this, o, c));
    }
    /**
     * List Files
     *
     * @remarks
     * Returns a list of files that belong to the user's organization.
     */
    async list(o, c) {
      return (0, u.unwrapAsync)((0, a.filesList)(this, o, c));
    }
    /**
     * Retrieve File
     *
     * @remarks
     * Returns information about a specific file.
     */
    async retrieve(o, c) {
      return (0, u.unwrapAsync)((0, r.filesRetrieve)(this, o, c));
    }
    /**
     * Delete File
     *
     * @remarks
     * Delete a file.
     */
    async delete(o, c) {
      return (0, u.unwrapAsync)((0, t.filesDelete)(this, o, c));
    }
    /**
     * Download File
     *
     * @remarks
     * Download a file
     */
    async download(o, c) {
      return (0, u.unwrapAsync)((0, e.filesDownload)(this, o, c));
    }
    /**
     * Get Signed Url
     */
    async getSignedUrl(o, c) {
      return (0, u.unwrapAsync)((0, n.filesGetSignedUrl)(this, o, c));
    }
  }
  return ml.Files = d, ml;
}
var bl = {}, qr = {}, G0;
function MJ() {
  if (G0) return qr;
  G0 = 1;
  var t = qr && qr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = qr && qr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = qr && qr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(qr, "__esModule", { value: !0 }), qr.fimComplete = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ Tn()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.FIMCompletionRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), R = (0, d.pathToFunc)("/v1/fim/completions")(), C = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, u.extractSecurity)(l._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, u.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "fim_completion_v1_fim_completions_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = l._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: R,
      headers: C,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, v = await l._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!v.ok)
      return [v, { status: "request-error", request: N }];
    const F = v.value, L = {
      HttpMeta: { Response: F, Request: N }
    }, [B] = await r.match(r.json(200, f.FIMCompletionResponse$inboundSchema), r.jsonErr(422, o.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(F, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: F }] : [B, { status: "complete", request: N, response: F }];
  }
  return qr;
}
var Jr = {}, W0;
function AJ() {
  if (W0) return Jr;
  W0 = 1;
  var t = Jr && Jr.__createBinding || (Object.create ? function(b, g, _, P) {
    P === void 0 && (P = _);
    var R = Object.getOwnPropertyDescriptor(g, _);
    (!R || ("get" in R ? !g.__esModule : R.writable || R.configurable)) && (R = { enumerable: !0, get: function() {
      return g[_];
    } }), Object.defineProperty(b, P, R);
  } : function(b, g, _, P) {
    P === void 0 && (P = _), b[P] = g[_];
  }), e = Jr && Jr.__setModuleDefault || (Object.create ? function(b, g) {
    Object.defineProperty(b, "default", { enumerable: !0, value: g });
  } : function(b, g) {
    b.default = g;
  }), n = Jr && Jr.__importStar || function(b) {
    if (b && b.__esModule) return b;
    var g = {};
    if (b != null) for (var _ in b) _ !== "default" && Object.prototype.hasOwnProperty.call(b, _) && t(g, b, _);
    return e(g, b), g;
  };
  Object.defineProperty(Jr, "__esModule", { value: !0 }), Jr.fimStream = l;
  const a = n(/* @__PURE__ */ H()), r = /* @__PURE__ */ Ne(), i = /* @__PURE__ */ wp(), s = n(/* @__PURE__ */ Fe()), u = /* @__PURE__ */ X(), d = /* @__PURE__ */ Z(), f = /* @__PURE__ */ ke(), o = /* @__PURE__ */ Ee(), c = n(/* @__PURE__ */ Oe()), h = n(/* @__PURE__ */ Tn()), p = /* @__PURE__ */ De();
  function l(b, g, _) {
    return new p.APIPromise(m(b, g, _));
  }
  async function m(b, g, _) {
    const P = (0, d.safeParse)(g, (ie) => c.FIMCompletionStreamRequest$outboundSchema.parse(ie), "Input validation failed");
    if (!P.ok)
      return [P, { status: "invalid" }];
    const R = P.value, C = (0, r.encodeJSON)("body", R, { explode: !0 }), T = (0, o.pathToFunc)("/v1/fim/completions#stream")(), O = new Headers((0, u.compactMap)({
      "Content-Type": "application/json",
      Accept: "text/event-stream"
    })), A = await (0, f.extractSecurity)(b._options.apiKey), M = A == null ? {} : { apiKey: A }, I = (0, f.resolveGlobalSecurity)(M), N = {
      baseURL: _?.serverURL ?? b._baseURL ?? "",
      operationID: "stream_fim",
      oAuth2Scopes: [],
      resolvedSecurity: I,
      securitySource: b._options.apiKey,
      retryConfig: _?.retries || b._options.retryConfig || { strategy: "none" },
      retryCodes: _?.retryCodes || ["429", "500", "502", "503", "504"]
    }, v = b._createRequest(N, {
      security: I,
      method: "POST",
      baseURL: _?.serverURL,
      path: T,
      headers: O,
      body: C,
      timeoutMs: _?.timeoutMs || b._options.timeoutMs || -1
    }, _);
    if (!v.ok)
      return [v, { status: "invalid" }];
    const F = v.value, L = await b._do(F, {
      context: N,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: N.retryConfig,
      retryCodes: N.retryCodes
    });
    if (!L.ok)
      return [L, { status: "request-error", request: F }];
    const B = L.value, V = {
      HttpMeta: { Response: B, Request: F }
    }, [ue] = await s.match(s.sse(200, a.instanceof(ReadableStream).transform((ie) => new i.EventStream({
      stream: ie,
      decoder(ut) {
        return c.CompletionEvent$inboundSchema.parse(ut);
      }
    })), { sseSentinel: "[DONE]" }), s.jsonErr(422, h.HTTPValidationError$inboundSchema), s.fail("4XX"), s.fail("5XX"))(B, { extraFields: V });
    return ue.ok ? [ue, { status: "complete", request: F, response: B }] : [ue, { status: "complete", request: F, response: B }];
  }
  return Jr;
}
var X0;
function EJ() {
  if (X0) return bl;
  X0 = 1, Object.defineProperty(bl, "__esModule", { value: !0 }), bl.Fim = void 0;
  const t = /* @__PURE__ */ MJ(), e = /* @__PURE__ */ AJ(), n = /* @__PURE__ */ Rn(), a = /* @__PURE__ */ Vn();
  class r extends n.ClientSDK {
    /**
     * Fim Completion
     *
     * @remarks
     * FIM completion.
     */
    async complete(s, u) {
      return (0, a.unwrapAsync)((0, t.fimComplete)(this, s, u));
    }
    /**
     * Stream fim completion
     *
     * @remarks
     * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
     */
    async stream(s, u) {
      return (0, a.unwrapAsync)((0, e.fimStream)(this, s, u));
    }
  }
  return bl.Fim = r, bl;
}
var gl = {}, _l = {}, Lr = {}, Q0;
function IJ() {
  if (Q0) return Lr;
  Q0 = 1;
  var t = Lr && Lr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Lr && Lr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Lr && Lr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Lr, "__esModule", { value: !0 }), Lr.fineTuningJobsCancel = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = {
      job_id: (0, a.encodeSimple)("job_id", _.job_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, d.pathToFunc)("/v1/fine_tuning/jobs/{job_id}/cancel")(R), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_cancel_fine_tuning_job",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "POST",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.DetailedJobOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return Lr;
}
var Ur = {}, Y0;
function NJ() {
  if (Y0) return Ur;
  Y0 = 1;
  var t = Ur && Ur.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Ur && Ur.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Ur && Ur.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Ur, "__esModule", { value: !0 }), Ur.fineTuningJobsCreate = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (B) => f.JobIn$outboundSchema.parse(B), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), R = (0, d.pathToFunc)("/v1/fine_tuning/jobs")(), C = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, u.extractSecurity)(l._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, u.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_create_fine_tuning_job",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = l._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: R,
      headers: C,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, v = await l._do(N, {
      context: M,
      errorCodes: ["4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!v.ok)
      return [v, { status: "request-error", request: N }];
    const F = v.value, [L] = await r.match(r.json(200, o.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema), r.fail("4XX"), r.fail("5XX"))(F);
    return L.ok ? [L, { status: "complete", request: N, response: F }] : [L, { status: "complete", request: N, response: F }];
  }
  return Ur;
}
var Br = {}, ej;
function FJ() {
  if (ej) return Br;
  ej = 1;
  var t = Br && Br.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Br && Br.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Br && Br.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Br, "__esModule", { value: !0 }), Br.fineTuningJobsGet = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = {
      job_id: (0, a.encodeSimple)("job_id", _.job_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, d.pathToFunc)("/v1/fine_tuning/jobs/{job_id}")(R), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_get_fine_tuning_job",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.DetailedJobOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return Br;
}
var xr = {}, tj;
function kJ() {
  if (tj) return xr;
  tj = 1;
  var t = xr && xr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = xr && xr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = xr && xr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(xr, "__esModule", { value: !0 }), xr.fineTuningJobsList = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema.optional().parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = (0, d.pathToFunc)("/v1/fine_tuning/jobs")(), C = (0, a.encodeFormQuery)({
      created_after: _?.created_after,
      created_by_me: _?.created_by_me,
      model: _?.model,
      page: _?.page,
      page_size: _?.page_size,
      status: _?.status,
      suffix: _?.suffix,
      wandb_name: _?.wandb_name,
      wandb_project: _?.wandb_project
    }), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_get_fine_tuning_jobs",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: R,
      headers: T,
      query: C,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.JobsOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return xr;
}
var Vr = {}, nj;
function DJ() {
  if (nj) return Vr;
  nj = 1;
  var t = Vr && Vr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Vr && Vr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Vr && Vr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Vr, "__esModule", { value: !0 }), Vr.fineTuningJobsStart = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = {
      job_id: (0, a.encodeSimple)("job_id", _.job_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, d.pathToFunc)("/v1/fine_tuning/jobs/{job_id}/start")(R), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_start_fine_tuning_job",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "POST",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.DetailedJobOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return Vr;
}
var rj;
function qJ() {
  if (rj) return _l;
  rj = 1, Object.defineProperty(_l, "__esModule", { value: !0 }), _l.Jobs = void 0;
  const t = /* @__PURE__ */ IJ(), e = /* @__PURE__ */ NJ(), n = /* @__PURE__ */ FJ(), a = /* @__PURE__ */ kJ(), r = /* @__PURE__ */ DJ(), i = /* @__PURE__ */ Rn(), s = /* @__PURE__ */ Vn();
  class u extends i.ClientSDK {
    /**
     * Get Fine Tuning Jobs
     *
     * @remarks
     * Get a list of fine-tuning jobs for your organization and user.
     */
    async list(f, o) {
      return (0, s.unwrapAsync)((0, a.fineTuningJobsList)(this, f, o));
    }
    /**
     * Create Fine Tuning Job
     *
     * @remarks
     * Create a new fine-tuning job, it will be queued for processing.
     */
    async create(f, o) {
      return (0, s.unwrapAsync)((0, e.fineTuningJobsCreate)(this, f, o));
    }
    /**
     * Get Fine Tuning Job
     *
     * @remarks
     * Get a fine-tuned job details by its UUID.
     */
    async get(f, o) {
      return (0, s.unwrapAsync)((0, n.fineTuningJobsGet)(this, f, o));
    }
    /**
     * Cancel Fine Tuning Job
     *
     * @remarks
     * Request the cancellation of a fine tuning job.
     */
    async cancel(f, o) {
      return (0, s.unwrapAsync)((0, t.fineTuningJobsCancel)(this, f, o));
    }
    /**
     * Start Fine Tuning Job
     *
     * @remarks
     * Request the start of a validated fine tuning job.
     */
    async start(f, o) {
      return (0, s.unwrapAsync)((0, r.fineTuningJobsStart)(this, f, o));
    }
  }
  return _l.Jobs = u, _l;
}
var aj;
function JJ() {
  if (aj) return gl;
  aj = 1, Object.defineProperty(gl, "__esModule", { value: !0 }), gl.FineTuning = void 0;
  const t = /* @__PURE__ */ Rn(), e = /* @__PURE__ */ qJ();
  class n extends t.ClientSDK {
    get jobs() {
      return this._jobs ?? (this._jobs = new e.Jobs(this._options));
    }
  }
  return gl.FineTuning = n, gl;
}
var yl = {}, zr = {}, ij;
function LJ() {
  if (ij) return zr;
  ij = 1;
  var t = zr && zr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = zr && zr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = zr && zr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(zr, "__esModule", { value: !0 }), zr.modelsArchive = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = {
      model_id: (0, a.encodeSimple)("model_id", _.model_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, d.pathToFunc)("/v1/fine_tuning/models/{model_id}/archive")(R), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_archive_fine_tuned_model",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "POST",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.ArchiveFTModelOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return zr;
}
var Zr = {}, sj;
function UJ() {
  if (sj) return Zr;
  sj = 1;
  var t = Zr && Zr.__createBinding || (Object.create ? function(m, b, g, _) {
    _ === void 0 && (_ = g);
    var P = Object.getOwnPropertyDescriptor(b, g);
    (!P || ("get" in P ? !b.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
      return b[g];
    } }), Object.defineProperty(m, _, P);
  } : function(m, b, g, _) {
    _ === void 0 && (_ = g), m[_] = b[g];
  }), e = Zr && Zr.__setModuleDefault || (Object.create ? function(m, b) {
    Object.defineProperty(m, "default", { enumerable: !0, value: b });
  } : function(m, b) {
    m.default = b;
  }), n = Zr && Zr.__importStar || function(m) {
    if (m && m.__esModule) return m;
    var b = {};
    if (m != null) for (var g in m) g !== "default" && Object.prototype.hasOwnProperty.call(m, g) && t(b, m, g);
    return e(b, m), b;
  };
  Object.defineProperty(Zr, "__esModule", { value: !0 }), Zr.modelsDelete = p;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ Tn()), c = n(/* @__PURE__ */ yt()), h = /* @__PURE__ */ De();
  function p(m, b, g) {
    return new h.APIPromise(l(m, b, g));
  }
  async function l(m, b, g) {
    const _ = (0, s.safeParse)(b, (ie) => c.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema.parse(ie), "Input validation failed");
    if (!_.ok)
      return [_, { status: "invalid" }];
    const P = _.value, R = null, C = {
      model_id: (0, a.encodeSimple)("model_id", P.model_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, T = (0, d.pathToFunc)("/v1/models/{model_id}")(C), O = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), A = await (0, u.extractSecurity)(m._options.apiKey), M = A == null ? {} : { apiKey: A }, I = (0, u.resolveGlobalSecurity)(M), N = {
      baseURL: g?.serverURL ?? m._baseURL ?? "",
      operationID: "delete_model_v1_models__model_id__delete",
      oAuth2Scopes: [],
      resolvedSecurity: I,
      securitySource: m._options.apiKey,
      retryConfig: g?.retries || m._options.retryConfig || { strategy: "none" },
      retryCodes: g?.retryCodes || ["429", "500", "502", "503", "504"]
    }, v = m._createRequest(N, {
      security: I,
      method: "DELETE",
      baseURL: g?.serverURL,
      path: T,
      headers: O,
      body: R,
      timeoutMs: g?.timeoutMs || m._options.timeoutMs || -1
    }, g);
    if (!v.ok)
      return [v, { status: "invalid" }];
    const F = v.value, L = await m._do(F, {
      context: N,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: N.retryConfig,
      retryCodes: N.retryCodes
    });
    if (!L.ok)
      return [L, { status: "request-error", request: F }];
    const B = L.value, V = {
      HttpMeta: { Response: B, Request: F }
    }, [ue] = await r.match(r.json(200, f.DeleteModelOut$inboundSchema), r.jsonErr(422, o.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(B, { extraFields: V });
    return ue.ok ? [ue, { status: "complete", request: F, response: B }] : [ue, { status: "complete", request: F, response: B }];
  }
  return Zr;
}
var Kr = {}, oj;
function BJ() {
  if (oj) return Kr;
  oj = 1;
  var t = Kr && Kr.__createBinding || (Object.create ? function(h, p, l, m) {
    m === void 0 && (m = l);
    var b = Object.getOwnPropertyDescriptor(p, l);
    (!b || ("get" in b ? !p.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
      return p[l];
    } }), Object.defineProperty(h, m, b);
  } : function(h, p, l, m) {
    m === void 0 && (m = l), h[m] = p[l];
  }), e = Kr && Kr.__setModuleDefault || (Object.create ? function(h, p) {
    Object.defineProperty(h, "default", { enumerable: !0, value: p });
  } : function(h, p) {
    h.default = p;
  }), n = Kr && Kr.__importStar || function(h) {
    if (h && h.__esModule) return h;
    var p = {};
    if (h != null) for (var l in h) l !== "default" && Object.prototype.hasOwnProperty.call(h, l) && t(p, h, l);
    return e(p, h), p;
  };
  Object.defineProperty(Kr, "__esModule", { value: !0 }), Kr.modelsList = o;
  const a = n(/* @__PURE__ */ Fe()), r = /* @__PURE__ */ X(), i = /* @__PURE__ */ ke(), s = /* @__PURE__ */ Ee(), u = n(/* @__PURE__ */ Oe()), d = n(/* @__PURE__ */ Tn()), f = /* @__PURE__ */ De();
  function o(h, p) {
    return new f.APIPromise(c(h, p));
  }
  async function c(h, p) {
    const l = (0, s.pathToFunc)("/v1/models")(), m = new Headers((0, r.compactMap)({
      Accept: "application/json"
    })), b = await (0, i.extractSecurity)(h._options.apiKey), g = b == null ? {} : { apiKey: b }, _ = (0, i.resolveGlobalSecurity)(g), P = {
      baseURL: p?.serverURL ?? h._baseURL ?? "",
      operationID: "list_models_v1_models_get",
      oAuth2Scopes: [],
      resolvedSecurity: _,
      securitySource: h._options.apiKey,
      retryConfig: p?.retries || h._options.retryConfig || { strategy: "none" },
      retryCodes: p?.retryCodes || ["429", "500", "502", "503", "504"]
    }, R = h._createRequest(P, {
      security: _,
      method: "GET",
      baseURL: p?.serverURL,
      path: l,
      headers: m,
      timeoutMs: p?.timeoutMs || h._options.timeoutMs || -1
    }, p);
    if (!R.ok)
      return [R, { status: "invalid" }];
    const C = R.value, T = await h._do(C, {
      context: P,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: P.retryConfig,
      retryCodes: P.retryCodes
    });
    if (!T.ok)
      return [T, { status: "request-error", request: C }];
    const O = T.value, A = {
      HttpMeta: { Response: O, Request: C }
    }, [M] = await a.match(a.json(200, u.ModelList$inboundSchema), a.jsonErr(422, d.HTTPValidationError$inboundSchema), a.fail("4XX"), a.fail("5XX"))(O, { extraFields: A });
    return M.ok ? [M, { status: "complete", request: C, response: O }] : [M, { status: "complete", request: C, response: O }];
  }
  return Kr;
}
var Hr = {}, uj;
function xJ() {
  if (uj) return Hr;
  uj = 1;
  var t = Hr && Hr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Hr && Hr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Hr && Hr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Hr, "__esModule", { value: !0 }), Hr.modelsRetrieve = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Tn()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (ue) => o.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema.parse(ue), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = {
      model_id: (0, a.encodeSimple)("model_id", _.model_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, d.pathToFunc)("/v1/models/{model_id}")(R), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "retrieve_model_v1_models__model_id__get",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "GET",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, B = {
      HttpMeta: { Response: L, Request: v }
    }, [V] = await r.match(r.json(200, o.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema), r.jsonErr(422, f.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L, { extraFields: B });
    return V.ok ? [V, { status: "complete", request: v, response: L }] : [V, { status: "complete", request: v, response: L }];
  }
  return Hr;
}
var Gr = {}, cj;
function VJ() {
  if (cj) return Gr;
  cj = 1;
  var t = Gr && Gr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Gr && Gr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Gr && Gr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Gr, "__esModule", { value: !0 }), Gr.modelsUnarchive = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = null, R = {
      model_id: (0, a.encodeSimple)("model_id", _.model_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, d.pathToFunc)("/v1/fine_tuning/models/{model_id}/archive")(R), T = new Headers((0, i.compactMap)({
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_unarchive_fine_tuned_model",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "DELETE",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.UnarchiveFTModelOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return Gr;
}
var Wr = {}, lj;
function zJ() {
  if (lj) return Wr;
  lj = 1;
  var t = Wr && Wr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Wr && Wr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Wr && Wr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Wr, "__esModule", { value: !0 }), Wr.modelsUpdate = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ yt()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => o.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _.UpdateFTModelIn, { explode: !0 }), R = {
      model_id: (0, a.encodeSimple)("model_id", _.model_id, {
        explode: !1,
        charEncoding: "percent"
      })
    }, C = (0, d.pathToFunc)("/v1/fine_tuning/models/{model_id}")(R), T = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), O = await (0, u.extractSecurity)(l._options.apiKey), A = O == null ? {} : { apiKey: O }, M = (0, u.resolveGlobalSecurity)(A), I = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "jobs_api_routes_fine_tuning_update_fine_tuned_model",
      oAuth2Scopes: [],
      resolvedSecurity: M,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, N = l._createRequest(I, {
      security: M,
      method: "PATCH",
      baseURL: b?.serverURL,
      path: C,
      headers: T,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!N.ok)
      return [N, { status: "invalid" }];
    const v = N.value, F = await l._do(v, {
      context: I,
      errorCodes: ["4XX", "5XX"],
      retryConfig: I.retryConfig,
      retryCodes: I.retryCodes
    });
    if (!F.ok)
      return [F, { status: "request-error", request: v }];
    const L = F.value, [B] = await r.match(r.json(200, f.FTModelOut$inboundSchema), r.fail("4XX"), r.fail("5XX"))(L);
    return B.ok ? [B, { status: "complete", request: v, response: L }] : [B, { status: "complete", request: v, response: L }];
  }
  return Wr;
}
var dj;
function ZJ() {
  if (dj) return yl;
  dj = 1, Object.defineProperty(yl, "__esModule", { value: !0 }), yl.Models = void 0;
  const t = /* @__PURE__ */ LJ(), e = /* @__PURE__ */ UJ(), n = /* @__PURE__ */ BJ(), a = /* @__PURE__ */ xJ(), r = /* @__PURE__ */ VJ(), i = /* @__PURE__ */ zJ(), s = /* @__PURE__ */ Rn(), u = /* @__PURE__ */ Vn();
  class d extends s.ClientSDK {
    /**
     * List Models
     *
     * @remarks
     * List all models available to the user.
     */
    async list(o) {
      return (0, u.unwrapAsync)((0, n.modelsList)(this, o));
    }
    /**
     * Retrieve Model
     *
     * @remarks
     * Retrieve a model information.
     */
    async retrieve(o, c) {
      return (0, u.unwrapAsync)((0, a.modelsRetrieve)(this, o, c));
    }
    /**
     * Delete Model
     *
     * @remarks
     * Delete a fine-tuned model.
     */
    async delete(o, c) {
      return (0, u.unwrapAsync)((0, e.modelsDelete)(this, o, c));
    }
    /**
     * Update Fine Tuned Model
     *
     * @remarks
     * Update a model name or description.
     */
    async update(o, c) {
      return (0, u.unwrapAsync)((0, i.modelsUpdate)(this, o, c));
    }
    /**
     * Archive Fine Tuned Model
     *
     * @remarks
     * Archive a fine-tuned model.
     */
    async archive(o, c) {
      return (0, u.unwrapAsync)((0, t.modelsArchive)(this, o, c));
    }
    /**
     * Unarchive Fine Tuned Model
     *
     * @remarks
     * Un-archive a fine-tuned model.
     */
    async unarchive(o, c) {
      return (0, u.unwrapAsync)((0, r.modelsUnarchive)(this, o, c));
    }
  }
  return yl.Models = d, yl;
}
var vl = {}, Xr = {}, fj;
function KJ() {
  if (fj) return Xr;
  fj = 1;
  var t = Xr && Xr.__createBinding || (Object.create ? function(l, m, b, g) {
    g === void 0 && (g = b);
    var _ = Object.getOwnPropertyDescriptor(m, b);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[b];
    } }), Object.defineProperty(l, g, _);
  } : function(l, m, b, g) {
    g === void 0 && (g = b), l[g] = m[b];
  }), e = Xr && Xr.__setModuleDefault || (Object.create ? function(l, m) {
    Object.defineProperty(l, "default", { enumerable: !0, value: m });
  } : function(l, m) {
    l.default = m;
  }), n = Xr && Xr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var m = {};
    if (l != null) for (var b in l) b !== "default" && Object.prototype.hasOwnProperty.call(l, b) && t(m, l, b);
    return e(m, l), m;
  };
  Object.defineProperty(Xr, "__esModule", { value: !0 }), Xr.ocrProcess = h;
  const a = /* @__PURE__ */ Ne(), r = n(/* @__PURE__ */ Fe()), i = /* @__PURE__ */ X(), s = /* @__PURE__ */ Z(), u = /* @__PURE__ */ ke(), d = /* @__PURE__ */ Ee(), f = n(/* @__PURE__ */ Oe()), o = n(/* @__PURE__ */ Tn()), c = /* @__PURE__ */ De();
  function h(l, m, b) {
    return new c.APIPromise(p(l, m, b));
  }
  async function p(l, m, b) {
    const g = (0, s.safeParse)(m, (V) => f.OCRRequest$outboundSchema.parse(V), "Input validation failed");
    if (!g.ok)
      return [g, { status: "invalid" }];
    const _ = g.value, P = (0, a.encodeJSON)("body", _, { explode: !0 }), R = (0, d.pathToFunc)("/v1/ocr")(), C = new Headers((0, i.compactMap)({
      "Content-Type": "application/json",
      Accept: "application/json"
    })), T = await (0, u.extractSecurity)(l._options.apiKey), O = T == null ? {} : { apiKey: T }, A = (0, u.resolveGlobalSecurity)(O), M = {
      baseURL: b?.serverURL ?? l._baseURL ?? "",
      operationID: "ocr_v1_ocr_post",
      oAuth2Scopes: [],
      resolvedSecurity: A,
      securitySource: l._options.apiKey,
      retryConfig: b?.retries || l._options.retryConfig || { strategy: "none" },
      retryCodes: b?.retryCodes || ["429", "500", "502", "503", "504"]
    }, I = l._createRequest(M, {
      security: A,
      method: "POST",
      baseURL: b?.serverURL,
      path: R,
      headers: C,
      body: P,
      timeoutMs: b?.timeoutMs || l._options.timeoutMs || -1
    }, b);
    if (!I.ok)
      return [I, { status: "invalid" }];
    const N = I.value, v = await l._do(N, {
      context: M,
      errorCodes: ["422", "4XX", "5XX"],
      retryConfig: M.retryConfig,
      retryCodes: M.retryCodes
    });
    if (!v.ok)
      return [v, { status: "request-error", request: N }];
    const F = v.value, L = {
      HttpMeta: { Response: F, Request: N }
    }, [B] = await r.match(r.json(200, f.OCRResponse$inboundSchema), r.jsonErr(422, o.HTTPValidationError$inboundSchema), r.fail("4XX"), r.fail("5XX"))(F, { extraFields: L });
    return B.ok ? [B, { status: "complete", request: N, response: F }] : [B, { status: "complete", request: N, response: F }];
  }
  return Xr;
}
var hj;
function HJ() {
  if (hj) return vl;
  hj = 1, Object.defineProperty(vl, "__esModule", { value: !0 }), vl.Ocr = void 0;
  const t = /* @__PURE__ */ KJ(), e = /* @__PURE__ */ Rn(), n = /* @__PURE__ */ Vn();
  class a extends e.ClientSDK {
    /**
     * OCR
     */
    async process(i, s) {
      return (0, n.unwrapAsync)((0, t.ocrProcess)(this, i, s));
    }
  }
  return vl.Ocr = a, vl;
}
var pj;
function GJ() {
  if (pj) return jc;
  pj = 1, Object.defineProperty(jc, "__esModule", { value: !0 }), jc.Mistral = void 0;
  const t = /* @__PURE__ */ Rn(), e = /* @__PURE__ */ Jq(), n = /* @__PURE__ */ lJ(), a = /* @__PURE__ */ bJ(), r = /* @__PURE__ */ yJ(), i = /* @__PURE__ */ wJ(), s = /* @__PURE__ */ $J(), u = /* @__PURE__ */ EJ(), d = /* @__PURE__ */ JJ(), f = /* @__PURE__ */ ZJ(), o = /* @__PURE__ */ HJ();
  class c extends t.ClientSDK {
    get models() {
      return this._models ?? (this._models = new f.Models(this._options));
    }
    get files() {
      return this._files ?? (this._files = new s.Files(this._options));
    }
    get fineTuning() {
      return this._fineTuning ?? (this._fineTuning = new d.FineTuning(this._options));
    }
    get batch() {
      return this._batch ?? (this._batch = new n.Batch(this._options));
    }
    get chat() {
      return this._chat ?? (this._chat = new a.Chat(this._options));
    }
    get fim() {
      return this._fim ?? (this._fim = new u.Fim(this._options));
    }
    get agents() {
      return this._agents ?? (this._agents = new e.Agents(this._options));
    }
    get embeddings() {
      return this._embeddings ?? (this._embeddings = new i.Embeddings(this._options));
    }
    get classifiers() {
      return this._classifiers ?? (this._classifiers = new r.Classifiers(this._options));
    }
    get ocr() {
      return this._ocr ?? (this._ocr = new o.Ocr(this._options));
    }
  }
  return jc.Mistral = c, jc;
}
var mj;
function WJ() {
  return mj || (mj = 1, function(t) {
    var e = Yn && Yn.__createBinding || (Object.create ? function(i, s, u, d) {
      d === void 0 && (d = u);
      var f = Object.getOwnPropertyDescriptor(s, u);
      (!f || ("get" in f ? !s.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
        return s[u];
      } }), Object.defineProperty(i, d, f);
    } : function(i, s, u, d) {
      d === void 0 && (d = u), i[d] = s[u];
    }), n = Yn && Yn.__setModuleDefault || (Object.create ? function(i, s) {
      Object.defineProperty(i, "default", { enumerable: !0, value: s });
    } : function(i, s) {
      i.default = s;
    }), a = Yn && Yn.__exportStar || function(i, s) {
      for (var u in i) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && e(s, i, u);
    }, r = Yn && Yn.__importStar || function(i) {
      if (i && i.__esModule) return i;
      var s = {};
      if (i != null) for (var u in i) u !== "default" && Object.prototype.hasOwnProperty.call(i, u) && e(s, i, u);
      return n(s, i), s;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.files = void 0, a(/* @__PURE__ */ o_(), t), t.files = r(/* @__PURE__ */ UR()), a(/* @__PURE__ */ GJ(), t);
  }(Yn)), Yn;
}
var a$ = /* @__PURE__ */ WJ();
const XJ = /* @__PURE__ */ BM({
  __proto__: null
}, [a$]);
var i$ = /* @__PURE__ */ vp();
const QJ = /^[a-zA-Z0-9]{9}$/;
function YJ(t) {
  return QJ.test(t);
}
function eL(t) {
  let e = t;
  const n = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  if (e === 0)
    return n[0];
  const a = [], r = n.length;
  for (; e; )
    a.push(n[e % r]), e = Math.floor(e / r);
  return a.reverse().join("");
}
function tL(t) {
  let e = 0;
  for (let n = 0; n < t.length; n += 1) {
    const a = t.charCodeAt(n);
    e = (e << 5) - e + a, e &= e;
  }
  return Math.abs(e);
}
function bj(t) {
  if (YJ(t))
    return t;
  {
    const e = tL(t), n = eL(e);
    return n.length >= 9 ? n.slice(0, 9) : n.padStart(9, "0");
  }
}
function s$(t) {
  return t ? typeof t == "string" ? t : t.map((e) => {
    if (e.type === "image_url") {
      if (typeof e.imageUrl != "string" && e.imageUrl?.detail) {
        const { detail: n } = e.imageUrl;
        if (n !== "high" && n !== "auto" && n !== "low")
          return {
            type: e.type,
            image_url: {
              url: e.imageUrl.url
            }
          };
      }
      return {
        type: e.type,
        image_url: e.imageUrl
      };
    }
    return e;
  }) : "";
}
function gj(t) {
  const e = (r) => {
    switch (r) {
      case "human":
        return "user";
      case "ai":
        return "assistant";
      case "system":
        return "system";
      case "tool":
        return "tool";
      case "function":
        return "assistant";
      default:
        throw new Error(`Unknown message type: ${r}`);
    }
  }, n = (r, i) => {
    const s = (u, d) => {
      if (u.type === "image_url" && (d === "user" || d === "assistant"))
        return {
          type: u.type,
          imageUrl: u?.image_url
        };
      if (u.type === "text")
        return {
          type: u.type,
          text: u?.text
        };
      throw new Error(`ChatMistralAI only supports messages of "image_url" for roles "user" and "assistant", and "text" for all others.

Received: ${JSON.stringify(r, null, 2)}`);
    };
    if (typeof r == "string")
      return r;
    if (Array.isArray(r)) {
      const u = e(i), d = [];
      return r.forEach((f) => {
        if (f.type === "text" || f.type === "image_url")
          d.push(s(f, u));
        else
          throw new Error('Mistral only supports types "text" or "image_url" for complex message types.');
      }), d;
    }
    throw new Error(`Message content must be a string or an array.

Received: ${JSON.stringify(r, null, 2)}`);
  }, a = (r) => {
    if (uo(r) && r.tool_calls?.length)
      return r.tool_calls.map((i) => ({
        ...i,
        id: bj(i.id ?? "")
      })).map(cR);
  };
  return t.map((r) => {
    const i = a(r), s = n(r.content, r.getType());
    return "tool_call_id" in r && typeof r.tool_call_id == "string" ? {
      role: e(r.getType()),
      content: s,
      name: r.name,
      toolCallId: bj(r.tool_call_id)
    } : uo(r) ? i === void 0 ? {
      role: e(r.getType()),
      content: s
    } : {
      role: e(r.getType()),
      toolCalls: i
    } : {
      role: e(r.getType()),
      content: s
    };
  });
}
function nL(t, e) {
  const { message: n } = t;
  if (n === void 0)
    throw new Error("No message found in response");
  let a = [];
  "toolCalls" in n && Array.isArray(n.toolCalls) && (a = n.toolCalls);
  const r = s$(n.content);
  switch (n.role) {
    case "assistant": {
      const i = [], s = [];
      for (const u of a)
        try {
          const d = dp(u, { returnId: !0 });
          i.push({
            ...d,
            id: d.id ?? jt().replace(/-/g, "")
          });
        } catch (d) {
          s.push(zg(u, d.message));
        }
      return new At({
        content: r,
        tool_calls: i,
        invalid_tool_calls: s,
        additional_kwargs: {},
        usage_metadata: e ? {
          input_tokens: e.promptTokens,
          output_tokens: e.completionTokens,
          total_tokens: e.totalTokens
        } : void 0
      });
    }
    default:
      return new mr({ content: r });
  }
}
function rL(t, e) {
  if (!t.content && !t.toolCalls)
    return e ? new We({
      content: "",
      usage_metadata: e ? {
        input_tokens: e.promptTokens,
        output_tokens: e.completionTokens,
        total_tokens: e.totalTokens
      } : void 0
    }) : null;
  const n = t.toolCalls?.length ? t.toolCalls?.map((u, d) => ({
    ...u,
    index: d,
    id: u.id ?? jt().replace(/-/g, ""),
    type: "function"
  })) : void 0;
  let a = "assistant";
  t.role && (a = t.role);
  const r = s$(t.content);
  let i;
  const s = [];
  if (n !== void 0)
    for (const u of n) {
      const d = u.function?.arguments, f = d === void 0 || typeof d == "string" ? d : JSON.stringify(d);
      s.push({
        name: u.function?.name,
        args: f,
        id: u.id,
        index: u.index,
        type: "tool_call_chunk"
      });
    }
  else
    i = {};
  return a === "user" ? new Md({ content: r }) : a === "assistant" ? new We({
    content: r,
    tool_call_chunks: s,
    additional_kwargs: i,
    usage_metadata: e ? {
      input_tokens: e.promptTokens,
      output_tokens: e.completionTokens,
      total_tokens: e.totalTokens
    } : void 0
  }) : a === "tool" ? new sp({
    content: r,
    additional_kwargs: i,
    tool_call_id: n?.[0].id ?? ""
  }) : a === "function" ? new $d({
    content: r,
    additional_kwargs: i
  }) : new Td({ content: r, role: a });
}
function _j(t) {
  return t.map((e) => {
    if ("function" in e)
      return e;
    const n = e.description ?? `Tool: ${e.name}`;
    return {
      type: "function",
      function: {
        name: e.name,
        description: n,
        parameters: xn(e.schema)
      }
    };
  });
}
class qV extends kn {
  // Used for tracing, replace with the same name as your class
  static lc_name() {
    return "ChatMistralAI";
  }
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "chat_models", "mistralai"]
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mistral-small-latest"
    }), Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "endpoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serverURL", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0.7
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "maxTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "safeMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "safePrompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "randomSeed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "seed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxRetries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "streamUsage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "beforeRequestHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "requestErrorHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "responseHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "httpClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "presencePenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "frequencyPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numCompletions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const n = e?.apiKey ?? _t("MISTRAL_API_KEY");
    if (!n)
      throw new Error("API key MISTRAL_API_KEY is missing for MistralAI, but it is required.");
    this.apiKey = n, this.streaming = e?.streaming ?? this.streaming, this.serverURL = e?.serverURL ?? this.serverURL, this.temperature = e?.temperature ?? this.temperature, this.topP = e?.topP ?? this.topP, this.maxTokens = e?.maxTokens ?? this.maxTokens, this.safePrompt = e?.safePrompt ?? this.safePrompt, this.randomSeed = e?.seed ?? e?.randomSeed ?? this.seed, this.seed = this.randomSeed, this.maxRetries = e?.maxRetries, this.httpClient = e?.httpClient, this.model = e?.model ?? e?.modelName ?? this.model, this.streamUsage = e?.streamUsage ?? this.streamUsage, this.beforeRequestHooks = e?.beforeRequestHooks ?? this.beforeRequestHooks, this.requestErrorHooks = e?.requestErrorHooks ?? this.requestErrorHooks, this.responseHooks = e?.responseHooks ?? this.responseHooks, this.presencePenalty = e?.presencePenalty ?? this.presencePenalty, this.frequencyPenalty = e?.frequencyPenalty ?? this.frequencyPenalty, this.numCompletions = e?.numCompletions ?? this.numCompletions, this.addAllHooksToHttpClient();
  }
  get lc_secrets() {
    return {
      apiKey: "MISTRAL_API_KEY"
    };
  }
  get lc_aliases() {
    return {
      apiKey: "mistral_api_key"
    };
  }
  getLsParams(e) {
    const n = this.invocationParams(e);
    return {
      ls_provider: "mistral",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: n.temperature ?? void 0,
      ls_max_tokens: n.maxTokens ?? void 0
    };
  }
  _llmType() {
    return "mistral_ai";
  }
  /**
   * Get the parameters used to invoke the model
   */
  invocationParams(e) {
    const { response_format: n, tools: a, tool_choice: r } = e ?? {}, i = a?.length ? _j(a) : void 0;
    return {
      model: this.model,
      tools: i,
      temperature: this.temperature,
      maxTokens: this.maxTokens,
      topP: this.topP,
      randomSeed: this.seed,
      safePrompt: this.safePrompt,
      toolChoice: r,
      responseFormat: n,
      presencePenalty: this.presencePenalty,
      frequencyPenalty: this.frequencyPenalty,
      n: this.numCompletions
    };
  }
  bindTools(e, n) {
    return this.bind({
      tools: _j(e),
      ...n
    });
  }
  async completionWithRetry(e, n) {
    const a = new Qo({
      maxRetries: this.maxRetries
    }), r = new a$.Mistral({
      apiKey: this.apiKey,
      serverURL: this.serverURL,
      // If httpClient exists, pass it into constructor
      ...this.httpClient ? { httpClient: this.httpClient } : {}
    });
    return a.call(async () => {
      try {
        let i;
        return n ? i = await r.chat.stream(e) : i = await r.chat.complete(e), i;
      } catch (i) {
        throw (i.message?.includes("status: 400") || i.message?.toLowerCase().includes("status 400") || i.message?.includes("validation failed")) && (i.status = 400), i;
      }
    });
  }
  /** @ignore */
  async _generate(e, n, a) {
    const r = {}, i = this.invocationParams(n), s = gj(e), u = {
      ...i,
      messages: s
    }, d = n.signal ?? !!n.timeout;
    if (this.streaming || d) {
      const l = this._streamResponseChunks(e, n, a), m = {};
      for await (const g of l) {
        const _ = g.generationInfo?.completion ?? 0;
        m[_] === void 0 ? m[_] = g : m[_] = m[_].concat(g);
      }
      return { generations: Object.entries(m).sort(([g], [_]) => parseInt(g, 10) - parseInt(_, 10)).map(([g, _]) => _), llmOutput: { estimatedTokenUsage: r } };
    }
    const f = await this.completionWithRetry(u, !1), { completionTokens: o, promptTokens: c, totalTokens: h } = f?.usage ?? {};
    o && (r.completionTokens = (r.completionTokens ?? 0) + o), c && (r.promptTokens = (r.promptTokens ?? 0) + c), h && (r.totalTokens = (r.totalTokens ?? 0) + h);
    const p = [];
    for (const l of f?.choices ?? []) {
      if ("delta" in l)
        throw new Error("Delta not supported in non-streaming mode.");
      if (!("message" in l))
        throw new Error("No message found in the choice.");
      let m = l.message?.content ?? "";
      Array.isArray(m) && (m = m[0].type === "text" ? m[0].text : "");
      const b = {
        text: m,
        message: nL(l, f?.usage)
      };
      l.finishReason && (b.generationInfo = { finishReason: l.finishReason }), p.push(b);
    }
    return {
      generations: p,
      llmOutput: { tokenUsage: r }
    };
  }
  async *_streamResponseChunks(e, n, a) {
    const r = gj(e), s = {
      ...this.invocationParams(n),
      messages: r
    }, u = await this.completionWithRetry(s, !0);
    for await (const { data: d } of u) {
      if (n.signal?.aborted)
        throw new Error("AbortError");
      const f = d?.choices[0];
      if (!f || !("delta" in f))
        continue;
      const { delta: o } = f;
      if (!o)
        continue;
      const c = {
        prompt: 0,
        completion: f.index ?? 0
      }, h = this.streamUsage || n.streamUsage, p = rL(o, h ? d.usage : null);
      if (p === null)
        continue;
      let l = o.content ?? "";
      Array.isArray(l) && (l = l[0].type === "text" ? l[0].text : "");
      const m = new On({
        message: p,
        text: l,
        generationInfo: c
      });
      yield m, a?.handleLLMNewToken(m.text ?? "", c, void 0, void 0, void 0, { chunk: m });
    }
  }
  addAllHooksToHttpClient() {
    try {
      if (this.removeAllHooksFromHttpClient(), [
        this.beforeRequestHooks,
        this.requestErrorHooks,
        this.responseHooks
      ].some((n) => n && n.length > 0) && !this.httpClient && (this.httpClient = new i$.HTTPClient()), this.beforeRequestHooks)
        for (const n of this.beforeRequestHooks)
          this.httpClient?.addHook("beforeRequest", n);
      if (this.requestErrorHooks)
        for (const n of this.requestErrorHooks)
          this.httpClient?.addHook("requestError", n);
      if (this.responseHooks)
        for (const n of this.responseHooks)
          this.httpClient?.addHook("response", n);
    } catch {
      throw new Error("Error in adding all hooks");
    }
  }
  removeAllHooksFromHttpClient() {
    try {
      if (this.beforeRequestHooks)
        for (const e of this.beforeRequestHooks)
          this.httpClient?.removeHook("beforeRequest", e);
      if (this.requestErrorHooks)
        for (const e of this.requestErrorHooks)
          this.httpClient?.removeHook("requestError", e);
      if (this.responseHooks)
        for (const e of this.responseHooks)
          this.httpClient?.removeHook("response", e);
    } catch {
      throw new Error("Error in removing hooks");
    }
  }
  removeHookFromHttpClient(e) {
    try {
      this.httpClient?.removeHook("beforeRequest", e), this.httpClient?.removeHook("requestError", e), this.httpClient?.removeHook("response", e);
    } catch {
      throw new Error("Error in removing hook");
    }
  }
  /** @ignore */
  _combineLLMOutput() {
    return [];
  }
  withStructuredOutput(e, n) {
    const a = e, r = n?.name, i = n?.method, s = n?.includeRaw;
    let u, d;
    if (i === "jsonMode")
      u = this.bind({
        response_format: { type: "json_object" }
      }), yj(a) ? d = $h.fromZodSchema(a) : d = new Mh();
    else {
      let h = r ?? "extract";
      if (yj(a)) {
        const p = xn(a);
        u = this.bind({
          tools: [
            {
              type: "function",
              function: {
                name: h,
                description: p.description,
                parameters: p
              }
            }
          ],
          tool_choice: "any"
        }), d = new Ah({
          returnSingle: !0,
          keyName: h,
          zodSchema: a
        });
      } else {
        let p;
        typeof a.name == "string" && typeof a.parameters == "object" && a.parameters != null ? (p = a, h = a.name) : p = {
          name: h,
          description: a.description ?? "",
          parameters: a
        }, u = this.bind({
          tools: [
            {
              type: "function",
              function: p
            }
          ],
          tool_choice: "any"
        }), d = new Ah({
          returnSingle: !0,
          keyName: h
        });
      }
    }
    if (!s)
      return u.pipe(d);
    const f = Ut.assign({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parsed: (h, p) => d.invoke(h.raw, p)
    }), o = Ut.assign({
      parsed: () => null
    }), c = f.withFallbacks({
      fallbacks: [o]
    });
    return gt.from([
      {
        raw: u
      },
      c
    ]);
  }
}
function yj(t) {
  return typeof t?.parse == "function";
}
class JV extends Xg {
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "modelName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mistral-embed"
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mistral-embed"
    }), Object.defineProperty(this, "encodingFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "float"
    }), Object.defineProperty(this, "batchSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 512
    }), Object.defineProperty(this, "stripNewLines", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "endpoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serverURL", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "beforeRequestHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "requestErrorHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "responseHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "httpClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const n = e?.apiKey ?? _t("MISTRAL_API_KEY");
    if (!n)
      throw new Error("API key missing for MistralAI, but it is required.");
    this.apiKey = n, this.serverURL = e?.serverURL ?? this.serverURL, this.modelName = e?.model ?? e?.modelName ?? this.model, this.model = this.modelName, this.encodingFormat = e?.encodingFormat ?? this.encodingFormat, this.batchSize = e?.batchSize ?? this.batchSize, this.stripNewLines = e?.stripNewLines ?? this.stripNewLines, this.beforeRequestHooks = e?.beforeRequestHooks ?? this.beforeRequestHooks, this.requestErrorHooks = e?.requestErrorHooks ?? this.requestErrorHooks, this.responseHooks = e?.responseHooks ?? this.responseHooks, this.httpClient = e?.httpClient ?? this.httpClient, this.addAllHooksToHttpClient();
  }
  /**
   * Method to generate embeddings for an array of documents. Splits the
   * documents into batches and makes requests to the MistralAI API to generate
   * embeddings.
   * @param {Array<string>} texts Array of documents to generate embeddings for.
   * @returns {Promise<number[][]>} Promise that resolves to a 2D array of embeddings for each document.
   */
  async embedDocuments(e) {
    const n = kh(this.stripNewLines ? e.map((s) => s.replace(/\n/g, " ")) : e, this.batchSize), a = n.map((s) => this.embeddingWithRetry(s)), r = await Promise.all(a), i = [];
    for (let s = 0; s < r.length; s += 1) {
      const u = n[s], { data: d } = r[s];
      for (let f = 0; f < u.length; f += 1)
        i.push(d[f].embedding ?? []);
    }
    return i;
  }
  /**
   * Method to generate an embedding for a single document. Calls the
   * embeddingWithRetry method with the document as the input.
   * @param {string} text Document to generate an embedding for.
   * @returns {Promise<number[]>} Promise that resolves to an embedding for the document.
   */
  async embedQuery(e) {
    const { data: n } = await this.embeddingWithRetry(this.stripNewLines ? e.replace(/\n/g, " ") : e);
    return n[0].embedding ?? [];
  }
  /**
   * Private method to make a request to the MistralAI API to generate
   * embeddings. Handles the retry logic and returns the response from the
   * API.
   * @param {string | Array<string>} inputs Text to send to the MistralAI API.
   * @returns {Promise<MistralAIEmbeddingsResponse>} Promise that resolves to the response from the API.
   */
  async embeddingWithRetry(e) {
    const { Mistral: n } = await this.imports(), a = new n({
      apiKey: this.apiKey,
      serverURL: this.serverURL,
      // If httpClient exists, pass it into constructor
      ...this.httpClient ? { httpClient: this.httpClient } : {}
    }), r = {
      model: this.model,
      inputs: e,
      encodingFormat: this.encodingFormat
    };
    return this.caller.call(async () => await a.embeddings.create(r));
  }
  addAllHooksToHttpClient() {
    try {
      if (this.removeAllHooksFromHttpClient(), [
        this.beforeRequestHooks,
        this.requestErrorHooks,
        this.responseHooks
      ].some((n) => n && n.length > 0) && !this.httpClient && (this.httpClient = new i$.HTTPClient()), this.beforeRequestHooks)
        for (const n of this.beforeRequestHooks)
          this.httpClient?.addHook("beforeRequest", n);
      if (this.requestErrorHooks)
        for (const n of this.requestErrorHooks)
          this.httpClient?.addHook("requestError", n);
      if (this.responseHooks)
        for (const n of this.responseHooks)
          this.httpClient?.addHook("response", n);
    } catch {
      throw new Error("Error in adding all hooks");
    }
  }
  removeAllHooksFromHttpClient() {
    try {
      if (this.beforeRequestHooks)
        for (const e of this.beforeRequestHooks)
          this.httpClient?.removeHook("beforeRequest", e);
      if (this.requestErrorHooks)
        for (const e of this.requestErrorHooks)
          this.httpClient?.removeHook("requestError", e);
      if (this.responseHooks)
        for (const e of this.responseHooks)
          this.httpClient?.removeHook("response", e);
    } catch {
      throw new Error("Error in removing hooks");
    }
  }
  removeHookFromHttpClient(e) {
    try {
      this.httpClient?.removeHook("beforeRequest", e), this.httpClient?.removeHook("requestError", e), this.httpClient?.removeHook("response", e);
    } catch {
      throw new Error("Error in removing hook");
    }
  }
  /** @ignore */
  async imports() {
    const { Mistral: e } = await Promise.resolve().then(() => XJ);
    return { Mistral: e };
  }
}
const aL = "0.5.14", o$ = "11434", u$ = `http://127.0.0.1:${o$}`;
var iL = Object.defineProperty, sL = (t, e, n) => e in t ? iL(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Zm = (t, e, n) => (sL(t, typeof e != "symbol" ? e + "" : e, n), n);
class P_ extends Error {
  constructor(e, n) {
    super(e), this.error = e, this.status_code = n, this.name = "ResponseError", Error.captureStackTrace && Error.captureStackTrace(this, P_);
  }
}
class oL {
  constructor(e, n, a) {
    Zm(this, "abortController"), Zm(this, "itr"), Zm(this, "doneCallback"), this.abortController = e, this.itr = n, this.doneCallback = a;
  }
  abort() {
    this.abortController.abort();
  }
  async *[Symbol.asyncIterator]() {
    for await (const e of this.itr) {
      if ("error" in e)
        throw new Error(e.error);
      if (yield e, e.done || e.status === "success") {
        this.doneCallback();
        return;
      }
    }
    throw new Error("Did not receive done or success response in stream.");
  }
}
const C_ = async (t) => {
  if (t.ok)
    return;
  let e = `Error ${t.status}: ${t.statusText}`, n = null;
  if (t.headers.get("content-type")?.includes("application/json"))
    try {
      n = await t.json(), e = n.error || e;
    } catch {
      console.log("Failed to parse error response as JSON");
    }
  else
    try {
      console.log("Getting text from response"), e = await t.text() || e;
    } catch {
      console.log("Failed to get text from error response");
    }
  throw new P_(e, t.status);
};
function uL() {
  if (typeof window < "u" && window.navigator) {
    const t = navigator;
    return "userAgentData" in t && t.userAgentData?.platform ? `${t.userAgentData.platform.toLowerCase()} Browser/${navigator.userAgent};` : navigator.platform ? `${navigator.platform.toLowerCase()} Browser/${navigator.userAgent};` : `unknown Browser/${navigator.userAgent};`;
  } else if (typeof pe < "u")
    return `${pe.arch} ${pe.platform} Node.js/${pe.version}`;
  return "";
}
function cL(t) {
  if (t instanceof Headers) {
    const e = {};
    return t.forEach((n, a) => {
      e[a] = n;
    }), e;
  } else return Array.isArray(t) ? Object.fromEntries(t) : t || {};
}
const R_ = async (t, e, n = {}) => {
  const a = {
    "Content-Type": "application/json",
    Accept: "application/json",
    "User-Agent": `ollama-js/${aL} (${uL()})`
  };
  n.headers = cL(n.headers);
  const r = Object.fromEntries(
    Object.entries(n.headers).filter(([i]) => !Object.keys(a).some((s) => s.toLowerCase() === i.toLowerCase()))
  );
  return n.headers = {
    ...a,
    ...r
  }, t(e, n);
}, vj = async (t, e, n) => {
  const a = await R_(t, e, {
    headers: n?.headers
  });
  return await C_(a), a;
}, gu = async (t, e, n, a) => {
  const i = ((u) => u !== null && typeof u == "object" && !Array.isArray(u))(n) ? JSON.stringify(n) : n, s = await R_(t, e, {
    method: "POST",
    body: i,
    signal: a?.signal,
    headers: a?.headers
  });
  return await C_(s), s;
}, lL = async (t, e, n, a) => {
  const r = await R_(t, e, {
    method: "DELETE",
    body: JSON.stringify(n),
    headers: a?.headers
  });
  return await C_(r), r;
}, dL = async function* (t) {
  const e = new TextDecoder("utf-8");
  let n = "";
  const a = t.getReader();
  for (; ; ) {
    const { done: r, value: i } = await a.read();
    if (r)
      break;
    n += e.decode(i);
    const s = n.split(`
`);
    n = s.pop() ?? "";
    for (const u of s)
      try {
        yield JSON.parse(u);
      } catch {
        console.warn("invalid json: ", u);
      }
  }
  for (const r of n.split(`
`).filter((i) => i !== ""))
    try {
      yield JSON.parse(r);
    } catch {
      console.warn("invalid json: ", r);
    }
}, fL = (t) => {
  if (!t)
    return u$;
  let e = t.includes("://");
  t.startsWith(":") && (t = `http://127.0.0.1${t}`, e = !0), e || (t = `http://${t}`);
  const n = new URL(t);
  let a = n.port;
  a || (e ? a = n.protocol === "https:" ? "443" : "80" : a = o$);
  let r = `${n.protocol}//${n.hostname}:${a}${n.pathname}`;
  return r.endsWith("/") && (r = r.slice(0, -1)), r;
};
var hL = Object.defineProperty, pL = (t, e, n) => e in t ? hL(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Km = (t, e, n) => (pL(t, typeof e != "symbol" ? e + "" : e, n), n);
let Cp = class {
  constructor(e) {
    Km(this, "config"), Km(this, "fetch"), Km(this, "ongoingStreamedRequests", []), this.config = {
      host: "",
      headers: e?.headers
    }, e?.proxy || (this.config.host = fL(e?.host ?? u$)), this.fetch = e?.fetch ?? fetch;
  }
  // Abort any ongoing streamed requests to Ollama
  abort() {
    for (const e of this.ongoingStreamedRequests)
      e.abort();
    this.ongoingStreamedRequests.length = 0;
  }
  /**
   * Processes a request to the Ollama server. If the request is streamable, it will return a
   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response
   * object.
   * @param endpoint {string} - The endpoint to send the request to.
   * @param request {object} - The request object to send to the endpoint.
   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields
   * response messages.
   * @throws {Error} - If the response body is missing or if the response is an error.
   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.
   */
  async processStreamableRequest(e, n) {
    n.stream = n.stream ?? !1;
    const a = `${this.config.host}/api/${e}`;
    if (n.stream) {
      const i = new AbortController(), s = await gu(this.fetch, a, n, {
        signal: i.signal,
        headers: this.config.headers
      });
      if (!s.body)
        throw new Error("Missing body");
      const u = dL(s.body), d = new oL(
        i,
        u,
        () => {
          const f = this.ongoingStreamedRequests.indexOf(d);
          f > -1 && this.ongoingStreamedRequests.splice(f, 1);
        }
      );
      return this.ongoingStreamedRequests.push(d), d;
    }
    return await (await gu(this.fetch, a, n, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Encodes an image to base64 if it is a Uint8Array.
   * @param image {Uint8Array | string} - The image to encode.
   * @returns {Promise<string>} - The base64 encoded image.
   */
  async encodeImage(e) {
    if (typeof e != "string") {
      const n = new Uint8Array(e);
      let a = "";
      const r = n.byteLength;
      for (let i = 0; i < r; i++)
        a += String.fromCharCode(n[i]);
      return btoa(a);
    }
    return e;
  }
  /**
   * Generates a response from a text prompt.
   * @param request {GenerateRequest} - The request object.
   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async generate(e) {
    return e.images && (e.images = await Promise.all(e.images.map(this.encodeImage.bind(this)))), this.processStreamableRequest("generate", e);
  }
  /**
   * Chats with the model. The request object can contain messages with images that are either
   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the
   * request.
   * @param request {ChatRequest} - The request object.
   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an
   * AbortableAsyncIterator that yields response messages.
   */
  async chat(e) {
    if (e.messages)
      for (const n of e.messages)
        n.images && (n.images = await Promise.all(
          n.images.map(this.encodeImage.bind(this))
        ));
    return this.processStreamableRequest("chat", e);
  }
  /**
   * Creates a new model from a stream of data.
   * @param request {CreateRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.
   */
  async create(e) {
    return this.processStreamableRequest("create", {
      ...e
    });
  }
  /**
   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PullRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async pull(e) {
    return this.processStreamableRequest("pull", {
      name: e.model,
      stream: e.stream,
      insecure: e.insecure
    });
  }
  /**
   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PushRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async push(e) {
    return this.processStreamableRequest("push", {
      name: e.model,
      stream: e.stream,
      insecure: e.insecure
    });
  }
  /**
   * Deletes a model from the server. The request object should contain the name of the model to
   * delete.
   * @param request {DeleteRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async delete(e) {
    return await lL(
      this.fetch,
      `${this.config.host}/api/delete`,
      { name: e.model },
      { headers: this.config.headers }
    ), { status: "success" };
  }
  /**
   * Copies a model from one name to another. The request object should contain the name of the
   * model to copy and the new name.
   * @param request {CopyRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async copy(e) {
    return await gu(this.fetch, `${this.config.host}/api/copy`, { ...e }, {
      headers: this.config.headers
    }), { status: "success" };
  }
  /**
   * Lists the models on the server.
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async list() {
    return await (await vj(this.fetch, `${this.config.host}/api/tags`, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Shows the metadata of a model. The request object should contain the name of the model.
   * @param request {ShowRequest} - The request object.
   * @returns {Promise<ShowResponse>} - The response object.
   */
  async show(e) {
    return await (await gu(this.fetch, `${this.config.host}/api/show`, {
      ...e
    }, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Embeds text input into vectors.
   * @param request {EmbedRequest} - The request object.
   * @returns {Promise<EmbedResponse>} - The response object.
   */
  async embed(e) {
    return await (await gu(this.fetch, `${this.config.host}/api/embed`, {
      ...e
    }, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Embeds a text prompt into a vector.
   * @param request {EmbeddingsRequest} - The request object.
   * @returns {Promise<EmbeddingsResponse>} - The response object.
   */
  async embeddings(e) {
    return await (await gu(this.fetch, `${this.config.host}/api/embeddings`, {
      ...e
    }, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Lists the running models on the server
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async ps() {
    return await (await vj(this.fetch, `${this.config.host}/api/ps`, {
      headers: this.config.headers
    })).json();
  }
};
new Cp();
function wj(t, e) {
  return new We({
    content: t.content ?? "",
    tool_call_chunks: t.tool_calls?.map((n) => ({
      name: n.function.name,
      args: JSON.stringify(n.function.arguments),
      type: "tool_call_chunk",
      index: 0,
      id: jt()
    })),
    response_metadata: e?.responseMetadata,
    usage_metadata: e?.usageMetadata
  });
}
function Sj(t) {
  const e = t.match(/^data:.*?;base64,(.*)$/);
  return e ? e[1] : "";
}
function mL(t) {
  if (typeof t.content == "string")
    return [
      {
        role: "assistant",
        content: t.content
      }
    ];
  const n = t.content.filter((r) => r.type === "text" && typeof r.text == "string").map((r) => ({
    role: "assistant",
    content: r.text
  }));
  let a;
  if (t.content.find((r) => r.type === "tool_use") && t.tool_calls?.length) {
    const r = t.tool_calls?.map((i) => ({
      id: i.id,
      type: "function",
      function: {
        name: i.name,
        arguments: i.args
      }
    }));
    r && (a = {
      role: "assistant",
      tool_calls: r,
      content: ""
    });
  } else if (t.content.find((r) => r.type === "tool_use") && !t.tool_calls?.length)
    throw new Error("'tool_use' content type is not supported without tool calls.");
  return [...n, ...a ? [a] : []];
}
function bL(t) {
  return typeof t.content == "string" ? [
    {
      role: "user",
      content: t.content
    }
  ] : t.content.map((e) => {
    if (e.type === "text")
      return {
        role: "user",
        content: e.text
      };
    if (e.type === "image_url") {
      if (typeof e.image_url == "string")
        return {
          role: "user",
          content: "",
          images: [Sj(e.image_url)]
        };
      if (e.image_url.url && typeof e.image_url.url == "string")
        return {
          role: "user",
          content: "",
          images: [Sj(e.image_url.url)]
        };
    }
    throw new Error(`Unsupported content type: ${e.type}`);
  });
}
function gL(t) {
  if (typeof t.content == "string")
    return [
      {
        role: "system",
        content: t.content
      }
    ];
  if (t.content.every((e) => e.type === "text" && typeof e.text == "string"))
    return t.content.map((e) => ({
      role: "system",
      content: e.text
    }));
  throw new Error(`Unsupported content type(s): ${t.content.map((e) => e.type).join(", ")}`);
}
function _L(t) {
  if (typeof t.content != "string")
    throw new Error("Non string tool message content is not supported");
  return [
    {
      role: "tool",
      content: t.content
    }
  ];
}
function yL(t) {
  return t.flatMap((e) => {
    if (["human", "generic"].includes(e._getType()))
      return bL(e);
    if (e._getType() === "ai")
      return mL(e);
    if (e._getType() === "system")
      return gL(e);
    if (e._getType() === "tool")
      return _L(e);
    throw new Error(`Unsupported message type: ${e._getType()}`);
  });
}
class UV extends kn {
  // Used for tracing, replace with the same name as your class
  static lc_name() {
    return "ChatOllama";
  }
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "llama3"
    }), Object.defineProperty(this, "numa", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numCtx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numBatch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numGpu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainGpu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lowVram", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "f16Kv", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logitsAll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "vocabOnly", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useMmap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useMlock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "embeddingOnly", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numThread", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numKeep", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "seed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numPredict", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topK", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tfsZ", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "typicalP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repeatLastN", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repeatPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "presencePenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "frequencyPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mirostat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mirostatTau", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mirostatEta", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "penalizeNewline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "format", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "keepAlive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkOrPullModel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "baseUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "http://127.0.0.1:11434"
    }), this.client = new Cp({
      host: e?.baseUrl,
      headers: e?.headers
    }), this.baseUrl = e?.baseUrl ?? this.baseUrl, this.model = e?.model ?? this.model, this.numa = e?.numa, this.numCtx = e?.numCtx, this.numBatch = e?.numBatch, this.numGpu = e?.numGpu, this.mainGpu = e?.mainGpu, this.lowVram = e?.lowVram, this.f16Kv = e?.f16Kv, this.logitsAll = e?.logitsAll, this.vocabOnly = e?.vocabOnly, this.useMmap = e?.useMmap, this.useMlock = e?.useMlock, this.embeddingOnly = e?.embeddingOnly, this.numThread = e?.numThread, this.numKeep = e?.numKeep, this.seed = e?.seed, this.numPredict = e?.numPredict, this.topK = e?.topK, this.topP = e?.topP, this.tfsZ = e?.tfsZ, this.typicalP = e?.typicalP, this.repeatLastN = e?.repeatLastN, this.temperature = e?.temperature, this.repeatPenalty = e?.repeatPenalty, this.presencePenalty = e?.presencePenalty, this.frequencyPenalty = e?.frequencyPenalty, this.mirostat = e?.mirostat, this.mirostatTau = e?.mirostatTau, this.mirostatEta = e?.mirostatEta, this.penalizeNewline = e?.penalizeNewline, this.streaming = e?.streaming, this.format = e?.format, this.keepAlive = e?.keepAlive, this.checkOrPullModel = e?.checkOrPullModel ?? this.checkOrPullModel;
  }
  // Replace
  _llmType() {
    return "ollama";
  }
  /**
   * Download a model onto the local machine.
   *
   * @param {string} model The name of the model to download.
   * @param {PullModelOptions | undefined} options Options for pulling the model.
   * @returns {Promise<void>}
   */
  async pull(e, n) {
    const { stream: a, insecure: r, logProgress: i } = {
      stream: !0,
      ...n
    };
    if (a)
      for await (const s of await this.client.pull({
        model: e,
        insecure: r,
        stream: a
      }))
        i && console.log(s);
    else {
      const s = await this.client.pull({ model: e, insecure: r });
      i && console.log(s);
    }
  }
  bindTools(e, n) {
    return this.bind({
      tools: e.map((a) => Ih(a)),
      ...n
    });
  }
  getLsParams(e) {
    const n = this.invocationParams(e);
    return {
      ls_provider: "ollama",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: n.options?.temperature ?? void 0,
      ls_max_tokens: n.options?.num_predict ?? void 0,
      ls_stop: e.stop
    };
  }
  invocationParams(e) {
    if (e?.tool_choice)
      throw new Error("Tool choice is not supported for ChatOllama.");
    return {
      model: this.model,
      format: e?.format ?? this.format,
      keep_alive: this.keepAlive,
      options: {
        numa: this.numa,
        num_ctx: this.numCtx,
        num_batch: this.numBatch,
        num_gpu: this.numGpu,
        main_gpu: this.mainGpu,
        low_vram: this.lowVram,
        f16_kv: this.f16Kv,
        logits_all: this.logitsAll,
        vocab_only: this.vocabOnly,
        use_mmap: this.useMmap,
        use_mlock: this.useMlock,
        embedding_only: this.embeddingOnly,
        num_thread: this.numThread,
        num_keep: this.numKeep,
        seed: this.seed,
        num_predict: this.numPredict,
        top_k: this.topK,
        top_p: this.topP,
        tfs_z: this.tfsZ,
        typical_p: this.typicalP,
        repeat_last_n: this.repeatLastN,
        temperature: this.temperature,
        repeat_penalty: this.repeatPenalty,
        presence_penalty: this.presencePenalty,
        frequency_penalty: this.frequencyPenalty,
        mirostat: this.mirostat,
        mirostat_tau: this.mirostatTau,
        mirostat_eta: this.mirostatEta,
        penalize_newline: this.penalizeNewline,
        stop: e?.stop
      },
      tools: e?.tools?.length ? e.tools.map((n) => Ih(n)) : void 0
    };
  }
  /**
   * Check if a model exists on the local machine.
   *
   * @param {string} model The name of the model to check.
   * @returns {Promise<boolean>} Whether or not the model exists.
   */
  async checkModelExistsOnMachine(e) {
    const { models: n } = await this.client.list();
    return !!n.find((a) => a.name === e || a.name === `${e}:latest`);
  }
  async _generate(e, n, a) {
    this.checkOrPullModel && (await this.checkModelExistsOnMachine(this.model) || await this.pull(this.model, {
      logProgress: !0
    }));
    let r;
    for await (const s of this._streamResponseChunks(e, n, a))
      r ? r = an(r, s.message) : r = s.message;
    const i = new At({
      id: r?.id,
      content: r?.content ?? "",
      tool_calls: r?.tool_calls,
      response_metadata: r?.response_metadata,
      usage_metadata: r?.usage_metadata
    });
    return {
      generations: [
        {
          text: typeof i.content == "string" ? i.content : "",
          message: i
        }
      ]
    };
  }
  /**
   * Implement to support streaming.
   * Should yield chunks iteratively.
   */
  async *_streamResponseChunks(e, n, a) {
    this.checkOrPullModel && (await this.checkModelExistsOnMachine(this.model) || await this.pull(this.model, {
      logProgress: !0
    }));
    const r = this.invocationParams(n), i = yL(e), s = {
      input_tokens: 0,
      output_tokens: 0,
      total_tokens: 0
    };
    if (r.tools && r.tools.length > 0) {
      const f = await this.client.chat({
        ...r,
        messages: i,
        stream: !1
        // Ollama currently does not support streaming with tools
      }), { message: o, ...c } = f;
      return s.input_tokens += c.prompt_eval_count ?? 0, s.output_tokens += c.eval_count ?? 0, s.total_tokens = s.input_tokens + s.output_tokens, yield new On({
        text: o.content,
        message: wj(o, {
          responseMetadata: c,
          usageMetadata: s
        })
      }), a?.handleLLMNewToken(o.content);
    }
    const u = await this.client.chat({
      ...r,
      messages: i,
      stream: !0
    });
    let d;
    for await (const f of u) {
      n.signal?.aborted && this.client.abort();
      const { message: o, ...c } = f;
      s.input_tokens += c.prompt_eval_count ?? 0, s.output_tokens += c.eval_count ?? 0, s.total_tokens = s.input_tokens + s.output_tokens, d = c, yield new On({
        text: o.content ?? "",
        message: wj(o)
      }), await a?.handleLLMNewToken(o.content ?? "");
    }
    yield new On({
      text: "",
      message: new We({
        content: "",
        response_metadata: d,
        usage_metadata: s
      })
    });
  }
  withStructuredOutput(e, n) {
    if (n?.method === void 0 || n?.method === "jsonSchema") {
      const a = Nd(e), r = a ? xn(e) : e, i = this.bind({
        format: r
      }), s = a ? $h.fromZodSchema(e) : new Mh();
      if (!n?.includeRaw)
        return i.pipe(s);
      const u = Ut.assign({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parsed: (o, c) => s.invoke(o.raw, c)
      }), d = Ut.assign({
        parsed: () => null
      }), f = u.withFallbacks({
        fallbacks: [d]
      });
      return gt.from([
        {
          raw: i
        },
        f
      ]);
    } else
      return super.withStructuredOutput(e, n);
  }
}
class BV extends Xg {
  constructor(e) {
    super({ maxConcurrency: 1, ...e }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mxbai-embed-large"
    }), Object.defineProperty(this, "baseUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "http://localhost:11434"
    }), Object.defineProperty(this, "keepAlive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "requestOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "truncate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.client = new Cp({
      host: e?.baseUrl,
      headers: e?.headers ? new Headers(e.headers) : void 0
    }), this.baseUrl = e?.baseUrl ?? this.baseUrl, this.model = e?.model ?? this.model, this.keepAlive = e?.keepAlive, this.truncate = e?.truncate ?? this.truncate, this.requestOptions = e?.requestOptions ? this._convertOptions(e?.requestOptions) : void 0;
  }
  /** convert camelCased Ollama request options like "useMMap" to
   * the snake_cased equivalent which the ollama API actually uses.
   * Used only for consistency with the llms/Ollama and chatModels/Ollama classes
   */
  _convertOptions(e) {
    const n = {}, a = {
      embeddingOnly: "embedding_only",
      frequencyPenalty: "frequency_penalty",
      keepAlive: "keep_alive",
      logitsAll: "logits_all",
      lowVram: "low_vram",
      mainGpu: "main_gpu",
      mirostat: "mirostat",
      mirostatEta: "mirostat_eta",
      mirostatTau: "mirostat_tau",
      numBatch: "num_batch",
      numCtx: "num_ctx",
      numGpu: "num_gpu",
      numKeep: "num_keep",
      numPredict: "num_predict",
      numThread: "num_thread",
      penalizeNewline: "penalize_newline",
      presencePenalty: "presence_penalty",
      repeatLastN: "repeat_last_n",
      repeatPenalty: "repeat_penalty",
      temperature: "temperature",
      stop: "stop",
      tfsZ: "tfs_z",
      topK: "top_k",
      topP: "top_p",
      typicalP: "typical_p",
      useMlock: "use_mlock",
      useMmap: "use_mmap",
      vocabOnly: "vocab_only",
      f16Kv: "f16_kv",
      numa: "numa",
      seed: "seed"
    };
    for (const [r, i] of Object.entries(e)) {
      const s = a[r];
      s ? n[s] = i : n[r] = i;
    }
    return n;
  }
  async embedDocuments(e) {
    return this.embeddingWithRetry(e);
  }
  async embedQuery(e) {
    return (await this.embeddingWithRetry([e]))[0];
  }
  async embeddingWithRetry(e) {
    return (await this.caller.call(() => this.client.embed({
      model: this.model,
      input: e,
      keep_alive: this.keepAlive,
      options: this.requestOptions,
      truncate: this.truncate
    }))).embeddings;
  }
}
class xV extends Wk {
  static lc_name() {
    return "Ollama";
  }
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "llama3"
    }), Object.defineProperty(this, "baseUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "http://localhost:11434"
    }), Object.defineProperty(this, "keepAlive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "embeddingOnly", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "f16KV", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "frequencyPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logitsAll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lowVram", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainGpu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mirostat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mirostatEta", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mirostatTau", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numBatch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numCtx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numGpu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numKeep", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numPredict", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numThread", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "penalizeNewline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "presencePenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repeatLastN", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repeatPenalty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tfsZ", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topK", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "typicalP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useMLock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useMMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "vocabOnly", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "format", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.model = e?.model ?? this.model, this.baseUrl = e?.baseUrl?.endsWith("/") ? e?.baseUrl.slice(0, -1) : e?.baseUrl ?? this.baseUrl, this.client = new Cp({
      host: this.baseUrl,
      headers: e?.headers
    }), this.keepAlive = e?.keepAlive, this.embeddingOnly = e?.embeddingOnly, this.f16KV = e?.f16Kv, this.frequencyPenalty = e?.frequencyPenalty, this.logitsAll = e?.logitsAll, this.lowVram = e?.lowVram, this.mainGpu = e?.mainGpu, this.mirostat = e?.mirostat, this.mirostatEta = e?.mirostatEta, this.mirostatTau = e?.mirostatTau, this.numBatch = e?.numBatch, this.numCtx = e?.numCtx, this.numGpu = e?.numGpu, this.numKeep = e?.numKeep, this.numPredict = e?.numPredict, this.numThread = e?.numThread, this.penalizeNewline = e?.penalizeNewline, this.presencePenalty = e?.presencePenalty, this.repeatLastN = e?.repeatLastN, this.repeatPenalty = e?.repeatPenalty, this.temperature = e?.temperature, this.stop = e?.stop, this.tfsZ = e?.tfsZ, this.topK = e?.topK, this.topP = e?.topP, this.typicalP = e?.typicalP, this.useMLock = e?.useMlock, this.useMMap = e?.useMmap, this.vocabOnly = e?.vocabOnly, this.format = e?.format;
  }
  _llmType() {
    return "ollama";
  }
  invocationParams(e) {
    return {
      model: this.model,
      format: this.format,
      keep_alive: this.keepAlive,
      images: e?.images,
      options: {
        embedding_only: this.embeddingOnly,
        f16_kv: this.f16KV,
        frequency_penalty: this.frequencyPenalty,
        logits_all: this.logitsAll,
        low_vram: this.lowVram,
        main_gpu: this.mainGpu,
        mirostat: this.mirostat,
        mirostat_eta: this.mirostatEta,
        mirostat_tau: this.mirostatTau,
        num_batch: this.numBatch,
        num_ctx: this.numCtx,
        num_gpu: this.numGpu,
        num_keep: this.numKeep,
        num_predict: this.numPredict,
        num_thread: this.numThread,
        penalize_newline: this.penalizeNewline,
        presence_penalty: this.presencePenalty,
        repeat_last_n: this.repeatLastN,
        repeat_penalty: this.repeatPenalty,
        temperature: this.temperature,
        stop: e?.stop ?? this.stop,
        tfs_z: this.tfsZ,
        top_k: this.topK,
        top_p: this.topP,
        typical_p: this.typicalP,
        use_mlock: this.useMLock,
        use_mmap: this.useMMap,
        vocab_only: this.vocabOnly
      }
    };
  }
  async *_streamResponseChunks(e, n, a) {
    const r = await this.caller.call(async () => this.client.generate({
      ...this.invocationParams(n),
      prompt: e,
      stream: !0
    }));
    for await (const i of r) {
      if (n.signal?.aborted)
        throw new Error("This operation was aborted");
      i.done ? yield new fa({
        text: "",
        generationInfo: {
          model: i.model,
          total_duration: i.total_duration,
          load_duration: i.load_duration,
          prompt_eval_count: i.prompt_eval_count,
          prompt_eval_duration: i.prompt_eval_duration,
          eval_count: i.eval_count,
          eval_duration: i.eval_duration
        }
      }) : (yield new fa({
        text: i.response,
        generationInfo: {
          ...i,
          response: void 0
        }
      }), await a?.handleLLMNewToken(i.response ?? ""));
    }
  }
  /** @ignore */
  async _call(e, n, a) {
    const r = [];
    for await (const i of this._streamResponseChunks(e, n, a))
      r.push(i.text);
    return r.join("");
  }
}
const Cu = "1.26.0";
let Oj = !1, xl, c$, Kb, l$, d$, f$;
function vL(t, e = { auto: !1 }) {
  if (Oj)
    throw new Error(`you must \`import '@cerebras/cerebras_cloud_sdk/shims/${t.kind}'\` before importing anything else from @cerebras/cerebras_cloud_sdk`);
  if (xl)
    throw new Error(`can't \`import '@cerebras/cerebras_cloud_sdk/shims/${t.kind}'\` after \`import '@cerebras/cerebras_cloud_sdk/shims/${xl}'\``);
  Oj = e.auto, xl = t.kind, c$ = t.fetch, Kb = t.File, l$ = t.ReadableStream, d$ = t.getDefaultAgent, f$ = t.fileFromPath;
}
class wL {
  constructor(e) {
    this.body = e;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
}
function SL({ manuallyImported: t } = {}) {
  const e = t ? "You may need to use polyfills" : "Add one of these imports before your first `import  from '@cerebras/cerebras_cloud_sdk'`:\n- `import '@cerebras/cerebras_cloud_sdk/shims/node'` (if you're running on Node)\n- `import '@cerebras/cerebras_cloud_sdk/shims/web'` (otherwise)\n";
  let n, a, r, i;
  try {
    n = fetch, a = Request, r = Response, i = Headers;
  } catch (s) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${s.message}. ${e}`);
  }
  return {
    kind: "web",
    fetch: n,
    Request: a,
    Response: r,
    Headers: i,
    FormData: (
      // @ts-ignore
      typeof FormData < "u" ? FormData : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`);
        }
      }
    ),
    Blob: typeof Blob < "u" ? Blob : class {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File < "u" ? File : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream < "u" ? ReadableStream : class {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`);
        }
      }
    ),
    getMultipartRequestOptions: async (s, u) => ({
      ...u,
      body: new wL(s)
    }),
    getDefaultAgent: (s) => {
    },
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/Cerebras/cerebras-cloud-sdk-node#file-uploads");
    },
    isFsReadStream: (s) => !1
  };
}
xl || vL(SL(), { auto: !0 });
class oa extends Error {
}
class Et extends oa {
  constructor(e, n, a, r) {
    super(`${Et.makeMessage(e, n, a)}`), this.status = e, this.headers = r, this.error = n;
  }
  static makeMessage(e, n, a) {
    const r = n?.message ? typeof n.message == "string" ? n.message : JSON.stringify(n.message) : n ? JSON.stringify(n) : a;
    return e && r ? `${e} ${r}` : e ? `${e} status code (no body)` : r || "(no status code or body)";
  }
  static generate(e, n, a, r) {
    if (e === void 0 || r === void 0)
      return new Rp({ message: a, cause: Gb(n) });
    const i = n;
    return e === 400 ? new p$(e, i, a, r) : e === 401 ? new m$(e, i, a, r) : e === 403 ? new b$(e, i, a, r) : e === 404 ? new g$(e, i, a, r) : e === 409 ? new _$(e, i, a, r) : e === 422 ? new y$(e, i, a, r) : e === 429 ? new v$(e, i, a, r) : e >= 500 ? new w$(e, i, a, r) : new Et(e, i, a, r);
  }
}
class Hb extends Et {
  constructor({ message: e } = {}) {
    super(void 0, void 0, e || "Request was aborted.", void 0);
  }
}
class Rp extends Et {
  constructor({ message: e, cause: n }) {
    super(void 0, void 0, e || "Connection error.", void 0), n && (this.cause = n);
  }
}
class h$ extends Rp {
  constructor({ message: e } = {}) {
    super({ message: e ?? "Request timed out." });
  }
}
class p$ extends Et {
}
class m$ extends Et {
}
class b$ extends Et {
}
class g$ extends Et {
}
class _$ extends Et {
}
class y$ extends Et {
}
class v$ extends Et {
}
class w$ extends Et {
}
class Eu {
  constructor(e, n) {
    this.iterator = e, this.controller = n;
  }
  static fromSSEResponse(e, n) {
    let a = !1;
    async function* r() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let i = !1;
      try {
        for await (const s of OL(e, n))
          if (!i) {
            if (s.data.startsWith("[DONE]")) {
              i = !0;
              continue;
            }
            if (s.event === null) {
              let u;
              try {
                u = JSON.parse(s.data);
              } catch (d) {
                throw console.error("Could not parse message into JSON:", s.data), console.error("From chunk:", s.raw), d;
              }
              if (u && u.error) {
                const d = u.status_code || 0;
                throw Et.generate(d, u.error, void 0, void 0);
              }
              yield u;
            } else {
              let u;
              try {
                u = JSON.parse(s.data);
              } catch (d) {
                throw console.error("Could not parse message into JSON:", s.data), console.error("From chunk:", s.raw), d;
              }
              if (s.event == "error") {
                const d = u.status_code || 0;
                throw Et.generate(d, u.error, void 0, void 0);
              }
              yield { event: s.event, data: u };
            }
          }
        i = !0;
      } catch (s) {
        if (s instanceof Error && s.name === "AbortError")
          return;
        throw s;
      } finally {
        i || n.abort();
      }
    }
    return new Eu(r, n);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(e, n) {
    let a = !1;
    async function* r() {
      const s = new Go(), u = S$(e);
      for await (const d of u)
        for (const f of s.decode(d))
          yield f;
      for (const d of s.flush())
        yield d;
    }
    async function* i() {
      if (a)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      a = !0;
      let s = !1;
      try {
        for await (const u of r())
          s || u && (yield JSON.parse(u));
        s = !0;
      } catch (u) {
        if (u instanceof Error && u.name === "AbortError")
          return;
        throw u;
      } finally {
        s || n.abort();
      }
    }
    return new Eu(i, n);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const e = [], n = [], a = this.iterator(), r = (i) => ({
      next: () => {
        if (i.length === 0) {
          const s = a.next();
          e.push(s), n.push(s);
        }
        return i.shift();
      }
    });
    return [
      new Eu(() => r(e), this.controller),
      new Eu(() => r(n), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const e = this;
    let n;
    const a = new TextEncoder();
    return new l$({
      async start() {
        n = e[Symbol.asyncIterator]();
      },
      async pull(r) {
        try {
          const { value: i, done: s } = await n.next();
          if (s)
            return r.close();
          const u = a.encode(JSON.stringify(i) + `
`);
          r.enqueue(u);
        } catch (i) {
          r.error(i);
        }
      },
      async cancel() {
        await n.return?.();
      }
    });
  }
}
async function* OL(t, e) {
  if (!t.body)
    throw e.abort(), new oa("Attempted to iterate over a response with no body");
  const n = new CL(), a = new Go(), r = S$(t.body);
  for await (const i of jL(r))
    for (const s of a.decode(i)) {
      const u = n.decode(s);
      u && (yield u);
    }
  for (const i of a.flush()) {
    const s = n.decode(i);
    s && (yield s);
  }
}
async function* jL(t) {
  let e = new Uint8Array();
  for await (const n of t) {
    if (n == null)
      continue;
    const a = n instanceof ArrayBuffer ? new Uint8Array(n) : typeof n == "string" ? new TextEncoder().encode(n) : n;
    let r = new Uint8Array(e.length + a.length);
    r.set(e), r.set(a, e.length), e = r;
    let i;
    for (; (i = PL(e)) !== -1; )
      yield e.slice(0, i), e = e.slice(i);
  }
  e.length > 0 && (yield e);
}
function PL(t) {
  for (let a = 0; a < t.length - 2; a++) {
    if (t[a] === 10 && t[a + 1] === 10 || t[a] === 13 && t[a + 1] === 13)
      return a + 2;
    if (t[a] === 13 && t[a + 1] === 10 && a + 3 < t.length && t[a + 2] === 13 && t[a + 3] === 10)
      return a + 4;
  }
  return -1;
}
class CL {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(e) {
    if (e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e) {
      if (!this.event && !this.data.length)
        return null;
      const i = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], i;
    }
    if (this.chunks.push(e), e.startsWith(":"))
      return null;
    let [n, a, r] = RL(e, ":");
    return r.startsWith(" ") && (r = r.substring(1)), n === "event" ? this.event = r : n === "data" && this.data.push(r), null;
  }
}
class Go {
  constructor() {
    this.buffer = [], this.trailingCR = !1;
  }
  decode(e) {
    let n = this.decodeText(e);
    if (this.trailingCR && (n = "\r" + n, this.trailingCR = !1), n.endsWith("\r") && (this.trailingCR = !0, n = n.slice(0, -1)), !n)
      return [];
    const a = Go.NEWLINE_CHARS.has(n[n.length - 1] || "");
    let r = n.split(Go.NEWLINE_REGEXP);
    return a && r.pop(), r.length === 1 && !a ? (this.buffer.push(r[0]), []) : (this.buffer.length > 0 && (r = [this.buffer.join("") + r[0], ...r.slice(1)], this.buffer = []), a || (this.buffer = [r.pop() || ""]), r);
  }
  decodeText(e) {
    if (e == null)
      return "";
    if (typeof e == "string")
      return e;
    if (typeof st < "u") {
      if (e instanceof st)
        return e.toString();
      if (e instanceof Uint8Array)
        return st.from(e).toString();
      throw new oa(`Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder < "u") {
      if (e instanceof Uint8Array || e instanceof ArrayBuffer)
        return this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8")), this.textDecoder.decode(e);
      throw new oa(`Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new oa("Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.");
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR)
      return [];
    const e = [this.buffer.join("")];
    return this.buffer = [], this.trailingCR = !1, e;
  }
}
Go.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r"]);
Go.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function RL(t, e) {
  const n = t.indexOf(e);
  return n !== -1 ? [t.substring(0, n), e, t.substring(n + e.length)] : [t, "", ""];
}
function S$(t) {
  if (t[Symbol.asyncIterator])
    return t;
  const e = t.getReader();
  return {
    async next() {
      try {
        const n = await e.read();
        return n?.done && e.releaseLock(), n;
      } catch (n) {
        throw e.releaseLock(), n;
      }
    },
    async return() {
      const n = e.cancel();
      return e.releaseLock(), await n, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
const TL = (t) => t != null && typeof t == "object" && typeof t.url == "string" && typeof t.blob == "function", $L = (t) => t != null && typeof t == "object" && typeof t.name == "string" && typeof t.lastModified == "number" && Tp(t), Tp = (t) => t != null && typeof t == "object" && typeof t.size == "number" && typeof t.type == "string" && typeof t.text == "function" && typeof t.slice == "function" && typeof t.arrayBuffer == "function";
async function ML(t, e, n) {
  if (t = await t, $L(t))
    return t;
  if (TL(t)) {
    const r = await t.blob();
    e || (e = new URL(t.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const i = Tp(r) ? [await r.arrayBuffer()] : [r];
    return new Kb(i, e, n);
  }
  const a = await AL(t);
  if (e || (e = IL(t) ?? "unknown_file"), !n?.type) {
    const r = a[0]?.type;
    typeof r == "string" && (n = { ...n, type: r });
  }
  return new Kb(a, e, n);
}
async function AL(t) {
  let e = [];
  if (typeof t == "string" || ArrayBuffer.isView(t) || // includes Uint8Array, Buffer, etc.
  t instanceof ArrayBuffer)
    e.push(t);
  else if (Tp(t))
    e.push(await t.arrayBuffer());
  else if (NL(t))
    for await (const n of t)
      e.push(n);
  else
    throw new Error(`Unexpected data type: ${typeof t}; constructor: ${t?.constructor?.name}; props: ${EL(t)}`);
  return e;
}
function EL(t) {
  return `[${Object.getOwnPropertyNames(t).map((n) => `"${n}"`).join(", ")}]`;
}
function IL(t) {
  return Hm(t.name) || Hm(t.filename) || // For fs.ReadStream
  Hm(t.path)?.split(/[\\/]/).pop();
}
const Hm = (t) => {
  if (typeof t == "string")
    return t;
  if (typeof st < "u" && t instanceof st)
    return String(t);
}, NL = (t) => t != null && typeof t == "object" && typeof t[Symbol.asyncIterator] == "function", jj = (t) => t && typeof t == "object" && t.body && t[Symbol.toStringTag] === "MultipartBody";
async function O$(t) {
  const { response: e } = t;
  if (t.options.stream)
    return Jo("response", e.status, e.url, e.headers, e.body), t.options.__streamClass ? t.options.__streamClass.fromSSEResponse(e, t.controller) : Eu.fromSSEResponse(e, t.controller);
  if (e.status === 204)
    return null;
  if (t.options.__binaryResponse)
    return e;
  const a = e.headers.get("content-type")?.split(";")[0]?.trim();
  if (a?.includes("application/json") || a?.endsWith("+json")) {
    const s = await e.json();
    return Jo("response", e.status, e.url, e.headers, s), s;
  }
  const i = await e.text();
  return Jo("response", e.status, e.url, e.headers, i), i;
}
class $p extends Promise {
  constructor(e, n = O$) {
    super((a) => {
      a(null);
    }), this.responsePromise = e, this.parseResponse = n;
  }
  _thenUnwrap(e) {
    return new $p(this.responsePromise, async (n) => e(await this.parseResponse(n), n));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from '@cerebras/cerebras_cloud_sdk'`:
   * - `import '@cerebras/cerebras_cloud_sdk/shims/node'` (if you're running on Node)
   * - `import '@cerebras/cerebras_cloud_sdk/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((e) => e.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from '@cerebras/cerebras_cloud_sdk'`:
   * - `import '@cerebras/cerebras_cloud_sdk/shims/node'` (if you're running on Node)
   * - `import '@cerebras/cerebras_cloud_sdk/shims/web'` (otherwise)
   */
  async withResponse() {
    const [e, n] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: e, response: n };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)), this.parsedPromise;
  }
  then(e, n) {
    return this.parse().then(e, n);
  }
  catch(e) {
    return this.parse().catch(e);
  }
  finally(e) {
    return this.parse().finally(e);
  }
}
class FL {
  constructor({
    baseURL: e,
    maxRetries: n = 2,
    timeout: a = 6e4,
    // 1 minute
    httpAgent: r,
    fetch: i
  }) {
    this.baseURL = e, this.maxRetries = Gm("maxRetries", n), this.timeout = Gm("timeout", a), this.httpAgent = r, this.fetch = i ?? c$;
  }
  authHeaders(e) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(e) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...UL(),
      ...this.authHeaders(e)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(e, n) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${ZL()}`;
  }
  get(e, n) {
    return this.methodRequest("get", e, n);
  }
  post(e, n) {
    return this.methodRequest("post", e, n);
  }
  patch(e, n) {
    return this.methodRequest("patch", e, n);
  }
  put(e, n) {
    return this.methodRequest("put", e, n);
  }
  delete(e, n) {
    return this.methodRequest("delete", e, n);
  }
  methodRequest(e, n, a) {
    return this.request(Promise.resolve(a).then(async (r) => {
      const i = r && Tp(r?.body) ? new DataView(await r.body.arrayBuffer()) : r?.body instanceof DataView ? r.body : r?.body instanceof ArrayBuffer ? new DataView(r.body) : r && ArrayBuffer.isView(r?.body) ? new DataView(r.body.buffer) : r?.body;
      return { method: e, path: n, ...r, body: i };
    }));
  }
  getAPIList(e, n, a) {
    return this.requestAPIList(n, { method: "get", path: e, ...a });
  }
  calculateContentLength(e) {
    if (typeof e == "string") {
      if (typeof st < "u")
        return st.byteLength(e, "utf8").toString();
      if (typeof TextEncoder < "u")
        return new TextEncoder().encode(e).length.toString();
    } else if (ArrayBuffer.isView(e))
      return e.byteLength.toString();
    return null;
  }
  buildRequest(e, { retryCount: n = 0 } = {}) {
    e = { ...e };
    const { method: a, path: r, query: i, headers: s = {} } = e, u = ArrayBuffer.isView(e.body) || e.__binaryRequest && typeof e.body == "string" ? e.body : jj(e.body) ? e.body.body : e.body ? JSON.stringify(e.body, null, 2) : null, d = this.calculateContentLength(u), f = this.buildURL(r, i);
    "timeout" in e && Gm("timeout", e.timeout), e.timeout = e.timeout ?? this.timeout;
    const o = e.httpAgent ?? this.httpAgent ?? d$(f), c = e.timeout + 1e3;
    typeof o?.options?.timeout == "number" && c > (o.options.timeout ?? 0) && (o.options.timeout = c), this.idempotencyHeader && a !== "get" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()), s[this.idempotencyHeader] = e.idempotencyKey);
    const h = this.buildHeaders({ options: e, headers: s, contentLength: d, retryCount: n });
    return { req: {
      method: a,
      ...u && { body: u },
      headers: h,
      ...o && { agent: o },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: e.signal ?? null
    }, url: f, timeout: e.timeout };
  }
  buildHeaders({ options: e, headers: n, contentLength: a, retryCount: r }) {
    const i = {};
    a && (i["content-length"] = a);
    const s = this.defaultHeaders(e);
    return Mj(i, s), Mj(i, n), jj(e.body) && xl !== "node" && delete i["content-type"], Lf(s, "x-stainless-retry-count") === void 0 && Lf(n, "x-stainless-retry-count") === void 0 && (i["x-stainless-retry-count"] = String(r)), Lf(s, "x-stainless-timeout") === void 0 && Lf(n, "x-stainless-timeout") === void 0 && e.timeout && (i["x-stainless-timeout"] = String(e.timeout)), this.validateHeaders(i, n), i;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(e) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(e, { url: n, options: a }) {
  }
  parseHeaders(e) {
    return e ? Symbol.iterator in e ? Object.fromEntries(Array.from(e).map((n) => [...n])) : { ...e } : {};
  }
  makeStatusError(e, n, a, r) {
    return Et.generate(e, n, a, r);
  }
  request(e, n = null) {
    return new $p(this.makeRequest(e, n));
  }
  async makeRequest(e, n) {
    const a = await e, r = a.maxRetries ?? this.maxRetries;
    n == null && (n = r), await this.prepareOptions(a);
    const { req: i, url: s, timeout: u } = this.buildRequest(a, { retryCount: r - n });
    if (await this.prepareRequest(i, { url: s, options: a }), Jo("request", s, a, i.headers), a.signal?.aborted)
      throw new Hb();
    const d = new AbortController(), f = await this.fetchWithTimeout(s, i, u, d).catch(Gb);
    if (f instanceof Error) {
      if (a.signal?.aborted)
        throw new Hb();
      if (n)
        return this.retryRequest(a, n);
      throw f.name === "AbortError" ? new h$() : new Rp({ cause: f });
    }
    const o = DL(f.headers);
    if (!f.ok) {
      if (n && this.shouldRetry(f)) {
        const b = `retrying, ${n} attempts remaining`;
        return Jo(`response (error; ${b})`, f.status, s, o), this.retryRequest(a, n, o);
      }
      const c = await f.text().catch((b) => Gb(b).message), h = BL(c), p = h ? void 0 : c;
      throw Jo(`response (error; ${n ? "(error; no more retries left)" : "(error; not retryable)"})`, f.status, s, o, p), this.makeStatusError(f.status, h, p, o);
    }
    return { response: f, options: a, controller: d };
  }
  requestAPIList(e, n) {
    const a = this.makeRequest(n, null);
    return new kL(this, a, e);
  }
  buildURL(e, n) {
    const a = VL(e) ? new URL(e) : new URL(this.baseURL + (this.baseURL.endsWith("/") && e.startsWith("/") ? e.slice(1) : e)), r = this.defaultQuery();
    return j$(r) || (n = { ...r, ...n }), typeof n == "object" && n && !Array.isArray(n) && (a.search = this.stringifyQuery(n)), a.toString();
  }
  stringifyQuery(e) {
    return Object.entries(e).filter(([n, a]) => typeof a < "u").map(([n, a]) => {
      if (typeof a == "string" || typeof a == "number" || typeof a == "boolean")
        return `${encodeURIComponent(n)}=${encodeURIComponent(a)}`;
      if (a === null)
        return `${encodeURIComponent(n)}=`;
      throw new oa(`Cannot stringify type ${typeof a}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(e, n, a, r) {
    const { signal: i, ...s } = n || {};
    i && i.addEventListener("abort", () => r.abort());
    const u = setTimeout(() => r.abort(), a), d = {
      signal: r.signal,
      ...s
    };
    return d.method && (d.method = d.method.toUpperCase()), // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
    this.fetch.call(void 0, e, d).finally(() => {
      clearTimeout(u);
    });
  }
  shouldRetry(e) {
    const n = e.headers.get("x-should-retry");
    return n === "true" ? !0 : n === "false" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500;
  }
  async retryRequest(e, n, a) {
    let r;
    const i = a?.["retry-after-ms"];
    if (i) {
      const u = parseFloat(i);
      Number.isNaN(u) || (r = u);
    }
    const s = a?.["retry-after"];
    if (s && !r) {
      const u = parseFloat(s);
      Number.isNaN(u) ? r = Date.parse(s) - Date.now() : r = u * 1e3;
    }
    if (!(r && 0 <= r && r < 60 * 1e3)) {
      const u = e.maxRetries ?? this.maxRetries;
      r = this.calculateDefaultRetryTimeoutMillis(n, u);
    }
    return await zL(r), this.makeRequest(e, n - 1);
  }
  calculateDefaultRetryTimeoutMillis(e, n) {
    const i = n - e, s = Math.min(0.5 * Math.pow(2, i), 8), u = 1 - Math.random() * 0.25;
    return s * u * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${Cu}`;
  }
}
class kL extends $p {
  constructor(e, n, a) {
    super(n, async (r) => new a(e, r.response, await O$(r), r.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const e = await this;
    for await (const n of e)
      yield n;
  }
}
const DL = (t) => new Proxy(Object.fromEntries(
  // @ts-ignore
  t.entries()
), {
  get(e, n) {
    const a = n.toString();
    return e[a.toLowerCase()] || e[a];
  }
}), qL = {
  method: !0,
  path: !0,
  query: !0,
  body: !0,
  headers: !0,
  maxRetries: !0,
  stream: !0,
  timeout: !0,
  httpAgent: !0,
  signal: !0,
  idempotencyKey: !0,
  __binaryRequest: !0,
  __binaryResponse: !0,
  __streamClass: !0
}, Pj = (t) => typeof t == "object" && t !== null && !j$(t) && Object.keys(t).every((e) => P$(qL, e)), JL = () => {
  if (typeof Deno < "u" && Deno.build != null)
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Cu,
      "X-Stainless-OS": Rj(Deno.build.os),
      "X-Stainless-Arch": Cj(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Cu,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": pe.version
    };
  if (Object.prototype.toString.call(typeof pe < "u" ? pe : 0) === "[object process]")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Cu,
      "X-Stainless-OS": Rj(pe.platform),
      "X-Stainless-Arch": Cj(pe.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": pe.version
    };
  const t = LL();
  return t ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Cu,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${t.browser}`,
    "X-Stainless-Runtime-Version": t.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Cu,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function LL() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const t = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: e, pattern: n } of t) {
    const a = n.exec(navigator.userAgent);
    if (a) {
      const r = a[1] || 0, i = a[2] || 0, s = a[3] || 0;
      return { browser: e, version: `${r}.${i}.${s}` };
    }
  }
  return null;
}
const Cj = (t) => t === "x32" ? "x32" : t === "x86_64" || t === "x64" ? "x64" : t === "arm" ? "arm" : t === "aarch64" || t === "arm64" ? "arm64" : t ? `other:${t}` : "unknown", Rj = (t) => (t = t.toLowerCase(), t.includes("ios") ? "iOS" : t === "android" ? "Android" : t === "darwin" ? "MacOS" : t === "win32" ? "Windows" : t === "freebsd" ? "FreeBSD" : t === "openbsd" ? "OpenBSD" : t === "linux" ? "Linux" : t ? `Other:${t}` : "Unknown");
let Tj;
const UL = () => Tj ?? (Tj = JL()), BL = (t) => {
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}, xL = /^[a-z][a-z0-9+.-]*:/i, VL = (t) => xL.test(t), zL = (t) => new Promise((e) => setTimeout(e, t)), Gm = (t, e) => {
  if (typeof e != "number" || !Number.isInteger(e))
    throw new oa(`${t} must be an integer`);
  if (e < 0)
    throw new oa(`${t} must be a positive integer`);
  return e;
}, Gb = (t) => {
  if (t instanceof Error)
    return t;
  if (typeof t == "object" && t !== null)
    try {
      return new Error(JSON.stringify(t));
    } catch {
    }
  return new Error(t);
}, $j = (t) => {
  if (typeof pe < "u")
    return pe.env?.[t]?.trim() ?? void 0;
  if (typeof Deno < "u")
    return Deno.env?.get?.(t)?.trim();
};
function j$(t) {
  if (!t)
    return !0;
  for (const e in t)
    return !1;
  return !0;
}
function P$(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function Mj(t, e) {
  for (const n in e) {
    if (!P$(e, n))
      continue;
    const a = n.toLowerCase();
    if (!a)
      continue;
    const r = e[n];
    r === null ? delete t[a] : r !== void 0 && (t[a] = r);
  }
}
function Jo(t, ...e) {
  typeof pe < "u" && pe?.env?.DEBUG === "true" && console.log(`Cerebras:DEBUG:${t}`, ...e);
}
const ZL = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
  const e = Math.random() * 16 | 0;
  return (t === "x" ? e : e & 3 | 8).toString(16);
}), KL = (t) => typeof t?.get == "function", Lf = (t, e) => {
  const n = e.toLowerCase();
  if (KL(t)) {
    const a = e[0]?.toUpperCase() + e.substring(1).replace(/([^\w])(\w)/g, (r, i, s) => i + s.toUpperCase());
    for (const r of [e, n, e.toUpperCase(), a]) {
      const i = t.get(r);
      if (i)
        return i;
    }
  }
  for (const [a, r] of Object.entries(t))
    if (a.toLowerCase() === n)
      return Array.isArray(r) ? (r.length <= 1 || console.warn(`Received ${r.length} entries for the ${e} header, using the first entry.`), r[0]) : r;
};
class Mp {
  constructor(e) {
    this._client = e;
  }
}
let C$ = class extends Mp {
  create(e, n) {
    const { "CF-RAY": a, "X-Amz-Cf-Id": r, "X-delay-time": i, ...s } = e;
    return this._client.post("/v1/chat/completions", {
      body: s,
      ...n,
      stream: s.stream ?? !1,
      headers: {
        ...a != null ? { "CF-RAY": a } : void 0,
        ...r != null ? { "X-Amz-Cf-Id": r } : void 0,
        ...i?.toString() != null ? { "X-delay-time": i?.toString() } : void 0,
        ...n?.headers
      }
    });
  }
};
class T_ extends Mp {
  constructor() {
    super(...arguments), this.completions = new C$(this._client);
  }
}
T_.Completions = C$;
class R$ extends Mp {
  create(e, n) {
    const { "CF-RAY": a, "X-Amz-Cf-Id": r, "X-delay-time": i, ...s } = e;
    return this._client.post("/v1/completions", {
      body: s,
      ...n,
      stream: s.stream ?? !1,
      headers: {
        ...a != null ? { "CF-RAY": a } : void 0,
        ...r != null ? { "X-Amz-Cf-Id": r } : void 0,
        ...i?.toString() != null ? { "X-delay-time": i?.toString() } : void 0,
        ...n?.headers
      }
    });
  }
}
class T$ extends Mp {
  retrieve(e, n = {}, a) {
    if (Pj(n))
      return this.retrieve(e, {}, n);
    const { "CF-RAY": r, "X-Amz-Cf-Id": i } = n;
    return this._client.get(`/v1/models/${e}`, {
      ...a,
      headers: {
        ...r != null ? { "CF-RAY": r } : void 0,
        ...i != null ? { "X-Amz-Cf-Id": i } : void 0,
        ...a?.headers
      }
    });
  }
  list(e = {}, n) {
    if (Pj(e))
      return this.list({}, e);
    const { "CF-RAY": a, "X-Amz-Cf-Id": r } = e;
    return this._client.get("/v1/models", {
      ...n,
      headers: {
        ...a != null ? { "CF-RAY": a } : void 0,
        ...r != null ? { "X-Amz-Cf-Id": r } : void 0,
        ...n?.headers
      }
    });
  }
}
var $$;
class rt extends FL {
  /**
   * API Client for interfacing with the Cerebras API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['CEREBRAS_API_KEY'] ?? undefined]
   * @param {string} [opts.baseURL=process.env['CEREBRAS_BASE_URL'] ?? https://api.cerebras.ai] - Override the default base URL for the API.
   * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean | undefined} opts.warmTCPConnection - Whether to warm TCP connection in the constructor.
   */
  constructor({ baseURL: e = $j("CEREBRAS_BASE_URL"), apiKey: n = $j("CEREBRAS_API_KEY"), warmTCPConnection: a = !0, ...r } = {}) {
    if (n === void 0)
      throw new oa("The CEREBRAS_API_KEY environment variable is missing or empty; either provide it, or instantiate the Cerebras client with an apiKey option, like new Cerebras({ apiKey: 'My API Key' }).");
    const i = {
      apiKey: n,
      ...r,
      baseURL: e || "https://api.cerebras.ai"
    };
    super({
      baseURL: i.baseURL,
      timeout: i.timeout ?? 6e4,
      httpAgent: i.httpAgent,
      maxRetries: i.maxRetries,
      fetch: i.fetch
    }), this.chat = new T_(this), this.completions = new R$(this), this.models = new T$(this), this._options = i, this.apiKey = n, a && (async () => {
      try {
        await this.get("/v1/tcp_warming", {
          timeout: 1e3,
          maxRetries: 0
        });
      } catch (s) {
        Jo(`TCP Warming had exception: ${s}`);
      }
    })();
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(e) {
    return {
      ...super.defaultHeaders(e),
      ...this._options.defaultHeaders
    };
  }
  authHeaders(e) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
}
$$ = rt;
rt.Cerebras = $$;
rt.DEFAULT_TIMEOUT = 6e4;
rt.CerebrasError = oa;
rt.APIError = Et;
rt.APIConnectionError = Rp;
rt.APIConnectionTimeoutError = h$;
rt.APIUserAbortError = Hb;
rt.NotFoundError = g$;
rt.ConflictError = _$;
rt.RateLimitError = v$;
rt.BadRequestError = p$;
rt.AuthenticationError = m$;
rt.InternalServerError = w$;
rt.PermissionDeniedError = b$;
rt.UnprocessableEntityError = y$;
rt.toFile = ML;
rt.fileFromPath = f$;
rt.Chat = T_;
rt.Completions = R$;
rt.Models = T$;
function Aj(t) {
  const e = t.match(/^data:.*?;base64,(.*)$/);
  return e ? e[1] : "";
}
function HL(t) {
  if (typeof t.content == "string")
    return [
      {
        role: "assistant",
        content: t.content
      }
    ];
  const n = t.content.filter((r) => r.type === "text" && typeof r.text == "string").map((r) => ({
    role: "assistant",
    content: r.text
  }));
  let a;
  if (t.content.find((r) => r.type === "tool_use") && t.tool_calls?.length) {
    const r = t.tool_calls?.map((i) => ({
      id: i.id,
      type: "function",
      function: {
        name: i.name,
        arguments: JSON.stringify(i.args)
      }
    }));
    r && (a = {
      role: "assistant",
      tool_calls: r,
      content: ""
    });
  } else if (t.content.find((r) => r.type === "tool_use") && !t.tool_calls?.length)
    throw new Error("'tool_use' content type is not supported without tool calls.");
  return [...n, ...a ? [a] : []];
}
function GL(t) {
  return typeof t.content == "string" ? [
    {
      role: "user",
      content: t.content
    }
  ] : t.content.map((e) => {
    if (e.type === "text")
      return {
        role: "user",
        content: e.text
      };
    if (e.type === "image_url") {
      if (typeof e.image_url == "string")
        return {
          role: "user",
          content: "",
          images: [Aj(e.image_url)]
        };
      if (e.image_url.url && typeof e.image_url.url == "string")
        return {
          role: "user",
          content: "",
          images: [Aj(e.image_url.url)]
        };
    }
    throw new Error(`Unsupported content type: ${e.type}`);
  });
}
function WL(t) {
  if (typeof t.content == "string")
    return [
      {
        role: "system",
        content: t.content
      }
    ];
  if (t.content.every((e) => e.type === "text" && typeof e.text == "string"))
    return t.content.map((e) => ({
      role: "system",
      content: e.text
    }));
  throw new Error(`Unsupported content type(s): ${t.content.map((e) => e.type).join(", ")}`);
}
function XL(t) {
  if (typeof t.content != "string")
    throw new Error("Non string tool message content is not supported");
  return [
    {
      role: "tool",
      content: t.content,
      tool_call_id: t.tool_call_id
    }
  ];
}
function Ej(t) {
  return t.flatMap((e) => {
    if (["human", "generic"].includes(e._getType()))
      return GL(e);
    if (e._getType() === "ai")
      return HL(e);
    if (e._getType() === "system")
      return WL(e);
    if (e._getType() === "tool")
      return XL(e);
    throw new Error(`Unsupported message type: ${e._getType()}`);
  });
}
function QL(t) {
  if (t)
    return t === "any" || t === "required" ? "required" : t === "auto" ? "auto" : t === "none" ? "none" : typeof t == "string" ? {
      type: "function",
      function: {
        name: t
      }
    } : t;
}
class GV extends kn {
  static lc_name() {
    return "ChatCerebras";
  }
  get lc_secrets() {
    return {
      apiKey: "CEREBRAS_API_KEY"
    };
  }
  get lc_aliases() {
    return {
      apiKey: "CEREBRAS_API_KEY"
    };
  }
  getLsParams(e) {
    const n = this.invocationParams(e);
    return {
      ls_provider: "cerebras",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: n.temperature ?? void 0,
      ls_max_tokens: n.max_completion_tokens ?? void 0,
      ls_stop: e.stop
    };
  }
  constructor(e) {
    super(e ?? {}), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "model", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxCompletionTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temperature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "topP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "seed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.model = e.model, this.maxCompletionTokens = e.maxCompletionTokens, this.temperature = e.temperature, this.topP = e.topP, this.seed = e.seed, this.streaming = e.streaming, this.client = new rt({
      apiKey: e.apiKey ?? _t("CEREBRAS_API_KEY"),
      timeout: e.timeout,
      // Rely on built-in async caller
      maxRetries: 0,
      fetch: e.fetch
    });
  }
  // Replace
  _llmType() {
    return "cerebras";
  }
  bindTools(e, n) {
    return this.bind({
      tools: e.map((a) => Ih(a)),
      ...n
    });
  }
  /**
   * A method that returns the parameters for an Ollama API call. It
   * includes model and options parameters.
   * @param options Optional parsed call options.
   * @returns An object containing the parameters for an Ollama API call.
   */
  invocationParams(e) {
    return {
      model: this.model,
      max_completion_tokens: this.maxCompletionTokens,
      temperature: this.temperature,
      top_p: this.topP,
      seed: this.seed,
      stop: e?.stop,
      response_format: e?.response_format,
      user: e?.user,
      tools: e?.tools?.length ? e.tools.map((n) => Ih(n)) : void 0,
      tool_choice: QL(e?.tool_choice)
    };
  }
  async _generate(e, n, a) {
    if (this.streaming) {
      let c;
      for await (const p of this._streamResponseChunks(e, n, a))
        c ? c = an(c, p.message) : c = p.message;
      const h = new At({
        id: c?.id,
        content: c?.content ?? "",
        tool_calls: c?.tool_calls,
        response_metadata: c?.response_metadata,
        usage_metadata: c?.usage_metadata
      });
      return {
        generations: [
          {
            text: typeof h.content == "string" ? h.content : "",
            message: h
          }
        ]
      };
    }
    const r = await this.caller.call(async () => await this.client.chat.completions.create({
      ...this.invocationParams(n),
      messages: Ej(e),
      stream: !1
    }, {
      headers: n.headers,
      httpAgent: n.httpAgent
    })), { choices: i, usage: s, ...u } = r, d = i[0], f = d?.message?.content ?? "", o = {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      input_tokens: s?.prompt_tokens,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      output_tokens: s?.completion_tokens,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      total_tokens: s?.total_tokens
    };
    return {
      generations: [
        {
          text: f,
          message: new At({
            content: f,
            tool_calls: d?.message?.tool_calls?.map(
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              (c) => ({
                id: c.id,
                name: c.function?.name,
                args: JSON.parse(c.function?.arguments),
                index: c.index,
                type: "tool_call"
              })
            ),
            usage_metadata: o,
            response_metadata: u
          })
        }
      ]
    };
  }
  /**
   * Implement to support streaming.
   * Should yield chunks iteratively.
   */
  async *_streamResponseChunks(e, n, a) {
    const r = await this.caller.call(async () => await this.client.chat.completions.create({
      ...this.invocationParams(n),
      messages: Ej(e),
      stream: !0
    }, {
      headers: n.headers,
      httpAgent: n.httpAgent
    }));
    for await (const i of r) {
      const { choices: s, system_fingerprint: u, model: d, id: f, object: o, usage: c, ...h } = i, p = s[0], l = p?.delta?.content ?? "";
      let m;
      c !== void 0 && (m = {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        input_tokens: c.prompt_tokens,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        output_tokens: c.completion_tokens,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        total_tokens: c.total_tokens
      });
      const b = {};
      p.finish_reason != null && (b.finish_reason = p.finish_reason, b.id = f, b.system_fingerprint = u, b.model = d, b.object = o);
      const g = new On({
        text: l,
        message: new We({
          content: l,
          tool_call_chunks: p?.delta.tool_calls?.map(
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (_) => ({
              id: _.id,
              name: _.function?.name,
              args: _.function?.arguments,
              index: _.index,
              type: "tool_call_chunk"
            })
          ),
          usage_metadata: m,
          response_metadata: h
        }),
        generationInfo: b
      });
      yield g, await a?.handleLLMNewToken(l, void 0, void 0, void 0, void 0, { chunk: g });
    }
  }
  withStructuredOutput(e, n) {
    if (n?.strict)
      throw new Error('"strict" mode is not supported for this model by default.');
    const a = e, r = n?.name, i = a.description ?? "A function available to call.", s = n?.method, u = n?.includeRaw;
    if (s === "jsonMode")
      throw new Error('Cerebras withStructuredOutput implementation only supports "functionCalling" as a method.');
    let d = r ?? "extract", f;
    Nd(a) ? f = [
      {
        type: "function",
        function: {
          name: d,
          description: i,
          parameters: xn(a)
        }
      }
    ] : ("name" in a && (d = a.name), f = [
      {
        type: "function",
        function: {
          name: d,
          description: i,
          parameters: a
        }
      }
    ]);
    const o = this.bindTools(f, {
      tool_choice: f[0].function.name
    }), c = Yo.from((m) => {
      if (!m.tool_calls || m.tool_calls.length === 0)
        throw new Error("No tool calls found in the response.");
      const b = m.tool_calls.find((g) => g.name === d);
      if (!b)
        throw new Error(`No tool call found with name ${d}.`);
      return b.args;
    });
    if (!u)
      return o.pipe(c).withConfig({
        runName: "ChatCerebrasStructuredOutput"
      });
    const h = Ut.assign({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parsed: (m, b) => c.invoke(m.raw, b)
    }), p = Ut.assign({
      parsed: () => null
    }), l = h.withFallbacks({
      fallbacks: [p]
    });
    return gt.from([
      {
        raw: o
      },
      l
    ]).withConfig({
      runName: "ChatCerebrasStructuredOutput"
    });
  }
}
class ur {
  constructor(e) {
    Object.defineProperty(this, "pageContent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.pageContent = e.pageContent !== void 0 ? e.pageContent.toString() : "", this.metadata = e.metadata ?? {}, this.id = e.id;
  }
}
class YL extends Te {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "documents", "transformers"]
    });
  }
  /**
   * Method to invoke the document transformation. This method calls the
   * transformDocuments method with the provided input.
   * @param input The input documents to be transformed.
   * @param _options Optional configuration object to customize the behavior of callbacks.
   * @returns A Promise that resolves to the transformed documents.
   */
  invoke(e, n) {
    return this.transformDocuments(e);
  }
}
class Ap extends Te {
  get lc_attributes() {
    return {
      partialVariables: void 0
      // python doesn't support this yet
    };
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompts", this._getPromptType()]
    }), Object.defineProperty(this, "inputVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputParser", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "partialVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { inputVariables: n } = e;
    if (n.includes("stop"))
      throw new Error("Cannot have an input variable named 'stop', as it is used internally, please rename.");
    Object.assign(this, e);
  }
  /**
   * Merges partial variables and user variables.
   * @param userVariables The user variables to merge with the partial variables.
   * @returns A Promise that resolves to an object containing the merged variables.
   */
  async mergePartialAndUserVariables(e) {
    const n = this.partialVariables ?? {}, a = {};
    for (const [i, s] of Object.entries(n))
      typeof s == "string" ? a[i] = s : a[i] = await s();
    return {
      ...a,
      ...e
    };
  }
  /**
   * Invokes the prompt template with the given input and options.
   * @param input The input to invoke the prompt template with.
   * @param options Optional configuration for the callback.
   * @returns A Promise that resolves to the output of the prompt template.
   */
  async invoke(e, n) {
    const a = {
      ...this.metadata,
      ...n?.metadata
    }, r = [...this.tags ?? [], ...n?.tags ?? []];
    return this._callWithConfig((i) => this.formatPromptValue(i), e, { ...n, tags: r, metadata: a, runType: "prompt" });
  }
  /**
   * Return a json-like object representing this prompt template.
   * @deprecated
   */
  serialize() {
    throw new Error("Use .toJSON() instead");
  }
  /**
   * @deprecated
   * Load a prompt template from a json-like object describing it.
   *
   * @remarks
   * Deserializing needs to be async because templates (e.g. {@link FewShotPromptTemplate}) can
   * reference remote resources that we read asynchronously with a web
   * request.
   */
  static async deserialize(e) {
    switch (e._type) {
      case "prompt": {
        const { PromptTemplate: n } = await Promise.resolve().then(() => Fj);
        return n.deserialize(e);
      }
      case void 0: {
        const { PromptTemplate: n } = await Promise.resolve().then(() => Fj);
        return n.deserialize({ ...e, _type: "prompt" });
      }
      case "few_shot": {
        const { FewShotPromptTemplate: n } = await Promise.resolve().then(() => RU);
        return n.deserialize(e);
      }
      default:
        throw new Error(`Invalid prompt type in config: ${e._type}`);
    }
  }
}
class Lh extends Ap {
  /**
   * Formats the prompt given the input values and returns a formatted
   * prompt value.
   * @param values The input values to format the prompt.
   * @returns A Promise that resolves to a formatted prompt value.
   */
  async formatPromptValue(e) {
    const n = await this.format(e);
    return new nR(n);
  }
}
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
var eU = Object.prototype.toString, ic = Array.isArray || function(e) {
  return eU.call(e) === "[object Array]";
};
function $_(t) {
  return typeof t == "function";
}
function tU(t) {
  return ic(t) ? "array" : typeof t;
}
function Wm(t) {
  return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function Ij(t, e) {
  return t != null && typeof t == "object" && e in t;
}
function nU(t, e) {
  return t != null && typeof t != "object" && t.hasOwnProperty && t.hasOwnProperty(e);
}
var rU = RegExp.prototype.test;
function aU(t, e) {
  return rU.call(t, e);
}
var iU = /\S/;
function sU(t) {
  return !aU(iU, t);
}
var oU = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function uU(t) {
  return String(t).replace(/[&<>"'`=\/]/g, function(n) {
    return oU[n];
  });
}
var cU = /\s*/, lU = /\s+/, Nj = /\s*=/, dU = /\s*\}/, fU = /#|\^|\/|>|\{|&|=|!/;
function hU(t, e) {
  if (!t)
    return [];
  var n = !1, a = [], r = [], i = [], s = !1, u = !1, d = "", f = 0;
  function o() {
    if (s && !u)
      for (; i.length; )
        delete r[i.pop()];
    else
      i = [];
    s = !1, u = !1;
  }
  var c, h, p;
  function l(A) {
    if (typeof A == "string" && (A = A.split(lU, 2)), !ic(A) || A.length !== 2)
      throw new Error("Invalid tags: " + A);
    c = new RegExp(Wm(A[0]) + "\\s*"), h = new RegExp("\\s*" + Wm(A[1])), p = new RegExp("\\s*" + Wm("}" + A[1]));
  }
  l(e || cn.tags);
  for (var m = new zd(t), b, g, _, P, R, C; !m.eos(); ) {
    if (b = m.pos, _ = m.scanUntil(c), _)
      for (var T = 0, O = _.length; T < O; ++T)
        P = _.charAt(T), sU(P) ? (i.push(r.length), d += P) : (u = !0, n = !0, d += " "), r.push(["text", P, b, b + 1]), b += 1, P === `
` && (o(), d = "", f = 0, n = !1);
    if (!m.scan(c))
      break;
    if (s = !0, g = m.scan(fU) || "name", m.scan(cU), g === "=" ? (_ = m.scanUntil(Nj), m.scan(Nj), m.scanUntil(h)) : g === "{" ? (_ = m.scanUntil(p), m.scan(dU), m.scanUntil(h), g = "&") : _ = m.scanUntil(h), !m.scan(h))
      throw new Error("Unclosed tag at " + m.pos);
    if (g == ">" ? R = [g, _, b, m.pos, d, f, n] : R = [g, _, b, m.pos], f++, r.push(R), g === "#" || g === "^")
      a.push(R);
    else if (g === "/") {
      if (C = a.pop(), !C)
        throw new Error('Unopened section "' + _ + '" at ' + b);
      if (C[1] !== _)
        throw new Error('Unclosed section "' + C[1] + '" at ' + b);
    } else g === "name" || g === "{" || g === "&" ? u = !0 : g === "=" && l(_);
  }
  if (o(), C = a.pop(), C)
    throw new Error('Unclosed section "' + C[1] + '" at ' + m.pos);
  return mU(pU(r));
}
function pU(t) {
  for (var e = [], n, a, r = 0, i = t.length; r < i; ++r)
    n = t[r], n && (n[0] === "text" && a && a[0] === "text" ? (a[1] += n[1], a[3] = n[3]) : (e.push(n), a = n));
  return e;
}
function mU(t) {
  for (var e = [], n = e, a = [], r, i, s = 0, u = t.length; s < u; ++s)
    switch (r = t[s], r[0]) {
      case "#":
      case "^":
        n.push(r), a.push(r), n = r[4] = [];
        break;
      case "/":
        i = a.pop(), i[5] = r[2], n = a.length > 0 ? a[a.length - 1][4] : e;
        break;
      default:
        n.push(r);
    }
  return e;
}
function zd(t) {
  this.string = t, this.tail = t, this.pos = 0;
}
zd.prototype.eos = function() {
  return this.tail === "";
};
zd.prototype.scan = function(e) {
  var n = this.tail.match(e);
  if (!n || n.index !== 0)
    return "";
  var a = n[0];
  return this.tail = this.tail.substring(a.length), this.pos += a.length, a;
};
zd.prototype.scanUntil = function(e) {
  var n = this.tail.search(e), a;
  switch (n) {
    case -1:
      a = this.tail, this.tail = "";
      break;
    case 0:
      a = "";
      break;
    default:
      a = this.tail.substring(0, n), this.tail = this.tail.substring(n);
  }
  return this.pos += a.length, a;
};
function zu(t, e) {
  this.view = t, this.cache = { ".": this.view }, this.parent = e;
}
zu.prototype.push = function(e) {
  return new zu(e, this);
};
zu.prototype.lookup = function(e) {
  var n = this.cache, a;
  if (n.hasOwnProperty(e))
    a = n[e];
  else {
    for (var r = this, i, s, u, d = !1; r; ) {
      if (e.indexOf(".") > 0)
        for (i = r.view, s = e.split("."), u = 0; i != null && u < s.length; )
          u === s.length - 1 && (d = Ij(i, s[u]) || nU(i, s[u])), i = i[s[u++]];
      else
        i = r.view[e], d = Ij(r.view, e);
      if (d) {
        a = i;
        break;
      }
      r = r.parent;
    }
    n[e] = a;
  }
  return $_(a) && (a = a.call(this.view)), a;
};
function Wt() {
  this.templateCache = {
    _cache: {},
    set: function(e, n) {
      this._cache[e] = n;
    },
    get: function(e) {
      return this._cache[e];
    },
    clear: function() {
      this._cache = {};
    }
  };
}
Wt.prototype.clearCache = function() {
  typeof this.templateCache < "u" && this.templateCache.clear();
};
Wt.prototype.parse = function(e, n) {
  var a = this.templateCache, r = e + ":" + (n || cn.tags).join(":"), i = typeof a < "u", s = i ? a.get(r) : void 0;
  return s == null && (s = hU(e, n), i && a.set(r, s)), s;
};
Wt.prototype.render = function(e, n, a, r) {
  var i = this.getConfigTags(r), s = this.parse(e, i), u = n instanceof zu ? n : new zu(n, void 0);
  return this.renderTokens(s, u, a, e, r);
};
Wt.prototype.renderTokens = function(e, n, a, r, i) {
  for (var s = "", u, d, f, o = 0, c = e.length; o < c; ++o)
    f = void 0, u = e[o], d = u[0], d === "#" ? f = this.renderSection(u, n, a, r, i) : d === "^" ? f = this.renderInverted(u, n, a, r, i) : d === ">" ? f = this.renderPartial(u, n, a, i) : d === "&" ? f = this.unescapedValue(u, n) : d === "name" ? f = this.escapedValue(u, n, i) : d === "text" && (f = this.rawValue(u)), f !== void 0 && (s += f);
  return s;
};
Wt.prototype.renderSection = function(e, n, a, r, i) {
  var s = this, u = "", d = n.lookup(e[1]);
  function f(h) {
    return s.render(h, n, a, i);
  }
  if (d) {
    if (ic(d))
      for (var o = 0, c = d.length; o < c; ++o)
        u += this.renderTokens(e[4], n.push(d[o]), a, r, i);
    else if (typeof d == "object" || typeof d == "string" || typeof d == "number")
      u += this.renderTokens(e[4], n.push(d), a, r, i);
    else if ($_(d)) {
      if (typeof r != "string")
        throw new Error("Cannot use higher-order sections without the original template");
      d = d.call(n.view, r.slice(e[3], e[5]), f), d != null && (u += d);
    } else
      u += this.renderTokens(e[4], n, a, r, i);
    return u;
  }
};
Wt.prototype.renderInverted = function(e, n, a, r, i) {
  var s = n.lookup(e[1]);
  if (!s || ic(s) && s.length === 0)
    return this.renderTokens(e[4], n, a, r, i);
};
Wt.prototype.indentPartial = function(e, n, a) {
  for (var r = n.replace(/[^ \t]/g, ""), i = e.split(`
`), s = 0; s < i.length; s++)
    i[s].length && (s > 0 || !a) && (i[s] = r + i[s]);
  return i.join(`
`);
};
Wt.prototype.renderPartial = function(e, n, a, r) {
  if (a) {
    var i = this.getConfigTags(r), s = $_(a) ? a(e[1]) : a[e[1]];
    if (s != null) {
      var u = e[6], d = e[5], f = e[4], o = s;
      d == 0 && f && (o = this.indentPartial(s, f, u));
      var c = this.parse(o, i);
      return this.renderTokens(c, n, a, o, r);
    }
  }
};
Wt.prototype.unescapedValue = function(e, n) {
  var a = n.lookup(e[1]);
  if (a != null)
    return a;
};
Wt.prototype.escapedValue = function(e, n, a) {
  var r = this.getConfigEscape(a) || cn.escape, i = n.lookup(e[1]);
  if (i != null)
    return typeof i == "number" && r === cn.escape ? String(i) : r(i);
};
Wt.prototype.rawValue = function(e) {
  return e[1];
};
Wt.prototype.getConfigTags = function(e) {
  return ic(e) ? e : e && typeof e == "object" ? e.tags : void 0;
};
Wt.prototype.getConfigEscape = function(e) {
  if (e && typeof e == "object" && !ic(e))
    return e.escape;
};
var cn = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: void 0,
  escape: void 0,
  parse: void 0,
  render: void 0,
  Scanner: void 0,
  Context: void 0,
  Writer: void 0,
  /**
   * Allows a user to override the default caching strategy, by providing an
   * object with set, get and clear methods. This can also be used to disable
   * the cache by setting it to the literal `undefined`.
   */
  set templateCache(t) {
    bd.templateCache = t;
  },
  /**
   * Gets the default or overridden caching object from the default writer.
   */
  get templateCache() {
    return bd.templateCache;
  }
}, bd = new Wt();
cn.clearCache = function() {
  return bd.clearCache();
};
cn.parse = function(e, n) {
  return bd.parse(e, n);
};
cn.render = function(e, n, a, r) {
  if (typeof e != "string")
    throw new TypeError('Invalid template! Template should be a "string" but "' + tU(e) + '" was given as the first argument for mustache#render(template, view, partials)');
  return bd.render(e, n, a, r);
};
cn.escape = uU;
cn.Scanner = zd;
cn.Context = zu;
cn.Writer = Wt;
function M$() {
  cn.escape = (t) => t;
}
const Uh = (t) => {
  const e = t.split(""), n = [], a = (i, s) => {
    for (let u = s; u < e.length; u += 1)
      if (i.includes(e[u]))
        return u;
    return -1;
  };
  let r = 0;
  for (; r < e.length; )
    if (e[r] === "{" && r + 1 < e.length && e[r + 1] === "{")
      n.push({ type: "literal", text: "{" }), r += 2;
    else if (e[r] === "}" && r + 1 < e.length && e[r + 1] === "}")
      n.push({ type: "literal", text: "}" }), r += 2;
    else if (e[r] === "{") {
      const i = a("}", r);
      if (i < 0)
        throw new Error("Unclosed '{' in template.");
      n.push({
        type: "variable",
        name: e.slice(r + 1, i).join("")
      }), r = i + 1;
    } else {
      if (e[r] === "}")
        throw new Error("Single '}' in template.");
      {
        const i = a("{}", r), s = (i < 0 ? e.slice(r) : e.slice(r, i)).join("");
        n.push({ type: "literal", text: s }), r = i < 0 ? e.length : i;
      }
    }
  return n;
}, bU = (t) => t.map((e) => e[0] === "name" ? { type: "variable", name: e[1].includes(".") ? e[1].split(".")[0] : e[1] } : ["#", "&", "^", ">"].includes(e[0]) ? { type: "variable", name: e[1] } : { type: "literal", text: e[1] }), Wb = (t) => {
  M$();
  const e = cn.parse(t);
  return bU(e);
}, gU = (t, e) => Uh(t).reduce((n, a) => {
  if (a.type === "variable") {
    if (a.name in e) {
      const r = typeof e[a.name] == "string" ? e[a.name] : JSON.stringify(e[a.name]);
      return n + r;
    }
    throw new Error(`(f-string) Missing value for input ${a.name}`);
  }
  return n + a.text;
}, ""), _U = (t, e) => (M$(), cn.render(t, e)), Xb = {
  "f-string": gU,
  mustache: _U
}, yU = {
  "f-string": Uh,
  mustache: Wb
}, cr = (t, e, n) => {
  try {
    return Xb[e](t, n);
  } catch (a) {
    throw op(a, "INVALID_PROMPT_INPUT");
  }
}, vU = (t, e) => yU[e](t), M_ = (t, e, n) => {
  if (!(e in Xb)) {
    const a = Object.keys(Xb);
    throw new Error(`Invalid template format. Got \`${e}\`;
                         should be one of ${a}`);
  }
  try {
    const a = n.reduce((r, i) => (r[i] = "foo", r), {});
    Array.isArray(t) ? t.forEach((r) => {
      if (r.type === "text")
        cr(r.text, e, a);
      else if (r.type === "image_url")
        if (typeof r.image_url == "string")
          cr(r.image_url, e, a);
        else {
          const i = r.image_url.url;
          cr(i, e, a);
        }
      else
        throw new Error(`Invalid message template received. ${JSON.stringify(r, null, 2)}`);
    }) : cr(t, e, a);
  } catch (a) {
    throw new Error(`Invalid prompt schema: ${a.message}`);
  }
};
class He extends Lh {
  static lc_name() {
    return "PromptTemplate";
  }
  constructor(e) {
    if (super(e), Object.defineProperty(this, "template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "templateFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "f-string"
    }), Object.defineProperty(this, "validateTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "additionalContentFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), e.templateFormat === "mustache" && e.validateTemplate === void 0 && (this.validateTemplate = !1), Object.assign(this, e), this.validateTemplate) {
      if (this.templateFormat === "mustache")
        throw new Error("Mustache templates cannot be validated.");
      let n = this.inputVariables;
      this.partialVariables && (n = n.concat(Object.keys(this.partialVariables))), M_(this.template, this.templateFormat, n);
    }
  }
  _getPromptType() {
    return "prompt";
  }
  /**
   * Formats the prompt template with the provided values.
   * @param values The values to be used to format the prompt template.
   * @returns A promise that resolves to a string which is the formatted prompt.
   */
  async format(e) {
    const n = await this.mergePartialAndUserVariables(e);
    return cr(this.template, this.templateFormat, n);
  }
  /**
   * Take examples in list format with prefix and suffix to create a prompt.
   *
   * Intended to be used a a way to dynamically create a prompt from examples.
   *
   * @param examples - List of examples to use in the prompt.
   * @param suffix - String to go after the list of examples. Should generally set up the user's input.
   * @param inputVariables - A list of variable names the final prompt template will expect
   * @param exampleSeparator - The separator to use in between examples
   * @param prefix - String that should go before any examples. Generally includes examples.
   *
   * @returns The final prompt template generated.
   */
  static fromExamples(e, n, a, r = `

`, i = "") {
    const s = [i, ...e, n].join(r);
    return new He({
      inputVariables: a,
      template: s
    });
  }
  static fromTemplate(e, n) {
    const { templateFormat: a = "f-string", ...r } = n ?? {}, i = /* @__PURE__ */ new Set();
    return vU(e, a).forEach((s) => {
      s.type === "variable" && i.add(s.name);
    }), new He({
      // Rely on extracted types
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      inputVariables: [...i],
      templateFormat: a,
      template: e,
      ...r
    });
  }
  /**
   * Partially applies values to the prompt template.
   * @param values The values to be partially applied to the prompt template.
   * @returns A new instance of PromptTemplate with the partially applied values.
   */
  async partial(e) {
    const n = this.inputVariables.filter((i) => !(i in e)), a = {
      ...this.partialVariables ?? {},
      ...e
    }, r = {
      ...this,
      inputVariables: n,
      partialVariables: a
    };
    return new He(r);
  }
  serialize() {
    if (this.outputParser !== void 0)
      throw new Error("Cannot serialize a prompt template with an output parser");
    return {
      _type: this._getPromptType(),
      input_variables: this.inputVariables,
      template: this.template,
      template_format: this.templateFormat
    };
  }
  static async deserialize(e) {
    if (!e.template)
      throw new Error("Prompt template must have a template");
    return new He({
      inputVariables: e.input_variables,
      template: e.template,
      templateFormat: e.template_format
    });
  }
}
const Fj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PromptTemplate: He
}, Symbol.toStringTag, { value: "Module" }));
class Vl extends Ap {
  static lc_name() {
    return "ImagePromptTemplate";
  }
  constructor(e) {
    if (super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompts", "image"]
    }), Object.defineProperty(this, "template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "templateFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "f-string"
    }), Object.defineProperty(this, "validateTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "additionalContentFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.template = e.template, this.templateFormat = e.templateFormat ?? this.templateFormat, this.validateTemplate = e.validateTemplate ?? this.validateTemplate, this.additionalContentFields = e.additionalContentFields, this.validateTemplate) {
      let n = this.inputVariables;
      this.partialVariables && (n = n.concat(Object.keys(this.partialVariables))), M_([
        { type: "image_url", image_url: this.template }
      ], this.templateFormat, n);
    }
  }
  _getPromptType() {
    return "prompt";
  }
  /**
   * Partially applies values to the prompt template.
   * @param values The values to be partially applied to the prompt template.
   * @returns A new instance of ImagePromptTemplate with the partially applied values.
   */
  async partial(e) {
    const n = this.inputVariables.filter((i) => !(i in e)), a = {
      ...this.partialVariables ?? {},
      ...e
    }, r = {
      ...this,
      inputVariables: n,
      partialVariables: a
    };
    return new Vl(r);
  }
  /**
   * Formats the prompt template with the provided values.
   * @param values The values to be used to format the prompt template.
   * @returns A promise that resolves to a string which is the formatted prompt.
   */
  async format(e) {
    const n = {};
    for (const [s, u] of Object.entries(this.template))
      typeof u == "string" ? n[s] = cr(u, this.templateFormat, e) : n[s] = u;
    const a = e.url || n.url, r = e.detail || n.detail;
    if (!a)
      throw new Error("Must provide either an image URL.");
    if (typeof a != "string")
      throw new Error("url must be a string.");
    const i = { url: a };
    return r && (i.detail = r), i;
  }
  /**
   * Formats the prompt given the input values and returns a formatted
   * prompt value.
   * @param values The input values to format the prompt.
   * @returns A Promise that resolves to a formatted prompt value.
   */
  async formatPromptValue(e) {
    const n = await this.format(e);
    return new kF(n);
  }
}
class A_ extends Te {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompts", "chat"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
  }
  /**
   * Calls the formatMessages method with the provided input and options.
   * @param input Input for the formatMessages method
   * @param options Optional BaseCallbackConfig
   * @returns Formatted output messages
   */
  async invoke(e, n) {
    return this._callWithConfig((a) => this.formatMessages(a), e, { ...n, runType: "prompt" });
  }
}
class kj extends A_ {
  static lc_name() {
    return "MessagesPlaceholder";
  }
  constructor(e) {
    typeof e == "string" && (e = { variableName: e }), super(e), Object.defineProperty(this, "variableName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "optional", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.variableName = e.variableName, this.optional = e.optional ?? !1;
  }
  get inputVariables() {
    return [this.variableName];
  }
  async formatMessages(e) {
    const n = e[this.variableName];
    if (this.optional && !n)
      return [];
    if (!n) {
      const r = new Error(`Field "${this.variableName}" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages as an input value. Received: undefined`);
      throw r.name = "InputFormatError", r;
    }
    let a;
    try {
      Array.isArray(n) ? a = n.map(io) : a = [io(n)];
    } catch (r) {
      const i = typeof n == "string" ? n : JSON.stringify(n, null, 2), s = new Error([
        `Field "${this.variableName}" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages or coerceable values as input.`,
        `Received value: ${i}`,
        `Additional message: ${r.message}`
      ].join(`

`));
      throw s.name = "InputFormatError", s.lc_error_code = r.lc_error_code, s;
    }
    return a;
  }
}
class wU extends A_ {
  constructor(e) {
    "prompt" in e || (e = { prompt: e }), super(e), Object.defineProperty(this, "prompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.prompt = e.prompt;
  }
  get inputVariables() {
    return this.prompt.inputVariables;
  }
  async formatMessages(e) {
    return [await this.format(e)];
  }
}
class SU extends Ap {
  constructor(e) {
    super(e);
  }
  async format(e) {
    return (await this.formatPromptValue(e)).toString();
  }
  async formatPromptValue(e) {
    const n = await this.formatMessages(e);
    return new rR(n);
  }
}
class OU extends wU {
  static lc_name() {
    return "ChatMessagePromptTemplate";
  }
  constructor(e, n) {
    "prompt" in e || (e = { prompt: e, role: n }), super(e), Object.defineProperty(this, "role", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.role = e.role;
  }
  async format(e) {
    return new Xo(await this.prompt.format(e), this.role);
  }
  static fromTemplate(e, n, a) {
    return new this(He.fromTemplate(e, {
      templateFormat: a?.templateFormat
    }), n);
  }
}
class E_ extends A_ {
  static _messageClass() {
    throw new Error("Can not invoke _messageClass from inside _StringImageMessagePromptTemplate");
  }
  constructor(e, n) {
    if ("prompt" in e || (e = { prompt: e }), super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain_core", "prompts", "chat"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "inputVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "additionalOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "prompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "messageClass", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chatMessageClass", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.prompt = e.prompt, Array.isArray(this.prompt)) {
      let a = [];
      this.prompt.forEach((r) => {
        "inputVariables" in r && (a = a.concat(r.inputVariables));
      }), this.inputVariables = a;
    } else
      this.inputVariables = this.prompt.inputVariables;
    this.additionalOptions = n ?? this.additionalOptions;
  }
  createMessage(e) {
    const n = this.constructor;
    if (n._messageClass()) {
      const a = n._messageClass();
      return new a({ content: e });
    } else if (n.chatMessageClass) {
      const a = n.chatMessageClass();
      return new a({
        content: e,
        role: this.getRoleFromMessageClass(a.lc_name())
      });
    } else
      throw new Error("No message class defined");
  }
  getRoleFromMessageClass(e) {
    switch (e) {
      case "HumanMessage":
        return "human";
      case "AIMessage":
        return "ai";
      case "SystemMessage":
        return "system";
      case "ChatMessage":
        return "chat";
      default:
        throw new Error("Invalid message class name");
    }
  }
  static fromTemplate(e, n) {
    if (typeof e == "string")
      return new this(He.fromTemplate(e, n));
    const a = [];
    for (const r of e)
      if (typeof r == "string" || typeof r == "object" && "text" in r) {
        let i = "";
        typeof r == "string" ? i = r : typeof r.text == "string" && (i = r.text ?? "");
        const s = {
          ...n,
          ...typeof r != "string" ? { additionalContentFields: r } : {}
        };
        a.push(He.fromTemplate(i, s));
      } else if (typeof r == "object" && "image_url" in r) {
        let i = r.image_url ?? "", s, u = [];
        if (typeof i == "string") {
          let d;
          n?.templateFormat === "mustache" ? d = Wb(i) : d = Uh(i);
          const f = d.flatMap((o) => o.type === "variable" ? [o.name] : []);
          if ((f?.length ?? 0) > 0) {
            if (f.length > 1)
              throw new Error(`Only one format variable allowed per image template.
Got: ${f}
From: ${i}`);
            u = [f[0]];
          } else
            u = [];
          i = { url: i }, s = new Vl({
            template: i,
            inputVariables: u,
            templateFormat: n?.templateFormat,
            additionalContentFields: r
          });
        } else if (typeof i == "object") {
          if ("url" in i) {
            let d;
            n?.templateFormat === "mustache" ? d = Wb(i.url) : d = Uh(i.url), u = d.flatMap((f) => f.type === "variable" ? [f.name] : []);
          } else
            u = [];
          s = new Vl({
            template: i,
            inputVariables: u,
            templateFormat: n?.templateFormat,
            additionalContentFields: r
          });
        } else
          throw new Error("Invalid image template");
        a.push(s);
      }
    return new this({ prompt: a, additionalOptions: n });
  }
  async format(e) {
    if (this.prompt instanceof Lh) {
      const n = await this.prompt.format(e);
      return this.createMessage(n);
    } else {
      const n = [];
      for (const a of this.prompt) {
        let r = {};
        if (!("inputVariables" in a))
          throw new Error(`Prompt ${a} does not have inputVariables defined.`);
        for (const i of a.inputVariables)
          r || (r = { [i]: e[i] }), r = { ...r, [i]: e[i] };
        if (a instanceof Lh) {
          const i = await a.format(r);
          let s;
          "additionalContentFields" in a && (s = a.additionalContentFields), n.push({
            ...s,
            type: "text",
            text: i
          });
        } else if (a instanceof Vl) {
          const i = await a.format(r);
          let s;
          "additionalContentFields" in a && (s = a.additionalContentFields), n.push({
            ...s,
            type: "image_url",
            image_url: i
          });
        }
      }
      return this.createMessage(n);
    }
  }
  async formatMessages(e) {
    return [await this.format(e)];
  }
}
class Bs extends E_ {
  static _messageClass() {
    return mr;
  }
  static lc_name() {
    return "HumanMessagePromptTemplate";
  }
}
class A$ extends E_ {
  static _messageClass() {
    return At;
  }
  static lc_name() {
    return "AIMessagePromptTemplate";
  }
}
class sc extends E_ {
  static _messageClass() {
    return dh;
  }
  static lc_name() {
    return "SystemMessagePromptTemplate";
  }
}
function jU(t) {
  return typeof t.formatMessages == "function";
}
function PU(t, e) {
  if (jU(t) || nn(t))
    return t;
  if (Array.isArray(t) && t[0] === "placeholder") {
    const r = t[1];
    if (e?.templateFormat === "mustache" && typeof r == "string" && r.slice(0, 2) === "{{" && r.slice(-2) === "}}") {
      const i = r.slice(2, -2);
      return new kj({ variableName: i, optional: !0 });
    } else if (typeof r == "string" && r[0] === "{" && r[r.length - 1] === "}") {
      const i = r.slice(1, -1);
      return new kj({ variableName: i, optional: !0 });
    }
    throw new Error(`Invalid placeholder template for format ${e?.templateFormat ?? '"f-string"'}: "${t[1]}". Expected a variable name surrounded by ${e?.templateFormat === "mustache" ? "double" : "single"} curly braces.`);
  }
  const n = io(t);
  let a;
  if (typeof n.content == "string" ? a = n.content : a = n.content.map((r) => "text" in r ? { ...r, text: r.text } : "image_url" in r ? { ...r, image_url: r.image_url } : r), n._getType() === "human")
    return Bs.fromTemplate(a, e);
  if (n._getType() === "ai")
    return A$.fromTemplate(a, e);
  if (n._getType() === "system")
    return sc.fromTemplate(a, e);
  if (Xo.isInstance(n))
    return OU.fromTemplate(n.content, n.role, e);
  throw new Error(`Could not coerce message prompt template from input. Received message type: "${n._getType()}".`);
}
function CU(t) {
  return t.constructor.lc_name() === "MessagesPlaceholder";
}
class ua extends SU {
  static lc_name() {
    return "ChatPromptTemplate";
  }
  get lc_aliases() {
    return {
      promptMessages: "messages"
    };
  }
  constructor(e) {
    if (super(e), Object.defineProperty(this, "promptMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "validateTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "templateFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "f-string"
    }), e.templateFormat === "mustache" && e.validateTemplate === void 0 && (this.validateTemplate = !1), Object.assign(this, e), this.validateTemplate) {
      const n = /* @__PURE__ */ new Set();
      for (const u of this.promptMessages)
        if (!(u instanceof sa))
          for (const d of u.inputVariables)
            n.add(d);
      const a = this.inputVariables, r = new Set(this.partialVariables ? a.concat(Object.keys(this.partialVariables)) : a), i = new Set([...r].filter((u) => !n.has(u)));
      if (i.size > 0)
        throw new Error(`Input variables \`${[
          ...i
        ]}\` are not used in any of the prompt messages.`);
      const s = new Set([...n].filter((u) => !r.has(u)));
      if (s.size > 0)
        throw new Error(`Input variables \`${[
          ...s
        ]}\` are used in prompt messages but not in the prompt template.`);
    }
  }
  _getPromptType() {
    return "chat";
  }
  async _parseImagePrompts(e, n) {
    if (typeof e.content == "string")
      return e;
    const a = await Promise.all(e.content.map(async (r) => {
      if (r.type !== "image_url")
        return r;
      let i = "";
      typeof r.image_url == "string" ? i = r.image_url : i = r.image_url.url;
      const u = await He.fromTemplate(i, {
        templateFormat: this.templateFormat
      }).format(n);
      return typeof r.image_url != "string" && "url" in r.image_url ? r.image_url.url = u : r.image_url = u, r;
    }));
    return e.content = a, e;
  }
  async formatMessages(e) {
    const n = await this.mergePartialAndUserVariables(e);
    let a = [];
    for (const r of this.promptMessages)
      if (r instanceof sa)
        a.push(await this._parseImagePrompts(r, n));
      else {
        const i = r.inputVariables.reduce((u, d) => {
          if (!(d in n) && !(CU(r) && r.optional))
            throw op(new Error(`Missing value for input variable \`${d.toString()}\``), "INVALID_PROMPT_INPUT");
          return u[d] = n[d], u;
        }, {}), s = await r.formatMessages(i);
        a = a.concat(s);
      }
    return a;
  }
  async partial(e) {
    const n = this.inputVariables.filter((i) => !(i in e)), a = {
      ...this.partialVariables ?? {},
      ...e
    }, r = {
      ...this,
      inputVariables: n,
      partialVariables: a
    };
    return new ua(r);
  }
  static fromTemplate(e, n) {
    const a = He.fromTemplate(e, n), r = new Bs({ prompt: a });
    return this.fromMessages([r]);
  }
  /**
   * Create a chat model-specific prompt from individual chat messages
   * or message-like tuples.
   * @param promptMessages Messages to be passed to the chat model
   * @returns A new ChatPromptTemplate
   */
  static fromMessages(e, n) {
    const a = e.reduce((s, u) => s.concat(
      // eslint-disable-next-line no-instanceof/no-instanceof
      u instanceof ua ? u.promptMessages : [
        PU(u, n)
      ]
    ), []), r = e.reduce((s, u) => (
      // eslint-disable-next-line no-instanceof/no-instanceof
      u instanceof ua ? Object.assign(s, u.partialVariables) : s
    ), /* @__PURE__ */ Object.create(null)), i = /* @__PURE__ */ new Set();
    for (const s of a)
      if (!(s instanceof sa))
        for (const u of s.inputVariables)
          u in r || i.add(u);
    return new this({
      ...n,
      inputVariables: [...i],
      promptMessages: a,
      partialVariables: r,
      templateFormat: n?.templateFormat
    });
  }
  /** @deprecated Renamed to .fromMessages */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static fromPromptMessages(e) {
    return this.fromMessages(e);
  }
}
class Bh extends Lh {
  constructor(e) {
    if (super(e), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "examples", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "exampleSelector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "examplePrompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "suffix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "exampleSeparator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: `

`
    }), Object.defineProperty(this, "prefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "templateFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "f-string"
    }), Object.defineProperty(this, "validateTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.assign(this, e), this.examples !== void 0 && this.exampleSelector !== void 0)
      throw new Error("Only one of 'examples' and 'example_selector' should be provided");
    if (this.examples === void 0 && this.exampleSelector === void 0)
      throw new Error("One of 'examples' and 'example_selector' should be provided");
    if (this.validateTemplate) {
      let n = this.inputVariables;
      this.partialVariables && (n = n.concat(Object.keys(this.partialVariables))), M_(this.prefix + this.suffix, this.templateFormat, n);
    }
  }
  _getPromptType() {
    return "few_shot";
  }
  static lc_name() {
    return "FewShotPromptTemplate";
  }
  async getExamples(e) {
    if (this.examples !== void 0)
      return this.examples;
    if (this.exampleSelector !== void 0)
      return this.exampleSelector.selectExamples(e);
    throw new Error("One of 'examples' and 'example_selector' should be provided");
  }
  async partial(e) {
    const n = this.inputVariables.filter((i) => !(i in e)), a = {
      ...this.partialVariables ?? {},
      ...e
    }, r = {
      ...this,
      inputVariables: n,
      partialVariables: a
    };
    return new Bh(r);
  }
  /**
   * Formats the prompt with the given values.
   * @param values The values to format the prompt with.
   * @returns A promise that resolves to a string representing the formatted prompt.
   */
  async format(e) {
    const n = await this.mergePartialAndUserVariables(e), a = await this.getExamples(n), r = await Promise.all(a.map((s) => this.examplePrompt.format(s))), i = [this.prefix, ...r, this.suffix].join(this.exampleSeparator);
    return cr(i, this.templateFormat, n);
  }
  serialize() {
    if (this.exampleSelector || !this.examples)
      throw new Error("Serializing an example selector is not currently supported");
    if (this.outputParser !== void 0)
      throw new Error("Serializing an output parser is not currently supported");
    return {
      _type: this._getPromptType(),
      input_variables: this.inputVariables,
      example_prompt: this.examplePrompt.serialize(),
      example_separator: this.exampleSeparator,
      suffix: this.suffix,
      prefix: this.prefix,
      template_format: this.templateFormat,
      examples: this.examples
    };
  }
  static async deserialize(e) {
    const { example_prompt: n } = e;
    if (!n)
      throw new Error("Missing example prompt");
    const a = await He.deserialize(n);
    let r;
    if (Array.isArray(e.examples))
      r = e.examples;
    else
      throw new Error("Invalid examples format. Only list or string are supported.");
    return new Bh({
      inputVariables: e.input_variables,
      examplePrompt: a,
      examples: r,
      exampleSeparator: e.example_separator,
      prefix: e.prefix,
      suffix: e.suffix,
      templateFormat: e.template_format
    });
  }
}
const RU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FewShotPromptTemplate: Bh
}, Symbol.toStringTag, { value: "Module" }));
class I_ extends YL {
  constructor(e) {
    if (super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "document_transformers", "text_splitters"]
    }), Object.defineProperty(this, "chunkSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "chunkOverlap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 200
    }), Object.defineProperty(this, "keepSeparator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "lengthFunction", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.chunkSize = e?.chunkSize ?? this.chunkSize, this.chunkOverlap = e?.chunkOverlap ?? this.chunkOverlap, this.keepSeparator = e?.keepSeparator ?? this.keepSeparator, this.lengthFunction = e?.lengthFunction ?? ((n) => n.length), this.chunkOverlap >= this.chunkSize)
      throw new Error("Cannot have chunkOverlap >= chunkSize");
  }
  async transformDocuments(e, n = {}) {
    return this.splitDocuments(e, n);
  }
  splitOnSeparator(e, n) {
    let a;
    if (n)
      if (this.keepSeparator) {
        const r = n.replace(/[/\-\\^$*+?.()|[\]{}]/g, "\\$&");
        a = e.split(new RegExp(`(?=${r})`));
      } else
        a = e.split(n);
    else
      a = e.split("");
    return a.filter((r) => r !== "");
  }
  async createDocuments(e, n = [], a = {}) {
    const r = n.length > 0 ? n : [...Array(e.length)].map(() => ({})), { chunkHeader: i = "", chunkOverlapHeader: s = "(cont'd) ", appendChunkOverlapHeader: u = !1 } = a, d = new Array();
    for (let f = 0; f < e.length; f += 1) {
      const o = e[f];
      let c = 1, h = null, p = -1;
      for (const l of await this.splitText(o)) {
        let m = i;
        const b = o.indexOf(l, p + 1);
        if (h === null) {
          const R = this.numberOfNewLines(o, 0, b);
          c += R;
        } else {
          const R = p + await this.lengthFunction(h);
          if (R < b) {
            const C = this.numberOfNewLines(o, R, b);
            c += C;
          } else if (R > b) {
            const C = this.numberOfNewLines(o, b, R);
            c -= C;
          }
          u && (m += s);
        }
        const g = this.numberOfNewLines(l), _ = r[f].loc && typeof r[f].loc == "object" ? { ...r[f].loc } : {};
        _.lines = {
          from: c,
          to: c + g
        };
        const P = {
          ...r[f],
          loc: _
        };
        m += l, d.push(new ur({
          pageContent: m,
          metadata: P
        })), c += g, h = l, p = b;
      }
    }
    return d;
  }
  numberOfNewLines(e, n, a) {
    return (e.slice(n, a).match(/\n/g) || []).length;
  }
  async splitDocuments(e, n = {}) {
    const a = e.filter((s) => s.pageContent !== void 0), r = a.map((s) => s.pageContent), i = a.map((s) => s.metadata);
    return this.createDocuments(r, i, n);
  }
  joinDocs(e, n) {
    const a = e.join(n).trim();
    return a === "" ? null : a;
  }
  async mergeSplits(e, n) {
    const a = [], r = [];
    let i = 0;
    for (const u of e) {
      const d = await this.lengthFunction(u);
      if (i + d + r.length * n.length > this.chunkSize && (i > this.chunkSize && console.warn(`Created a chunk of size ${i}, +
which is longer than the specified ${this.chunkSize}`), r.length > 0)) {
        const f = this.joinDocs(r, n);
        for (f !== null && a.push(f); i > this.chunkOverlap || i + d + r.length * n.length > this.chunkSize && i > 0; )
          i -= await this.lengthFunction(r[0]), r.shift();
      }
      r.push(u), i += d;
    }
    const s = this.joinDocs(r, n);
    return s !== null && a.push(s), a;
  }
}
class WV extends I_ {
  static lc_name() {
    return "CharacterTextSplitter";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "separator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: `

`
    }), this.separator = e?.separator ?? this.separator;
  }
  async splitText(e) {
    const n = this.splitOnSeparator(e, this.separator);
    return this.mergeSplits(n, this.keepSeparator ? "" : this.separator);
  }
}
class xh extends I_ {
  static lc_name() {
    return "RecursiveCharacterTextSplitter";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "separators", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [`

`, `
`, " ", ""]
    }), this.separators = e?.separators ?? this.separators, this.keepSeparator = e?.keepSeparator ?? !0;
  }
  async _splitText(e, n) {
    const a = [];
    let r = n[n.length - 1], i;
    for (let f = 0; f < n.length; f += 1) {
      const o = n[f];
      if (o === "") {
        r = o;
        break;
      }
      if (e.includes(o)) {
        r = o, i = n.slice(f + 1);
        break;
      }
    }
    const s = this.splitOnSeparator(e, r);
    let u = [];
    const d = this.keepSeparator ? "" : r;
    for (const f of s)
      if (await this.lengthFunction(f) < this.chunkSize)
        u.push(f);
      else {
        if (u.length) {
          const o = await this.mergeSplits(u, d);
          a.push(...o), u = [];
        }
        if (!i)
          a.push(f);
        else {
          const o = await this._splitText(f, i);
          a.push(...o);
        }
      }
    if (u.length) {
      const f = await this.mergeSplits(u, d);
      a.push(...f);
    }
    return a;
  }
  async splitText(e) {
    return this._splitText(e, this.separators);
  }
  static fromLanguage(e, n) {
    return new xh({
      ...n,
      separators: xh.getSeparatorsForLanguage(e)
    });
  }
  static getSeparatorsForLanguage(e) {
    if (e === "cpp")
      return [
        // Split along class definitions
        `
class `,
        // Split along function definitions
        `
void `,
        `
int `,
        `
float `,
        `
double `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
while `,
        `
switch `,
        `
case `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "go")
      return [
        // Split along function definitions
        `
func `,
        `
var `,
        `
const `,
        `
type `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
switch `,
        `
case `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "java")
      return [
        // Split along class definitions
        `
class `,
        // Split along method definitions
        `
public `,
        `
protected `,
        `
private `,
        `
static `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
while `,
        `
switch `,
        `
case `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "js")
      return [
        // Split along function definitions
        `
function `,
        `
const `,
        `
let `,
        `
var `,
        `
class `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
while `,
        `
switch `,
        `
case `,
        `
default `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "php")
      return [
        // Split along function definitions
        `
function `,
        // Split along class definitions
        `
class `,
        // Split along control flow statements
        `
if `,
        `
foreach `,
        `
while `,
        `
do `,
        `
switch `,
        `
case `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "proto")
      return [
        // Split along message definitions
        `
message `,
        // Split along service definitions
        `
service `,
        // Split along enum definitions
        `
enum `,
        // Split along option definitions
        `
option `,
        // Split along import statements
        `
import `,
        // Split along syntax declarations
        `
syntax `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "python")
      return [
        // First, try to split along class definitions
        `
class `,
        `
def `,
        `
	def `,
        // Now split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "rst")
      return [
        // Split along section titles
        `
===
`,
        `
---
`,
        `
***
`,
        // Split along directive markers
        `
.. `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "ruby")
      return [
        // Split along method definitions
        `
def `,
        `
class `,
        // Split along control flow statements
        `
if `,
        `
unless `,
        `
while `,
        `
for `,
        `
do `,
        `
begin `,
        `
rescue `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "rust")
      return [
        // Split along function definitions
        `
fn `,
        `
const `,
        `
let `,
        // Split along control flow statements
        `
if `,
        `
while `,
        `
for `,
        `
loop `,
        `
match `,
        `
const `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "scala")
      return [
        // Split along class definitions
        `
class `,
        `
object `,
        // Split along method definitions
        `
def `,
        `
val `,
        `
var `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
while `,
        `
match `,
        `
case `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "swift")
      return [
        // Split along function definitions
        `
func `,
        // Split along class definitions
        `
class `,
        `
struct `,
        `
enum `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
while `,
        `
do `,
        `
switch `,
        `
case `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "markdown")
      return [
        // First, try to split along Markdown headings (starting with level 2)
        `
## `,
        `
### `,
        `
#### `,
        `
##### `,
        `
###### `,
        // Note the alternative syntax for headings (below) is not handled here
        // Heading level 2
        // ---------------
        // End of code block
        "```\n\n",
        // Horizontal lines
        `

***

`,
        `

---

`,
        `

___

`,
        // Note that this splitter doesn't handle horizontal lines defined
        // by *three or more* of ***, ---, or ___, but this is not handled
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "latex")
      return [
        // First, try to split along Latex sections
        `
\\chapter{`,
        `
\\section{`,
        `
\\subsection{`,
        `
\\subsubsection{`,
        // Now split by environments
        `
\\begin{enumerate}`,
        `
\\begin{itemize}`,
        `
\\begin{description}`,
        `
\\begin{list}`,
        `
\\begin{quote}`,
        `
\\begin{quotation}`,
        `
\\begin{verse}`,
        `
\\begin{verbatim}`,
        // Now split by math environments
        `
\\begin{align}`,
        "$$",
        "$",
        // Now split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    if (e === "html")
      return [
        // First, try to split along HTML tags
        "<body>",
        "<div>",
        "<p>",
        "<br>",
        "<li>",
        "<h1>",
        "<h2>",
        "<h3>",
        "<h4>",
        "<h5>",
        "<h6>",
        "<span>",
        "<table>",
        "<tr>",
        "<td>",
        "<th>",
        "<ul>",
        "<ol>",
        "<header>",
        "<footer>",
        "<nav>",
        // Head
        "<head>",
        "<style>",
        "<script>",
        "<meta>",
        "<title>",
        // Normal type of lines
        " ",
        ""
      ];
    if (e === "sol")
      return [
        // Split along compiler informations definitions
        `
pragma `,
        `
using `,
        // Split along contract definitions
        `
contract `,
        `
interface `,
        `
library `,
        // Split along method definitions
        `
constructor `,
        `
type `,
        `
function `,
        `
event `,
        `
modifier `,
        `
error `,
        `
struct `,
        `
enum `,
        // Split along control flow statements
        `
if `,
        `
for `,
        `
while `,
        `
do while `,
        `
assembly `,
        // Split by the normal type of lines
        `

`,
        `
`,
        " ",
        ""
      ];
    throw new Error(`Language ${e} is not supported.`);
  }
}
class XV extends I_ {
  static lc_name() {
    return "TokenTextSplitter";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "encodingName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "allowedSpecial", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "disallowedSpecial", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tokenizer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.encodingName = e?.encodingName ?? "gpt2", this.allowedSpecial = e?.allowedSpecial ?? [], this.disallowedSpecial = e?.disallowedSpecial ?? "all";
  }
  async splitText(e) {
    this.tokenizer || (this.tokenizer = await iR(this.encodingName));
    const n = [], a = this.tokenizer.encode(e, this.allowedSpecial, this.disallowedSpecial);
    let r = 0;
    for (; r < a.length; ) {
      r > 0 && (r -= this.chunkOverlap);
      const i = Math.min(r + this.chunkSize, a.length), s = a.slice(r, i);
      n.push(this.tokenizer.decode(s)), r = i;
    }
    return n;
  }
}
class E$ {
}
const I$ = (t, e) => {
  if (e !== void 0)
    return t[e];
  const n = Object.keys(t);
  if (n.length === 1)
    return t[n[0]];
}, N$ = (t, e) => {
  const n = I$(t, e);
  if (!n) {
    const a = Object.keys(t);
    throw new Error(`input values have ${a.length} keys, you must specify an input key or pass only 1 key as input`);
  }
  return n;
}, TU = (t, e) => {
  const n = I$(t, e);
  if (!n && n !== "") {
    const a = Object.keys(t);
    throw new Error(`output values have ${a.length} keys, you must specify an output key or pass only 1 key as output`);
  }
  return n;
};
class $U extends pr {
  /**
   * This is a convenience method for adding a human message string to the store.
   * Please note that this is a convenience method. Code should favor the
   * bulk addMessages interface instead to save on round-trips to the underlying
   * persistence layer.
   * This method may be deprecated in a future release.
   */
  addUserMessage(e) {
    return this.addMessage(new mr(e));
  }
  /** @deprecated Use addAIMessage instead */
  addAIChatMessage(e) {
    return this.addMessage(new At(e));
  }
  /**
   * This is a convenience method for adding an AI message string to the store.
   * Please note that this is a convenience method. Code should favor the bulk
   * addMessages interface instead to save on round-trips to the underlying
   * persistence layer.
   * This method may be deprecated in a future release.
   */
  addAIMessage(e) {
    return this.addMessage(new At(e));
  }
  /**
   * Add a list of messages.
   *
   * Implementations should override this method to handle bulk addition of messages
   * in an efficient manner to avoid unnecessary round-trips to the underlying store.
   *
   * @param messages - A list of BaseMessage objects to store.
   */
  async addMessages(e) {
    for (const n of e)
      await this.addMessage(n);
  }
  /**
   * Remove all messages from the store.
   */
  clear() {
    throw new Error("Not implemented.");
  }
}
class MU extends $U {
  constructor(e) {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "stores", "message", "in_memory"]
    }), Object.defineProperty(this, "messages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this.messages = e ?? [];
  }
  /**
   * Method to get all the messages stored in the ChatMessageHistory
   * instance.
   * @returns Array of stored BaseMessage instances.
   */
  async getMessages() {
    return this.messages;
  }
  /**
   * Method to add a new message to the ChatMessageHistory instance.
   * @param message The BaseMessage instance to add.
   * @returns A promise that resolves when the message has been added.
   */
  async addMessage(e) {
    this.messages.push(e);
  }
  /**
   * Method to clear all the messages from the ChatMessageHistory instance.
   * @returns A promise that resolves when all messages have been cleared.
   */
  async clear() {
    this.messages = [];
  }
}
class N_ extends E$ {
  constructor(e) {
    super(), Object.defineProperty(this, "chatHistory", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.chatHistory = e?.chatHistory ?? new MU(), this.returnMessages = e?.returnMessages ?? this.returnMessages, this.inputKey = e?.inputKey ?? this.inputKey, this.outputKey = e?.outputKey ?? this.outputKey;
  }
  /**
   * Method to add user and AI messages to the chat history in sequence.
   * @param inputValues The input values from the user.
   * @param outputValues The output values from the AI.
   * @returns Promise that resolves when the context has been saved.
   */
  async saveContext(e, n) {
    await this.chatHistory.addUserMessage(N$(e, this.inputKey)), await this.chatHistory.addAIChatMessage(TU(n, this.outputKey));
  }
  /**
   * Method to clear the chat history.
   * @returns Promise that resolves when the chat history has been cleared.
   */
  async clear() {
    await this.chatHistory.clear();
  }
}
class AU extends N_ {
  constructor(e) {
    super({
      chatHistory: e?.chatHistory,
      returnMessages: e?.returnMessages ?? !1,
      inputKey: e?.inputKey,
      outputKey: e?.outputKey
    }), Object.defineProperty(this, "humanPrefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Human"
    }), Object.defineProperty(this, "aiPrefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AI"
    }), Object.defineProperty(this, "memoryKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "history"
    }), this.humanPrefix = e?.humanPrefix ?? this.humanPrefix, this.aiPrefix = e?.aiPrefix ?? this.aiPrefix, this.memoryKey = e?.memoryKey ?? this.memoryKey;
  }
  get memoryKeys() {
    return [this.memoryKey];
  }
  /**
   * Loads the memory variables. It takes an `InputValues` object as a
   * parameter and returns a `Promise` that resolves with a
   * `MemoryVariables` object.
   * @param _values `InputValues` object.
   * @returns A `Promise` that resolves with a `MemoryVariables` object.
   */
  async loadMemoryVariables(e) {
    const n = await this.chatHistory.getMessages();
    return this.returnMessages ? {
      [this.memoryKey]: n
    } : {
      [this.memoryKey]: so(n, this.humanPrefix, this.aiPrefix)
    };
  }
}
class It extends Bg {
  get lc_namespace() {
    return ["langchain", "chains", this._chainType()];
  }
  constructor(e, n, a) {
    if (arguments.length === 1 && typeof e == "object" && !("saveContext" in e)) {
      const { memory: r, callbackManager: i, ...s } = e;
      super({ ...s, callbacks: i ?? s.callbacks }), this.memory = r;
    } else
      super({ verbose: n, callbacks: a }), this.memory = e;
  }
  /** @ignore */
  _selectMemoryInputs(e) {
    const n = { ...e };
    return "signal" in n && delete n.signal, "timeout" in n && delete n.timeout, n;
  }
  /**
   * Invoke the chain with the provided input and returns the output.
   * @param input Input values for the chain run.
   * @param config Optional configuration for the Runnable.
   * @returns Promise that resolves with the output of the chain run.
   */
  async invoke(e, n) {
    const a = Ce(n), r = await this._formatValues(e), s = await (await it.configure(a?.callbacks, this.callbacks, a?.tags, this.tags, a?.metadata, this.metadata, { verbose: this.verbose }))?.handleChainStart(this.toJSON(), r, void 0, void 0, void 0, void 0, a?.runName);
    let u;
    try {
      u = await (r.signal ? Promise.race([
        this._call(r, s, a),
        new Promise((d, f) => {
          r.signal?.addEventListener("abort", () => {
            f(new Error("AbortError"));
          });
        })
      ]) : this._call(r, s, a));
    } catch (d) {
      throw await s?.handleChainError(d), d;
    }
    return this.memory != null && await this.memory.saveContext(this._selectMemoryInputs(e), u), await s?.handleChainEnd(u), Object.defineProperty(u, pd, {
      value: s ? { runId: s?.runId } : void 0,
      configurable: !0
    }), u;
  }
  _validateOutputs(e) {
    const n = this.outputKeys.filter((a) => !(a in e));
    if (n.length)
      throw new Error(`Missing output keys: ${n.join(", ")} from chain ${this._chainType()}`);
  }
  async prepOutputs(e, n, a = !1) {
    return this._validateOutputs(n), this.memory && await this.memory.saveContext(e, n), a ? n : { ...e, ...n };
  }
  /**
   * Return a json-like object representing this chain.
   */
  serialize() {
    throw new Error("Method not implemented.");
  }
  /** @deprecated Use .invoke() instead. Will be removed in 0.2.0. */
  async run(e, n) {
    const a = this.inputKeys.filter((d) => !this.memory?.memoryKeys.includes(d));
    if (!(a.length <= 1))
      throw new Error(`Chain ${this._chainType()} expects multiple inputs, cannot use 'run' `);
    const i = a.length ? { [a[0]]: e } : {}, s = await this.call(i, n), u = Object.keys(s);
    if (u.length === 1)
      return s[u[0]];
    throw new Error("return values have multiple keys, `run` only supported when one key currently");
  }
  async _formatValues(e) {
    const n = { ...e };
    if (n.timeout && !n.signal && (n.signal = AbortSignal.timeout(n.timeout), delete n.timeout), this.memory != null) {
      const a = await this.memory.loadMemoryVariables(this._selectMemoryInputs(e));
      for (const [r, i] of Object.entries(a))
        n[r] = i;
    }
    return n;
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Run the core logic of this chain and add to output if desired.
   *
   * Wraps _call and handles memory.
   */
  async call(e, n, a) {
    const r = { tags: a, ...cp(n) };
    return this.invoke(e, r);
  }
  /**
   * @deprecated Use .batch() instead. Will be removed in 0.2.0.
   *
   * Call the chain on all inputs in the list
   */
  async apply(e, n) {
    return Promise.all(e.map(async (a, r) => this.call(a, n?.[r])));
  }
  /**
   * Load a chain from a json-like object describing it.
   */
  static async deserialize(e, n = {}) {
    switch (e._type) {
      case "llm_chain": {
        const { LLMChain: a } = await Promise.resolve().then(() => NU);
        return a.deserialize(e);
      }
      case "sequential_chain": {
        const { SequentialChain: a } = await Promise.resolve().then(() => xj);
        return a.deserialize(e);
      }
      case "simple_sequential_chain": {
        const { SimpleSequentialChain: a } = await Promise.resolve().then(() => xj);
        return a.deserialize(e);
      }
      case "stuff_documents_chain": {
        const { StuffDocumentsChain: a } = await Promise.resolve().then(() => Ym);
        return a.deserialize(e);
      }
      case "map_reduce_documents_chain": {
        const { MapReduceDocumentsChain: a } = await Promise.resolve().then(() => Ym);
        return a.deserialize(e);
      }
      case "refine_documents_chain": {
        const { RefineDocumentsChain: a } = await Promise.resolve().then(() => Ym);
        return a.deserialize(e);
      }
      case "vector_db_qa": {
        const { VectorDBQAChain: a } = await Promise.resolve().then(() => qB);
        return a.deserialize(e, n);
      }
      case "api_chain": {
        const { APIChain: a } = await Promise.resolve().then(() => rx);
        return a.deserialize(e);
      }
      default:
        throw new Error(`Invalid prompt type in config: ${e._type}`);
    }
  }
}
class EU extends Fd {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "output_parsers", "default"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
  }
  static lc_name() {
    return "NoOpOutputParser";
  }
  /**
   * This method takes a string as input and returns the same string as
   * output. It does not perform any operations on the input string.
   * @param text The input string to be parsed.
   * @returns The same input string without any operations performed on it.
   */
  parse(e) {
    return Promise.resolve(e);
  }
  /**
   * This method returns an empty string. It does not provide any formatting
   * instructions.
   * @returns An empty string, indicating no formatting instructions.
   */
  getFormatInstructions() {
    return "";
  }
}
function IU(t) {
  return typeof t._llmType == "function";
}
function Yf(t) {
  if (IU(t))
    return t;
  if ("bound" in t && Te.isRunnable(t.bound))
    return Yf(t.bound);
  if ("runnable" in t && "fallbacks" in t && Te.isRunnable(t.runnable))
    return Yf(t.runnable);
  if ("default" in t && Te.isRunnable(t.default))
    return Yf(t.default);
  throw new Error("Unable to extract BaseLanguageModel from llmLike object.");
}
class tt extends It {
  static lc_name() {
    return "LLMChain";
  }
  get inputKeys() {
    return this.prompt.inputVariables;
  }
  get outputKeys() {
    return [this.outputKey];
  }
  constructor(e) {
    if (super(e), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "prompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "llm", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "llmKwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "text"
    }), Object.defineProperty(this, "outputParser", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.prompt = e.prompt, this.llm = e.llm, this.llmKwargs = e.llmKwargs, this.outputKey = e.outputKey ?? this.outputKey, this.outputParser = e.outputParser ?? new EU(), this.prompt.outputParser) {
      if (e.outputParser)
        throw new Error("Cannot set both outputParser and prompt.outputParser");
      this.outputParser = this.prompt.outputParser;
    }
  }
  getCallKeys() {
    return "callKeys" in this.llm ? this.llm.callKeys : [];
  }
  /** @ignore */
  _selectMemoryInputs(e) {
    const n = super._selectMemoryInputs(e), a = this.getCallKeys();
    for (const r of a)
      r in e && delete n[r];
    return n;
  }
  /** @ignore */
  async _getFinalOutput(e, n, a) {
    let r;
    return this.outputParser ? r = await this.outputParser.parseResultWithPrompt(e, n, a?.getChild()) : r = e[0].text, r;
  }
  /**
   * Run the core logic of this chain and add to output if desired.
   *
   * Wraps _call and handles memory.
   */
  call(e, n) {
    return super.call(e, n);
  }
  /** @ignore */
  async _call(e, n) {
    const a = { ...e }, r = {
      ...this.llmKwargs
    }, i = this.getCallKeys();
    for (const f of i)
      f in e && r && (r[f] = e[f], delete a[f]);
    const s = await this.prompt.formatPromptValue(a);
    if ("generatePrompt" in this.llm) {
      const { generations: f } = await this.llm.generatePrompt([s], r, n?.getChild());
      return {
        [this.outputKey]: await this._getFinalOutput(f[0], s, n)
      };
    }
    const d = await (this.outputParser ? this.llm.pipe(this.outputParser) : this.llm).invoke(s, n?.getChild());
    return {
      [this.outputKey]: d
    };
  }
  /**
   * Format prompt with values and pass to LLM
   *
   * @param values - keys to pass to prompt template
   * @param callbackManager - CallbackManager to use
   * @returns Completion from LLM.
   *
   * @example
   * ```ts
   * llm.predict({ adjective: "funny" })
   * ```
   */
  async predict(e, n) {
    return (await this.call(e, n))[this.outputKey];
  }
  _chainType() {
    return "llm";
  }
  static async deserialize(e) {
    const { llm: n, prompt: a } = e;
    if (!n)
      throw new Error("LLMChain must have llm");
    if (!a)
      throw new Error("LLMChain must have prompt");
    return new tt({
      llm: await xg.deserialize(n),
      prompt: await Ap.deserialize(a)
    });
  }
  /** @deprecated */
  serialize() {
    const e = "serialize" in this.llm ? this.llm.serialize() : void 0;
    return {
      _type: `${this._chainType()}_chain`,
      llm: e,
      prompt: this.prompt.serialize()
    };
  }
  _getNumTokens(e) {
    return Yf(this.llm).getNumTokens(e);
  }
}
const NU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LLMChain: tt
}, Symbol.toStringTag, { value: "Module" })), FU = `Progressively summarize the lines of conversation provided, adding onto the previous summary returning a new summary.

EXAMPLE
Current summary:
The human asks what the AI thinks of artificial intelligence. The AI thinks artificial intelligence is a force for good.

New lines of conversation:
Human: Why do you think artificial intelligence is a force for good?
AI: Because artificial intelligence will help humans reach their full potential.

New summary:
The human asks what the AI thinks of artificial intelligence. The AI thinks artificial intelligence is a force for good because it will help humans reach their full potential.
END OF EXAMPLE

Current summary:
{summary}

New lines of conversation:
{new_lines}

New summary:`, kU = /* @__PURE__ */ new He({
  inputVariables: ["summary", "new_lines"],
  template: FU
});
class DU extends N_ {
  constructor(e) {
    const { returnMessages: n, inputKey: a, outputKey: r, chatHistory: i, humanPrefix: s, aiPrefix: u, llm: d, prompt: f, summaryChatMessageClass: o } = e;
    super({ returnMessages: n, inputKey: a, outputKey: r, chatHistory: i }), Object.defineProperty(this, "memoryKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "history"
    }), Object.defineProperty(this, "humanPrefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Human"
    }), Object.defineProperty(this, "aiPrefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AI"
    }), Object.defineProperty(this, "llm", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "prompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: kU
    }), Object.defineProperty(this, "summaryChatMessageClass", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: dh
    }), this.memoryKey = e?.memoryKey ?? this.memoryKey, this.humanPrefix = s ?? this.humanPrefix, this.aiPrefix = u ?? this.aiPrefix, this.llm = d, this.prompt = f ?? this.prompt, this.summaryChatMessageClass = o ?? this.summaryChatMessageClass;
  }
  /**
   * Predicts a new summary for the conversation given the existing messages
   * and summary.
   * @param messages Existing messages in the conversation.
   * @param existingSummary Current summary of the conversation.
   * @returns A promise that resolves to a new summary string.
   */
  async predictNewSummary(e, n) {
    const a = so(e, this.humanPrefix, this.aiPrefix);
    return await new tt({ llm: this.llm, prompt: this.prompt }).predict({
      summary: n,
      new_lines: a
    });
  }
}
class QV extends DU {
  constructor(e) {
    super(e), Object.defineProperty(this, "buffer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    });
  }
  get memoryKeys() {
    return [this.memoryKey];
  }
  /**
   * Loads the memory variables for the conversation memory.
   * @returns A promise that resolves to an object containing the memory variables.
   */
  async loadMemoryVariables(e) {
    return this.returnMessages ? {
      [this.memoryKey]: [new this.summaryChatMessageClass(this.buffer)]
    } : { [this.memoryKey]: this.buffer };
  }
  /**
   * Saves the context of the conversation memory.
   * @param inputValues Input values for the conversation.
   * @param outputValues Output values from the conversation.
   * @returns A promise that resolves when the context has been saved.
   */
  async saveContext(e, n) {
    await super.saveContext(e, n);
    const a = await this.chatHistory.getMessages();
    this.buffer = await this.predictNewSummary(a.slice(-2), this.buffer);
  }
  /**
   * Clears the conversation memory.
   * @returns A promise that resolves when the memory has been cleared.
   */
  async clear() {
    await super.clear(), this.buffer = "";
  }
}
const qU = (t) => t.map((e) => e.pageContent).join(`

`);
class YV extends E$ {
  constructor(e) {
    super(), Object.defineProperty(this, "vectorStoreRetriever", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "memoryKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnDocs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.vectorStoreRetriever = e.vectorStoreRetriever, this.inputKey = e.inputKey, this.memoryKey = e.memoryKey ?? "memory", this.returnDocs = e.returnDocs ?? !1, this.metadata = e.metadata;
  }
  get memoryKeys() {
    return [this.memoryKey];
  }
  /**
   * Method to load memory variables. It uses the vectorStoreRetriever to
   * get relevant documents based on the query obtained from the input
   * values.
   * @param values An InputValues object.
   * @returns A Promise that resolves to a MemoryVariables object.
   */
  async loadMemoryVariables(e) {
    const n = N$(e, this.inputKey), a = await this.vectorStoreRetriever.getRelevantDocuments(n);
    return {
      [this.memoryKey]: this.returnDocs ? a : qU(a)
    };
  }
  /**
   * Method to save context. It constructs a document from the input and
   * output values (excluding the memory key) and adds it to the vector
   * store database using the vectorStoreRetriever.
   * @param inputValues An InputValues object.
   * @param outputValues An OutputValues object.
   * @returns A Promise that resolves to void.
   */
  async saveContext(e, n) {
    const a = typeof this.metadata == "function" ? this.metadata(e, n) : this.metadata, r = Object.entries(e).filter(([i]) => i !== this.memoryKey).concat(Object.entries(n)).map(([i, s]) => `${i}: ${s}`).join(`
`);
    await this.vectorStoreRetriever.addDocuments([
      new ur({ pageContent: r, metadata: a })
    ]);
  }
}
class ez extends N_ {
  constructor(e) {
    super(e), Object.defineProperty(this, "humanPrefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Human"
    }), Object.defineProperty(this, "aiPrefix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AI"
    }), Object.defineProperty(this, "memoryKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "history"
    }), Object.defineProperty(this, "maxTokenLimit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 2e3
    }), Object.defineProperty(this, "llm", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.llm = e.llm, this.humanPrefix = e?.humanPrefix ?? this.humanPrefix, this.aiPrefix = e?.aiPrefix ?? this.aiPrefix, this.memoryKey = e?.memoryKey ?? this.memoryKey, this.maxTokenLimit = e?.maxTokenLimit ?? this.maxTokenLimit;
  }
  get memoryKeys() {
    return [this.memoryKey];
  }
  /**
   * Loads the memory variables. It takes an `InputValues` object as a
   * parameter and returns a `Promise` that resolves with a
   * `MemoryVariables` object.
   * @param _values `InputValues` object.
   * @returns A `Promise` that resolves with a `MemoryVariables` object.
   */
  async loadMemoryVariables(e) {
    const n = await this.chatHistory.getMessages();
    return this.returnMessages ? {
      [this.memoryKey]: n
    } : {
      [this.memoryKey]: so(n, this.humanPrefix, this.aiPrefix)
    };
  }
  /**
   * Saves the context from this conversation to buffer. If the amount
   * of tokens required to save the buffer exceeds MAX_TOKEN_LIMIT,
   * prune it.
   */
  async saveContext(e, n) {
    await super.saveContext(e, n);
    const a = await this.chatHistory.getMessages();
    let r = await this.llm.getNumTokens(so(a, this.humanPrefix, this.aiPrefix));
    if (r > this.maxTokenLimit) {
      const i = [];
      for (; r > this.maxTokenLimit; )
        i.push(a.shift()), r = await this.llm.getNumTokens(so(a, this.humanPrefix, this.aiPrefix));
    }
  }
}
class F_ {
  /**
   * @deprecated Use `this.load()` and `splitter.splitDocuments()` individually.
   * Loads the documents and splits them using a specified text splitter.
   * @param textSplitter The TextSplitter instance to use for splitting the loaded documents. Defaults to a RecursiveCharacterTextSplitter instance.
   * @returns A Promise that resolves with an array of Document instances, each split according to the provided TextSplitter.
   */
  async loadAndSplit(e) {
    if (e === void 0)
      throw new Error("You must pass a text splitter to use this method.");
    const n = await this.load();
    return e.invoke(n);
  }
}
class eh extends F_ {
  constructor(e, n) {
    super(), Object.defineProperty(this, "webPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "selector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textDecoder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { timeout: a, selector: r, textDecoder: i, headers: s, ...u } = n ?? {};
    this.timeout = a ?? 1e4, this.caller = new Qo(u), this.selector = r ?? "body", this.textDecoder = i, this.headers = s;
  }
  /**
   * Fetches web documents from the given array of URLs and loads them using Cheerio.
   * It returns an array of CheerioAPI instances.
   * @param urls An array of URLs to fetch and load.
   * @returns A Promise that resolves to an array of CheerioAPI instances.
   */
  static async scrapeAll(e, n, a, r, i) {
    return Promise.all(e.map((s) => eh._scrape(s, n, a, r, i)));
  }
  static async _scrape(e, n, a, r, i) {
    const { headers: s, ...u } = i ?? {}, { load: d } = await eh.imports(), f = await n.call(fetch, e, {
      signal: a ? AbortSignal.timeout(a) : void 0,
      headers: s
    }), o = r?.decode(await f.arrayBuffer()) ?? await f.text();
    return d(o, u);
  }
  /**
   * Fetches the web document from the webPath and loads it using Cheerio.
   * It returns a CheerioAPI instance.
   * @returns A Promise that resolves to a CheerioAPI instance.
   */
  async scrape() {
    const e = { headers: this.headers };
    return eh._scrape(this.webPath, this.caller, this.timeout, this.textDecoder, e);
  }
  /**
   * Extracts the text content from the loaded document using the selector
   * and creates a Document instance with the extracted text and metadata.
   * It returns an array of Document instances.
   * @returns A Promise that resolves to an array of Document instances.
   */
  async load() {
    const e = await this.scrape(), n = e("title").text(), a = e(this.selector).text(), r = { source: this.webPath, title: n };
    return [new ur({ pageContent: a, metadata: r })];
  }
  /**
   * A static method that dynamically imports the Cheerio library and
   * returns the load function. If the import fails, it throws an error.
   * @returns A Promise that resolves to an object containing the load function from the Cheerio library.
   */
  static async imports() {
    try {
      const { load: e } = await Promise.resolve().then(() => b4);
      return { load: e };
    } catch (e) {
      throw console.error(e), new Error("Please install cheerio as a dependency with, e.g. `yarn add cheerio`");
    }
  }
}
class tz extends F_ {
  constructor(e, n) {
    super(), Object.defineProperty(this, "webPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textDecoder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { timeout: a, textDecoder: r, headers: i, ...s } = n ?? {};
    this.timeout = a ?? 1e4, this.caller = new Qo(s), this.textDecoder = r, this.headers = i;
  }
  async load() {
    const e = await this.caller.call(fetch, this.webPath, {
      signal: this.timeout ? AbortSignal.timeout(this.timeout) : void 0,
      headers: this.headers
    }), n = this.textDecoder?.decode(await e.arrayBuffer()) ?? await e.text();
    return [new ur({ pageContent: n })];
  }
}
class nz extends F_ {
  constructor(e, { splitPages: n = !0, pdfjs: a = JU, parsedItemSeparator: r = "" } = {}) {
    super(), Object.defineProperty(this, "blob", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "splitPages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "pdfjs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "parsedItemSeparator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.blob = e, this.splitPages = n ?? this.splitPages, this.pdfjs = a, this.parsedItemSeparator = r;
  }
  /**
   * Loads the contents of the PDF as documents.
   * @returns An array of Documents representing the retrieved data.
   */
  async load() {
    const { getDocument: e, version: n } = await this.pdfjs(), a = await e({
      data: new Uint8Array(await this.blob.arrayBuffer()),
      useWorkerFetch: !1,
      isEvalSupported: !1,
      useSystemFonts: !0
    }).promise, r = await a.getMetadata().catch(() => null), i = [];
    for (let s = 1; s <= a.numPages; s += 1) {
      const d = await (await a.getPage(s)).getTextContent();
      if (d.items.length === 0)
        continue;
      let f;
      const o = [];
      for (const h of d.items)
        "str" in h && (f === h.transform[5] || !f ? o.push(h.str) : o.push(`
${h.str}`), f = h.transform[5]);
      const c = o.join(this.parsedItemSeparator);
      i.push(new ur({
        pageContent: c,
        metadata: {
          pdf: {
            version: n,
            info: r?.info,
            metadata: r?.metadata,
            totalPages: a.numPages
          },
          loc: {
            pageNumber: s
          }
        }
      }));
    }
    return this.splitPages ? i : i.length === 0 ? [] : [
      new ur({
        pageContent: i.map((s) => s.pageContent).join(`

`),
        metadata: {
          pdf: {
            version: n,
            info: r?.info,
            metadata: r?.metadata,
            totalPages: a.numPages
          }
        }
      })
    ];
  }
}
async function JU() {
  try {
    const { default: t } = await Promise.resolve().then(() => _4), { getDocument: e, version: n } = t;
    return { getDocument: e, version: n };
  } catch (t) {
    throw console.error(t), new Error("Failed to load pdf-parse. Please install it with eg. `npm install pdf-parse`.");
  }
}
class LU extends Te {
  /**
   * Constructs a new `BaseRetriever` instance with optional configuration fields.
   *
   * @param fields - Optional input configuration that can include `callbacks`,
   *                 `tags`, `metadata`, and `verbose` settings for custom retriever behavior.
   */
  constructor(e) {
    super(e), Object.defineProperty(this, "callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "verbose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.callbacks = e?.callbacks, this.tags = e?.tags ?? [], this.metadata = e?.metadata ?? {}, this.verbose = e?.verbose ?? !1;
  }
  /**
   * TODO: This should be an abstract method, but we'd like to avoid breaking
   * changes to people currently using subclassed custom retrievers.
   * Change it on next major release.
   */
  /**
   * Placeholder method for retrieving relevant documents based on a query.
   *
   * This method is intended to be implemented by subclasses and will be
   * converted to an abstract method in the next major release. Currently, it
   * throws an error if not implemented, ensuring that custom retrievers define
   * the specific retrieval logic.
   *
   * @param _query - The query string used to search for relevant documents.
   * @param _callbacks - (optional) Callback manager for managing callbacks
   *                     during retrieval.
   * @returns A promise resolving to an array of `DocumentInterface` instances relevant to the query.
   * @throws {Error} Throws an error indicating the method is not implemented.
   */
  _getRelevantDocuments(e, n) {
    throw new Error("Not implemented!");
  }
  /**
   * Executes a retrieval operation.
   *
   * @param input - The query string used to search for relevant documents.
   * @param options - (optional) Configuration options for the retrieval run,
   *                  which may include callbacks, tags, and metadata.
   * @returns A promise that resolves to an array of `DocumentInterface` instances
   *          representing the most relevant documents to the query.
   */
  async invoke(e, n) {
    return this.getRelevantDocuments(e, Ce(n));
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
   *
   * Main method used to retrieve relevant documents. It takes a query
   * string and an optional configuration object, and returns a promise that
   * resolves to an array of `Document` objects. This method handles the
   * retrieval process, including starting and ending callbacks, and error
   * handling.
   * @param query The query string to retrieve relevant documents for.
   * @param config Optional configuration object for the retrieval process.
   * @returns A promise that resolves to an array of `Document` objects.
   */
  async getRelevantDocuments(e, n) {
    const a = Ce(cp(n)), i = await (await it.configure(a.callbacks, this.callbacks, a.tags, this.tags, a.metadata, this.metadata, { verbose: this.verbose }))?.handleRetrieverStart(this.toJSON(), e, a.runId, void 0, void 0, void 0, a.runName);
    try {
      const s = await this._getRelevantDocuments(e, i);
      return await i?.handleRetrieverEnd(s), s;
    } catch (s) {
      throw await i?.handleRetrieverError(s), s;
    }
  }
}
class Xm extends LU {
  static lc_name() {
    return "VectorStoreRetriever";
  }
  get lc_namespace() {
    return ["langchain_core", "vectorstores"];
  }
  /**
   * Returns the type of vector store, as defined by the `vectorStore` instance.
   *
   * @returns {string} The vector store type.
   */
  _vectorstoreType() {
    return this.vectorStore._vectorstoreType();
  }
  /**
   * Initializes a new instance of `VectorStoreRetriever` with the specified configuration.
   *
   * This constructor configures the retriever to interact with a given `VectorStore`
   * and supports different retrieval strategies, including similarity search and maximal
   * marginal relevance (MMR) search. Various options allow customization of the number
   * of documents retrieved per query, filtering based on conditions, and fine-tuning
   * MMR-specific parameters.
   *
   * @param fields - Configuration options for setting up the retriever:
   *
   *   - `vectorStore` (required): The `VectorStore` instance implementing `VectorStoreInterface`
   *     that will be used to store and retrieve document embeddings. This is the core component
   *     of the retriever, enabling vector-based similarity and MMR searches.
   *
   *   - `k` (optional): Specifies the number of documents to retrieve per search query. If not
   *     provided, defaults to 4. This count determines the number of most relevant documents returned
   *     for each search operation, balancing performance with comprehensiveness.
   *
   *   - `searchType` (optional): Defines the search approach used by the retriever, allowing for
   *     flexibility between two methods:
   *       - `"similarity"` (default): A similarity-based search, retrieving documents with high vector
   *         similarity to the query. This type prioritizes relevance and is often used when diversity
   *         among results is less critical.
   *       - `"mmr"`: Maximal Marginal Relevance search, which combines relevance with diversity. MMR
   *         is useful for scenarios where varied content is essential, as it selects results that
   *         both match the query and introduce content diversity.
   *
   *   - `filter` (optional): A filter of type `FilterType`, defined by the vector store, that allows
   *     for refined and targeted search results. This filter applies specified conditions to limit
   *     which documents are eligible for retrieval, offering control over the scope of results.
   *
   *   - `searchKwargs` (optional, applicable only if `searchType` is `"mmr"`): Additional settings
   *     for configuring MMR-specific behavior. These parameters allow further tuning of the MMR
   *     search process:
   *       - `fetchK`: The initial number of documents fetched from the vector store before the MMR
   *         algorithm is applied. Fetching a larger set enables the algorithm to select a more
   *         diverse subset of documents.
   *       - `lambda`: A parameter controlling the relevance-diversity balance, where 0 emphasizes
   *         diversity and 1 prioritizes relevance. Intermediate values provide a blend of the two,
   *         allowing customization based on the importance of content variety relative to query relevance.
   */
  constructor(e) {
    super(e), Object.defineProperty(this, "vectorStore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "k", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4
    }), Object.defineProperty(this, "searchType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "similarity"
    }), Object.defineProperty(this, "searchKwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "filter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.vectorStore = e.vectorStore, this.k = e.k ?? this.k, this.searchType = e.searchType ?? this.searchType, this.filter = e.filter, e.searchType === "mmr" && (this.searchKwargs = e.searchKwargs);
  }
  /**
   * Retrieves relevant documents based on the specified query, using either
   * similarity or maximal marginal relevance (MMR) search.
   *
   * If `searchType` is set to `"mmr"`, performs an MMR search to balance
   * similarity and diversity among results. If `searchType` is `"similarity"`,
   * retrieves results purely based on similarity to the query.
   *
   * @param query - The query string used to find relevant documents.
   * @param runManager - Optional callback manager for tracking retrieval progress.
   * @returns A promise that resolves to an array of `DocumentInterface` instances
   *          representing the most relevant documents to the query.
   * @throws {Error} Throws an error if MMR search is requested but not supported
   *                 by the vector store.
   * @protected
   */
  async _getRelevantDocuments(e, n) {
    if (this.searchType === "mmr") {
      if (typeof this.vectorStore.maxMarginalRelevanceSearch != "function")
        throw new Error(`The vector store backing this retriever, ${this._vectorstoreType()} does not support max marginal relevance search.`);
      return this.vectorStore.maxMarginalRelevanceSearch(e, {
        k: this.k,
        filter: this.filter,
        ...this.searchKwargs
      }, n?.getChild("vectorstore"));
    }
    return this.vectorStore.similaritySearch(e, this.k, this.filter, n?.getChild("vectorstore"));
  }
  /**
   * Adds an array of documents to the vector store, embedding them as part of
   * the storage process.
   *
   * This method delegates document embedding and storage to the `addDocuments`
   * method of the underlying vector store.
   *
   * @param documents - An array of documents to embed and add to the vector store.
   * @param options - Optional settings to customize document addition.
   * @returns A promise that resolves to an array of document IDs or `void`,
   *          depending on the vector store's implementation.
   */
  async addDocuments(e, n) {
    return this.vectorStore.addDocuments(e, n);
  }
}
class UU extends pr {
  /**
   * Initializes a new vector store with embeddings and database configuration.
   *
   * @param embeddings - Instance of `EmbeddingsInterface` used to embed queries.
   * @param dbConfig - Configuration settings for the database or storage system.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e, n) {
    super(n), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "vectorstores", this._vectorstoreType()]
    }), Object.defineProperty(this, "embeddings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.embeddings = e;
  }
  /**
   * Deletes documents from the vector store based on the specified parameters.
   *
   * @param _params - Flexible key-value pairs defining conditions for document deletion.
   * @returns A promise that resolves once the deletion is complete.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async delete(e) {
    throw new Error("Not implemented.");
  }
  /**
   * Searches for documents similar to a text query by embedding the query and
   * performing a similarity search on the resulting vector.
   *
   * @param query - Text query for finding similar documents.
   * @param k - Number of similar results to return. Defaults to 4.
   * @param filter - Optional filter based on `FilterType`.
   * @param _callbacks - Optional callbacks for monitoring search progress
   * @returns A promise resolving to an array of `DocumentInterface` instances representing similar documents.
   */
  async similaritySearch(e, n = 4, a = void 0, r = void 0) {
    return (await this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(e), n, a)).map((s) => s[0]);
  }
  /**
   * Searches for documents similar to a text query by embedding the query,
   * and returns results with similarity scores.
   *
   * @param query - Text query for finding similar documents.
   * @param k - Number of similar results to return. Defaults to 4.
   * @param filter - Optional filter based on `FilterType`.
   * @param _callbacks - Optional callbacks for monitoring search progress
   * @returns A promise resolving to an array of tuples, each containing a
   *          document and its similarity score.
   */
  async similaritySearchWithScore(e, n = 4, a = void 0, r = void 0) {
    return this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(e), n, a);
  }
  /**
   * Creates a `VectorStore` instance from an array of text strings and optional
   * metadata, using the specified embeddings and database configuration.
   *
   * Subclasses must implement this method to define how text and metadata
   * are embedded and stored in the vector store. Throws an error if not overridden.
   *
   * @param _texts - Array of strings representing the text documents to be stored.
   * @param _metadatas - Metadata for the texts, either as an array (one for each text)
   *                     or a single object (applied to all texts).
   * @param _embeddings - Instance of `EmbeddingsInterface` to embed the texts.
   * @param _dbConfig - Database configuration settings.
   * @returns A promise that resolves to a new `VectorStore` instance.
   * @throws {Error} Throws an error if this method is not overridden by a subclass.
   */
  static fromTexts(e, n, a, r) {
    throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
  }
  /**
   * Creates a `VectorStore` instance from an array of documents, using the specified
   * embeddings and database configuration.
   *
   * Subclasses must implement this method to define how documents are embedded
   * and stored. Throws an error if not overridden.
   *
   * @param _docs - Array of `DocumentInterface` instances representing the documents to be stored.
   * @param _embeddings - Instance of `EmbeddingsInterface` to embed the documents.
   * @param _dbConfig - Database configuration settings.
   * @returns A promise that resolves to a new `VectorStore` instance.
   * @throws {Error} Throws an error if this method is not overridden by a subclass.
   */
  static fromDocuments(e, n, a) {
    throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
  }
  /**
   * Creates a `VectorStoreRetriever` instance with flexible configuration options.
   *
   * @param kOrFields
   *    - If a number is provided, it sets the `k` parameter (number of items to retrieve).
   *    - If an object is provided, it should contain various configuration options.
   * @param filter
   *    - Optional filter criteria to limit the items retrieved based on the specified filter type.
   * @param callbacks
   *    - Optional callbacks that may be triggered at specific stages of the retrieval process.
   * @param tags
   *    - Tags to categorize or label the `VectorStoreRetriever`. Defaults to an empty array if not provided.
   * @param metadata
   *    - Additional metadata as key-value pairs to add contextual information for the retrieval process.
   * @param verbose
   *    - If `true`, enables detailed logging for the retrieval process. Defaults to `false`.
   *
   * @returns
   *    - A configured `VectorStoreRetriever` instance based on the provided parameters.
   *
   * @example
   * Basic usage with a `k` value:
   * ```typescript
   * const retriever = myVectorStore.asRetriever(5);
   * ```
   *
   * Usage with a configuration object:
   * ```typescript
   * const retriever = myVectorStore.asRetriever({
   *   k: 10,
   *   filter: myFilter,
   *   tags: ['example', 'test'],
   *   verbose: true,
   *   searchType: 'mmr',
   *   searchKwargs: { alpha: 0.5 },
   * });
   * ```
   */
  asRetriever(e, n, a, r, i, s) {
    if (typeof e == "number")
      return new Xm({
        vectorStore: this,
        k: e,
        filter: n,
        tags: [...r ?? [], this._vectorstoreType()],
        metadata: i,
        verbose: s,
        callbacks: a
      });
    {
      const u = {
        vectorStore: this,
        k: e?.k,
        filter: e?.filter,
        tags: [...e?.tags ?? [], this._vectorstoreType()],
        metadata: e?.metadata,
        verbose: e?.verbose,
        callbacks: e?.callbacks,
        searchType: e?.searchType
      };
      return e?.searchType === "mmr" ? new Xm({
        ...u,
        searchKwargs: e.searchKwargs
      }) : new Xm({ ...u });
    }
  }
}
function BU(t, e) {
  let n = 0, a = 0, r = 0;
  for (let i = 0; i < t.length; i++)
    n += t[i] * e[i], a += t[i] * t[i], r += e[i] * e[i];
  return n / (Math.sqrt(a) * Math.sqrt(r));
}
function xU(t, e) {
  let n = 0, a = 0, r = 0;
  for (let i = 0; i < t.length; i++)
    n += t[i] * e[i], a += t[i] * t[i], r += e[i] * e[i];
  return n / (Math.sqrt(a) * Math.sqrt(r));
}
function VU(t, e, n) {
  if (t.length === 0 || t[0].length === 0 || e.length === 0 || e[0].length === 0)
    return [[]];
  if (t[0].length !== e[0].length)
    throw new Error(`Number of columns in X and Y must be the same. X has shape ${[
      t.length,
      t[0].length
    ]} and Y has shape ${[e.length, e[0].length]}.`);
  return t.map((a) => e.map((r) => n(a, r)).map((r) => Number.isNaN(r) ? 0 : r));
}
function Dj(t, e) {
  return VU(t, e, xU);
}
function zU(t, e, n = 0.5, a = 4) {
  if (Math.min(a, e.length) <= 0)
    return [];
  const r = Array.isArray(t[0]) ? t : [t], i = Dj(r, e)[0], s = ZU(i).maxIndex, u = [e[s]], d = [s];
  for (; d.length < Math.min(a, e.length); ) {
    let f = -1 / 0, o = -1;
    const c = Dj(e, u);
    i.forEach((h, p) => {
      if (d.includes(p))
        return;
      const l = Math.max(...c[p]), m = n * h - (1 - n) * l;
      m > f && (f = m, o = p);
    }), u.push(e[o]), d.push(o);
  }
  return d;
}
function ZU(t) {
  if (t.length === 0)
    return {
      maxIndex: -1,
      maxValue: NaN
    };
  let e = t[0], n = 0;
  for (let a = 1; a < t.length; a += 1)
    t[a] > e && (n = a, e = t[a]);
  return { maxIndex: n, maxValue: e };
}
class k_ extends UU {
  _vectorstoreType() {
    return "memory";
  }
  constructor(e, { similarity: n, ...a } = {}) {
    super(e, a), Object.defineProperty(this, "memoryVectors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "similarity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.similarity = n ?? BU;
  }
  /**
   * Method to add documents to the memory vector store. It extracts the
   * text from each document, generates embeddings for them, and adds the
   * resulting vectors to the store.
   * @param documents Array of `Document` instances to be added to the store.
   * @returns Promise that resolves when all documents have been added.
   */
  async addDocuments(e) {
    const n = e.map(({ pageContent: a }) => a);
    return this.addVectors(await this.embeddings.embedDocuments(n), e);
  }
  /**
   * Method to add vectors to the memory vector store. It creates
   * `MemoryVector` instances for each vector and document pair and adds
   * them to the store.
   * @param vectors Array of vectors to be added to the store.
   * @param documents Array of `Document` instances corresponding to the vectors.
   * @returns Promise that resolves when all vectors have been added.
   */
  async addVectors(e, n) {
    const a = e.map((r, i) => ({
      content: n[i].pageContent,
      embedding: r,
      metadata: n[i].metadata,
      id: n[i].id
    }));
    this.memoryVectors = this.memoryVectors.concat(a);
  }
  async _queryVectors(e, n, a) {
    const r = (s) => {
      if (!a)
        return !0;
      const u = new ur({
        metadata: s.metadata,
        pageContent: s.content,
        id: s.id
      });
      return a(u);
    };
    return this.memoryVectors.filter(r).map((s, u) => ({
      similarity: this.similarity(e, s.embedding),
      index: u,
      metadata: s.metadata,
      content: s.content,
      embedding: s.embedding,
      id: s.id
    })).sort((s, u) => s.similarity > u.similarity ? -1 : 0).slice(0, n);
  }
  /**
   * Method to perform a similarity search in the memory vector store. It
   * calculates the similarity between the query vector and each vector in
   * the store, sorts the results by similarity, and returns the top `k`
   * results along with their scores.
   * @param query Query vector to compare against the vectors in the store.
   * @param k Number of top results to return.
   * @param filter Optional filter function to apply to the vectors before performing the search.
   * @returns Promise that resolves with an array of tuples, each containing a `Document` and its similarity score.
   */
  async similaritySearchVectorWithScore(e, n, a) {
    return (await this._queryVectors(e, n, a)).map((s) => [
      new ur({
        metadata: s.metadata,
        pageContent: s.content,
        id: s.id
      }),
      s.similarity
    ]);
  }
  async maxMarginalRelevanceSearch(e, n) {
    const a = await this.embeddings.embedQuery(e), r = await this._queryVectors(a, n.fetchK ?? 20, n.filter), i = r.map((u) => u.embedding);
    return zU(a, i, n.lambda, n.k).map((u) => new ur({
      metadata: r[u].metadata,
      pageContent: r[u].content,
      id: r[u].id
    }));
  }
  /**
   * Static method to create a `MemoryVectorStore` instance from an array of
   * texts. It creates a `Document` for each text and metadata pair, and
   * adds them to the store.
   * @param texts Array of texts to be added to the store.
   * @param metadatas Array or single object of metadata corresponding to the texts.
   * @param embeddings `Embeddings` instance used to generate embeddings for the texts.
   * @param dbConfig Optional `MemoryVectorStoreArgs` to configure the `MemoryVectorStore` instance.
   * @returns Promise that resolves with a new `MemoryVectorStore` instance.
   */
  static async fromTexts(e, n, a, r) {
    const i = [];
    for (let s = 0; s < e.length; s += 1) {
      const u = Array.isArray(n) ? n[s] : n, d = new ur({
        pageContent: e[s],
        metadata: u
      });
      i.push(d);
    }
    return k_.fromDocuments(i, a, r);
  }
  /**
   * Static method to create a `MemoryVectorStore` instance from an array of
   * `Document` instances. It adds the documents to the store.
   * @param docs Array of `Document` instances to be added to the store.
   * @param embeddings `Embeddings` instance used to generate embeddings for the documents.
   * @param dbConfig Optional `MemoryVectorStoreArgs` to configure the `MemoryVectorStore` instance.
   * @returns Promise that resolves with a new `MemoryVectorStore` instance.
   */
  static async fromDocuments(e, n, a) {
    const r = new this(n, a);
    return await r.addDocuments(e), r;
  }
  /**
   * Static method to create a `MemoryVectorStore` instance from an existing
   * index. It creates a new `MemoryVectorStore` instance without adding any
   * documents or vectors.
   * @param embeddings `Embeddings` instance used to generate embeddings for the documents.
   * @param dbConfig Optional `MemoryVectorStoreArgs` to configure the `MemoryVectorStore` instance.
   * @returns Promise that resolves with a new `MemoryVectorStore` instance.
   */
  static async fromExistingIndex(e, n) {
    return new this(e, n);
  }
}
class F$ extends k_ {
  static async fromJSON(e, n) {
    const a = JSON.parse(e);
    if (a.lc == null || a.type !== "constructor" || !Array.isArray(a.id))
      throw new Error("invalid serialization format");
    const r = new F$(n);
    if (a.kwargs?.docs == null)
      throw new Error("no documents in serialization");
    {
      const i = [], s = [];
      for (const u of a.kwargs.docs)
        u.pageContent && u.vector && (i.push(new ur({
          pageContent: u.pageContent,
          metadata: u.metadata || {}
        })), s.push(u.vector));
      r.addVectors(s, i);
    }
    return r;
  }
}
class KU extends Error {
  constructor(e, n) {
    super(e), Object.defineProperty(this, "output", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.output = n;
  }
}
class k$ extends pr {
  get returnValues() {
    return ["output"];
  }
  get allowedTools() {
  }
  /**
   * Return the string type key uniquely identifying this class of agent.
   */
  _agentType() {
    throw new Error("Not implemented");
  }
  /**
   * Return response when agent has been stopped due to max iterations
   */
  returnStoppedResponse(e, n, a, r) {
    if (e === "force")
      return Promise.resolve({
        returnValues: { output: "Agent stopped due to max iterations." },
        log: ""
      });
    throw new Error(`Invalid stopping method: ${e}`);
  }
  /**
   * Prepare the agent for output, if needed
   */
  async prepareForOutput(e, n) {
    return {};
  }
}
class D$ extends k$ {
  _agentActionType() {
    return "single";
  }
}
class HU extends k$ {
  _agentActionType() {
    return "multi";
  }
}
function GU(t) {
  return !Array.isArray(t) && t?.tool !== void 0;
}
function WU(t) {
  return t.runnable !== void 0;
}
class Ep extends gt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "streamRunnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "singleAction", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static fromRunnables([e, ...n], a) {
    const r = gt.from([e, ...n], a.name);
    return r.singleAction = a.singleAction, r.streamRunnable = a.streamRunnable, r;
  }
  static isAgentRunnableSequence(e) {
    return typeof e.singleAction == "boolean";
  }
}
class XU extends D$ {
  get inputKeys() {
    return [];
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "runnable"]
    }), Object.defineProperty(this, "runnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streamRunnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "defaultRunName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RunnableAgent"
    }), this.runnable = e.runnable, this.defaultRunName = e.defaultRunName ?? this.runnable.name ?? this.defaultRunName, this.streamRunnable = e.streamRunnable ?? this.streamRunnable;
  }
  async plan(e, n, a, r) {
    const i = { ...n, steps: e }, s = Qe(r, {
      callbacks: a,
      runName: this.defaultRunName
    });
    if (this.streamRunnable) {
      const u = await this.runnable.stream(i, s);
      let d;
      for await (const f of u)
        if (d === void 0)
          d = f;
        else
          throw new Error([
            "Multiple agent actions/finishes received in streamed agent output.",
            'Set "streamRunnable: false" when initializing the agent to invoke this agent in non-streaming mode.'
          ].join(`
`));
      if (d === void 0)
        throw new Error([
          "No streaming output received from underlying runnable.",
          'Set "streamRunnable: false" when initializing the agent to invoke this agent in non-streaming mode.'
        ].join(`
`));
      return d;
    } else
      return this.runnable.invoke(i, s);
  }
}
class qj extends HU {
  get inputKeys() {
    return [];
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "runnable"]
    }), Object.defineProperty(this, "runnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "defaultRunName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RunnableAgent"
    }), Object.defineProperty(this, "stop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streamRunnable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.runnable = e.runnable, this.stop = e.stop, this.defaultRunName = e.defaultRunName ?? this.runnable.name ?? this.defaultRunName, this.streamRunnable = e.streamRunnable ?? this.streamRunnable;
  }
  async plan(e, n, a, r) {
    const i = { ...n, steps: e }, s = Qe(r, {
      callbacks: a,
      runName: this.defaultRunName
    });
    let u;
    if (this.streamRunnable) {
      const d = await this.runnable.stream(i, s);
      let f;
      for await (const o of d)
        if (f === void 0)
          f = o;
        else
          throw new Error([
            "Multiple agent actions/finishes received in streamed agent output.",
            'Set "streamRunnable: false" when initializing the agent to invoke this agent in non-streaming mode.'
          ].join(`
`));
      if (f === void 0)
        throw new Error([
          "No streaming output received from underlying runnable.",
          'Set "streamRunnable: false" when initializing the agent to invoke this agent in non-streaming mode.'
        ].join(`
`));
      u = f;
    } else
      u = await this.runnable.invoke(i, s);
    return GU(u) ? [u] : u;
  }
}
class q$ extends D$ {
  get allowedTools() {
    return this._allowedTools;
  }
  get inputKeys() {
    return this.llmChain.inputKeys.filter((e) => e !== "agent_scratchpad");
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "llmChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputParser", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_allowedTools", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.llmChain = e.llmChain, this._allowedTools = e.allowedTools, this.outputParser = e.outputParser;
  }
  /**
   * Get the default output parser for this agent.
   */
  static getDefaultOutputParser(e) {
    throw new Error("Not implemented");
  }
  /**
   * Create a prompt for this class
   *
   * @param _tools - List of tools the agent will have access to, used to format the prompt.
   * @param _fields - Additional fields used to format the prompt.
   *
   * @returns A PromptTemplate assembled from the given tools and fields.
   * */
  static createPrompt(e, n) {
    throw new Error("Not implemented");
  }
  /** Construct an agent from an LLM and a list of tools */
  static fromLLMAndTools(e, n, a) {
    throw new Error("Not implemented");
  }
  /**
   * Validate that appropriate tools are passed in
   */
  static validateTools(e) {
  }
  _stop() {
    return [`
${this.observationPrefix()}`];
  }
  /**
   * Name of tool to use to terminate the chain.
   */
  finishToolName() {
    return "Final Answer";
  }
  /**
   * Construct a scratchpad to let the agent continue its thought process
   */
  async constructScratchPad(e) {
    return e.reduce((n, { action: a, observation: r }) => n + [
      a.log,
      `${this.observationPrefix()}${r}`,
      this.llmPrefix()
    ].join(`
`), "");
  }
  async _plan(e, n, a, r) {
    const i = await this.constructScratchPad(e), s = {
      ...n,
      agent_scratchpad: a ? `${i}${a}` : i
    };
    this._stop().length !== 0 && (s.stop = this._stop());
    const u = await this.llmChain.predict(s, r);
    if (!this.outputParser)
      throw new Error("Output parser not set");
    return this.outputParser.parse(u, r);
  }
  /**
   * Decide what to do given some input.
   *
   * @param steps - Steps the LLM has taken so far, along with observations from each.
   * @param inputs - User inputs.
   * @param callbackManager - Callback manager to use for this call.
   *
   * @returns Action specifying what tool to use.
   */
  plan(e, n, a) {
    return this._plan(e, n, void 0, a);
  }
  /**
   * Return response when agent has been stopped due to max iterations
   */
  async returnStoppedResponse(e, n, a, r) {
    if (e === "force")
      return {
        returnValues: { output: "Agent stopped due to max iterations." },
        log: ""
      };
    if (e === "generate")
      try {
        const i = await this._plan(n, a, `

I now need to return a final answer based on the previous steps:`, r);
        return "returnValues" in i ? i : { returnValues: { output: i.log }, log: i.log };
      } catch (i) {
        if (!(i instanceof KU))
          throw i;
        return { returnValues: { output: i.output }, log: i.output };
      }
    throw new Error(`Invalid stopping method: ${e}`);
  }
  /**
   * Load an agent from a json-like object describing it.
   */
  static async deserialize(e) {
    switch (e._type) {
      case "zero-shot-react-description": {
        const { ZeroShotAgent: n } = await Promise.resolve().then(() => rB);
        return n.deserialize(e);
      }
      default:
        throw new Error("Unknown agent type");
    }
  }
}
const QU = async (t, e, n, a, r) => {
  if (n.load_from_llm_and_tools) {
    if (!t)
      throw new Error("Loading from llm and tools, llm must be provided.");
    if (!e)
      throw new Error("Loading from llm and tools, tools must be provided.");
    return a(t, e, n);
  }
  if (!n.llm_chain)
    throw new Error("Loading from constructor, llm_chain must be provided.");
  const i = await tt.deserialize(n.llm_chain);
  return r({ ...n, llmChain: i });
};
class oc extends Fd {
}
const YU = "Answer the following questions as best you can. You have access to the following tools:", J$ = `Use the following format in your response:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question`, eB = `Begin!

Question: {input}
Thought:{agent_scratchpad}`, tB = "Final Answer:";
class nB extends oc {
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "mrkl"]
    }), Object.defineProperty(this, "finishToolName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.finishToolName = e?.finishToolName || tB;
  }
  /**
   * Parses the text output of an agent action, extracting the tool, tool
   * input, and output.
   * @param text The text output of an agent action.
   * @returns An object containing the tool, tool input, and output extracted from the text, along with the original text as a log.
   */
  async parse(e) {
    if (e.includes(this.finishToolName)) {
      const a = e.split(this.finishToolName);
      return {
        returnValues: { output: a[a.length - 1].trim() },
        log: e
      };
    }
    const n = /Action:([\s\S]*?)(?:\nAction Input:([\s\S]*?))?$/.exec(e);
    if (!n)
      throw new Bt(`Could not parse LLM output: ${e}`);
    return {
      tool: n[1].trim(),
      toolInput: n[2] ? n[2].trim().replace(/^("+)(.*?)(\1)$/, "$2") : "",
      log: e
    };
  }
  /**
   * Returns the format instructions for parsing the output of an agent
   * action in the style of the ZeroShotAgent.
   * @returns The format instructions for parsing the output.
   */
  getFormatInstructions() {
    return J$;
  }
}
class Is extends q$ {
  static lc_name() {
    return "ZeroShotAgent";
  }
  constructor(e) {
    const n = e?.outputParser ?? Is.getDefaultOutputParser();
    super({ ...e, outputParser: n }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "mrkl"]
    });
  }
  _agentType() {
    return "zero-shot-react-description";
  }
  observationPrefix() {
    return "Observation: ";
  }
  llmPrefix() {
    return "Thought:";
  }
  /**
   * Returns the default output parser for the ZeroShotAgent.
   * @param fields Optional arguments for the output parser.
   * @returns An instance of ZeroShotAgentOutputParser.
   */
  static getDefaultOutputParser(e) {
    return new nB(e);
  }
  /**
   * Validates the tools for the ZeroShotAgent. Throws an error if any tool
   * does not have a description.
   * @param tools List of tools to validate.
   */
  static validateTools(e) {
    const n = e.find((a) => !a.description);
    if (n) {
      const a = `Got a tool ${n.name} without a description. This agent requires descriptions for all tools.`;
      throw new Error(a);
    }
  }
  /**
   * Create prompt in the style of the zero shot agent.
   *
   * @param tools - List of tools the agent will have access to, used to format the prompt.
   * @param args - Arguments to create the prompt with.
   * @param args.suffix - String to put after the list of tools.
   * @param args.prefix - String to put before the list of tools.
   * @param args.inputVariables - List of input variables the final prompt will expect.
   */
  static createPrompt(e, n) {
    const { prefix: a = YU, suffix: r = eB, inputVariables: i = ["input", "agent_scratchpad"] } = n ?? {}, s = e.map((o) => `${o.name}: ${o.description}`).join(`
`), u = e.map((o) => `"${o.name}"`).join(", "), d = cr(J$, "f-string", {
      tool_names: u
    }), f = [a, s, d, r].join(`

`);
    return new He({
      template: f,
      inputVariables: i
    });
  }
  /**
   * Creates a ZeroShotAgent from a Large Language Model and a set of tools.
   * @param llm The Large Language Model to use.
   * @param tools The tools for the agent to use.
   * @param args Optional arguments for creating the agent.
   * @returns A new instance of ZeroShotAgent.
   */
  static fromLLMAndTools(e, n, a) {
    Is.validateTools(n);
    const r = Is.createPrompt(n, a), i = a?.outputParser ?? Is.getDefaultOutputParser(), s = new tt({
      prompt: r,
      llm: e,
      callbacks: a?.callbacks ?? a?.callbackManager
    });
    return new Is({
      llmChain: s,
      allowedTools: n.map((u) => u.name),
      outputParser: i
    });
  }
  static async deserialize(e) {
    const { llm: n, tools: a, ...r } = e;
    return QU(n, a, r, (i, s, u) => Is.fromLLMAndTools(i, s, {
      prefix: u.prefix,
      suffix: u.suffix,
      inputVariables: u.input_variables
    }), (i) => new Is(i));
  }
}
const rB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ZeroShotAgent: Is
}, Symbol.toStringTag, { value: "Module" }));
class aB extends pr {
  get finalOutputs() {
    return this._finalOutputs;
  }
  /** Intended to be used as a setter method, needs to be async. */
  async setFinalOutputs(e) {
    if (this._finalOutputs = void 0, e) {
      const n = await this.agentExecutor.prepOutputs(this.inputs, e, !0);
      this._finalOutputs = n;
    }
  }
  get nameToToolMap() {
    const e = this.agentExecutor.tools.map((n) => ({
      [n.name]: n
    }));
    return Object.assign({}, ...e);
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "executor_iterator"]
    }), Object.defineProperty(this, "agentExecutor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "runName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_finalOutputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "runManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "intermediateSteps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "iterations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.agentExecutor = e.agentExecutor, this.inputs = e.inputs, this.callbacks = e.callbacks, this.tags = e.tags, this.metadata = e.metadata, this.runName = e.runName, this.runManager = e.runManager, this.config = e.config;
  }
  /**
   * Reset the iterator to its initial state, clearing intermediate steps,
   * iterations, and the final output.
   */
  reset() {
    this.intermediateSteps = [], this.iterations = 0, this._finalOutputs = void 0;
  }
  updateIterations() {
    this.iterations += 1;
  }
  async *streamIterator() {
    for (this.reset(); ; )
      try {
        this.iterations === 0 && await this.onFirstStep(), yield await this._callNext();
      } catch (e) {
        if ("message" in e && e.message.startsWith("Final outputs already reached: ")) {
          if (!this.finalOutputs)
            throw e;
          return this.finalOutputs;
        }
        throw this.runManager && await this.runManager.handleChainError(e), e;
      }
  }
  /**
   * Perform any necessary setup for the first step
   * of the asynchronous iterator.
   */
  async onFirstStep() {
    if (this.iterations === 0) {
      const e = await it.configure(this.callbacks ?? this.config?.callbacks, this.agentExecutor.callbacks, this.tags ?? this.config?.tags, this.agentExecutor.tags, this.metadata ?? this.config?.metadata, this.agentExecutor.metadata, {
        verbose: this.agentExecutor.verbose
      });
      this.runManager = await e?.handleChainStart(this.agentExecutor.toJSON(), this.inputs, this.config?.runId, void 0, this.tags ?? this.config?.tags, this.metadata ?? this.config?.metadata, this.runName ?? this.config?.runName), this.config !== void 0 && delete this.config.runId;
    }
  }
  /**
   * Execute the next step in the chain using the
   * AgentExecutor's _takeNextStep method.
   */
  async _executeNextStep(e) {
    return this.agentExecutor._takeNextStep(this.nameToToolMap, this.inputs, this.intermediateSteps, e, this.config);
  }
  /**
   * Process the output of the next step,
   * handling AgentFinish and tool return cases.
   */
  async _processNextStepOutput(e, n) {
    if ("returnValues" in e) {
      const r = await this.agentExecutor._return(e, this.intermediateSteps, n);
      return this.runManager && await this.runManager.handleChainEnd(r), await this.setFinalOutputs(r), r;
    }
    this.intermediateSteps = this.intermediateSteps.concat(e);
    let a = {};
    if (Array.isArray(e) && e.length === 1) {
      const r = e[0], i = await this.agentExecutor._getToolReturn(r);
      i && (a = await this.agentExecutor._return(i, this.intermediateSteps, n), await this.runManager?.handleChainEnd(a), await this.setFinalOutputs(a));
    }
    return a = { intermediateSteps: e }, a;
  }
  async _stop() {
    const e = await this.agentExecutor.agent.returnStoppedResponse(this.agentExecutor.earlyStoppingMethod, this.intermediateSteps, this.inputs), n = await this.agentExecutor._return(e, this.intermediateSteps, this.runManager);
    return await this.setFinalOutputs(n), await this.runManager?.handleChainEnd(n), n;
  }
  async _callNext() {
    if (this.finalOutputs)
      throw new Error(`Final outputs already reached: ${JSON.stringify(this.finalOutputs, null, 2)}`);
    if (!this.agentExecutor.shouldContinueGetter(this.iterations))
      return this._stop();
    const e = await this._executeNextStep(this.runManager), n = await this._processNextStepOutput(e, this.runManager);
    return this.updateIterations(), n;
  }
}
class Qm extends fp {
  constructor() {
    super(...arguments), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "_Exception"
    }), Object.defineProperty(this, "description", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Exception tool"
    });
  }
  async _call(e) {
    return e;
  }
}
class L$ extends It {
  static lc_name() {
    return "AgentExecutor";
  }
  get lc_namespace() {
    return ["langchain", "agents", "executor"];
  }
  get inputKeys() {
    return this.agent.inputKeys;
  }
  get outputKeys() {
    return this.agent.returnValues;
  }
  constructor(e) {
    let n, a = !0;
    if (Te.isRunnable(e.agent) ? (Ep.isAgentRunnableSequence(e.agent) ? e.agent.singleAction ? n = new XU({
      runnable: e.agent,
      streamRunnable: e.agent.streamRunnable
    }) : n = new qj({
      runnable: e.agent,
      streamRunnable: e.agent.streamRunnable
    }) : n = new qj({ runnable: e.agent }), a = !1) : (WU(e.agent) && (a = !1), n = e.agent), super(e), Object.defineProperty(this, "agent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tools", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnIntermediateSteps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "maxIterations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 15
    }), Object.defineProperty(this, "earlyStoppingMethod", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "force"
    }), Object.defineProperty(this, "returnOnlyOutputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "handleParsingErrors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "handleToolRuntimeErrors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.agent = n, this.tools = e.tools, this.handleParsingErrors = e.handleParsingErrors ?? this.handleParsingErrors, this.handleToolRuntimeErrors = e.handleToolRuntimeErrors, this.returnOnlyOutputs = a, this.agent._agentActionType() === "multi") {
      for (const r of this.tools)
        if (r.returnDirect)
          throw new Error(`Tool with return direct ${r.name} not supported for multi-action agent.`);
    }
    this.returnIntermediateSteps = e.returnIntermediateSteps ?? this.returnIntermediateSteps, this.maxIterations = e.maxIterations ?? this.maxIterations, this.earlyStoppingMethod = e.earlyStoppingMethod ?? this.earlyStoppingMethod;
  }
  /** Create from agent and a list of tools. */
  static fromAgentAndTools(e) {
    return new L$(e);
  }
  get shouldContinueGetter() {
    return this.shouldContinue.bind(this);
  }
  /**
   * Method that checks if the agent execution should continue based on the
   * number of iterations.
   * @param iterations The current number of iterations.
   * @returns A boolean indicating whether the agent execution should continue.
   */
  shouldContinue(e) {
    return this.maxIterations === void 0 || e < this.maxIterations;
  }
  /** @ignore */
  async _call(e, n, a) {
    const r = Object.fromEntries(this.tools.map((f) => [f.name.toLowerCase(), f])), i = [];
    let s = 0;
    const u = async (f) => {
      const { returnValues: o } = f, c = await this.agent.prepareForOutput(o, i);
      await n?.handleAgentEnd(f);
      let h;
      return this.returnIntermediateSteps ? h = { ...o, intermediateSteps: i, ...c } : h = { ...o, ...c }, this.returnOnlyOutputs || (h = { ...e, ...h }), h;
    };
    for (; this.shouldContinue(s); ) {
      let f;
      try {
        f = await this.agent.plan(i, e, n?.getChild(), a);
      } catch (l) {
        if (l instanceof Bt) {
          let m, b = l.message;
          if (this.handleParsingErrors === !0)
            l.sendToLLM ? (m = l.observation, b = l.llmOutput ?? "") : m = "Invalid or incomplete response";
          else if (typeof this.handleParsingErrors == "string")
            m = this.handleParsingErrors;
          else if (typeof this.handleParsingErrors == "function")
            m = this.handleParsingErrors(l);
          else
            throw l;
          f = {
            tool: "_Exception",
            toolInput: m,
            log: b
          };
        } else
          throw l;
      }
      if ("returnValues" in f)
        return u(f);
      let o;
      Array.isArray(f) ? o = f : o = [f];
      const c = await Promise.all(o.map(async (l) => {
        await n?.handleAgentAction(l);
        const m = l.tool === "_Exception" ? new Qm() : r[l.tool?.toLowerCase()];
        let b;
        try {
          if (b = m ? await m.invoke(l.toolInput, Qe(a, { callbacks: n?.getChild() })) : `${l.tool} is not a valid tool, try another one.`, typeof b != "string")
            throw new Error("Received unsupported non-string response from tool call.");
        } catch (g) {
          if (g instanceof fh) {
            if (this.handleParsingErrors === !0)
              b = "Invalid or incomplete tool input. Please try again.";
            else if (typeof this.handleParsingErrors == "string")
              b = this.handleParsingErrors;
            else if (typeof this.handleParsingErrors == "function")
              b = this.handleParsingErrors(g);
            else
              throw g;
            return b = await new Qm().call(b, n?.getChild()), { action: l, observation: b ?? "" };
          } else this.handleToolRuntimeErrors !== void 0 && (b = this.handleToolRuntimeErrors(g));
        }
        return { action: l, observation: b ?? "" };
      }));
      i.push(...c);
      const h = i[i.length - 1];
      if (r[h.action.tool?.toLowerCase()]?.returnDirect)
        return u({
          returnValues: { [this.agent.returnValues[0]]: h.observation },
          log: ""
        });
      s += 1;
    }
    const d = await this.agent.returnStoppedResponse(this.earlyStoppingMethod, i, e);
    return u(d);
  }
  async _takeNextStep(e, n, a, r, i) {
    let s;
    try {
      s = await this.agent.plan(a, n, r?.getChild(), i);
    } catch (f) {
      if (f instanceof Bt) {
        let o, c = f.message;
        if (this.handleParsingErrors === !0)
          f.sendToLLM ? (o = f.observation, c = f.llmOutput ?? "") : o = "Invalid or incomplete response";
        else if (typeof this.handleParsingErrors == "string")
          o = this.handleParsingErrors;
        else if (typeof this.handleParsingErrors == "function")
          o = this.handleParsingErrors(f);
        else
          throw f;
        s = {
          tool: "_Exception",
          toolInput: o,
          log: c
        };
      } else
        throw f;
    }
    if ("returnValues" in s)
      return s;
    let u;
    Array.isArray(s) ? u = s : u = [s];
    const d = [];
    for (const f of u) {
      let o = "";
      if (r && await r?.handleAgentAction(f), f.tool in e) {
        const c = e[f.tool];
        try {
          if (o = await c.call(f.toolInput, r?.getChild()), typeof o != "string")
            throw new Error("Received unsupported non-string response from tool call.");
        } catch (h) {
          if (h instanceof fh) {
            if (this.handleParsingErrors === !0)
              o = "Invalid or incomplete tool input. Please try again.";
            else if (typeof this.handleParsingErrors == "string")
              o = this.handleParsingErrors;
            else if (typeof this.handleParsingErrors == "function")
              o = this.handleParsingErrors(h);
            else
              throw h;
            o = await new Qm().call(o, r?.getChild());
          }
        }
      } else
        o = `${f.tool} is not a valid tool, try another available tool: ${Object.keys(e).join(", ")}`;
      d.push({
        action: f,
        observation: o
      });
    }
    return d;
  }
  async _return(e, n, a) {
    a && await a.handleAgentEnd(e);
    const r = e.returnValues;
    return this.returnIntermediateSteps && (r.intermediateSteps = n), r;
  }
  async _getToolReturn(e) {
    const { action: n, observation: a } = e, r = Object.fromEntries(this.tools.map((s) => [s.name.toLowerCase(), s])), [i = "output"] = this.agent.returnValues;
    return n.tool in r && r[n.tool].returnDirect ? {
      returnValues: { [i]: a },
      log: ""
    } : null;
  }
  _returnStoppedResponse(e) {
    if (e === "force")
      return {
        returnValues: {
          output: "Agent stopped due to iteration limit or time limit."
        },
        log: ""
      };
    throw new Error(`Got unsupported early_stopping_method: ${e}`);
  }
  async *_streamIterator(e, n) {
    const r = new aB({
      inputs: e,
      agentExecutor: this,
      config: n,
      // TODO: Deprecate these other parameters
      metadata: n?.metadata,
      tags: n?.tags,
      callbacks: n?.callbacks
    }).streamIterator();
    for await (const i of r)
      i && (yield i);
  }
  _chainType() {
    return "agent_executor";
  }
  serialize() {
    throw new Error("Cannot serialize an AgentExecutor");
  }
}
class uc extends It {
  static lc_name() {
    return "StuffDocumentsChain";
  }
  get inputKeys() {
    return [this.inputKey, ...this.llmChain.inputKeys].filter((e) => e !== this.documentVariableName);
  }
  get outputKeys() {
    return this.llmChain.outputKeys;
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "llmChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "input_documents"
    }), Object.defineProperty(this, "documentVariableName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "context"
    }), this.llmChain = e.llmChain, this.documentVariableName = e.documentVariableName ?? this.documentVariableName, this.inputKey = e.inputKey ?? this.inputKey;
  }
  /** @ignore */
  _prepInputs(e) {
    if (!(this.inputKey in e))
      throw new Error(`Document key ${this.inputKey} not found.`);
    const { [this.inputKey]: n, ...a } = e, i = n.map(({ pageContent: s }) => s).join(`

`);
    return {
      ...a,
      [this.documentVariableName]: i
    };
  }
  /** @ignore */
  async _call(e, n) {
    return await this.llmChain.call(this._prepInputs(e), n?.getChild("combine_documents"));
  }
  _chainType() {
    return "stuff_documents_chain";
  }
  static async deserialize(e) {
    if (!e.llm_chain)
      throw new Error("Missing llm_chain");
    return new uc({
      llmChain: await tt.deserialize(e.llm_chain)
    });
  }
  serialize() {
    return {
      _type: this._chainType(),
      llm_chain: this.llmChain.serialize()
    };
  }
}
class Ip extends It {
  static lc_name() {
    return "MapReduceDocumentsChain";
  }
  get inputKeys() {
    return [this.inputKey, ...this.combineDocumentChain.inputKeys];
  }
  get outputKeys() {
    return this.combineDocumentChain.outputKeys;
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "llmChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "input_documents"
    }), Object.defineProperty(this, "documentVariableName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "context"
    }), Object.defineProperty(this, "returnIntermediateSteps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "maxTokens", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3e3
    }), Object.defineProperty(this, "maxIterations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 10
    }), Object.defineProperty(this, "ensureMapStep", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "combineDocumentChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.llmChain = e.llmChain, this.combineDocumentChain = e.combineDocumentChain, this.documentVariableName = e.documentVariableName ?? this.documentVariableName, this.ensureMapStep = e.ensureMapStep ?? this.ensureMapStep, this.inputKey = e.inputKey ?? this.inputKey, this.maxTokens = e.maxTokens ?? this.maxTokens, this.maxIterations = e.maxIterations ?? this.maxIterations, this.returnIntermediateSteps = e.returnIntermediateSteps ?? !1;
  }
  /** @ignore */
  async _call(e, n) {
    if (!(this.inputKey in e))
      throw new Error(`Document key ${this.inputKey} not found.`);
    const { [this.inputKey]: a, ...r } = e;
    let i = a, s = [];
    for (let f = 0; f < this.maxIterations; f += 1) {
      const o = i.map((l) => ({
        [this.documentVariableName]: l.pageContent,
        ...r
      }));
      if (f !== 0 || !this.ensureMapStep) {
        const l = await this.combineDocumentChain.llmChain.prompt.format(this.combineDocumentChain._prepInputs({
          [this.combineDocumentChain.inputKey]: i,
          ...r
        }));
        if (await this.combineDocumentChain.llmChain._getNumTokens(l) < this.maxTokens)
          break;
      }
      const h = await this.llmChain.apply(
        o,
        // If we have a runManager, then we need to create a child for each input
        // so that we can track the progress of each input.
        n ? Array.from({ length: o.length }, (l, m) => n.getChild(`map_${m + 1}`)) : void 0
      ), { outputKey: p } = this.llmChain;
      this.returnIntermediateSteps && (s = s.concat(h.map((l) => l[p]))), i = h.map((l) => ({
        pageContent: l[p],
        metadata: {}
      }));
    }
    const u = {
      [this.combineDocumentChain.inputKey]: i,
      ...r
    }, d = await this.combineDocumentChain.call(u, n?.getChild("combine_documents"));
    return this.returnIntermediateSteps ? { ...d, intermediateSteps: s } : d;
  }
  _chainType() {
    return "map_reduce_documents_chain";
  }
  static async deserialize(e) {
    if (!e.llm_chain)
      throw new Error("Missing llm_chain");
    if (!e.combine_document_chain)
      throw new Error("Missing combine_document_chain");
    return new Ip({
      llmChain: await tt.deserialize(e.llm_chain),
      combineDocumentChain: await uc.deserialize(e.combine_document_chain)
    });
  }
  serialize() {
    return {
      _type: this._chainType(),
      llm_chain: this.llmChain.serialize(),
      combine_document_chain: this.combineDocumentChain.serialize()
    };
  }
}
class Np extends It {
  static lc_name() {
    return "RefineDocumentsChain";
  }
  get defaultDocumentPrompt() {
    return new He({
      inputVariables: ["page_content"],
      template: "{page_content}"
    });
  }
  get inputKeys() {
    return [
      .../* @__PURE__ */ new Set([
        this.inputKey,
        ...this.llmChain.inputKeys,
        ...this.refineLLMChain.inputKeys
      ])
    ].filter((e) => e !== this.documentVariableName && e !== this.initialResponseName);
  }
  get outputKeys() {
    return [this.outputKey];
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "llmChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "input_documents"
    }), Object.defineProperty(this, "outputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "output_text"
    }), Object.defineProperty(this, "documentVariableName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "context"
    }), Object.defineProperty(this, "initialResponseName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "existing_answer"
    }), Object.defineProperty(this, "refineLLMChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "documentPrompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.defaultDocumentPrompt
    }), this.llmChain = e.llmChain, this.refineLLMChain = e.refineLLMChain, this.documentVariableName = e.documentVariableName ?? this.documentVariableName, this.inputKey = e.inputKey ?? this.inputKey, this.outputKey = e.outputKey ?? this.outputKey, this.documentPrompt = e.documentPrompt ?? this.documentPrompt, this.initialResponseName = e.initialResponseName ?? this.initialResponseName;
  }
  /** @ignore */
  async _constructInitialInputs(e, n) {
    const a = {
      page_content: e.pageContent,
      ...e.metadata
    }, r = {};
    return this.documentPrompt.inputVariables.forEach((u) => {
      r[u] = a[u];
    }), { ...{
      [this.documentVariableName]: await this.documentPrompt.format({
        ...r
      })
    }, ...n };
  }
  /** @ignore */
  async _constructRefineInputs(e, n) {
    const a = {
      page_content: e.pageContent,
      ...e.metadata
    }, r = {};
    this.documentPrompt.inputVariables.forEach((u) => {
      r[u] = a[u];
    });
    const i = {
      [this.documentVariableName]: await this.documentPrompt.format({
        ...r
      })
    };
    return { [this.initialResponseName]: n, ...i };
  }
  /** @ignore */
  async _call(e, n) {
    if (!(this.inputKey in e))
      throw new Error(`Document key ${this.inputKey} not found.`);
    const { [this.inputKey]: a, ...r } = e, i = a, s = await this._constructInitialInputs(i[0], r);
    let u = await this.llmChain.predict({ ...s }, n?.getChild("answer"));
    for (let d = 1; d < i.length; d += 1) {
      const o = { ...await this._constructRefineInputs(i[d], u), ...r };
      u = await this.refineLLMChain.predict({ ...o }, n?.getChild("refine"));
    }
    return { [this.outputKey]: u };
  }
  _chainType() {
    return "refine_documents_chain";
  }
  static async deserialize(e) {
    const n = e.llm_chain;
    if (!n)
      throw new Error("Missing llm_chain");
    const a = e.refine_llm_chain;
    if (!a)
      throw new Error("Missing refine_llm_chain");
    return new Np({
      llmChain: await tt.deserialize(n),
      refineLLMChain: await tt.deserialize(a)
    });
  }
  serialize() {
    return {
      _type: this._chainType(),
      llm_chain: this.llmChain.serialize(),
      refine_llm_chain: this.refineLLMChain.serialize()
    };
  }
}
const Ym = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MapReduceDocumentsChain: Ip,
  RefineDocumentsChain: Np,
  StuffDocumentsChain: uc
}, Symbol.toStringTag, { value: "Module" }));
class iB {
  /**
   * Asynchronous version of `getPrompt` that also accepts an options object
   * for partial variables.
   * @param llm The language model for which to get a prompt.
   * @param options Optional object for partial variables.
   * @returns A Promise that resolves to a prompt template.
   */
  async getPromptAsync(e, n) {
    return this.getPrompt(e).partial(n?.partialVariables ?? {});
  }
}
class Zd extends iB {
  constructor(e, n = []) {
    super(), Object.defineProperty(this, "defaultPrompt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "conditionals", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.defaultPrompt = e, this.conditionals = n;
  }
  /**
   * Method that selects a prompt based on a set of conditions. If none of
   * the conditions are met, it returns the default prompt.
   * @param llm The language model for which to get a prompt.
   * @returns A prompt template.
   */
  getPrompt(e) {
    for (const [n, a] of this.conditionals)
      if (n(e))
        return a;
    return this.defaultPrompt;
  }
}
function Kd(t) {
  return t._modelType() === "base_chat_model";
}
const sB = /* @__PURE__ */ new He({
  template: `Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.

{context}

Question: {question}
Helpful Answer:`,
  inputVariables: ["context", "question"]
}), oB = `Use the following pieces of context to answer the users question. 
If you don't know the answer, just say that you don't know, don't try to make up an answer.
----------------
{context}`, uB = [
  /* @__PURE__ */ sc.fromTemplate(oB),
  /* @__PURE__ */ Bs.fromTemplate("{question}")
], cB = /* @__PURE__ */ ua.fromMessages(uB), lB = /* @__PURE__ */ new Zd(sB, [[Kd, cB]]), dB = `Use the following portion of a long document to see if any of the text is relevant to answer the question. 
Return any relevant text verbatim.
{context}
Question: {question}
Relevant text, if any:`, fB = /* @__PURE__ */ He.fromTemplate(dB), hB = `Use the following portion of a long document to see if any of the text is relevant to answer the question. 
Return any relevant text verbatim.
----------------
{context}`, pB = [
  /* @__PURE__ */ sc.fromTemplate(hB),
  /* @__PURE__ */ Bs.fromTemplate("{question}")
], mB = /* @__PURE__ */ ua.fromMessages(pB), bB = /* @__PURE__ */ new Zd(fB, [
  [Kd, mB]
]), gB = `Given the following extracted parts of a long document and a question, create a final answer. 
If you don't know the answer, just say that you don't know. Don't try to make up an answer.

QUESTION: Which state/country's law governs the interpretation of the contract?
=========
Content: This Agreement is governed by English law and the parties submit to the exclusive jurisdiction of the English courts in  relation to any dispute (contractual or non-contractual) concerning this Agreement save that either party may apply to any court for an  injunction or other relief to protect its Intellectual Property Rights.

Content: No Waiver. Failure or delay in exercising any right or remedy under this Agreement shall not constitute a waiver of such (or any other)  right or remedy.

11.7 Severability. The invalidity, illegality or unenforceability of any term (or part of a term) of this Agreement shall not affect the continuation  in force of the remainder of the term (if any) and this Agreement.

11.8 No Agency. Except as expressly stated otherwise, nothing in this Agreement shall create an agency, partnership or joint venture of any  kind between the parties.

11.9 No Third-Party Beneficiaries.

Content: (b) if Google believes, in good faith, that the Distributor has violated or caused Google to violate any Anti-Bribery Laws (as  defined in Clause 8.5) or that such a violation is reasonably likely to occur,
=========
FINAL ANSWER: This Agreement is governed by English law.

QUESTION: What did the president say about Michael Jackson?
=========
Content: Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.  

Last year COVID-19 kept us apart. This year we are finally together again. 

Tonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. 

With a duty to one another to the American people to the Constitution. 

And with an unwavering resolve that freedom will always triumph over tyranny. 

Six days ago, Russias Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. 

He thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. 

He met the Ukrainian people. 

From President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world. 

Groups of citizens blocking tanks with their bodies. Everyone from students to retirees teachers turned soldiers defending their homeland.

Content: And we wont stop. 

We have lost so much to COVID-19. Time with one another. And worst of all, so much loss of life. 

Lets use this moment to reset. Lets stop looking at COVID-19 as a partisan dividing line and see it for what it is: A God-awful disease.  

Lets stop seeing each other as enemies, and start seeing each other for who we really are: Fellow Americans.  

We cant change how divided weve been. But we can change how we move forwardon COVID-19 and other issues we must face together. 

I recently visited the New York City Police Department days after the funerals of Officer Wilbert Mora and his partner, Officer Jason Rivera. 

They were responding to a 9-1-1 call when a man shot and killed them with a stolen gun. 

Officer Mora was 27 years old. 

Officer Rivera was 22. 

Both Dominican Americans whod grown up on the same streets they later chose to patrol as police officers. 

I spoke with their families and told them that we are forever in debt for their sacrifice, and we will carry on their mission to restore the trust and safety every community deserves.

Content: And a proud Ukrainian people, who have known 30 years  of independence, have repeatedly shown that they will not tolerate anyone who tries to take their country backwards.  

To all Americans, I will be honest with you, as Ive always promised. A Russian dictator, invading a foreign country, has costs around the world. 

And Im taking robust action to make sure the pain of our sanctions  is targeted at Russias economy. And I will use every tool at our disposal to protect American businesses and consumers. 

Tonight, I can announce that the United States has worked with 30 other countries to release 60 Million barrels of oil from reserves around the world.  

America will lead that effort, releasing 30 Million barrels from our own Strategic Petroleum Reserve. And we stand ready to do more if necessary, unified with our allies.  

These steps will help blunt gas prices here at home. And I know the news about whats happening can seem alarming. 

But I want you to know that we are going to be okay.

Content: More support for patients and families. 

To get there, I call on Congress to fund ARPA-H, the Advanced Research Projects Agency for Health. 

Its based on DARPAthe Defense Department project that led to the Internet, GPS, and so much more.  

ARPA-H will have a singular purposeto drive breakthroughs in cancer, Alzheimers, diabetes, and more. 

A unity agenda for the nation. 

We can do this. 

My fellow Americanstonight , we have gathered in a sacred spacethe citadel of our democracy. 

In this Capitol, generation after generation, Americans have debated great questions amid great strife, and have done great things. 

We have fought for freedom, expanded liberty, defeated totalitarianism and terror. 

And built the strongest, freest, and most prosperous nation the world has ever known. 

Now is the hour. 

Our moment of responsibility. 

Our test of resolve and conscience, of history itself. 

It is in this moment that our character is formed. Our purpose is found. Our future is forged. 

Well I know this nation.
=========
FINAL ANSWER: The president did not mention Michael Jackson.

QUESTION: {question}
=========
{summaries}
=========
FINAL ANSWER:`, _B = /* @__PURE__ */ He.fromTemplate(gB), yB = `Given the following extracted parts of a long document and a question, create a final answer. 
If you don't know the answer, just say that you don't know. Don't try to make up an answer.
----------------
{summaries}`, vB = [
  /* @__PURE__ */ sc.fromTemplate(yB),
  /* @__PURE__ */ Bs.fromTemplate("{question}")
], wB = /* @__PURE__ */ ua.fromMessages(vB), SB = /* @__PURE__ */ new Zd(_B, [
  [Kd, wB]
]), OB = `The original question is as follows: {question}
We have provided an existing answer: {existing_answer}
We have the opportunity to refine the existing answer
(only if needed) with some more context below.
------------
{context}
------------
Given the new context, refine the original answer to better answer the question. 
If the context isn't useful, return the original answer.`, jB = /* @__PURE__ */ new He({
  inputVariables: ["question", "existing_answer", "context"],
  template: OB
}), PB = `The original question is as follows: {question}
We have provided an existing answer: {existing_answer}
We have the opportunity to refine the existing answer
(only if needed) with some more context below.
------------
{context}
------------
Given the new context, refine the original answer to better answer the question. 
If the context isn't useful, return the original answer.`, CB = [
  /* @__PURE__ */ Bs.fromTemplate("{question}"),
  /* @__PURE__ */ A$.fromTemplate("{existing_answer}"),
  /* @__PURE__ */ Bs.fromTemplate(PB)
], RB = /* @__PURE__ */ ua.fromMessages(CB), TB = /* @__PURE__ */ new Zd(jB, [
  [Kd, RB]
]), $B = `Context information is below. 
---------------------
{context}
---------------------
Given the context information and no prior knowledge, answer the question: {question}`, MB = /* @__PURE__ */ new He({
  inputVariables: ["context", "question"],
  template: $B
}), AB = `Context information is below. 
---------------------
{context}
---------------------
Given the context information and no prior knowledge, answer any questions`, EB = [
  /* @__PURE__ */ sc.fromTemplate(AB),
  /* @__PURE__ */ Bs.fromTemplate("{question}")
], IB = /* @__PURE__ */ ua.fromMessages(EB), NB = /* @__PURE__ */ new Zd(MB, [
  [Kd, IB]
]), FB = (t, e = { type: "stuff" }) => {
  const { type: n } = e;
  if (n === "stuff")
    return D_(t, e);
  if (n === "map_reduce")
    return kB(t, e);
  if (n === "refine")
    return DB(t, e);
  throw new Error(`Invalid _type: ${n}`);
};
function D_(t, e = {}) {
  const { prompt: n = lB.getPrompt(t), verbose: a } = e, r = new tt({ prompt: n, llm: t, verbose: a });
  return new uc({ llmChain: r, verbose: a });
}
function kB(t, e = {}) {
  const { combineMapPrompt: n = bB.getPrompt(t), combinePrompt: a = SB.getPrompt(t), verbose: r, combineLLM: i, returnIntermediateSteps: s } = e, u = new tt({ prompt: n, llm: t, verbose: r }), d = new tt({
    prompt: a,
    llm: i ?? t,
    verbose: r
  }), f = new uc({
    llmChain: d,
    documentVariableName: "summaries",
    verbose: r
  });
  return new Ip({
    llmChain: u,
    combineDocumentChain: f,
    returnIntermediateSteps: s,
    verbose: r
  });
}
function DB(t, e = {}) {
  const { questionPrompt: n = NB.getPrompt(t), refinePrompt: a = TB.getPrompt(t), refineLLM: r, verbose: i } = e, s = new tt({ prompt: n, llm: t, verbose: i }), u = new tt({
    prompt: a,
    llm: r ?? t,
    verbose: i
  });
  return new Np({
    llmChain: s,
    refineLLMChain: u,
    verbose: i
  });
}
class q_ extends It {
  static lc_name() {
    return "VectorDBQAChain";
  }
  get inputKeys() {
    return [this.inputKey];
  }
  get outputKeys() {
    return this.combineDocumentsChain.outputKeys.concat(this.returnSourceDocuments ? ["sourceDocuments"] : []);
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "k", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "query"
    }), Object.defineProperty(this, "vectorstore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "combineDocumentsChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnSourceDocuments", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.vectorstore = e.vectorstore, this.combineDocumentsChain = e.combineDocumentsChain, this.inputKey = e.inputKey ?? this.inputKey, this.k = e.k ?? this.k, this.returnSourceDocuments = e.returnSourceDocuments ?? this.returnSourceDocuments;
  }
  /** @ignore */
  async _call(e, n) {
    if (!(this.inputKey in e))
      throw new Error(`Question key ${this.inputKey} not found.`);
    const a = e[this.inputKey], r = await this.vectorstore.similaritySearch(a, this.k, e.filter, n?.getChild("vectorstore")), i = { question: a, input_documents: r }, s = await this.combineDocumentsChain.call(i, n?.getChild("combine_documents"));
    return this.returnSourceDocuments ? {
      ...s,
      sourceDocuments: r
    } : s;
  }
  _chainType() {
    return "vector_db_qa";
  }
  static async deserialize(e, n) {
    if (!("vectorstore" in n))
      throw new Error("Need to pass in a vectorstore to deserialize VectorDBQAChain");
    const { vectorstore: a } = n;
    if (!e.combine_documents_chain)
      throw new Error("VectorDBQAChain must have combine_documents_chain in serialized data");
    return new q_({
      combineDocumentsChain: await It.deserialize(e.combine_documents_chain),
      k: e.k,
      vectorstore: a
    });
  }
  serialize() {
    return {
      _type: this._chainType(),
      combine_documents_chain: this.combineDocumentsChain.serialize(),
      k: this.k
    };
  }
  /**
   * Static method that creates a VectorDBQAChain instance from a
   * BaseLanguageModel and a vector store. It also accepts optional options
   * to customize the chain.
   * @param llm The BaseLanguageModel instance.
   * @param vectorstore The vector store used for similarity search.
   * @param options Optional options to customize the chain.
   * @returns A new instance of VectorDBQAChain.
   */
  static fromLLM(e, n, a) {
    const r = D_(e);
    return new this({
      vectorstore: n,
      combineDocumentsChain: r,
      ...a
    });
  }
}
const qB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VectorDBQAChain: q_
}, Symbol.toStringTag, { value: "Module" })), JB = "Answer the following questions as best you can. You have access to the following tools:", U$ = `The way you use the tools is by specifying a json blob, denoted below by $JSON_BLOB
Specifically, this $JSON_BLOB should have a "action" key (with the name of the tool to use) and a "action_input" key (with the input to the tool going here). 
The $JSON_BLOB should only contain a SINGLE action, do NOT return a list of multiple actions. Here is an example of a valid $JSON_BLOB:

\`\`\`
{{
  "action": "calculator",
  "action_input": "1 + 2"
}}
\`\`\`

ALWAYS use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: 
\`\`\`
$JSON_BLOB
\`\`\`
Observation: the result of the action
... (this Thought/Action/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question`, LB = "Begin! Reminder to always use the exact characters `Final Answer` when responding.", Jj = "Final Answer:";
class UB extends oc {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "chat"]
    });
  }
  /**
   * Parses the output text from the MRKL chain into an agent action or
   * agent finish. If the text contains the final answer action or does not
   * contain an action, it returns an AgentFinish with the output and log.
   * If the text contains a JSON response, it returns the tool, toolInput,
   * and log.
   * @param text The output text from the MRKL chain.
   * @returns An object that satisfies the AgentFinish interface or an object with the tool, toolInput, and log.
   */
  async parse(e) {
    if (e.includes(Jj) || !e.includes('"action":')) {
      const a = e.split(Jj);
      return { returnValues: { output: a[a.length - 1].trim() }, log: e };
    }
    const n = e.includes("```") ? e.trim().split(/```(?:json)?/)[1] : e.trim();
    try {
      const a = JSON.parse(n.trim());
      return {
        tool: a.action,
        toolInput: a.action_input,
        log: e
      };
    } catch {
      throw new Bt(`Unable to parse JSON response from chat agent.

${e}`);
    }
  }
  /**
   * Returns the format instructions used in the output parser for the
   * ChatAgent class.
   * @returns The format instructions as a string.
   */
  getFormatInstructions() {
    return U$;
  }
}
const BB = `{input}

{agent_scratchpad}`;
class Ru extends q$ {
  static lc_name() {
    return "ChatAgent";
  }
  constructor(e) {
    const n = e?.outputParser ?? Ru.getDefaultOutputParser();
    super({ ...e, outputParser: n }), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "chat"]
    });
  }
  _agentType() {
    return "chat-zero-shot-react-description";
  }
  observationPrefix() {
    return "Observation: ";
  }
  llmPrefix() {
    return "Thought:";
  }
  _stop() {
    return ["Observation:"];
  }
  /**
   * Validates that all tools have descriptions. Throws an error if a tool
   * without a description is found.
   * @param tools Array of Tool instances to validate.
   * @returns void
   */
  static validateTools(e) {
    const n = e.find((a) => !a.description);
    if (n) {
      const a = `Got a tool ${n.name} without a description. This agent requires descriptions for all tools.`;
      throw new Error(a);
    }
  }
  /**
   * Returns a default output parser for the ChatAgent.
   * @param _fields Optional OutputParserArgs to customize the output parser.
   * @returns ChatAgentOutputParser instance
   */
  static getDefaultOutputParser(e) {
    return new UB();
  }
  /**
   * Constructs the agent's scratchpad, which is a string representation of
   * the agent's previous steps.
   * @param steps Array of AgentStep instances representing the agent's previous steps.
   * @returns Promise resolving to a string representing the agent's scratchpad.
   */
  async constructScratchPad(e) {
    const n = await super.constructScratchPad(e);
    return n && `This was your previous work (but I haven't seen any of it! I only see what you return as final answer):
${n}`;
  }
  /**
   * Create prompt in the style of the zero shot agent.
   *
   * @param tools - List of tools the agent will have access to, used to format the prompt.
   * @param args - Arguments to create the prompt with.
   * @param args.suffix - String to put after the list of tools.
   * @param args.prefix - String to put before the list of tools.
   * @param args.humanMessageTemplate - String to use directly as the human message template
   * @param args.formatInstructions - Formattable string to use as the instructions template
   */
  static createPrompt(e, n) {
    const { prefix: a = JB, suffix: r = LB, humanMessageTemplate: i = BB, formatInstructions: s = U$ } = n ?? {}, u = e.map((o) => `${o.name}: ${o.description}`).join(`
`), d = [a, u, s, r].join(`

`), f = [
      sc.fromTemplate(d),
      Bs.fromTemplate(i)
    ];
    return ua.fromMessages(f);
  }
  /**
   * Creates a ChatAgent instance using a language model, tools, and
   * optional arguments.
   * @param llm BaseLanguageModelInterface instance to use in the agent.
   * @param tools Array of Tool instances to include in the agent.
   * @param args Optional arguments to customize the agent and prompt.
   * @returns ChatAgent instance
   */
  static fromLLMAndTools(e, n, a) {
    Ru.validateTools(n);
    const r = Ru.createPrompt(n, a), i = new tt({
      prompt: r,
      llm: e,
      callbacks: a?.callbacks ?? a?.callbackManager
    }), s = a?.outputParser ?? Ru.getDefaultOutputParser();
    return new Ru({
      llmChain: i,
      outputParser: s,
      allowedTools: n.map((u) => u.name)
    });
  }
}
const xB = `Instructions:
--------------
{instructions}
--------------
Completion:
--------------
{completion}
--------------

Above, the Completion did not satisfy the constraints given in the Instructions.
Error:
--------------
{error}
--------------

Please try again. Please only respond with an answer that satisfies the constraints laid out in the Instructions:`, VB = /* @__PURE__ */ He.fromTemplate(xB);
function zB(t) {
  return t.prompt !== void 0 && t.llm !== void 0;
}
class J_ extends Fd {
  static lc_name() {
    return "OutputFixingParser";
  }
  /**
   * Static method to create a new instance of OutputFixingParser using a
   * given language model, parser, and optional fields.
   * @param llm The language model to be used.
   * @param parser The parser to be used.
   * @param fields Optional fields which may contain a prompt.
   * @returns A new instance of OutputFixingParser.
   */
  static fromLLM(e, n, a) {
    const r = a?.prompt ?? VB, i = new tt({ llm: e, prompt: r });
    return new J_({ parser: n, retryChain: i });
  }
  constructor({ parser: e, retryChain: n }) {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "output_parsers", "fix"]
    }), Object.defineProperty(this, "lc_serializable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "parser", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "retryChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.parser = e, this.retryChain = n;
  }
  /**
   * Method to parse the completion using the parser. If the initial parsing
   * fails, it uses the retryChain to attempt to fix the output and retry
   * the parsing process.
   * @param completion The completion to be parsed.
   * @param callbacks Optional callbacks to be used during parsing.
   * @returns The parsed output.
   */
  async parse(e, n) {
    try {
      return await this.parser.parse(e, n);
    } catch (a) {
      if (a instanceof Bt) {
        const r = {
          instructions: this.parser.getFormatInstructions(),
          completion: e,
          error: a
        };
        if (zB(this.retryChain)) {
          const s = (await this.retryChain.call(r, n))[this.retryChain.outputKey];
          return this.parser.parse(s, n);
        } else
          return await this.retryChain.invoke(r, {
            callbacks: n
          });
      }
      throw a;
    }
  }
  /**
   * Method to get the format instructions for the parser.
   * @returns The format instructions for the parser.
   */
  getFormatInstructions() {
    return this.parser.getFormatInstructions();
  }
}
const B$ = `Output a JSON markdown code snippet containing a valid JSON blob (denoted below by $JSON_BLOB).
This $JSON_BLOB must have a "action" key (with the name of the tool to use) and an "action_input" key (tool input).

Valid "action" values: "Final Answer" (which you must use when giving your final response to the user), or one of [{tool_names}].

The $JSON_BLOB must be valid, parseable JSON and only contain a SINGLE action. Here is an example of an acceptable output:

\`\`\`json
{{
  "action": $TOOL_NAME,
  "action_input": $INPUT
}}
\`\`\`

Remember to include the surrounding markdown code snippet delimiters (begin with "\`\`\`" json and close with "\`\`\`")!
`, ZB = `You have access to the following tools.
You must format your inputs to these tools to match their "JSON schema" definitions below.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Here are the JSON Schema instances for the tools you have access to:

{tool_schemas}

The way you use the tools is as follows:

------------------------

${B$}

If you are using a tool, "action_input" must adhere to the tool's input schema, given above.

------------------------

ALWAYS use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action:
\`\`\`json
$JSON_BLOB
\`\`\`
Observation: the result of the action
... (this Thought/Action/Observation can repeat N times)
Thought: I now know the final answer
Action:
\`\`\`json
{{
  "action": "Final Answer",
  "action_input": "Final response to human"
}}
\`\`\``;
class Lj extends oc {
  constructor(e) {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "structured_chat"]
    }), Object.defineProperty(this, "toolNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.toolNames = e.toolNames;
  }
  /**
   * Parses the given text and returns an `AgentAction` or `AgentFinish`
   * object. If an `OutputFixingParser` is provided, it is used for parsing;
   * otherwise, the base parser is used.
   * @param text The text to parse.
   * @param callbacks Optional callbacks for asynchronous operations.
   * @returns A Promise that resolves to an `AgentAction` or `AgentFinish` object.
   */
  async parse(e) {
    try {
      const a = /```(?:json)?(.*)(```)/gs.exec(e);
      if (a === null)
        throw new Bt('Could not parse an action. The agent action must be within a markdown code block, and "action" must be a provided tool or "Final Answer"');
      const r = JSON.parse(a[1].trim()), { action: i, action_input: s } = r;
      return i === "Final Answer" ? { returnValues: { output: s }, log: e } : { tool: i, toolInput: s || {}, log: e };
    } catch (n) {
      throw new Bt(`Failed to parse. Text: "${e}". Error: ${n}`);
    }
  }
  /**
   * Returns the format instructions for parsing the output of an agent
   * action in the style of the StructuredChatAgent.
   * @returns A string representing the format instructions.
   */
  getFormatInstructions() {
    return cr(B$, "f-string", {
      tool_names: this.toolNames.join(", ")
    });
  }
}
class L_ extends oc {
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "structured_chat"]
    }), Object.defineProperty(this, "baseParser", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputFixingParser", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "toolNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this.toolNames = e.toolNames ?? this.toolNames, this.baseParser = e?.baseParser ?? new Lj({ toolNames: this.toolNames }), this.outputFixingParser = e?.outputFixingParser;
  }
  /**
   * Parses the given text and returns an `AgentAction` or `AgentFinish`
   * object. Throws an `OutputParserException` if the parsing fails.
   * @param text The text to parse.
   * @returns A Promise that resolves to an `AgentAction` or `AgentFinish` object.
   */
  async parse(e, n) {
    return this.outputFixingParser !== void 0 ? this.outputFixingParser.parse(e, n) : this.baseParser.parse(e);
  }
  /**
   * Returns the format instructions for parsing the output of an agent
   * action in the style of the StructuredChatAgent.
   * @returns A string representing the format instructions.
   */
  getFormatInstructions() {
    return cr(ZB, "f-string", {
      tool_names: this.toolNames.join(", ")
    });
  }
  /**
   * Creates a new `StructuredChatOutputParserWithRetries` instance from a
   * `BaseLanguageModel` and options. The options can include a base parser
   * and tool names.
   * @param llm A `BaseLanguageModel` instance.
   * @param options Options for creating a `StructuredChatOutputParserWithRetries` instance.
   * @returns A new `StructuredChatOutputParserWithRetries` instance.
   */
  static fromLLM(e, n) {
    const a = n.baseParser ?? new Lj({ toolNames: n.toolNames ?? [] }), r = J_.fromLLM(e, a);
    return new L_({
      baseParser: a,
      outputFixingParser: r,
      toolNames: n.toolNames
    });
  }
}
function KB(t) {
  return t.every(tc) ? t.map((e) => `${e.function.name}${e.function.description ? `: ${e.function.description}` : ""}`).join(`
`) : t.map((e) => `${e.name}: ${e.description}`).join(`
`);
}
function HB(t) {
  return t.every(tc) ? t.map((e) => `${e.function.name}${e.function.description ? `: ${e.function.description}` : ""}, args: ${JSON.stringify(e.function.parameters)}`).join(`
`) : t.map((e) => `${e.name}: ${e.description}, args: ${JSON.stringify(xn(e.schema).properties)}`).join(`
`);
}
function x$(t, e = "Observation: ", n = "Thought: ") {
  return t.reduce((r, { action: i, observation: s }) => r + [i.log, `
${e}${s}`, n].join(`
`), "");
}
async function rz({ llm: t, tools: e, prompt: n, streamRunnable: a }) {
  const r = ["tools", "tool_names", "agent_scratchpad"].filter((f) => !n.inputVariables.includes(f));
  if (r.length > 0)
    throw new Error(`Provided prompt is missing required input variables: ${JSON.stringify(r)}`);
  let i = [];
  if (e.every(tc))
    i = e.map((f) => f.function.name);
  else if (e.every(mR))
    i = e.map((f) => f.name);
  else
    throw new Error("All tools must be either OpenAI or Structured tools, not a mix.");
  const s = await n.partial({
    tools: HB(e),
    tool_names: i.join(", ")
  }), u = t.bind({
    stop: ["Observation"]
  });
  return Ep.fromRunnables([
    Ut.assign({
      agent_scratchpad: (f) => x$(f.steps)
    }),
    s,
    u,
    L_.fromLLM(t, {
      toolNames: i
    })
  ], {
    name: "StructuredChatAgent",
    streamRunnable: a,
    singleAction: !0
  });
}
class GB extends oc {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "openai"]
    });
  }
  static lc_name() {
    return "OpenAIFunctionsAgentOutputParser";
  }
  async parse(e) {
    throw new Error(`OpenAIFunctionsAgentOutputParser can only parse messages.
Passed input: ${e}`);
  }
  async parseResult(e) {
    if ("message" in e[0] && nn(e[0].message))
      return this.parseAIMessage(e[0].message);
    throw new Error("parseResult on OpenAIFunctionsAgentOutputParser only works on ChatGeneration output");
  }
  /**
   * Parses the output message into a FunctionsAgentAction or AgentFinish
   * object.
   * @param message The BaseMessage to parse.
   * @returns A FunctionsAgentAction or AgentFinish object.
   */
  parseAIMessage(e) {
    if (e.content && typeof e.content != "string")
      throw new Error("This agent cannot parse non-string model responses.");
    if (e.additional_kwargs.function_call) {
      const n = e.additional_kwargs.function_call;
      try {
        const a = n.arguments ? JSON.parse(n.arguments) : {};
        return {
          tool: n.name,
          toolInput: a,
          log: `Invoking "${n.name}" with ${n.arguments ?? "{}"}
${e.content}`,
          messageLog: [e]
        };
      } catch (a) {
        throw new Bt(`Failed to parse function arguments from chat model response. Text: "${n.arguments}". ${a}`);
      }
    } else
      return {
        returnValues: { output: e.content },
        log: e.content
      };
  }
  getFormatInstructions() {
    throw new Error("getFormatInstructions not implemented inside OpenAIFunctionsAgentOutputParser.");
  }
}
function WB(t) {
  return t.flatMap(({ action: e, observation: n }) => "messageLog" in e && e.messageLog !== void 0 ? e.messageLog.concat(new OE(n, e.tool)) : [new At(e.log)]);
}
async function az({ llm: t, tools: e, prompt: n, streamRunnable: a }) {
  if (!n.inputVariables.includes("agent_scratchpad"))
    throw new Error([
      'Prompt must have an input variable named "agent_scratchpad".',
      `Found ${JSON.stringify(n.inputVariables)} instead.`
    ].join(`
`));
  const r = t.bind({
    functions: e.map((s) => Kg(s))
  });
  return Ep.fromRunnables([
    Ut.assign({
      agent_scratchpad: (s) => WB(s.steps)
    }),
    n,
    r,
    new GB()
  ], {
    name: "OpenAIFunctionsAgent",
    streamRunnable: a,
    singleAction: !0
  });
}
const XB = `Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question`, Uj = "Final Answer:", QB = "Parsing LLM output produced both a final answer and a parse-able action:";
class YB extends oc {
  constructor(e) {
    super(...arguments), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langchain", "agents", "react"]
    }), Object.defineProperty(this, "toolNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.toolNames = e.toolNames;
  }
  /**
   * Parses the given text into an AgentAction or AgentFinish object. If an
   * output fixing parser is defined, uses it to parse the text.
   * @param text Text to parse.
   * @returns Promise that resolves to an AgentAction or AgentFinish object.
   */
  async parse(e) {
    const n = e.includes(Uj), a = /Action\s*\d*\s*:[\s]*(.*?)[\s]*Action\s*\d*\s*Input\s*\d*\s*:[\s]*(.*)/, r = e.match(a);
    if (r) {
      if (n)
        throw new Bt(`${QB}: ${e}`);
      const i = r[1], u = r[2].trim().replace(/"/g, "");
      return {
        tool: i,
        toolInput: u,
        log: e
      };
    }
    if (n)
      return {
        returnValues: {
          output: e.split(Uj)[1].trim()
        },
        log: e
      };
    throw new Bt(`Could not parse LLM output: ${e}`);
  }
  /**
   * Returns the format instructions as a string. If the 'raw' option is
   * true, returns the raw FORMAT_INSTRUCTIONS.
   * @param options Options for getting the format instructions.
   * @returns Format instructions as a string.
   */
  getFormatInstructions() {
    return cr(XB, "f-string", {
      tool_names: this.toolNames.join(", ")
    });
  }
}
async function iz({ llm: t, tools: e, prompt: n, streamRunnable: a }) {
  const r = ["tools", "tool_names", "agent_scratchpad"].filter((f) => !n.inputVariables.includes(f));
  if (r.length > 0)
    throw new Error(`Provided prompt is missing required input variables: ${JSON.stringify(r)}`);
  const i = e.map((f) => f.name), s = await n.partial({
    tools: KB(e),
    tool_names: i.join(", ")
  }), u = t.bind({
    stop: [`
Observation:`]
  });
  return Ep.fromRunnables([
    Ut.assign({
      agent_scratchpad: (f) => x$(f.steps)
    }),
    s,
    u,
    new YB({
      toolNames: i
    })
  ], {
    name: "ReactAgent",
    streamRunnable: a,
    singleAction: !0
  });
}
class sz extends fp {
  static lc_name() {
    return "SearxngSearch";
  }
  get lc_secrets() {
    return {
      apiBase: "SEARXNG_API_BASE"
    };
  }
  /**
   * Constructor for the SearxngSearch class
   * @param apiBase Base URL of the Searxng instance
   * @param params SearxNG parameters
   * @param headers Custom headers
   */
  constructor({ apiBase: e, params: n, headers: a }) {
    if (super(...arguments), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "searxng-search"
    }), Object.defineProperty(this, "description", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "A meta search engine. Useful for when you need to answer questions about current events. Input should be a search query. Output is a JSON array of the query results"
    }), Object.defineProperty(this, "apiBase", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        numResults: 10,
        pageNumber: 1,
        format: "json",
        imageProxy: !0,
        safesearch: 0
      }
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.apiBase = _t("SEARXNG_API_BASE") || e, this.headers = { "content-type": "application/json", ...a }, !this.apiBase)
      throw new Error('SEARXNG_API_BASE not set. You can set it as "SEARXNG_API_BASE" in your environment variables.');
    n && (this.params = { ...this.params, ...n });
  }
  /**
   * Builds the URL for the Searxng search.
   * @param path The path for the URL.
   * @param parameters The parameters for the URL.
   * @param baseUrl The base URL.
   * @returns The complete URL as a string.
   */
  buildUrl(e, n, a) {
    const r = Object.entries(n).filter(([s, u]) => u !== void 0).map(([s, u]) => [s, u.toString()]), i = new URLSearchParams(r);
    return `${a}/${e}?${i}`;
  }
  async _call(e) {
    const n = {
      q: e,
      ...this.params
    }, a = this.buildUrl("search", n, this.apiBase), r = await fetch(a, {
      method: "POST",
      headers: this.headers,
      signal: AbortSignal.timeout(5 * 1e3)
      // 5 seconds
    });
    if (!r.ok)
      throw new Error(r.statusText);
    const i = await r.json();
    if (!i.results.length && !i.answers.length && !i.infoboxes.length && !i.suggestions.length)
      return "No good results found.";
    if (i.results.length) {
      const s = [];
      return i.results.forEach((u) => {
        s.push(JSON.stringify({
          title: u.title || "",
          link: u.url || "",
          snippet: u.content || ""
        }));
      }), s.slice(0, this.params?.numResults).toString();
    } else {
      if (i.answers.length)
        return i.answers[0];
      if (i.infoboxes.length)
        return i.infoboxes[0]?.content.replaceAll(/<[^>]+>/gi, "");
      if (i.suggestions.length) {
        let s = "Suggestions: ";
        return i.suggestions.forEach((u) => {
          s += `${u}, `;
        }), s;
      } else
        return "No good results found.";
    }
  }
}
class oz extends fp {
  static lc_name() {
    return "WikipediaQueryRun";
  }
  constructor(e = {}) {
    super(), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "wikipedia-api"
    }), Object.defineProperty(this, "description", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "A tool for interacting with and fetching data from the Wikipedia API."
    }), Object.defineProperty(this, "topKResults", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "maxDocContentLength", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4e3
    }), Object.defineProperty(this, "baseUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "https://en.wikipedia.org/w/api.php"
    }), this.topKResults = e.topKResults ?? this.topKResults, this.maxDocContentLength = e.maxDocContentLength ?? this.maxDocContentLength, this.baseUrl = e.baseUrl ?? this.baseUrl;
  }
  async _call(e) {
    const n = await this._fetchSearchResults(e), a = [];
    for (let r = 0; r < Math.min(this.topKResults, n.query.search.length); r += 1) {
      const i = n.query.search[r].title, s = await this._fetchPage(i, !0);
      if (s) {
        const u = `Page: ${i}
Summary: ${s.extract}`;
        a.push(u);
      }
    }
    return a.length === 0 ? "No good Wikipedia Search Result was found" : a.join(`

`).slice(0, this.maxDocContentLength);
  }
  /**
   * Fetches the content of a specific Wikipedia page. It returns the
   * extracted content as a string.
   * @param page The specific Wikipedia page to fetch its content.
   * @param redirect A boolean value to indicate whether to redirect or not.
   * @returns The extracted content of the specific Wikipedia page as a string.
   */
  async content(e, n = !0) {
    try {
      return (await this._fetchPage(e, n)).extract;
    } catch (a) {
      throw new Error(`Failed to fetch content for page "${e}": ${a}`);
    }
  }
  /**
   * Builds a URL for the Wikipedia API using the provided parameters.
   * @param parameters The parameters to be used in building the URL.
   * @returns A string representing the built URL.
   */
  buildUrl(e) {
    const n = Object.entries(e).filter(([r, i]) => i !== void 0).map(([r, i]) => [r, `${i}`]), a = new URLSearchParams(n);
    return `${this.baseUrl}?${a}`;
  }
  async _fetchSearchResults(e) {
    const n = new URLSearchParams({
      action: "query",
      list: "search",
      srsearch: e,
      format: "json"
    }), a = await fetch(`${this.baseUrl}?${n.toString()}`);
    if (!a.ok)
      throw new Error("Network response was not ok");
    return await a.json();
  }
  async _fetchPage(e, n) {
    const a = new URLSearchParams({
      action: "query",
      prop: "extracts",
      explaintext: "true",
      redirects: n ? "1" : "0",
      format: "json",
      titles: e
    }), r = await fetch(`${this.baseUrl}?${a.toString()}`);
    if (!r.ok)
      throw new Error("Network response was not ok");
    const i = await r.json(), { pages: s } = i.query, u = Object.keys(s)[0];
    return s[u];
  }
}
const V$ = `You are given the below API Documentation:
{api_docs}
Using this documentation, generate the full API url to call for answering the user question.
You should build the API url in order to get a response that is as short as possible, while still getting the necessary information to answer the question. Pay attention to deliberately exclude any unnecessary pieces of data in the API call.

Question:{question}
API url:`, ex = /* @__PURE__ */ new He({
  inputVariables: ["api_docs", "question"],
  template: V$
}), tx = `${V$} {api_url}

Here is the response from the API:

{api_response}

Summarize this response to answer the original question.

Summary:`, nx = /* @__PURE__ */ new He({
  inputVariables: ["api_docs", "question", "api_url", "api_response"],
  template: tx
});
class U_ extends It {
  get inputKeys() {
    return [this.inputKey];
  }
  get outputKeys() {
    return [this.outputKey];
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "apiAnswerChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiRequestChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiDocs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "question"
    }), Object.defineProperty(this, "outputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "output"
    }), this.apiRequestChain = e.apiRequestChain, this.apiAnswerChain = e.apiAnswerChain, this.apiDocs = e.apiDocs, this.inputKey = e.inputKey ?? this.inputKey, this.outputKey = e.outputKey ?? this.outputKey, this.headers = e.headers ?? this.headers;
  }
  /** @ignore */
  async _call(e, n) {
    const a = e[this.inputKey], r = await this.apiRequestChain.predict({ question: a, api_docs: this.apiDocs }, n?.getChild("request")), s = await (await fetch(r, { headers: this.headers })).text(), u = await this.apiAnswerChain.predict({ question: a, api_docs: this.apiDocs, api_url: r, api_response: s }, n?.getChild("response"));
    return { [this.outputKey]: u };
  }
  _chainType() {
    return "api_chain";
  }
  static async deserialize(e) {
    const { api_request_chain: n, api_answer_chain: a, api_docs: r } = e;
    if (!n)
      throw new Error("LLMChain must have api_request_chain");
    if (!a)
      throw new Error("LLMChain must have api_answer_chain");
    if (!r)
      throw new Error("LLMChain must have api_docs");
    return new U_({
      apiAnswerChain: await tt.deserialize(a),
      apiRequestChain: await tt.deserialize(n),
      apiDocs: r
    });
  }
  serialize() {
    return {
      _type: this._chainType(),
      api_answer_chain: this.apiAnswerChain.serialize(),
      api_request_chain: this.apiRequestChain.serialize(),
      api_docs: this.apiDocs
    };
  }
  /**
   * Static method to create a new APIChain from a BaseLanguageModel and API
   * documentation.
   * @param llm BaseLanguageModel instance.
   * @param apiDocs API documentation.
   * @param options Optional configuration options for the APIChain.
   * @returns New APIChain instance.
   */
  static fromLLMAndAPIDocs(e, n, a = {}) {
    const { apiUrlPrompt: r = ex, apiResponsePrompt: i = nx } = a, s = new tt({ prompt: r, llm: e }), u = new tt({ prompt: i, llm: e });
    return new this({
      apiAnswerChain: u,
      apiRequestChain: s,
      apiDocs: n,
      ...a
    });
  }
}
const rx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  APIChain: U_
}, Symbol.toStringTag, { value: "Module" })), ax = `The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.

Current conversation:
{history}
Human: {input}
AI:`;
class uz extends tt {
  static lc_name() {
    return "ConversationChain";
  }
  constructor({ prompt: e, outputKey: n, memory: a, ...r }) {
    super({
      prompt: e ?? new He({
        template: ax,
        inputVariables: ["history", "input"]
      }),
      outputKey: n ?? "response",
      memory: a ?? new AU(),
      ...r
    });
  }
}
function Bj(t, e) {
  const n = /* @__PURE__ */ new Set();
  for (const a of e)
    t.has(a) && n.add(a);
  return n;
}
function ix(t, e) {
  const n = new Set(t);
  for (const a of e)
    n.add(a);
  return n;
}
function Uf(t, e) {
  const n = new Set(t);
  for (const a of e)
    n.delete(a);
  return n;
}
function wl(t) {
  return Array.from(t).map((e) => `"${e}"`).join(", ");
}
class B_ extends It {
  static lc_name() {
    return "SequentialChain";
  }
  get inputKeys() {
    return this.inputVariables;
  }
  get outputKeys() {
    return this.outputVariables;
  }
  constructor(e) {
    if (super(e), Object.defineProperty(this, "chains", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnAll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.chains = e.chains, this.inputVariables = e.inputVariables, this.outputVariables = e.outputVariables ?? [], this.outputVariables.length > 0 && e.returnAll)
      throw new Error("Either specify variables to return using `outputVariables` or use `returnAll` param. Cannot apply both conditions at the same time.");
    this.returnAll = e.returnAll ?? !1, this._validateChains();
  }
  /** @ignore */
  _validateChains() {
    if (this.chains.length === 0)
      throw new Error("Sequential chain must have at least one chain.");
    const e = this.memory?.memoryKeys ?? [], n = new Set(this.inputKeys), a = new Set(e), r = Bj(n, a);
    if (r.size > 0)
      throw new Error(`The following keys: ${wl(r)} are overlapping between memory and input keys of the chain variables. This can lead to unexpected behaviour. Please use input and memory keys that don't overlap.`);
    const i = ix(n, a);
    for (const s of this.chains) {
      let u = Uf(new Set(s.inputKeys), i);
      if (s.memory && (u = Uf(u, new Set(s.memory.memoryKeys))), u.size > 0)
        throw new Error(`Missing variables for chain "${s._chainType()}": ${wl(u)}. Only got the following variables: ${wl(i)}.`);
      const d = new Set(s.outputKeys), f = Bj(i, d);
      if (f.size > 0)
        throw new Error(`The following output variables for chain "${s._chainType()}" are overlapping: ${wl(f)}. This can lead to unexpected behaviour.`);
      for (const o of d)
        i.add(o);
    }
    if (this.outputVariables.length === 0)
      if (this.returnAll) {
        const s = Uf(i, n);
        this.outputVariables = Array.from(s);
      } else
        this.outputVariables = this.chains[this.chains.length - 1].outputKeys;
    else {
      const s = Uf(new Set(this.outputVariables), new Set(i));
      if (s.size > 0)
        throw new Error(`The following output variables were expected to be in the final chain output but were not found: ${wl(s)}.`);
    }
  }
  /** @ignore */
  async _call(e, n) {
    let a = {};
    const r = e;
    let i = 0;
    for (const u of this.chains) {
      i += 1, a = await u.call(r, n?.getChild(`step_${i}`));
      for (const d of Object.keys(a))
        r[d] = a[d];
    }
    const s = {};
    for (const u of this.outputVariables)
      s[u] = r[u];
    return s;
  }
  _chainType() {
    return "sequential_chain";
  }
  static async deserialize(e) {
    const n = [], a = e.input_variables, r = e.output_variables, i = e.chains;
    for (const s of i) {
      const u = await It.deserialize(s);
      n.push(u);
    }
    return new B_({ chains: n, inputVariables: a, outputVariables: r });
  }
  serialize() {
    const e = [];
    for (const n of this.chains)
      e.push(n.serialize());
    return {
      _type: this._chainType(),
      input_variables: this.inputVariables,
      output_variables: this.outputVariables,
      chains: e
    };
  }
}
class x_ extends It {
  static lc_name() {
    return "SimpleSequentialChain";
  }
  get inputKeys() {
    return [this.inputKey];
  }
  get outputKeys() {
    return [this.outputKey];
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "chains", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "input"
    }), Object.defineProperty(this, "outputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "output"
    }), Object.defineProperty(this, "trimOutputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.chains = e.chains, this.trimOutputs = e.trimOutputs ?? !1, this._validateChains();
  }
  /** @ignore */
  _validateChains() {
    for (const e of this.chains) {
      if (e.inputKeys.filter((n) => !e.memory?.memoryKeys.includes(n)).length !== 1)
        throw new Error(`Chains used in SimpleSequentialChain should all have one input, got ${e.inputKeys.length} for ${e._chainType()}.`);
      if (e.outputKeys.length !== 1)
        throw new Error(`Chains used in SimpleSequentialChain should all have one output, got ${e.outputKeys.length} for ${e._chainType()}.`);
    }
  }
  /** @ignore */
  async _call(e, n) {
    let a = e[this.inputKey], r = 0;
    for (const i of this.chains)
      r += 1, a = (await i.call({ [i.inputKeys[0]]: a, signal: e.signal }, n?.getChild(`step_${r}`)))[i.outputKeys[0]], this.trimOutputs && (a = a.trim()), await n?.handleText(a);
    return { [this.outputKey]: a };
  }
  _chainType() {
    return "simple_sequential_chain";
  }
  static async deserialize(e) {
    const n = [], a = e.chains;
    for (const r of a) {
      const i = await It.deserialize(r);
      n.push(i);
    }
    return new x_({ chains: n });
  }
  serialize() {
    const e = [];
    for (const n of this.chains)
      e.push(n.serialize());
    return {
      _type: this._chainType(),
      chains: e
    };
  }
}
const xj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SequentialChain: B_,
  SimpleSequentialChain: x_
}, Symbol.toStringTag, { value: "Module" }));
class z$ extends It {
  static lc_name() {
    return "AnalyzeDocumentChain";
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "input_document"
    }), Object.defineProperty(this, "combineDocumentsChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textSplitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.combineDocumentsChain = e.combineDocumentsChain, this.inputKey = e.inputKey ?? this.inputKey, this.textSplitter = e.textSplitter ?? new xh();
  }
  get inputKeys() {
    return [this.inputKey];
  }
  get outputKeys() {
    return this.combineDocumentsChain.outputKeys;
  }
  /** @ignore */
  async _call(e, n) {
    if (!(this.inputKey in e))
      throw new Error(`Document key ${this.inputKey} not found.`);
    const { [this.inputKey]: a, ...r } = e, i = a, u = { input_documents: await this.textSplitter.createDocuments([i]), ...r };
    return await this.combineDocumentsChain.call(u, n?.getChild("combine_documents"));
  }
  _chainType() {
    return "analyze_document_chain";
  }
  static async deserialize(e, n) {
    if (!("text_splitter" in n))
      throw new Error("Need to pass in a text_splitter to deserialize AnalyzeDocumentChain.");
    const { text_splitter: a } = n;
    if (!e.combine_document_chain)
      throw new Error("Need to pass in a combine_document_chain to deserialize AnalyzeDocumentChain.");
    return new z$({
      combineDocumentsChain: await It.deserialize(e.combine_document_chain),
      textSplitter: a
    });
  }
  serialize() {
    return {
      _type: this._chainType(),
      combine_document_chain: this.combineDocumentsChain.serialize()
    };
  }
}
const sx = `Given the following conversation and a follow up question, rephrase the follow up question to be a standalone question.

Chat History:
{chat_history}
Follow Up Input: {question}
Standalone question:`;
class Z$ extends It {
  static lc_name() {
    return "ConversationalRetrievalQAChain";
  }
  get inputKeys() {
    return [this.inputKey, this.chatHistoryKey];
  }
  get outputKeys() {
    return this.combineDocumentsChain.outputKeys.concat(this.returnSourceDocuments ? ["sourceDocuments"] : []);
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "question"
    }), Object.defineProperty(this, "chatHistoryKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "chat_history"
    }), Object.defineProperty(this, "retriever", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "combineDocumentsChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "questionGeneratorChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnSourceDocuments", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "returnGeneratedQuestion", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.retriever = e.retriever, this.combineDocumentsChain = e.combineDocumentsChain, this.questionGeneratorChain = e.questionGeneratorChain, this.inputKey = e.inputKey ?? this.inputKey, this.returnSourceDocuments = e.returnSourceDocuments ?? this.returnSourceDocuments, this.returnGeneratedQuestion = e.returnGeneratedQuestion ?? this.returnGeneratedQuestion;
  }
  /**
   * Static method to convert the chat history input into a formatted
   * string.
   * @param chatHistory Chat history input which can be a string, an array of BaseMessage instances, or an array of string arrays.
   * @returns A formatted string representing the chat history.
   */
  static getChatHistoryString(e) {
    let n;
    return Array.isArray(e) ? (Array.isArray(e[0]) && typeof e[0][0] == "string" ? (console.warn(`Passing chat history as an array of strings is deprecated.
Please see https://js.langchain.com/docs/modules/chains/popular/chat_vector_db#externally-managed-memory for more information.`), n = e.flat().map((a, r) => r % 2 === 0 ? new mr(a) : new At(a))) : n = e, n.map((a) => a._getType() === "human" ? `Human: ${a.content}` : a._getType() === "ai" ? `Assistant: ${a.content}` : `${a.content}`).join(`
`)) : e;
  }
  /** @ignore */
  async _call(e, n) {
    if (!(this.inputKey in e))
      throw new Error(`Question key ${this.inputKey} not found.`);
    if (!(this.chatHistoryKey in e))
      throw new Error(`Chat history key ${this.chatHistoryKey} not found.`);
    const a = e[this.inputKey], r = Z$.getChatHistoryString(e[this.chatHistoryKey]);
    let i = a;
    if (r.length > 0) {
      const f = await this.questionGeneratorChain.call({
        question: a,
        chat_history: r
      }, n?.getChild("question_generator")), o = Object.keys(f);
      if (o.length === 1)
        i = f[o[0]];
      else
        throw new Error("Return from llm chain has multiple values, only single values supported.");
    }
    const s = await this.retriever.getRelevantDocuments(i, n?.getChild("retriever")), u = {
      question: i,
      input_documents: s,
      chat_history: r
    };
    let d = await this.combineDocumentsChain.call(u, n?.getChild("combine_documents"));
    return this.returnSourceDocuments && (d = {
      ...d,
      sourceDocuments: s
    }), this.returnGeneratedQuestion && (d = {
      ...d,
      generatedQuestion: i
    }), d;
  }
  _chainType() {
    return "conversational_retrieval_chain";
  }
  static async deserialize(e, n) {
    throw new Error("Not implemented.");
  }
  serialize() {
    throw new Error("Not implemented.");
  }
  /**
   * Static method to create a new ConversationalRetrievalQAChain from a
   * BaseLanguageModel and a BaseRetriever.
   * @param llm {@link BaseLanguageModelInterface} instance used to generate a new question.
   * @param retriever {@link BaseRetrieverInterface} instance used to retrieve relevant documents.
   * @param options.returnSourceDocuments Whether to return source documents in the final output
   * @param options.questionGeneratorChainOptions Options to initialize the standalone question generation chain used as the first internal step
   * @param options.qaChainOptions {@link QAChainParams} used to initialize the QA chain used as the second internal step
   * @returns A new instance of ConversationalRetrievalQAChain.
   */
  static fromLLM(e, n, a = {}) {
    const { questionGeneratorTemplate: r, qaTemplate: i, qaChainOptions: s = {
      type: "stuff",
      prompt: i ? He.fromTemplate(i) : void 0
    }, questionGeneratorChainOptions: u, verbose: d, ...f } = a, o = FB(e, s), c = He.fromTemplate(u?.template ?? r ?? sx), h = new tt({
      prompt: c,
      llm: u?.llm ?? e,
      verbose: d
    });
    return new this({
      retriever: n,
      combineDocumentsChain: o,
      questionGeneratorChain: h,
      verbose: d,
      ...f
    });
  }
}
class cz extends It {
  static lc_name() {
    return "RetrievalQAChain";
  }
  get inputKeys() {
    return [this.inputKey];
  }
  get outputKeys() {
    return this.combineDocumentsChain.outputKeys.concat(this.returnSourceDocuments ? ["sourceDocuments"] : []);
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "inputKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "query"
    }), Object.defineProperty(this, "retriever", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "combineDocumentsChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "returnSourceDocuments", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.retriever = e.retriever, this.combineDocumentsChain = e.combineDocumentsChain, this.inputKey = e.inputKey ?? this.inputKey, this.returnSourceDocuments = e.returnSourceDocuments ?? this.returnSourceDocuments;
  }
  /** @ignore */
  async _call(e, n) {
    if (!(this.inputKey in e))
      throw new Error(`Question key "${this.inputKey}" not found.`);
    const a = e[this.inputKey], r = await this.retriever.getRelevantDocuments(a, n?.getChild("retriever")), i = { question: a, input_documents: r, ...e }, s = await this.combineDocumentsChain.call(i, n?.getChild("combine_documents"));
    return this.returnSourceDocuments ? {
      ...s,
      sourceDocuments: r
    } : s;
  }
  _chainType() {
    return "retrieval_qa";
  }
  static async deserialize(e, n) {
    throw new Error("Not implemented");
  }
  serialize() {
    throw new Error("Not implemented");
  }
  /**
   * Creates a new instance of RetrievalQAChain using a BaseLanguageModel
   * and a BaseRetriever.
   * @param llm The BaseLanguageModel used to generate a new question.
   * @param retriever The BaseRetriever used to retrieve relevant documents.
   * @param options Optional parameters for the RetrievalQAChain.
   * @returns A new instance of RetrievalQAChain.
   */
  static fromLLM(e, n, a) {
    const r = D_(e, {
      prompt: a?.prompt
    });
    return new this({
      ...a,
      retriever: n,
      combineDocumentsChain: r
    });
  }
}
class lz extends It {
  static lc_name() {
    return "TransformChain";
  }
  _chainType() {
    return "transform";
  }
  get inputKeys() {
    return this.inputVariables;
  }
  get outputKeys() {
    return this.outputVariables;
  }
  constructor(e) {
    super(e), Object.defineProperty(this, "transformFunc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputVariables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.transformFunc = e.transform, this.inputVariables = e.inputVariables, this.outputVariables = e.outputVariables;
  }
  async _call(e, n) {
    return this.transformFunc(e, n?.getChild("transform"));
  }
}
class ru extends Error {
  constructor(e, n) {
    let a = e ?? "";
    n?.lc_error_code && (a = `${a}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${n.lc_error_code}/
`), super(a), Object.defineProperty(this, "lc_error_code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.lc_error_code = n?.lc_error_code;
  }
}
class K$ extends ru {
  get is_bubble_up() {
    return !0;
  }
}
class ox extends ru {
  constructor(e, n) {
    super(e, n), this.name = "GraphRecursionError";
  }
  static get unminifiable_name() {
    return "GraphRecursionError";
  }
}
class Vj extends ru {
  constructor(e, n) {
    super(e, n), this.name = "GraphValueError";
  }
  static get unminifiable_name() {
    return "GraphValueError";
  }
}
class zl extends K$ {
  constructor(e, n) {
    super(JSON.stringify(e, null, 2), n), Object.defineProperty(this, "interrupts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "GraphInterrupt", this.interrupts = e ?? [];
  }
  static get unminifiable_name() {
    return "GraphInterrupt";
  }
}
class H$ extends zl {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e, n) {
    super([
      {
        value: e,
        when: "during"
      }
    ], n), this.name = "NodeInterrupt";
  }
  static get unminifiable_name() {
    return "NodeInterrupt";
  }
}
class G$ extends K$ {
  constructor(e) {
    super(), Object.defineProperty(this, "command", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "ParentCommand", this.command = e;
  }
  static get unminifiable_name() {
    return "ParentCommand";
  }
}
function ux(t) {
  return t !== void 0 && t.name === G$.unminifiable_name;
}
function th(t) {
  return t !== void 0 && t.is_bubble_up === !0;
}
function Nl(t) {
  return t !== void 0 && [
    zl.unminifiable_name,
    H$.unminifiable_name
  ].includes(t.name);
}
class zj extends ru {
  constructor(e, n) {
    super(e, n), this.name = "EmptyInputError";
  }
  static get unminifiable_name() {
    return "EmptyInputError";
  }
}
class sn extends ru {
  constructor(e, n) {
    super(e, n), this.name = "EmptyChannelError";
  }
  static get unminifiable_name() {
    return "EmptyChannelError";
  }
}
class nt extends ru {
  constructor(e, n) {
    super(e, n), this.name = "InvalidUpdateError";
  }
  static get unminifiable_name() {
    return "InvalidUpdateError";
  }
}
class cx extends ru {
  constructor(e, n) {
    super(e, n), this.name = "UnreachableNodeError";
  }
  static get unminifiable_name() {
    return "UnreachableNodeError";
  }
}
function W$(t) {
  return n1({ clockseq: t });
}
function Iu(t, e) {
  const n = e.replace(/-/g, "").match(/.{2}/g).map((a) => parseInt(a, 16));
  return QI(t, new Uint8Array(n));
}
const lx = "__error__", nh = "__scheduled__", dx = "__interrupt__", fx = "__resume__";
function V_(t) {
  if (typeof t != "object" || t === null)
    return t;
  const e = Array.isArray(t) ? [] : {};
  for (const n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = V_(t[n]));
  return e;
}
function X$() {
  return {
    v: 1,
    id: W$(-2),
    ts: (/* @__PURE__ */ new Date()).toISOString(),
    channel_values: {},
    channel_versions: {},
    versions_seen: {},
    pending_sends: []
  };
}
function Vh(t) {
  return {
    v: t.v,
    id: t.id,
    ts: t.ts,
    channel_values: { ...t.channel_values },
    channel_versions: { ...t.channel_versions },
    versions_seen: V_(t.versions_seen),
    pending_sends: [...t.pending_sends]
  };
}
function Q$(t, e) {
  return typeof t == "number" && typeof e == "number" ? Math.sign(t - e) : String(t).localeCompare(String(e));
}
function Zj(...t) {
  return t.reduce((e, n, a) => a === 0 ? n : Q$(e, n) >= 0 ? e : n);
}
const Kj = {
  [lx]: -1,
  [nh]: -2,
  [dx]: -3,
  [fx]: -4
};
class Sl extends Error {
  constructor(e) {
    super(e), this.name = "InvalidNamespaceError";
  }
}
function hx(t) {
  if (t.length === 0)
    throw new Sl("Namespace cannot be empty.");
  for (const e of t) {
    if (typeof e != "string")
      throw new Sl(`Invalid namespace label '${e}' found in ${t}. Namespace labels must be strings, but got ${typeof e}.`);
    if (e.includes("."))
      throw new Sl(`Invalid namespace label '${e}' found in ${t}. Namespace labels cannot contain periods ('.').`);
    if (e === "")
      throw new Sl(`Namespace labels cannot be empty strings. Got ${e} in ${t}`);
  }
  if (t[0] === "langgraph")
    throw new Sl(`Root label for namespace cannot be "langgraph". Got: ${t}`);
}
class px {
  /**
   * Retrieve a single item by its namespace and key.
   *
   * @param namespace Hierarchical path for the item
   * @param key Unique identifier within the namespace
   * @returns Promise resolving to the item or null if not found
   */
  async get(e, n) {
    return (await this.batch([{ namespace: e, key: n }]))[0];
  }
  /**
   * Search for items within a namespace prefix.
   * Supports both metadata filtering and vector similarity search.
   *
   * @param namespacePrefix Hierarchical path prefix to search within
   * @param options Search options for filtering and pagination
   * @returns Promise resolving to list of matching items with relevance scores
   *
   * @example
   * // Search with filters
   * await store.search(["documents"], {
   *   filter: { type: "report", status: "active" },
   *   limit: 5,
   *   offset: 10
   * });
   *
   * // Vector similarity search
   * await store.search(["users", "content"], {
   *   query: "technical documentation about APIs",
   *   limit: 20
   * });
   */
  async search(e, n = {}) {
    const { filter: a, limit: r = 10, offset: i = 0, query: s } = n;
    return (await this.batch([
      {
        namespacePrefix: e,
        filter: a,
        limit: r,
        offset: i,
        query: s
      }
    ]))[0];
  }
  /**
   * Store or update an item.
   *
   * @param namespace Hierarchical path for the item
   * @param key Unique identifier within the namespace
   * @param value Object containing the item's data
   * @param index Optional indexing configuration
   *
   * @example
   * // Simple storage
   * await store.put(["docs"], "report", { title: "Annual Report" });
   *
   * // With specific field indexing
   * await store.put(
   *   ["docs"],
   *   "report",
   *   {
   *     title: "Q4 Report",
   *     chapters: [{ content: "..." }, { content: "..." }]
   *   },
   *   ["title", "chapters[*].content"]
   * );
   */
  async put(e, n, a, r) {
    hx(e), await this.batch([{ namespace: e, key: n, value: a, index: r }]);
  }
  /**
   * Delete an item from the store.
   *
   * @param namespace Hierarchical path for the item
   * @param key Unique identifier within the namespace
   */
  async delete(e, n) {
    await this.batch([{ namespace: e, key: n, value: null }]);
  }
  /**
   * List and filter namespaces in the store.
   * Used to explore data organization and navigate the namespace hierarchy.
   *
   * @param options Options for listing namespaces
   * @returns Promise resolving to list of namespace paths
   *
   * @example
   * // List all namespaces under "documents"
   * await store.listNamespaces({
   *   prefix: ["documents"],
   *   maxDepth: 2
   * });
   *
   * // List namespaces ending with "v1"
   * await store.listNamespaces({
   *   suffix: ["v1"],
   *   limit: 50
   * });
   */
  async listNamespaces(e = {}) {
    const { prefix: n, suffix: a, maxDepth: r, limit: i = 100, offset: s = 0 } = e, u = [];
    return n && u.push({ matchType: "prefix", path: n }), a && u.push({ matchType: "suffix", path: a }), (await this.batch([
      {
        matchConditions: u.length ? u : void 0,
        maxDepth: r,
        limit: i,
        offset: s
      }
    ]))[0];
  }
  /**
   * Start the store. Override if initialization is needed.
   */
  start() {
  }
  /**
   * Stop the store. Override if cleanup is needed.
   */
  stop() {
  }
}
class mx extends px {
  constructor(e) {
    super(), Object.defineProperty(this, "store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "nextKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "running", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "processingTask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), this.store = e;
  }
  get isRunning() {
    return this.running;
  }
  /**
   * @ignore
   * Batch is not implemented here as we're only extending `BaseStore`
   * to allow it to be passed where `BaseStore` is expected, and implement
   * the convenience methods (get, search, put, delete).
   */
  async batch(e) {
    throw new Error("The `batch` method is not implemented on `AsyncBatchedStore`.\n Instead, it calls the `batch` method on the wrapped store.\n If you are seeing this error, something is wrong.");
  }
  async get(e, n) {
    return this.enqueueOperation({ namespace: e, key: n });
  }
  async search(e, n) {
    const { filter: a, limit: r = 10, offset: i = 0, query: s } = n || {};
    return this.enqueueOperation({
      namespacePrefix: e,
      filter: a,
      limit: r,
      offset: i,
      query: s
    });
  }
  async put(e, n, a) {
    return this.enqueueOperation({ namespace: e, key: n, value: a });
  }
  async delete(e, n) {
    return this.enqueueOperation({
      namespace: e,
      key: n,
      value: null
    });
  }
  start() {
    this.running || (this.running = !0, this.processingTask = this.processBatchQueue());
  }
  async stop() {
    this.running = !1, this.processingTask && await this.processingTask;
  }
  enqueueOperation(e) {
    return new Promise((n, a) => {
      const r = this.nextKey;
      this.nextKey += 1, this.queue.set(r, { operation: e, resolve: n, reject: a });
    });
  }
  async processBatchQueue() {
    for (; this.running; ) {
      if (await new Promise((n) => {
        setTimeout(n, 0);
      }), this.queue.size === 0)
        continue;
      const e = new Map(this.queue);
      this.queue.clear();
      try {
        const n = Array.from(e.values()).map(({ operation: r }) => r), a = await this.store.batch(n);
        e.forEach(({ resolve: r }, i) => {
          const s = Array.from(e.keys()).indexOf(i);
          r(a[s]);
        });
      } catch (n) {
        e.forEach(({ reject: a }) => {
          a(n);
        });
      }
    }
  }
  // AsyncBatchedStore is internal and gets passed as args into traced tasks
  // some BaseStores contain circular references so just serialize without it
  // as this causes warnings when tracing with LangSmith.
  toJSON() {
    return {
      queue: this.queue,
      nextKey: this.nextKey,
      running: this.running,
      store: "[LangGraphStore]"
    };
  }
}
function Fp(t) {
  return t != null && t.lg_is_channel === !0;
}
class kp {
  constructor() {
    Object.defineProperty(this, "ValueType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "UpdateType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lg_is_channel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    });
  }
  /**
   * Mark the current value of the channel as consumed. By default, no-op.
   * This is called by Pregel before the start of the next step, for all
   * channels that triggered a node. If the channel was updated, return true.
   */
  consume() {
    return !1;
  }
}
function zh(t, e) {
  const n = Object.fromEntries(Object.entries(t).filter(([, r]) => Fp(r))), a = {};
  for (const r in n)
    if (Object.prototype.hasOwnProperty.call(n, r)) {
      const i = e.channel_values[r];
      a[r] = n[r].fromCheckpoint(i);
    }
  return a;
}
function Eo(t, e, n) {
  let a;
  if (e === void 0)
    a = t.channel_values;
  else {
    a = {};
    for (const r of Object.keys(e))
      try {
        a[r] = e[r].checkpoint();
      } catch (i) {
        if (i.name !== sn.unminifiable_name) throw i;
      }
  }
  return {
    v: 1,
    id: W$(n),
    ts: (/* @__PURE__ */ new Date()).toISOString(),
    channel_values: a,
    channel_versions: { ...t.channel_versions },
    versions_seen: V_(t.versions_seen),
    pending_sends: t.pending_sends ?? []
  };
}
class gd extends kp {
  constructor(e, n) {
    super(), Object.defineProperty(this, "lc_graph_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BinaryOperatorAggregate"
    }), Object.defineProperty(this, "value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "operator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "initialValueFactory", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.operator = e, this.initialValueFactory = n, this.value = n?.();
  }
  fromCheckpoint(e) {
    const n = new gd(this.operator, this.initialValueFactory);
    return e && (n.value = e), n;
  }
  update(e) {
    let n = e;
    if (!n.length)
      return !1;
    this.value === void 0 && ([this.value] = n, n = n.slice(1));
    for (const a of n)
      this.value !== void 0 && (this.value = this.operator(this.value, a));
    return !0;
  }
  get() {
    if (this.value === void 0)
      throw new sn();
    return this.value;
  }
  checkpoint() {
    if (this.value === void 0)
      throw new sn();
    return this.value;
  }
}
class Dp extends kp {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lc_graph_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "LastValue"
    }), Object.defineProperty(this, "value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  fromCheckpoint(e) {
    const n = new Dp();
    return e && (n.value = [e]), n;
  }
  update(e) {
    if (e.length === 0)
      return !1;
    if (e.length !== 1)
      throw new nt("LastValue can only receive one value per step.", {
        lc_error_code: "INVALID_CONCURRENT_GRAPH_UPDATE"
      });
    return this.value = [e[e.length - 1]], !0;
  }
  get() {
    if (this.value.length === 0)
      throw new sn();
    return this.value[0];
  }
  checkpoint() {
    if (this.value.length === 0)
      throw new sn();
    return this.value[0];
  }
}
const Ke = "__start__", Me = "__end__", Fs = "__input__", bx = "__copy__", jn = "__error__", Ls = "__pregel_send", Qb = "__pregel_call", Lo = "__pregel_read", mt = "__pregel_checkpointer", to = "__pregel_resuming", Zl = "__pregel_task_id", Zh = "__pregel_stream", gx = "__pregel_resume_value", Uo = "__pregel_scratchpad", rh = "__pregel_previous", _x = "checkpoint_id", Yb = "checkpoint_ns", yx = "__pregel_node_finished", Dn = "checkpoint_map", at = "__interrupt__", Bn = "__resume__", z_ = "__no_writes__", _d = "__return__", eb = "__previous__", _u = "__pregel_runtime_placeholder__", lt = "langsmith:hidden", vx = "langsmith:nostream", eg = "__self__", Zu = "__pregel_tasks", Kt = "__pregel_push", ah = "__pregel_pull", Jn = "00000000-0000-0000-0000-000000000000", wx = [
  lt,
  Fs,
  at,
  Bn,
  jn,
  z_,
  Zu,
  // reserved config.configurable keys
  Ls,
  Lo,
  mt,
  Zh,
  to,
  Zl,
  Qb,
  gx,
  Uo,
  rh,
  Dn,
  Yb,
  _x
], rn = "|", Bo = ":";
function tg(t) {
  const e = t;
  return e != null && typeof e.node == "string" && e.args !== void 0;
}
class Kh {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e, n) {
    Object.defineProperty(this, "lg_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Send"
    }), Object.defineProperty(this, "node", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.node = e, this.args = yd(n);
  }
  toJSON() {
    return {
      lg_name: this.lg_name,
      node: this.node,
      args: this.args
    };
  }
}
function Pn(t) {
  return t instanceof Kh;
}
class lr {
  constructor(e) {
    Object.defineProperty(this, "lg_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Command"
    }), Object.defineProperty(this, "lc_direct_tool_output", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "graph", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "update", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "resume", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "goto", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this.resume = e.resume, this.graph = e.graph, this.update = e.update, e.goto && (this.goto = Array.isArray(e.goto) ? yd(e.goto) : [yd(e.goto)]);
  }
  /**
   * Convert the update field to a list of {@link PendingWrite} tuples
   * @returns List of {@link PendingWrite} tuples of the form `[channelKey, value]`.
   * @internal
   */
  _updateAsTuples() {
    return this.update && typeof this.update == "object" && !Array.isArray(this.update) ? Object.entries(this.update) : Array.isArray(this.update) && this.update.every((e) => Array.isArray(e) && e.length === 2 && typeof e[0] == "string") ? this.update : [["__root__", this.update]];
  }
  toJSON() {
    let e;
    return typeof this.goto == "string" ? e = this.goto : Pn(this.goto) ? e = this.goto.toJSON() : e = this.goto?.map((n) => typeof n == "string" ? n : n.toJSON()), {
      lg_name: this.lg_name,
      update: this.update,
      resume: this.resume,
      goto: e
    };
  }
}
Object.defineProperty(lr, "PARENT", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "__parent__"
});
function qn(t) {
  return typeof t != "object" || t == null ? !1 : "lg_name" in t && t.lg_name === "Command";
}
function yd(t, e = /* @__PURE__ */ new Map()) {
  if (t != null && typeof t == "object") {
    if (e.has(t))
      return e.get(t);
    let n;
    if (Array.isArray(t))
      n = [], e.set(t, n), t.forEach((a, r) => {
        n[r] = yd(a, e);
      });
    else if (qn(t) && !(t instanceof lr))
      n = new lr(t), e.set(t, n);
    else if (tg(t) && !(t instanceof Kh))
      n = new Kh(t.node, t.args), e.set(t, n);
    else if (qn(t) || Pn(t))
      n = t, e.set(t, n);
    else {
      n = {}, e.set(t, n);
      for (const [a, r] of Object.entries(t))
        n[a] = yd(r, e);
    }
    return n;
  }
  return t;
}
class Sx {
  constructor(e, n) {
    Object.defineProperty(this, "runtime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_promises", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "lg_is_managed_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.config = e;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static async initialize(e, n) {
    throw new Error("Not implemented");
  }
  async promises() {
    return Promise.all(this._promises);
  }
  addPromise(e) {
    this._promises.push(e);
  }
}
const Ox = "__channel_key_placeholder__";
class jx extends Map {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e) {
    super(e ? Array.from(e) : void 0);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  replaceRuntimeValues(e, n) {
    if (!(this.size === 0 || !n) && !Array.from(this.values()).every((a) => !a.runtime)) {
      if (typeof n == "object" && !Array.isArray(n))
        for (const [a, r] of Object.entries(n))
          for (const [i, s] of this.entries())
            s.runtime && s.call(e) === r && (n[a] = { [_u]: i });
      else if (typeof n == "object" && "constructor" in n)
        for (const a of Object.getOwnPropertyNames(Object.getPrototypeOf(n)))
          try {
            const r = n[a];
            for (const [i, s] of this.entries())
              s.runtime && s.call(e) === r && (n[a] = { [_u]: i });
          } catch (r) {
            if (r.name !== TypeError.name)
              throw r;
          }
    }
  }
  replaceRuntimePlaceholders(e, n) {
    if (!(this.size === 0 || !n) && !Array.from(this.values()).every((a) => !a.runtime)) {
      if (typeof n == "object" && !Array.isArray(n)) {
        for (const [a, r] of Object.entries(n))
          if (typeof r == "object" && r !== null && _u in r) {
            const i = r[_u];
            typeof i == "string" && (n[a] = this.get(i)?.call(e));
          }
      } else if (typeof n == "object" && "constructor" in n)
        for (const a of Object.getOwnPropertyNames(Object.getPrototypeOf(n)))
          try {
            const r = n[a];
            if (typeof r == "object" && r !== null && _u in r) {
              const i = this.get(r[_u]);
              i && (n[a] = i.call(e));
            }
          } catch (r) {
            if (r.name !== TypeError.name)
              throw r;
          }
    }
  }
}
function Z_(t) {
  return !!(typeof t == "object" && t && "cls" in t && "params" in t);
}
class K_ extends Sx {
  call() {
  }
  static async initialize(e, n) {
    return Promise.resolve(new K_(e));
  }
}
function Hj(t) {
  return typeof t == "object" && t && "reducer" in t && t.reducer ? new gd(t.reducer, t.default) : typeof t == "object" && t && "value" in t && t.value ? new gd(t.value, t.default) : new Dp();
}
const Px = ["tags", "metadata", "callbacks", "configurable"], Cx = [
  "tags",
  "metadata",
  "callbacks",
  "runName",
  "maxConcurrency",
  "recursionLimit",
  "configurable",
  "runId",
  "outputKeys",
  "streamMode",
  "store",
  "writer",
  "interruptBefore",
  "interruptAfter",
  "signal"
], Rx = 25;
function Y$(...t) {
  const e = {
    tags: [],
    metadata: {},
    callbacks: void 0,
    recursionLimit: Rx,
    configurable: {}
  }, n = Ln.getRunnableConfig();
  if (n !== void 0) {
    for (const [a, r] of Object.entries(n))
      if (r !== void 0)
        if (Px.includes(a)) {
          let i;
          Array.isArray(r) ? i = [...r] : typeof r == "object" ? a === "callbacks" && "copy" in r && typeof r.copy == "function" ? i = r.copy() : i = { ...r } : i = r, e[a] = i;
        } else
          e[a] = r;
  }
  for (const a of t)
    if (a !== void 0)
      for (const [r, i] of Object.entries(a))
        i !== void 0 && Cx.includes(r) && (e[r] = i);
  for (const [a, r] of Object.entries(e.configurable))
    e.metadata = e.metadata ?? {}, !a.startsWith("__") && (typeof r == "string" || typeof r == "number" || typeof r == "boolean") && !(a in e.metadata) && (e.metadata[a] = r);
  return e;
}
function tb(t) {
  return t.split(rn).filter((e) => !e.match(/^\d+$/)).map((e) => e.split(Bo)[0]).join(rn);
}
function Tx(t) {
  const e = t.split(rn);
  for (; e.length > 1 && e[e.length - 1].match(/^\d+$/); )
    e.pop();
  return e.slice(0, -1).join(rn);
}
class au extends Te {
  constructor(e) {
    super(), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langgraph"]
    }), Object.defineProperty(this, "func", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "trace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "recurse", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.name = e.name ?? e.func.name, this.func = e.func, this.config = e.tags ? { tags: e.tags } : void 0, this.trace = e.trace ?? this.trace, this.recurse = e.recurse ?? this.recurse;
  }
  async _tracedInvoke(e, n, a) {
    return new Promise((r, i) => {
      const s = Qe(n, {
        callbacks: a?.getChild()
      });
      Ln.runWithConfig(s, async () => {
        try {
          const u = await this.func(e, s);
          r(u);
        } catch (u) {
          i(u);
        }
      });
    });
  }
  async invoke(e, n) {
    let a;
    const r = Y$(n), i = aa(this.config, r);
    return this.trace ? a = await this._callWithConfig(this._tracedInvoke, e, i) : a = await Ln.runWithConfig(i, async () => this.func(e, i)), Te.isRunnable(a) && this.recurse ? await Ln.runWithConfig(i, async () => a.invoke(e, i)) : a;
  }
}
function* Ys(t, e) {
  if (e === void 0)
    yield* t;
  else
    for (const n of t)
      yield [e, n];
}
async function ao(t) {
  const e = [];
  for await (const n of await t)
    e.push(n);
  return e;
}
function Fl(t) {
  const e = [];
  for (const n of t)
    e.push(n);
  return e;
}
function Ol(t, e) {
  return t ? "configurable" in t ? {
    ...t,
    configurable: {
      ...t.configurable,
      ...e
    }
  } : {
    ...t,
    configurable: e
  } : {
    configurable: e
  };
}
function $x(t) {
  return typeof t == "object" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  t?.[Symbol.for("LG_SKIP_WRITE")] !== void 0;
}
const xo = {
  [Symbol.for("LG_PASSTHROUGH")]: !0
};
function Bf(t) {
  return typeof t == "object" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  t?.[Symbol.for("LG_PASSTHROUGH")] !== void 0;
}
const nb = Symbol("IS_WRITER");
class Ct extends au {
  constructor(e, n) {
    const a = `ChannelWrite<${e.map((r) => Pn(r) ? r.node : "channel" in r ? r.channel : "...").join(",")}>`;
    super({
      writes: e,
      name: a,
      tags: n,
      func: async (r, i) => this._write(r, i ?? {})
    }), Object.defineProperty(this, "writes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.writes = e;
  }
  async _write(e, n) {
    const a = this.writes.map((r) => rb(r) && Bf(r.value) ? {
      mapper: r.mapper,
      value: e
    } : ih(r) && Bf(r.value) ? {
      channel: r.channel,
      value: e,
      skipNone: r.skipNone,
      mapper: r.mapper
    } : r);
    return await Ct.doWrite(n, a), e;
  }
  // TODO: Support requireAtLeastOneOf
  static async doWrite(e, n) {
    for (const i of n) {
      if (ih(i)) {
        if (i.channel === Zu)
          throw new nt("Cannot write to the reserved channel TASKS");
        if (Bf(i.value))
          throw new nt("PASSTHROUGH value must be replaced");
      }
      if (rb(i) && Bf(i.value))
        throw new nt("PASSTHROUGH value must be replaced");
    }
    const a = [];
    for (const i of n)
      if (Pn(i))
        a.push([Zu, i]);
      else if (rb(i)) {
        const s = await i.mapper.invoke(i.value, e);
        s != null && s.length > 0 && a.push(...s);
      } else if (ih(i)) {
        const s = i.mapper !== void 0 ? await i.mapper.invoke(i.value, e) : i.value;
        if ($x(s) || i.skipNone && s === void 0)
          continue;
        a.push([i.channel, s]);
      } else
        throw new Error(`Invalid write entry: ${JSON.stringify(i)}`);
    const r = e.configurable?.[Ls];
    r(a);
  }
  static isWriter(e) {
    return (
      // eslint-disable-next-line no-instanceof/no-instanceof
      e instanceof Ct || nb in e && !!e[nb]
    );
  }
  static registerWriter(e) {
    return Object.defineProperty(e, nb, { value: !0 });
  }
}
function ih(t) {
  return t !== void 0 && typeof t.channel == "string";
}
function rb(t) {
  return t !== void 0 && !ih(t) && Te.isRunnable(t.mapper);
}
class H_ extends au {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e, n, a = !1) {
    super({
      func: (r, i) => H_.doRead(i, this.channel, this.fresh, this.mapper)
    }), Object.defineProperty(this, "lc_graph_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChannelRead"
    }), Object.defineProperty(this, "channel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fresh", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "mapper", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.fresh = a, this.mapper = n, this.channel = e, this.name = Array.isArray(e) ? `ChannelRead<${e.join(",")}>` : `ChannelRead<${e}>`;
  }
  static doRead(e, n, a, r) {
    const i = e.configurable?.[Lo];
    if (!i)
      throw new Error(`Runnable ${this} is not configured with a read function. Make sure to call in the context of a Pregel process`);
    return r ? r(i(n, a)) : i(n, a);
  }
}
const yu = /* @__PURE__ */ new Ut();
class ia extends oo {
  constructor(e) {
    const { channels: n, triggers: a, mapper: r, writers: i, bound: s, kwargs: u, metadata: d, retryPolicy: f, tags: o, subgraphs: c, ends: h } = e, p = [
      ...e.config?.tags ? e.config.tags : [],
      ...o ?? []
    ];
    super({
      ...e,
      bound: e.bound ?? yu,
      config: {
        ...e.config ? e.config : {},
        tags: p
      }
    }), Object.defineProperty(this, "lc_graph_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "PregelNode"
    }), Object.defineProperty(this, "channels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "triggers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "mapper", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "writers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "bound", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: yu
    }), Object.defineProperty(this, "kwargs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "retryPolicy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subgraphs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ends", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.channels = n, this.triggers = a, this.mapper = r, this.writers = i ?? this.writers, this.bound = s ?? this.bound, this.kwargs = u ?? this.kwargs, this.metadata = d ?? this.metadata, this.tags = p, this.retryPolicy = f, this.subgraphs = c, this.ends = h;
  }
  getWriters() {
    const e = [...this.writers];
    for (; e.length > 1 && // eslint-disable-next-line no-instanceof/no-instanceof
    e[e.length - 1] instanceof Ct && // eslint-disable-next-line no-instanceof/no-instanceof
    e[e.length - 2] instanceof Ct; ) {
      const n = e.slice(-2), a = n[0].writes.concat(n[1].writes);
      e[e.length - 2] = new Ct(a, n[0].config?.tags), e.pop();
    }
    return e;
  }
  getNode() {
    const e = this.getWriters();
    if (!(this.bound === yu && e.length === 0))
      return this.bound === yu && e.length === 1 ? e[0] : this.bound === yu ? new gt({
        first: e[0],
        middle: e.slice(1, e.length - 1),
        last: e[e.length - 1],
        omitSequenceTags: !0
      }) : e.length > 0 ? new gt({
        first: this.bound,
        middle: e.slice(0, e.length - 1),
        last: e[e.length - 1],
        omitSequenceTags: !0
      }) : this.bound;
  }
  join(e) {
    if (!Array.isArray(e))
      throw new Error("channels must be a list");
    if (typeof this.channels != "object")
      throw new Error("all channels must be named when using .join()");
    return new ia({
      channels: {
        ...this.channels,
        ...Object.fromEntries(e.map((n) => [n, n]))
      },
      triggers: this.triggers,
      mapper: this.mapper,
      writers: this.writers,
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      retryPolicy: this.retryPolicy
    });
  }
  pipe(e) {
    return Ct.isWriter(e) ? new ia({
      channels: this.channels,
      triggers: this.triggers,
      mapper: this.mapper,
      writers: [...this.writers, e],
      bound: this.bound,
      config: this.config,
      kwargs: this.kwargs,
      retryPolicy: this.retryPolicy
    }) : this.bound === yu ? new ia({
      channels: this.channels,
      triggers: this.triggers,
      mapper: this.mapper,
      writers: this.writers,
      bound: Sn(e),
      config: this.config,
      kwargs: this.kwargs,
      retryPolicy: this.retryPolicy
    }) : new ia({
      channels: this.channels,
      triggers: this.triggers,
      mapper: this.mapper,
      writers: this.writers,
      bound: this.bound.pipe(e),
      config: this.config,
      kwargs: this.kwargs,
      retryPolicy: this.retryPolicy
    });
  }
}
class Ms extends Error {
  constructor(e) {
    super(e), this.name = "GraphValidationError";
  }
}
function Mx({ nodes: t, channels: e, inputChannels: n, outputChannels: a, streamChannels: r, interruptAfterNodes: i, interruptBeforeNodes: s }) {
  if (!e)
    throw new Ms("Channels not provided");
  const u = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Set();
  for (const [f, o] of Object.entries(t)) {
    if (f === at)
      throw new Ms(`"Node name ${at} is reserved"`);
    if (o.constructor === ia)
      o.triggers.forEach((c) => u.add(c));
    else
      throw new Ms(`Invalid node type ${typeof o}, expected PregelNode`);
  }
  for (const f of u)
    if (!(f in e))
      throw new Ms(`Subcribed channel '${String(f)}' not in channels`);
  if (Array.isArray(n)) {
    if (n.every((f) => !u.has(f)))
      throw new Ms(`None of the input channels ${n} are subscribed to by any node`);
  } else if (!u.has(n))
    throw new Ms(`Input channel ${String(n)} is not subscribed to by any node`);
  Array.isArray(a) ? a.forEach((f) => d.add(f)) : d.add(a), r && !Array.isArray(r) ? d.add(r) : Array.isArray(r) && r.forEach((f) => d.add(f));
  for (const f of d)
    if (!(f in e))
      throw new Ms(`Output channel '${String(f)}' not in channels`);
  if (i && i !== "*") {
    for (const f of i)
      if (!(f in t))
        throw new Ms(`Node ${String(f)} not in nodes`);
  }
  if (s && s !== "*") {
    for (const f of s)
      if (!(f in t))
        throw new Ms(`Node ${String(f)} not in nodes`);
  }
}
function Gj(t, e) {
  if (Array.isArray(t)) {
    for (const n of t)
      if (!(n in e))
        throw new Error(`Key ${String(n)} not found in channels`);
  } else if (!(t in e))
    throw new Error(`Key ${String(t)} not found in channels`);
}
function Vo(t, e, n = !0, a = !1) {
  try {
    return t[e].get();
  } catch (r) {
    if (r.name === sn.unminifiable_name) {
      if (a)
        return r;
      if (n)
        return null;
    }
    throw r;
  }
}
function Wo(t, e, n = !0) {
  if (Array.isArray(e)) {
    const a = {};
    for (const r of e)
      try {
        a[r] = Vo(t, r, !n);
      } catch (i) {
        if (i.name === sn.unminifiable_name)
          continue;
      }
    return a;
  } else
    return Vo(t, e);
}
function* Ax(t, e) {
  if (t.graph === lr.PARENT)
    throw new nt("There is no parent graph.");
  if (t.goto) {
    let n;
    Array.isArray(t.goto) ? n = t.goto : n = [t.goto];
    for (const a of n)
      if (Pn(a))
        yield [Jn, Zu, a];
      else if (typeof a == "string")
        yield [Jn, `branch:__start__:${eg}:${a}`, "__start__"];
      else
        throw new Error(`In Command.send, expected Send or string, got ${typeof a}`);
  }
  if (t.resume)
    if (typeof t.resume == "object" && Object.keys(t.resume).length && Object.keys(t.resume).every(qs))
      for (const [n, a] of Object.entries(t.resume)) {
        const r = e.filter((i) => i[0] === n && i[1] === Bn).map((i) => i[2]).slice(0, 1) ?? [];
        r.push(a), yield [n, Bn, r];
      }
    else
      yield [Jn, Bn, t.resume];
  if (t.update) {
    if (typeof t.update != "object" || !t.update)
      throw new Error("Expected cmd.update to be a dict mapping channel names to update values");
    if (Array.isArray(t.update))
      for (const [n, a] of t.update)
        yield [Jn, n, a];
    else
      for (const [n, a] of Object.entries(t.update))
        yield [Jn, n, a];
  }
}
function* eM(t, e) {
  if (e != null)
    if (Array.isArray(t) && typeof e == "object" && !Array.isArray(e))
      for (const n in e)
        t.includes(n) && (yield [n, e[n]]);
    else {
      if (Array.isArray(t))
        throw new Error('Input chunk must be an object when "inputChannels" is an array');
      yield [t, e];
    }
}
function* ab(t, e, n) {
  Array.isArray(t) ? (e === !0 || e.find(([a, r]) => t.includes(a))) && (yield Wo(n, t)) : (e === !0 || e.some(([a, r]) => a === t)) && (yield Vo(n, t));
}
function* Wj(t, e, n) {
  const a = e.filter(([u, d]) => (u.config === void 0 || !u.config.tags?.includes(lt)) && d[0][0] !== jn && d[0][0] !== at);
  if (!a.length)
    return;
  let r;
  a.some(([u]) => u.writes.some(([d, f]) => d === _d)) ? r = a.flatMap(([u]) => u.writes.filter(([d, f]) => d === _d).map(([d, f]) => [u.name, f])) : Array.isArray(t) ? r = a.flatMap(([u]) => {
    const { writes: d } = u, f = {};
    for (const [o] of d)
      t.includes(o) && (f[o] = (f[o] || 0) + 1);
    return Object.values(f).some((o) => o > 1) ? d.filter(([o]) => t.includes(o)).map(([o, c]) => [u.name, { [o]: c }]) : [
      [
        u.name,
        Object.fromEntries(d.filter(([o]) => t.includes(o)))
      ]
    ];
  }) : r = a.flatMap(([u]) => u.writes.filter(([d, f]) => d === t).map(([d, f]) => [u.name, f]));
  const i = {};
  for (const [u, d] of r)
    u in i || (i[u] = []), i[u].push(d);
  const s = {};
  for (const u in i)
    if (i[u].length === 1) {
      const [d] = i[u];
      s[u] = d;
    } else
      s[u] = i[u];
  n && (s.__metadata__ = { cached: n }), yield s;
}
function Ex(t) {
  return "steps" in t && Array.isArray(t.steps);
}
function G_(t) {
  return "lg_is_pregel" in t && t.lg_is_pregel === !0;
}
function tM(t) {
  const e = [t];
  for (const n of e) {
    if (G_(n))
      return n;
    Ex(n) && e.push(...n.steps);
  }
}
const vd = {
  blue: {
    start: "\x1B[34m",
    end: "\x1B[0m"
  },
  green: {
    start: "\x1B[32m",
    end: "\x1B[0m"
  },
  yellow: {
    start: "\x1B[33;1m",
    end: "\x1B[0m"
  }
}, wd = (t, e) => `${t.start}${e}${t.end}`;
function* Xj(t, e) {
  const n = (/* @__PURE__ */ new Date()).toISOString();
  for (const { id: a, name: r, input: i, config: s, triggers: u, writes: d } of e) {
    if (s?.tags?.includes(lt))
      continue;
    const f = d.filter(([o, c]) => o === a && c === at).map(([, o]) => o);
    yield {
      type: "task",
      timestamp: n,
      step: t,
      payload: {
        id: a,
        name: r,
        input: i,
        triggers: u,
        interrupts: f
      }
    };
  }
}
function* Ix(t, e, n) {
  const a = (/* @__PURE__ */ new Date()).toISOString();
  for (const [{ id: r, name: i, config: s }, u] of e)
    s?.tags?.includes(lt) || (yield {
      type: "task_result",
      timestamp: a,
      step: t,
      payload: {
        id: r,
        name: i,
        result: u.filter(([d]) => Array.isArray(n) ? n.includes(d) : d === n),
        interrupts: u.filter((d) => d[0] === at).map((d) => d[1])
      }
    });
}
function* Nx(t, e, n, a, r, i, s, u) {
  function d(h) {
    const p = {};
    return h.callbacks != null && (p.callbacks = h.callbacks), h.configurable != null && (p.configurable = h.configurable), h.maxConcurrency != null && (p.max_concurrency = h.maxConcurrency), h.metadata != null && (p.metadata = h.metadata), h.recursionLimit != null && (p.recursion_limit = h.recursionLimit), h.runId != null && (p.run_id = h.runId), h.runName != null && (p.run_name = h.runName), h.tags != null && (p.tags = h.tags), p;
  }
  const f = e.configurable?.checkpoint_ns, o = {};
  for (const h of i) {
    if (!(h.subgraphs?.length ? h.subgraphs : [h.proc]).find(tM))
      continue;
    let l = `${h.name}:${h.id}`;
    f && (l = `${f}|${l}`), o[h.id] = {
      configurable: {
        thread_id: e.configurable?.thread_id,
        checkpoint_ns: l
      }
    };
  }
  yield {
    type: "checkpoint",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    step: t,
    payload: {
      config: d(e),
      values: Wo(n, a),
      metadata: r,
      next: i.map((h) => h.name),
      tasks: nM(i, s, o),
      parentConfig: u ? d(u) : void 0
    }
  };
}
function nM(t, e, n) {
  return t.map((a) => {
    const r = e.find(([u, d]) => u === a.id && d === jn)?.[2], i = e.filter(([u, d]) => u === a.id && d === at).map(([, , u]) => u);
    if (r)
      return {
        id: a.id,
        name: a.name,
        path: a.path,
        error: r,
        interrupts: i
      };
    const s = n?.[a.id];
    return {
      id: a.id,
      name: a.name,
      path: a.path,
      interrupts: i,
      ...s !== void 0 ? { state: s } : {}
    };
  });
}
function Fx(t, e, n) {
  console.log([
    `${wd(vd.blue, `[${t}:checkpoint]`)}`,
    `\x1B[1m State at the end of step ${t}:\x1B[0m
`,
    JSON.stringify(Wo(e, n), null, 2)
  ].join(""));
}
function rM(t, e) {
  const n = e.length;
  console.log([
    `${wd(vd.blue, `[${t}:tasks]`)}`,
    `\x1B[1m Starting step ${t} with ${n} task${n === 1 ? "" : "s"}:\x1B[0m
`,
    e.map((a) => `- ${wd(vd.green, String(a.name))} -> ${JSON.stringify(a.input, null, 2)}`).join(`
`)
  ].join(""));
}
function kx(t, e, n) {
  const a = {};
  for (const [r, i] of e)
    n.includes(r) && (a[r] || (a[r] = []), a[r].push(i));
  console.log([
    `${wd(vd.blue, `[${t}:writes]`)}`,
    `\x1B[1m Finished step ${t} with writes to ${Object.keys(a).length} channel${Object.keys(a).length !== 1 ? "s" : ""}:\x1B[0m
`,
    Object.entries(a).map(([r, i]) => `- ${wd(vd.yellow, r)} -> ${i.map((s) => JSON.stringify(s)).join(", ")}`).join(`
`)
  ].join(""));
}
class Dx {
  constructor({ func: e, name: n, input: a, retry: r, callbacks: i }) {
    Object.defineProperty(this, "func", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "input", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "retry", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "__lg_type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "call"
    }), this.func = e, this.name = n, this.input = a, this.retry = r, this.callbacks = i;
  }
}
function qx(t) {
  return typeof t == "object" && t !== null && "__lg_type" in t && t.__lg_type === "call";
}
function aM(t) {
  const e = Object.values(t), n = e.length > 0 ? typeof e[0] : void 0;
  let a;
  return n === "number" ? a = 0 : n === "string" && (a = ""), a;
}
function ng(t, e) {
  if (Object.keys(t).length > 0) {
    const n = aM(e);
    return Object.fromEntries(Object.entries(e).filter(([a, r]) => r > (t[a] ?? n)));
  } else
    return e;
}
function Jx(t, e) {
  return t && !Array.isArray(t) && // eslint-disable-next-line no-instanceof/no-instanceof
  !(t instanceof Date) && typeof t == "object" ? t : { [e]: t };
}
function ko(t, e) {
  return t === null ? { configurable: e } : t?.configurable === void 0 ? { ...t, configurable: e } : {
    ...t,
    configurable: { ...t.configurable, ...e }
  };
}
function vu(t, e) {
  const n = e?.parents ?? {};
  return Object.keys(n).length > 0 ? ko(t, {
    [Dn]: {
      ...n,
      [t.configurable?.checkpoint_ns ?? ""]: t.configurable?.checkpoint_id
    }
  }) : t;
}
function Lx(t, e) {
  const n = new au({
    func: (a) => e(...a),
    name: t,
    trace: !1,
    recurse: !1
  });
  return new gt({
    name: t,
    first: n,
    last: new Ct([{ channel: _d, value: xo }], [lt])
  });
}
const Ux = (t) => t !== void 0 ? t + 1 : 1;
function xf(t, e, n) {
  const a = Object.values(t.channel_versions), r = a.length > 0 ? typeof a[0] : void 0;
  let i;
  r === "number" ? i = 0 : r === "string" && (i = "");
  const s = t.versions_seen[at] ?? {}, u = Object.entries(t.channel_versions).some(([f, o]) => o > (s[f] ?? i)), d = n.some((f) => e === "*" ? !f.config?.tags?.includes(lt) : e.includes(f.name));
  return u && d;
}
function sh(t, e, n, a, r, i, s = !1) {
  let u = [], d = /* @__PURE__ */ new Set();
  if (Array.isArray(i))
    u = i.filter((o) => a.get(o)), i = i.filter((o) => !a.get(o)), d = new Set(i.filter((o) => r.writes.some(([c, h]) => c === o)));
  else {
    for (const [o] of r.writes)
      if (o === i) {
        d = /* @__PURE__ */ new Set([o]);
        break;
      }
    d = d || /* @__PURE__ */ new Set();
  }
  let f;
  if (s && d.size > 0) {
    const o = Object.fromEntries(Object.entries(n).filter(([p, l]) => d.has(p))), c = Eo(e, o, -1), h = zh(o, c);
    yn(Vh(c), h, [r]), f = Wo({ ...n, ...h }, i);
  } else
    f = Wo(n, i);
  if (u.length > 0)
    for (const o of u) {
      const c = a.get(o);
      if (c) {
        const h = c.call(t);
        f[o] = h;
      }
    }
  return f;
}
function ib(t, e, n, a, r) {
  for (const [i, s] of r)
    if ([Kt, Zu].includes(i) && s != null) {
      if (!Pn(s))
        throw new nt(`Invalid packet type, expected SendProtocol, got ${JSON.stringify(s)}`);
      if (!(s.node in n))
        throw new nt(`Invalid node name "${s.node}" in Send packet`);
      a.replaceRuntimeValues(t, s.args);
    }
  e(r);
}
const Bx = /* @__PURE__ */ new Set([
  z_,
  Kt,
  Bn,
  at,
  _d,
  jn
]);
function yn(t, e, n, a) {
  n.sort((c, h) => {
    const p = c.path?.slice(0, 3) || [], l = h.path?.slice(0, 3) || [];
    for (let m = 0; m < Math.min(p.length, l.length); m += 1) {
      if (p[m] < l[m])
        return -1;
      if (p[m] > l[m])
        return 1;
    }
    return p.length - l.length;
  });
  const r = n.some((c) => c.triggers.length > 0), i = Object.fromEntries(Object.entries(e).filter(([c, h]) => Fp(h)));
  for (const c of n) {
    t.versions_seen[c.name] === void 0 && (t.versions_seen[c.name] = {});
    for (const h of c.triggers)
      h in t.channel_versions && (t.versions_seen[c.name][h] = t.channel_versions[h]);
  }
  let s;
  Object.keys(t.channel_versions).length > 0 && (s = Zj(...Object.values(t.channel_versions)));
  const u = new Set(n.flatMap((c) => c.triggers).filter((c) => !wx.includes(c)));
  for (const c of u)
    c in i && i[c].consume() && a !== void 0 && (t.channel_versions[c] = a(s, i[c]));
  t.pending_sends?.length && r && (t.pending_sends = []);
  const d = {}, f = {};
  for (const c of n)
    for (const [h, p] of c.writes)
      Bx.has(h) || (h === Zu ? t.pending_sends.push({
        node: p.node,
        args: p.args
      }) : h in i ? h in d ? d[h].push(p) : d[h] = [p] : h in f ? f[h].push(p) : f[h] = [p]);
  s = void 0, Object.keys(t.channel_versions).length > 0 && (s = Zj(...Object.values(t.channel_versions)));
  const o = /* @__PURE__ */ new Set();
  for (const [c, h] of Object.entries(d))
    if (c in i) {
      let p;
      try {
        p = i[c].update(h);
      } catch (l) {
        if (l.name === nt.unminifiable_name) {
          const m = new nt(`Invalid update for channel "${c}" with values ${JSON.stringify(h)}: ${l.message}`);
          throw m.lc_error_code = l.lc_error_code, m;
        } else
          throw l;
      }
      p && a !== void 0 && (t.channel_versions[c] = a(s, i[c])), o.add(c);
    }
  if (r)
    for (const c of Object.keys(i))
      o.has(c) || i[c].update([]) && a !== void 0 && (t.channel_versions[c] = a(s, i[c]));
  return f;
}
function Kl(t, e, n, a, r, i, s, u) {
  const d = {};
  for (let f = 0; f < t.pending_sends.length; f += 1) {
    const o = rg([Kt, f], t, e, n, a, r, i, s, u);
    o !== void 0 && (d[o.id] = o);
  }
  for (const f of Object.keys(n)) {
    const o = rg([ah, f], t, e, n, a, r, i, s, u);
    o !== void 0 && (d[o.id] = o);
  }
  return d;
}
function rg(t, e, n, a, r, i, s, u, d) {
  const { step: f, checkpointer: o, manager: c } = d, h = s.configurable ?? {}, p = h.checkpoint_ns ?? "";
  if (t[0] === Kt && qx(t[t.length - 1])) {
    const l = t[t.length - 1], m = Lx(l.name, l.func), b = [Kt], g = p === "" ? l.name : `${p}${rn}${l.name}`, _ = Iu(JSON.stringify([
      g,
      f.toString(),
      l.name,
      Kt,
      t[1],
      t[2]
    ]), e.id), P = `${g}${Bo}${_}`, R = {
      langgraph_step: f,
      langgraph_node: l.name,
      langgraph_triggers: b,
      langgraph_path: t.slice(0, 3),
      langgraph_checkpoint_ns: P
    };
    {
      const C = [];
      return {
        name: l.name,
        input: l.input,
        proc: m,
        writes: C,
        config: Qe(aa(s, {
          metadata: R,
          store: d.store ?? s.store
        }), {
          runName: l.name,
          callbacks: c?.getChild(`graph:step:${f}`),
          configurable: {
            [Zl]: _,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            [Ls]: (O) => ib(f, (A) => C.push(...A), a, i, O),
            [Lo]: (O, A = !1) => sh(f, e, r, i, {
              name: l.name,
              writes: C,
              triggers: b,
              path: t.slice(0, 3)
            }, O, A),
            [mt]: o ?? h[mt],
            [Dn]: {
              ...h[Dn],
              [p]: e.id
            },
            [Uo]: sb({
              pendingWrites: n ?? [],
              taskId: _,
              currentTaskInput: l.input
            }),
            [rh]: e.channel_values[eb],
            checkpoint_id: void 0,
            checkpoint_ns: P
          }
        }),
        triggers: b,
        retry_policy: l.retry,
        id: _,
        path: t.slice(0, 3),
        writers: []
      };
    }
  } else if (t[0] === Kt) {
    const l = typeof t[1] == "number" ? t[1] : parseInt(t[1], 10);
    if (l >= e.pending_sends.length)
      return;
    const m = tg(e.pending_sends[l]) && !Pn(e.pending_sends[l]) ? new Kh(e.pending_sends[l].node, e.pending_sends[l].args) : e.pending_sends[l];
    if (!tg(m)) {
      console.warn(`Ignoring invalid packet ${JSON.stringify(m)} in pending sends.`);
      return;
    }
    if (!(m.node in a)) {
      console.warn(`Ignoring unknown node name ${m.node} in pending sends.`);
      return;
    }
    const b = [Kt], g = p === "" ? m.node : `${p}${rn}${m.node}`, _ = Iu(JSON.stringify([
      g,
      f.toString(),
      m.node,
      Kt,
      l.toString()
    ]), e.id), P = `${g}${Bo}${_}`;
    let R = {
      langgraph_step: f,
      langgraph_node: m.node,
      langgraph_triggers: b,
      langgraph_path: t.slice(0, 3),
      langgraph_checkpoint_ns: P
    };
    {
      const C = a[m.node], T = C.getNode();
      if (T !== void 0) {
        i.replaceRuntimePlaceholders(f, m.args), C.metadata !== void 0 && (R = { ...R, ...C.metadata });
        const O = [];
        return {
          name: m.node,
          input: m.args,
          proc: T,
          subgraphs: C.subgraphs,
          writes: O,
          config: Qe(aa(s, {
            metadata: R,
            tags: C.tags,
            store: d.store ?? s.store
          }), {
            runName: m.node,
            callbacks: c?.getChild(`graph:step:${f}`),
            configurable: {
              [Zl]: _,
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              [Ls]: (A) => ib(f, (M) => O.push(...M), a, i, A),
              [Lo]: (A, M = !1) => sh(f, e, r, i, {
                name: m.node,
                writes: O,
                triggers: b,
                path: t
              }, A, M),
              [mt]: o ?? h[mt],
              [Dn]: {
                ...h[Dn],
                [p]: e.id
              },
              [Uo]: sb({
                pendingWrites: n ?? [],
                taskId: _,
                currentTaskInput: m.args
              }),
              [rh]: e.channel_values[eb],
              checkpoint_id: void 0,
              checkpoint_ns: P
            }
          }),
          triggers: b,
          retry_policy: C.retryPolicy,
          id: _,
          path: t,
          writers: C.getWriters()
        };
      }
    }
  } else if (t[0] === ah) {
    const l = t[1].toString(), m = a[l];
    if (m === void 0)
      return;
    if (n?.length) {
      const P = p === "" ? l : `${p}${rn}${l}`, R = Iu(JSON.stringify([
        P,
        f.toString(),
        l,
        ah,
        l
      ]), e.id);
      if (n.some((T) => T[0] === R && T[1] !== jn))
        return;
    }
    const b = aM(e.channel_versions);
    if (b === void 0)
      return;
    const g = e.versions_seen[l] ?? {}, _ = m.triggers.filter((P) => {
      const R = Vo(r, P, !1, !0);
      return !// eslint-disable-next-line no-instanceof/no-instanceof
      (R instanceof Error && R.name === sn.unminifiable_name) && (e.channel_versions[P] ?? b) > (g[P] ?? b);
    }).sort();
    if (_.length > 0) {
      const P = xx(f, m, i, r);
      if (P === void 0)
        return;
      const R = p === "" ? l : `${p}${rn}${l}`, C = Iu(JSON.stringify([
        R,
        f.toString(),
        l,
        ah,
        _
      ]), e.id), T = `${R}${Bo}${C}`;
      let O = {
        langgraph_step: f,
        langgraph_node: l,
        langgraph_triggers: _,
        langgraph_path: t,
        langgraph_checkpoint_ns: T
      };
      {
        const A = m.getNode();
        if (A !== void 0) {
          m.metadata !== void 0 && (O = { ...O, ...m.metadata });
          const M = [];
          return {
            name: l,
            input: P,
            proc: A,
            subgraphs: m.subgraphs,
            writes: M,
            config: Qe(aa(s, {
              metadata: O,
              tags: m.tags,
              store: d.store ?? s.store
            }), {
              runName: l,
              callbacks: c?.getChild(`graph:step:${f}`),
              configurable: {
                [Zl]: C,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                [Ls]: (I) => ib(f, (N) => {
                  M.push(...N);
                }, a, i, I),
                [Lo]: (I, N = !1) => sh(f, e, r, i, {
                  name: l,
                  writes: M,
                  triggers: _,
                  path: t
                }, I, N),
                [mt]: o ?? h[mt],
                [Dn]: {
                  ...h[Dn],
                  [p]: e.id
                },
                [Uo]: sb({
                  pendingWrites: n ?? [],
                  taskId: C,
                  currentTaskInput: P
                }),
                [rh]: e.channel_values[eb],
                checkpoint_id: void 0,
                checkpoint_ns: T
              }
            }),
            triggers: _,
            retry_policy: m.retryPolicy,
            id: C,
            path: t,
            writers: m.getWriters()
          };
        }
      }
    }
  }
}
function xx(t, e, n, a, r) {
  let i;
  if (typeof e.channels == "object" && !Array.isArray(e.channels)) {
    i = {};
    for (const [s, u] of Object.entries(e.channels))
      if (e.triggers.includes(u))
        try {
          i[s] = Vo(a, u, !1);
        } catch (d) {
          if (d.name === sn.unminifiable_name)
            return;
          throw d;
        }
      else if (u in a)
        try {
          i[s] = Vo(a, u, !1);
        } catch (d) {
          if (d.name === sn.unminifiable_name)
            continue;
          throw d;
        }
      else
        i[s] = n.get(s)?.call(t);
  } else if (Array.isArray(e.channels)) {
    let s = !1;
    for (const u of e.channels)
      try {
        i = Vo(a, u, !1), s = !0;
        break;
      } catch (d) {
        if (d.name === sn.unminifiable_name)
          continue;
        throw d;
      }
    if (!s)
      return;
  } else
    throw new Error(`Invalid channels type, expected list or dict, got ${e.channels}`);
  return e.mapper !== void 0 && (i = e.mapper(i)), i;
}
function sb({ pendingWrites: t, taskId: e, currentTaskInput: n }) {
  const a = t.find(([i, s]) => i === Jn && s === Bn)?.[2], r = {
    callCounter: 0,
    interruptCounter: -1,
    resume: t.filter(([i, s]) => i === e && s === Bn).flatMap(([i, s, u]) => u),
    nullResume: a,
    subgraphCounter: 0,
    currentTaskInput: n,
    consumeNullResume: () => {
      if (r.nullResume)
        return delete r.nullResume, t.splice(t.findIndex(([i, s]) => i === Jn && s === Bn), 1), a;
    }
  };
  return r;
}
class iM extends un {
  get closed() {
    return this._closed;
  }
  constructor(e) {
    let n;
    const a = new Promise((r) => {
      n = r;
    });
    super({
      start: (r) => {
        n(r);
      }
    }), Object.defineProperty(this, "modes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "controller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "passthroughFn", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_closed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), a.then((r) => {
      this.controller = r;
    }), this.passthroughFn = e.passthroughFn, this.modes = e.modes;
  }
  push(e) {
    this.passthroughFn?.(e), this.controller.enqueue(e);
  }
  close() {
    try {
      this.controller.close();
    } catch {
    } finally {
      this._closed = !0;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  error(e) {
    this.controller.error(e);
  }
}
const ob = Symbol.for("INPUT_DONE"), ub = Symbol.for("INPUT_RESUMING"), Vx = 25;
function zx(...t) {
  return new iM({
    passthroughFn: (e) => {
      for (const n of t)
        n.modes.has(e[1]) && n.push(e);
    },
    modes: new Set(t.flatMap((e) => Array.from(e.modes)))
  });
}
class W_ {
  get isResuming() {
    const e = Object.keys(this.checkpoint.channel_versions).length !== 0, a = this.config.configurable?.[to] !== void 0 && this.config.configurable?.[to], r = this.input === null || this.input === void 0, i = qn(this.input), s = this.input === ub;
    return e && (a || r || i || s);
  }
  constructor(e) {
    Object.defineProperty(this, "input", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "output", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointerGetNextVersion", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "channels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "managed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointConfig", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointMetadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointNamespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointPendingWrites", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "checkpointPreviousVersions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "step", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputKeys", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "streamKeys", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "nodes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "skipDoneTasks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "prevCheckpointConfig", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "pending"
    }), Object.defineProperty(this, "tasks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "stream", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkpointerPromises", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "isNested", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_checkpointerChainedPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Promise.resolve()
    }), Object.defineProperty(this, "store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "manager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interruptAfter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interruptBefore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "toInterrupt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "debug", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.input = e.input, this.checkpointer = e.checkpointer, this.checkpointer !== void 0 ? this.checkpointerGetNextVersion = this.checkpointer.getNextVersion.bind(this.checkpointer) : this.checkpointerGetNextVersion = Ux, this.checkpoint = e.checkpoint, this.checkpointMetadata = e.checkpointMetadata, this.checkpointPreviousVersions = e.checkpointPreviousVersions, this.channels = e.channels, this.managed = e.managed, this.checkpointPendingWrites = e.checkpointPendingWrites, this.step = e.step, this.stop = e.stop, this.config = e.config, this.checkpointConfig = e.checkpointConfig, this.isNested = e.isNested, this.manager = e.manager, this.outputKeys = e.outputKeys, this.streamKeys = e.streamKeys, this.nodes = e.nodes, this.skipDoneTasks = e.skipDoneTasks, this.store = e.store, this.stream = e.stream, this.checkpointNamespace = e.checkpointNamespace, this.prevCheckpointConfig = e.prevCheckpointConfig, this.interruptAfter = e.interruptAfter, this.interruptBefore = e.interruptBefore, this.debug = e.debug;
  }
  static async initialize(e) {
    let { config: n, stream: a } = e;
    a !== void 0 && n.configurable?.[Zh] !== void 0 && (a = zx(a, n.configurable[Zh]));
    const r = n.configurable ? !("checkpoint_id" in n.configurable) : !0, i = n.configurable?.[Uo];
    n.configurable && i && (i.subgraphCounter > 0 && (n = ko(n, {
      [Yb]: [
        n.configurable[Yb],
        i.subgraphCounter.toString()
      ].join(rn)
    })), i.subgraphCounter += 1);
    const s = Lo in (n.configurable ?? {});
    !s && n.configurable?.checkpoint_ns !== void 0 && n.configurable?.checkpoint_ns !== "" && (n = ko(n, {
      checkpoint_ns: "",
      checkpoint_id: void 0
    }));
    let u = n;
    n.configurable?.[Dn] !== void 0 && n.configurable?.[Dn]?.[n.configurable?.checkpoint_ns] && (u = ko(n, {
      checkpoint_id: n.configurable[Dn][n.configurable?.checkpoint_ns]
    }));
    const d = n.configurable?.checkpoint_ns?.split(rn) ?? [], f = await e.checkpointer?.getTuple(u) ?? {
      config: n,
      checkpoint: X$(),
      metadata: {
        source: "input",
        step: -2,
        writes: null,
        parents: {}
      },
      pendingWrites: []
    };
    u = {
      ...n,
      ...f.config,
      configurable: {
        checkpoint_ns: "",
        ...n.configurable,
        ...f.config.configurable
      }
    };
    const o = f.parentConfig, c = Vh(f.checkpoint), h = { ...f.metadata }, p = f.pendingWrites ?? [], l = zh(e.channelSpecs, c), m = (h.step ?? 0) + 1, b = m + (n.recursionLimit ?? Vx) + 1, g = { ...c.channel_versions }, _ = e.store ? new mx(e.store) : void 0;
    return _ && _.start(), new W_({
      input: e.input,
      config: n,
      checkpointer: e.checkpointer,
      checkpoint: c,
      checkpointMetadata: h,
      checkpointConfig: u,
      prevCheckpointConfig: o,
      checkpointNamespace: d,
      channels: l,
      managed: e.managed,
      isNested: s,
      manager: e.manager,
      skipDoneTasks: r,
      step: m,
      stop: b,
      checkpointPreviousVersions: g,
      checkpointPendingWrites: p,
      outputKeys: e.outputKeys ?? [],
      streamKeys: e.streamKeys ?? [],
      nodes: e.nodes,
      stream: a,
      store: _,
      interruptAfter: e.interruptAfter,
      interruptBefore: e.interruptBefore,
      debug: e.debug
    });
  }
  _checkpointerPutAfterPrevious(e) {
    this._checkpointerChainedPromise = this._checkpointerChainedPromise.then(() => this.checkpointer?.put(e.config, e.checkpoint, e.metadata, e.newVersions)), this.checkpointerPromises.push(this._checkpointerChainedPromise);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async updateManagedValues(e, n) {
    const a = this.managed.get(e);
    a && "update" in a && typeof a.update == "function" && await a.update(n);
  }
  /**
   * Put writes for a task, to be read by the next tick.
   * @param taskId
   * @param writes
   */
  putWrites(e, n) {
    let a = n;
    if (a.length === 0)
      return;
    a.every(([i]) => i in Kj) && (a = Array.from(new Map(a.map((i) => [i[0], i])).values()));
    for (const [i, s] of a) {
      const u = this.checkpointPendingWrites.findIndex((d) => d[0] === e && d[1] === i);
      i in Kj && u !== -1 ? this.checkpointPendingWrites[u] = [e, i, s] : this.checkpointPendingWrites.push([e, i, s]);
    }
    const r = this.checkpointer?.putWrites({
      ...this.checkpointConfig,
      configurable: {
        ...this.checkpointConfig.configurable,
        checkpoint_ns: this.config.configurable?.checkpoint_ns ?? "",
        checkpoint_id: this.checkpoint.id
      }
    }, a, e);
    r !== void 0 && this.checkpointerPromises.push(r), this.tasks && this._outputWrites(e, a);
  }
  _outputWrites(e, n, a = !1) {
    const r = this.tasks[e];
    if (r !== void 0) {
      if (r.config !== void 0 && (r.config.tags ?? []).includes(lt))
        return;
      n.length > 0 && n[0][0] !== jn && n[0][0] !== at && this._emit(Fl(Ys(Wj(this.outputKeys, [[r, n]], a), "updates"))), a || this._emit(Fl(Ys(Ix(this.step, [[r, n]], this.streamKeys), "debug")));
    }
  }
  /**
   * Execute a single iteration of the Pregel loop.
   * Returns true if more iterations are needed.
   * @param params
   */
  async tick(e) {
    this.store && !this.store.isRunning && this.store?.start();
    const { inputKeys: n = [] } = e;
    if (this.status !== "pending")
      throw new Error(`Cannot tick when status is no longer "pending". Current status: "${this.status}"`);
    if (![ob, ub].includes(this.input))
      await this._first(n);
    else {
      if (this.toInterrupt.length > 0)
        throw this.status = "interrupt_before", new zl();
      if (Object.values(this.tasks).every((i) => i.writes.length > 0)) {
        const i = Object.values(this.tasks).flatMap((d) => d.writes), s = yn(this.checkpoint, this.channels, Object.values(this.tasks), this.checkpointerGetNextVersion);
        for (const [d, f] of Object.entries(s))
          await this.updateManagedValues(d, f);
        const u = await ao(Ys(ab(this.outputKeys, i, this.channels), "values"));
        if (this._emit(u), this.checkpointPendingWrites = [], await this._putCheckpoint({
          source: "loop",
          writes: Wj(this.outputKeys, Object.values(this.tasks).map((d) => [d, d.writes])).next().value ?? null
        }), xf(this.checkpoint, this.interruptAfter, Object.values(this.tasks)))
          throw this.status = "interrupt_after", new zl();
        this.config.configurable?.[to] !== void 0 && delete this.config.configurable?.[to];
      } else
        return !1;
    }
    if (this.step > this.stop)
      return this.status = "out_of_steps", !1;
    const a = Kl(this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.managed, this.config, !0, {
      step: this.step,
      checkpointer: this.checkpointer,
      manager: this.manager,
      store: this.store
    });
    if (this.tasks = a, this.checkpointer && this._emit(await ao(Ys(Nx(
      this.step - 1,
      // printing checkpoint for previous step
      this.checkpointConfig,
      this.channels,
      this.streamKeys,
      this.checkpointMetadata,
      Object.values(this.tasks),
      this.checkpointPendingWrites,
      this.prevCheckpointConfig
    ), "debug"))), Object.values(this.tasks).length === 0)
      return this.status = "done", !1;
    if (this.skipDoneTasks && this.checkpointPendingWrites.length > 0) {
      for (const [i, s, u] of this.checkpointPendingWrites) {
        if (s === jn || s === at || s === Bn)
          continue;
        const d = Object.values(this.tasks).find((f) => f.id === i);
        d && d.writes.push([s, u]);
      }
      for (const i of Object.values(this.tasks))
        i.writes.length > 0 && this._outputWrites(i.id, i.writes, !0);
    }
    if (Object.values(this.tasks).every((i) => i.writes.length > 0))
      return this.tick({ inputKeys: n });
    if (xf(this.checkpoint, this.interruptBefore, Object.values(this.tasks)))
      throw this.status = "interrupt_before", new zl();
    const r = await ao(Ys(Xj(this.step, Object.values(this.tasks)), "debug"));
    return this._emit(r), !0;
  }
  async finishAndHandleError(e) {
    const n = this._suppressInterrupt(e);
    if ((n || e === void 0) && (this.output = Wo(this.channels, this.outputKeys)), n) {
      if (this.tasks !== void 0 && this.checkpointPendingWrites.length > 0 && Object.values(this.tasks).some((a) => a.writes.length > 0)) {
        const a = yn(this.checkpoint, this.channels, Object.values(this.tasks), this.checkpointerGetNextVersion);
        for (const [r, i] of Object.entries(a))
          await this.updateManagedValues(r, i);
        this._emit(Fl(Ys(ab(this.outputKeys, Object.values(this.tasks).flatMap((r) => r.writes), this.channels), "values")));
      }
      this._emit([
        [
          "updates",
          {
            [at]: e.interrupts
          }
        ]
      ]);
    }
    return n;
  }
  acceptPush(e, n, a) {
    if (this.interruptAfter?.length > 0 && xf(this.checkpoint, this.interruptAfter, [e])) {
      this.toInterrupt.push(e);
      return;
    }
    const r = rg([Kt, e.path ?? [], n, e.id, a], this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.managed, e.config ?? {}, !0, {
      step: this.step,
      checkpointer: this.checkpointer,
      manager: this.manager,
      store: this.store
    });
    if (r) {
      if (this.interruptBefore?.length > 0 && xf(this.checkpoint, this.interruptBefore, [r])) {
        this.toInterrupt.push(r);
        return;
      }
      return this._emit(Fl(Ys(Xj(this.step, [r]), "debug"))), this.debug && rM(this.step, [r]), this.tasks[r.id] = r, this.skipDoneTasks && this._matchWrites({ [r.id]: r }), r;
    }
  }
  _suppressInterrupt(e) {
    return Nl(e) && !this.isNested;
  }
  async _first(e) {
    const { configurable: n } = this.config, a = n?.[Uo];
    if (a && a.nullResume !== void 0 && this.putWrites(Jn, [[Bn, a.nullResume]]), qn(this.input)) {
      if (this.input.resume != null && this.checkpointer == null)
        throw new Error("Cannot use Command(resume=...) without checkpointer");
      const i = {};
      for (const [s, u, d] of Ax(this.input, this.checkpointPendingWrites))
        i[s] === void 0 && (i[s] = []), i[s].push([u, d]);
      if (Object.keys(i).length === 0)
        throw new zj("Received empty Command input");
      for (const [s, u] of Object.entries(i))
        this.putWrites(s, u);
    }
    const r = (this.checkpointPendingWrites ?? []).filter((i) => i[0] === Jn).map((i) => i.slice(1));
    if (r.length > 0 && yn(this.checkpoint, this.channels, [
      {
        name: Fs,
        writes: r,
        triggers: []
      }
    ], this.checkpointerGetNextVersion), this.isResuming) {
      for (const s of Object.keys(this.channels))
        if (this.checkpoint.channel_versions[s] !== void 0) {
          const u = this.checkpoint.channel_versions[s];
          this.checkpoint.versions_seen[at] = {
            ...this.checkpoint.versions_seen[at],
            [s]: u
          };
        }
      const i = await ao(Ys(ab(this.outputKeys, !0, this.channels), "values"));
      this._emit(i), this.input = ub;
    } else {
      const i = await ao(eM(e, this.input));
      if (i.length > 0) {
        const s = Kl(this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.managed, this.config, !0, { step: this.step });
        yn(this.checkpoint, this.channels, Object.values(s).concat([
          {
            name: Fs,
            writes: i,
            triggers: []
          }
        ]), this.checkpointerGetNextVersion), await this._putCheckpoint({
          source: "input",
          writes: Object.fromEntries(i)
        }), this.input = ob;
      } else if (to in (this.config.configurable ?? {}))
        this.input = ob;
      else
        throw new zj(`Received no input writes for ${JSON.stringify(e, null, 2)}`);
    }
    this.isNested || (this.config = ko(this.config, {
      [to]: this.isResuming
    }));
  }
  _emit(e) {
    for (const n of e)
      this.stream.modes.has(n[0]) && this.stream.push([this.checkpointNamespace, ...n]);
  }
  async _putCheckpoint(e) {
    const n = {
      ...e,
      step: this.step,
      parents: this.config.configurable?.[Dn] ?? {}
    };
    if (this.checkpointer !== void 0) {
      this.prevCheckpointConfig = this.checkpointConfig?.configurable?.checkpoint_id ? this.checkpointConfig : void 0, this.checkpointMetadata = n, this.checkpoint = Eo(this.checkpoint, this.channels, this.step), this.checkpointConfig = {
        ...this.checkpointConfig,
        configurable: {
          ...this.checkpointConfig.configurable,
          checkpoint_ns: this.config.configurable?.checkpoint_ns ?? ""
        }
      };
      const a = { ...this.checkpoint.channel_versions }, r = ng(this.checkpointPreviousVersions, a);
      this.checkpointPreviousVersions = a, this._checkpointerPutAfterPrevious({
        config: { ...this.checkpointConfig },
        checkpoint: Vh(this.checkpoint),
        metadata: { ...this.checkpointMetadata },
        newVersions: r
      }), this.checkpointConfig = {
        ...this.checkpointConfig,
        configurable: {
          ...this.checkpointConfig.configurable,
          checkpoint_id: this.checkpoint.id
        }
      };
    }
    this.step += 1;
  }
  _matchWrites(e) {
    for (const [n, a, r] of this.checkpointPendingWrites) {
      if (a === jn || a === at || a === Bn)
        continue;
      const i = Object.values(e).find((s) => s.id === n);
      i && i.writes.push([a, r]);
    }
    for (const n of Object.values(e))
      n.writes.length > 0 && this._outputWrites(n.id, n.writes, !0);
  }
}
function Zx(t) {
  return nn(t?.message);
}
class Kx extends Qu {
  constructor(e) {
    super(), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "StreamMessagesHandler"
    }), Object.defineProperty(this, "streamFn", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metadatas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "seen", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "emittedChatModelRunIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "stableMessageIdMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "lc_prefer_streaming", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this.streamFn = e;
  }
  _emit(e, n, a, r = !1) {
    if (r && n.id !== void 0 && this.seen[n.id] !== void 0)
      return;
    let i = n.id;
    SE(n) ? i ??= `run-${a}-tool-${n.tool_call_id}` : ((i == null || i === `run-${a}`) && (i = this.stableMessageIdMap[a] ?? i ?? `run-${a}`), this.stableMessageIdMap[a] ??= i), i !== n.id && (n.id = i, n.lc_kwargs.id = i), n.id != null && (this.seen[n.id] = n), this.streamFn([e[0], "messages", [n, e[1]]]);
  }
  handleChatModelStart(e, n, a, r, i, s, u, d) {
    u && // Include legacy LangGraph SDK tag
    (!s || !s.includes(vx) && !s.includes("nostream")) && (this.metadatas[a] = [
      u.langgraph_checkpoint_ns.split("|"),
      { tags: s, name: d, ...u }
    ]);
  }
  handleLLMNewToken(e, n, a, r, i, s) {
    const u = s?.chunk;
    this.emittedChatModelRunIds[a] = !0, this.metadatas[a] !== void 0 && (Zx(u) ? this._emit(this.metadatas[a], u.message, a) : this._emit(this.metadatas[a], new We({ content: e }), a));
  }
  handleLLMEnd(e, n) {
    if (!this.emittedChatModelRunIds[n]) {
      const a = e.generations?.[0]?.[0];
      nn(a?.message) && this._emit(this.metadatas[n], a?.message, n, !0), delete this.emittedChatModelRunIds[n];
    }
    delete this.metadatas[n], delete this.stableMessageIdMap[n];
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  handleLLMError(e, n) {
    delete this.metadatas[n];
  }
  handleChainStart(e, n, a, r, i, s, u, d) {
    if (s !== void 0 && d === s.langgraph_node && (i === void 0 || !i.includes(lt)) && (this.metadatas[a] = [
      s.langgraph_checkpoint_ns.split("|"),
      { tags: i, name: d, ...s }
    ], typeof n == "object")) {
      for (const f of Object.values(n))
        if ((nn(f) || Pb(f)) && f.id !== void 0)
          this.seen[f.id] = f;
        else if (Array.isArray(f))
          for (const o of f)
            (nn(o) || Pb(o)) && o.id !== void 0 && (this.seen[o.id] = o);
    }
  }
  handleChainEnd(e, n) {
    const a = this.metadatas[n];
    if (delete this.metadatas[n], a !== void 0) {
      if (nn(e))
        this._emit(a, e, n, !0);
      else if (Array.isArray(e))
        for (const r of e)
          nn(r) && this._emit(a, r, n, !0);
      else if (e != null && typeof e == "object") {
        for (const r of Object.values(e))
          if (nn(r))
            this._emit(a, r, n, !0);
          else if (Array.isArray(r))
            for (const i of r)
              nn(i) && this._emit(a, i, n, !0);
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  handleChainError(e, n) {
    delete this.metadatas[n];
  }
}
const Hx = 500, Gx = 2, Wx = 128e3, Xx = 3, Qx = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  409
  // Conflict
], Yx = (t) => {
  if (t.message.startsWith("Cancel") || t.message.startsWith("AbortError") || t.name === "AbortError" || t?.code === "ECONNABORTED")
    return !1;
  const e = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    t?.response?.status ?? t?.status
  );
  return !(e && Qx.includes(+e) || t?.error?.code === "insufficient_quota");
};
async function Qj(t, e, n, a) {
  const r = t.retry_policy ?? e;
  let i = r !== void 0 ? r.initialInterval ?? Hx : 0, s = 0, u, d, { config: f } = t;
  for (n && (f = ko(f, n)); ; ) {
    t.writes.splice(0, t.writes.length), u = void 0;
    try {
      d = await t.proc.invoke(t.input, f);
      break;
    } catch (o) {
      if (u = o, u.pregelTaskId = t.id, ux(u)) {
        const l = f?.configurable?.checkpoint_ns, m = u.command;
        if (m.graph === l) {
          for (const b of t.writers)
            await b.invoke(m, f);
          u = void 0;
          break;
        } else if (m.graph === lr.PARENT) {
          const b = Tx(l);
          u.command = new lr({
            ...u.command,
            graph: b
          });
        }
      }
      if (th(u) || r === void 0 || (s += 1, s >= (r.maxAttempts ?? Xx)) || !(r.retryOn ?? Yx)(u))
        break;
      i = Math.min(r.maxInterval ?? Wx, i * (r.backoffFactor ?? Gx));
      const h = r.jitter ? Math.floor(i + Math.random() * 1e3) : i;
      await new Promise((l) => setTimeout(l, h));
      const p = u.name ?? // eslint-disable-next-line @typescript-eslint/no-explicit-any
      u.constructor.unminifiable_name ?? u.constructor.name;
      (r?.logWarning ?? !0) && console.log(`Retrying task "${String(t.name)}" after ${i.toFixed(2)}ms (attempt ${s}) after ${p}: ${u}`), f = ko(f, { [to]: !0 });
    }
  }
  return {
    task: t,
    result: d,
    error: u
  };
}
class e4 {
  /**
   * Construct a new PregelRunner, which executes tasks from the provided PregelLoop.
   * @param loop - The PregelLoop that produces tasks for this runner to execute.
   */
  constructor({ loop: e, nodeFinished: n }) {
    Object.defineProperty(this, "nodeFinished", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "loop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.loop = e, this.nodeFinished = n;
  }
  /**
   * Execute tasks from the current step of the PregelLoop.
   *
   * Note: this method does NOT call {@link PregelLoop}#tick. That must be handled externally.
   * @param options - Options for the execution.
   */
  async tick(e = {}) {
    const { timeout: n, signal: a, retryPolicy: r, onStepWrite: i, maxConcurrency: s } = e, u = /* @__PURE__ */ new Set();
    let d;
    const f = Object.values(this.loop.tasks).filter((c) => c.writes.length === 0), o = this._executeTasksWithRetry(f, {
      stepTimeout: n,
      signal: a,
      retryPolicy: r,
      maxConcurrency: s
    });
    for await (const { task: c, error: h } of o)
      this._commit(c, h), Nl(h) || th(h) && !Nl(d) ? d = h : h && u.add(h);
    if (i?.(this.loop.step, Object.values(this.loop.tasks).map((c) => c.writes).flat()), u.size === 1)
      throw Array.from(u)[0];
    if (u.size > 1)
      throw new AggregateError(Array.from(u), `Multiple errors occurred during superstep ${this.loop.step}. See the "errors" field of this exception for more details.`);
    if (Nl(d) || th(d) && this.loop.isNested)
      throw d;
  }
  /**
   * Concurrently executes tasks with the requested retry policy, yielding a {@link SettledPregelTask} for each task as it completes.
   * @param tasks - The tasks to execute.
   * @param options - Options for the execution.
   */
  async *_executeTasksWithRetry(e, n) {
    const { stepTimeout: a, retryPolicy: r, maxConcurrency: i } = n ?? {};
    let s = n?.signal;
    const u = Symbol.for("promiseAdded");
    let d, f;
    function o(g) {
      d = () => {
        f = new Promise(o), g(u);
      };
    }
    f = new Promise(o);
    const c = {};
    function h(g, _, P, { calls: R } = {}) {
      if (P.every(([O]) => O !== Kt))
        return _.config?.configurable?.[Ls]?.(P) ?? [];
      const C = _.config?.configurable?.[Uo];
      if (!C)
        throw new Error(`BUG: No scratchpad found on task ${_.name}__${_.id}`);
      const T = {};
      for (const [O, A] of P.entries()) {
        const [M] = A;
        if (M !== Kt)
          continue;
        const I = R?.[O], N = C.callCounter;
        if (C.callCounter += 1, I == null)
          throw new Error("BUG: No call found");
        const v = g.loop.acceptPush(_, N, I);
        if (!v)
          continue;
        const F = c[v.id];
        if (F !== void 0)
          T[O] = F;
        else if (v.writes.length > 0) {
          const L = v.writes.filter(([V]) => V === _d), B = v.writes.filter(([V]) => V === jn);
          if (L.length > 0)
            if (L.length === 1)
              T[O] = Promise.resolve(L[0][1]);
            else
              throw new Error(`BUG: multiple returns found for task ${v.name}__${v.id}`);
          else if (B.length > 0)
            if (B.length === 1) {
              const V = B[0][1], ue = (
                // eslint-disable-next-line no-instanceof/no-instanceof
                V instanceof Error ? V : new Error(String(V))
              );
              T[O] = Promise.reject(ue);
            } else
              throw new Error(`BUG: multiple errors found for task ${v.name}__${v.id}`);
        } else {
          const L = Qj(v, r, {
            [Ls]: h.bind(null, g, v),
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            [Qb]: p.bind(null, g, v)
          });
          c[v.id] = L, d(), T[O] = L.then(({ result: B, error: V }) => V ? Promise.reject(V) : B);
        }
      }
      return Object.values(T);
    }
    function p(g, _, P, R, C, T = {}) {
      const O = h(g, _, [[Kt, null]], {
        calls: [
          new Dx({
            func: P,
            name: R,
            input: C,
            retry: T.retry,
            callbacks: T.callbacks
          })
        ]
      });
      return O !== void 0 ? O.length === 1 ? O[0] : Promise.all(O) : Promise.resolve();
    }
    if (a && s ? "any" in AbortSignal && (s = AbortSignal.any([
      s,
      AbortSignal.timeout(a)
    ])) : a && (s = AbortSignal.timeout(a)), s?.aborted)
      throw new Error("Abort");
    let l = 0, m;
    const b = new Promise((g, _) => {
      m = () => _(new Error("Abort")), s?.addEventListener("abort", m);
    }).finally(() => s?.removeEventListener("abort", m));
    for (; (l === 0 || Object.keys(c).length > 0) && e.length; ) {
      for (; Object.values(c).length < (i ?? e.length) && l < e.length; l += 1) {
        const _ = e[l];
        c[_.id] = Qj(_, r, {
          [Ls]: h?.bind(null, this, _),
          [Qb]: p?.bind(null, this, _)
        }).catch((P) => ({ task: _, error: P }));
      }
      const g = await Promise.race([
        ...Object.values(c),
        b,
        f
      ]);
      g !== u && (yield g, delete c[g.task.id]);
    }
  }
  /**
   * Determines what writes to apply based on whether the task completed successfully, and what type of error occurred.
   *
   * Throws an error if the error is a {@link GraphBubbleUp} error and {@link PregelLoop}#isNested is true.
   *
   * @param task - The task to commit.
   * @param error - The error that occurred, if any.
   */
  _commit(e, n) {
    if (n !== void 0)
      if (Nl(n)) {
        if (n.interrupts.length) {
          const a = n.interrupts.map((i) => [at, i]), r = e.writes.filter((i) => i[0] === Bn);
          r.length && a.push(...r), this.loop.putWrites(e.id, a);
        }
      } else th(n) && e.writes.length ? this.loop.putWrites(e.id, e.writes) : this.loop.putWrites(e.id, [
        [jn, { message: n.message, name: n.name }]
      ]);
    else
      this.nodeFinished && (e.config?.tags == null || !e.config.tags.includes(lt)) && this.nodeFinished(String(e.name)), e.writes.length === 0 && e.writes.push([z_, null]), this.loop.putWrites(e.id, e.writes);
  }
}
function t4(t) {
  return typeof t == "string";
}
class n4 {
  static subscribeTo(e, n) {
    const { key: a, tags: r } = {
      key: void 0,
      tags: void 0,
      ...n ?? {}
    };
    if (Array.isArray(e) && a !== void 0)
      throw new Error("Can't specify a key when subscribing to multiple channels");
    let i;
    t4(e) ? a ? i = { [a]: e } : i = [e] : i = Object.fromEntries(e.map((u) => [u, u]));
    const s = Array.isArray(e) ? e : [e];
    return new ia({
      channels: i,
      triggers: s,
      tags: r
    });
  }
  /**
   * Creates a ChannelWrite that specifies how to write values to channels.
   * This is used to define how nodes send output to channels.
   *
   * @example
   * ```typescript
   * // Write to multiple channels
   * const write = Channel.writeTo(["output", "state"]);
   *
   * // Write with specific values
   * const write = Channel.writeTo(["output"], {
   *   state: "completed",
   *   result: calculateResult()
   * });
   *
   * // Write with a transformation function
   * const write = Channel.writeTo(["output"], {
   *   result: (x) => processResult(x)
   * });
   * ```
   *
   * @param channels - Array of channel names to write to
   * @param writes - Optional map of channel names to values or transformations
   * @returns A ChannelWrite object that can be used to write to the specified channels
   */
  static writeTo(e, n) {
    const a = [];
    for (const r of e)
      a.push({
        channel: r,
        value: xo,
        skipNone: !1
      });
    for (const [r, i] of Object.entries(n ?? {}))
      Te.isRunnable(i) || typeof i == "function" ? a.push({
        channel: r,
        value: xo,
        skipNone: !0,
        mapper: Sn(i)
      }) : a.push({
        channel: r,
        value: i,
        skipNone: !1
      });
    return new Ct(a);
  }
}
class r4 extends Te {
  /**
   * Name of the class when serialized
   * @internal
   */
  static lc_name() {
    return "LangGraph";
  }
  /**
   * Constructor for Pregel - meant for internal use only.
   *
   * @internal
   */
  constructor(e) {
    super(e), Object.defineProperty(this, "lc_namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["langgraph", "pregel"]
    }), Object.defineProperty(this, "lg_is_pregel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "nodes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "channels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputChannels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputChannels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "autoValidate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "streamMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["values"]
    }), Object.defineProperty(this, "streamChannels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interruptAfter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interruptBefore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stepTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "debug", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "checkpointer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "retryPolicy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    let { streamMode: n } = e;
    n != null && !Array.isArray(n) && (n = [n]), this.nodes = e.nodes, this.channels = e.channels, this.autoValidate = e.autoValidate ?? this.autoValidate, this.streamMode = n ?? this.streamMode, this.inputChannels = e.inputChannels, this.outputChannels = e.outputChannels, this.streamChannels = e.streamChannels ?? this.streamChannels, this.interruptAfter = e.interruptAfter, this.interruptBefore = e.interruptBefore, this.stepTimeout = e.stepTimeout ?? this.stepTimeout, this.debug = e.debug ?? this.debug, this.checkpointer = e.checkpointer, this.retryPolicy = e.retryPolicy, this.config = e.config, this.store = e.store, this.name = e.name, this.autoValidate && this.validate();
  }
  /**
   * Creates a new instance of the Pregel graph with updated configuration.
   * This method follows the immutable pattern - instead of modifying the current instance,
   * it returns a new instance with the merged configuration.
   *
   * @example
   * ```typescript
   * // Create a new instance with debug enabled
   * const debugGraph = graph.withConfig({ debug: true });
   *
   * // Create a new instance with a specific thread ID
   * const threadGraph = graph.withConfig({
   *   configurable: { thread_id: "123" }
   * });
   * ```
   *
   * @param config - The configuration to merge with the current configuration
   * @returns A new Pregel instance with the merged configuration
   */
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore Remove ignore when we remove support for 0.2 versions of core
  withConfig(e) {
    const n = aa(this.config, e);
    return new this.constructor({ ...this, config: n });
  }
  /**
   * Validates the graph structure to ensure it is well-formed.
   * Checks for:
   * - No orphaned nodes
   * - Valid input/output channel configurations
   * - Valid interrupt configurations
   *
   * @returns this - The Pregel instance for method chaining
   * @throws {GraphValidationError} If the graph structure is invalid
   */
  validate() {
    return Mx({
      nodes: this.nodes,
      channels: this.channels,
      outputChannels: this.outputChannels,
      inputChannels: this.inputChannels,
      streamChannels: this.streamChannels,
      interruptAfterNodes: this.interruptAfter,
      interruptBeforeNodes: this.interruptBefore
    }), this;
  }
  /**
   * Gets a list of all channels that should be streamed.
   * If streamChannels is specified, returns those channels.
   * Otherwise, returns all channels in the graph.
   *
   * @returns Array of channel keys to stream
   */
  get streamChannelsList() {
    return Array.isArray(this.streamChannels) ? this.streamChannels : this.streamChannels ? [this.streamChannels] : Object.keys(this.channels);
  }
  /**
   * Gets the channels to stream in their original format.
   * If streamChannels is specified, returns it as-is (either single key or array).
   * Otherwise, returns all channels in the graph as an array.
   *
   * @returns Channel keys to stream, either as a single key or array
   */
  get streamChannelsAsIs() {
    return this.streamChannels ? this.streamChannels : Object.keys(this.channels);
  }
  /**
   * Gets a drawable representation of the graph structure.
   * This is an async version of getGraph() and is the preferred method to use.
   *
   * @param config - Configuration for generating the graph visualization
   * @returns A representation of the graph that can be visualized
   */
  async getGraphAsync(e) {
    return this.getGraph(e);
  }
  /**
   * Gets all subgraphs within this graph.
   * A subgraph is a Pregel instance that is nested within a node of this graph.
   *
   * @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release.
   * @param namespace - Optional namespace to filter subgraphs
   * @param recurse - Whether to recursively get subgraphs of subgraphs
   * @returns Generator yielding tuples of [name, subgraph]
   */
  *getSubgraphs(e, n) {
    for (const [a, r] of Object.entries(this.nodes)) {
      if (e !== void 0 && !e.startsWith(a))
        continue;
      const i = r.subgraphs?.length ? r.subgraphs : [r.bound];
      for (const s of i) {
        const u = tM(s);
        if (u !== void 0) {
          if (a === e) {
            yield [a, u];
            return;
          }
          if (e === void 0 && (yield [a, u]), n) {
            let d = e;
            e !== void 0 && (d = e.slice(a.length + 1));
            for (const [f, o] of u.getSubgraphs(d, n))
              yield [
                `${a}${rn}${f}`,
                o
              ];
          }
        }
      }
    }
  }
  /**
   * Gets all subgraphs within this graph asynchronously.
   * A subgraph is a Pregel instance that is nested within a node of this graph.
   *
   * @param namespace - Optional namespace to filter subgraphs
   * @param recurse - Whether to recursively get subgraphs of subgraphs
   * @returns AsyncGenerator yielding tuples of [name, subgraph]
   */
  async *getSubgraphsAsync(e, n) {
    yield* this.getSubgraphs(e, n);
  }
  /**
   * Prepares a state snapshot from saved checkpoint data.
   * This is an internal method used by getState and getStateHistory.
   *
   * @param config - Configuration for preparing the snapshot
   * @param saved - Optional saved checkpoint data
   * @param subgraphCheckpointer - Optional checkpointer for subgraphs
   * @param applyPendingWrites - Whether to apply pending writes to tasks and then to channels
   * @returns A snapshot of the graph state
   * @internal
   */
  async _prepareStateSnapshot({ config: e, saved: n, subgraphCheckpointer: a, applyPendingWrites: r = !1 }) {
    if (n === void 0)
      return {
        values: {},
        next: [],
        config: e,
        tasks: []
      };
    const { managed: i } = await this.prepareSpecs(e, {
      skipManaged: !0
    }), s = zh(this.channels, n.checkpoint);
    if (n.pendingWrites?.length) {
      const p = n.pendingWrites.filter(([l, m]) => l === Jn).map(([l, m, b]) => [String(m), b]);
      p.length > 0 && yn(n.checkpoint, s, [
        {
          name: Fs,
          writes: p,
          triggers: []
        }
      ]);
    }
    const u = Object.values(Kl(n.checkpoint, n.pendingWrites, this.nodes, s, i, n.config, !0, { step: (n.metadata?.step ?? -1) + 1, store: this.store })), d = await ao(this.getSubgraphsAsync()), f = n.config.configurable?.checkpoint_ns ?? "", o = {};
    for (const p of u) {
      const l = d.find(([b]) => b === p.name);
      if (!l)
        continue;
      let m = `${String(p.name)}${Bo}${p.id}`;
      if (f && (m = `${f}${rn}${m}`), a === void 0) {
        const b = {
          configurable: {
            thread_id: n.config.configurable?.thread_id,
            checkpoint_ns: m
          }
        };
        o[p.id] = b;
      } else {
        const b = {
          configurable: {
            [mt]: a,
            thread_id: n.config.configurable?.thread_id,
            checkpoint_ns: m
          }
        }, g = l[1];
        o[p.id] = await g.getState(b, {
          subgraphs: !0
        });
      }
    }
    if (r && n.pendingWrites?.length) {
      const p = Object.fromEntries(u.map((m) => [m.id, m]));
      for (const [m, b, g] of n.pendingWrites)
        [jn, at, nh].includes(b) || m in p && p[m].writes.push([String(b), g]);
      const l = u.filter((m) => m.writes.length > 0);
      l.length > 0 && yn(n.checkpoint, s, l);
    }
    let c = n?.metadata;
    c && n?.config?.configurable?.thread_id && (c = {
      ...c,
      thread_id: n.config.configurable.thread_id
    });
    const h = u.filter((p) => p.writes.length === 0).map((p) => p.name);
    return {
      values: Wo(s, this.streamChannelsAsIs),
      next: h,
      tasks: nM(u, n?.pendingWrites ?? [], o),
      metadata: c,
      config: vu(n.config, n.metadata),
      createdAt: n.checkpoint.ts,
      parentConfig: n.parentConfig
    };
  }
  /**
   * Gets the current state of the graph.
   * Requires a checkpointer to be configured.
   *
   * @param config - Configuration for retrieving the state
   * @param options - Additional options
   * @returns A snapshot of the current graph state
   * @throws {GraphValueError} If no checkpointer is configured
   */
  async getState(e, n) {
    const a = e.configurable?.[mt] ?? this.checkpointer;
    if (!a)
      throw new Vj("No checkpointer set");
    const r = e.configurable?.checkpoint_ns ?? "";
    if (r !== "" && e.configurable?.[mt] === void 0) {
      const d = tb(r);
      for await (const [f, o] of this.getSubgraphsAsync(d, !0))
        if (f === d)
          return await o.getState(Ol(e, {
            [mt]: a
          }), { subgraphs: n?.subgraphs });
      throw new Error(`Subgraph with namespace "${d}" not found.`);
    }
    const i = aa(this.config, e), s = await a.getTuple(e);
    return await this._prepareStateSnapshot({
      config: i,
      saved: s,
      subgraphCheckpointer: n?.subgraphs ? a : void 0,
      applyPendingWrites: !e.configurable?.checkpoint_id
    });
  }
  /**
   * Gets the history of graph states.
   * Requires a checkpointer to be configured.
   * Useful for:
   * - Debugging execution history
   * - Implementing time travel
   * - Analyzing graph behavior
   *
   * @param config - Configuration for retrieving the history
   * @param options - Options for filtering the history
   * @returns An async iterator of state snapshots
   * @throws {Error} If no checkpointer is configured
   */
  async *getStateHistory(e, n) {
    const a = e.configurable?.[mt] ?? this.checkpointer;
    if (!a)
      throw new Error("No checkpointer set");
    const r = e.configurable?.checkpoint_ns ?? "";
    if (r !== "" && e.configurable?.[mt] === void 0) {
      const s = tb(r);
      for await (const [u, d] of this.getSubgraphsAsync(s, !0))
        if (u === s) {
          yield* d.getStateHistory(Ol(e, {
            [mt]: a
          }), n);
          return;
        }
      throw new Error(`Subgraph with namespace "${s}" not found.`);
    }
    const i = aa(this.config, e, {
      configurable: { checkpoint_ns: r }
    });
    for await (const s of a.list(i, n))
      yield this._prepareStateSnapshot({
        config: s.config,
        saved: s
      });
  }
  /**
   * Apply updates to the graph state in bulk.
   * Requires a checkpointer to be configured.
   *
   * This method is useful for recreating a thread
   * from a list of updates, especially if a checkpoint
   * is created as a result of multiple tasks.
   *
   * @internal The API might change in the future.
   *
   * @param startConfig - Configuration for the update
   * @param updates - The list of updates to apply to graph state
   * @returns Updated configuration
   * @throws {GraphValueError} If no checkpointer is configured
   * @throws {InvalidUpdateError} If the update cannot be attributed to a node or an update can be only applied in sequence.
   */
  async bulkUpdateState(e, n) {
    const a = e.configurable?.[mt] ?? this.checkpointer;
    if (!a)
      throw new Vj("No checkpointer set");
    if (n.length === 0)
      throw new Error("No supersteps provided");
    if (n.some((u) => u.updates.length === 0))
      throw new Error("No updates provided");
    const r = e.configurable?.checkpoint_ns ?? "";
    if (r !== "" && e.configurable?.[mt] === void 0) {
      const u = tb(r);
      for await (const [, d] of this.getSubgraphsAsync(u, !0))
        return await d.bulkUpdateState(Ol(e, {
          [mt]: a
        }), n);
      throw new Error(`Subgraph "${u}" not found`);
    }
    const i = async (u, d) => {
      const f = this.config ? aa(this.config, u) : u, o = await a.getTuple(f), c = o !== void 0 ? Vh(o.checkpoint) : X$(), h = {
        ...o?.checkpoint.channel_versions
      }, p = o?.metadata?.step ?? -1;
      let l = Ol(f, {
        checkpoint_ns: f.configurable?.checkpoint_ns ?? ""
      }), m = f.metadata ?? {};
      o?.config.configurable && (l = Ol(f, o.config.configurable), m = {
        ...o.metadata,
        ...m
      });
      const { values: b, asNode: g } = d[0];
      if (b == null && g === void 0) {
        if (d.length > 1)
          throw new nt("Cannot create empty checkpoint with multiple updates");
        const M = await a.put(l, Eo(c, void 0, p), {
          source: "update",
          step: p + 1,
          writes: {},
          parents: o?.metadata?.parents ?? {}
        }, {});
        return vu(M, o ? o.metadata : void 0);
      }
      const _ = zh(this.channels, c), { managed: P } = await this.prepareSpecs(f, {
        skipManaged: !0
      });
      if (b === null && g === Me) {
        if (d.length > 1)
          throw new nt("Cannot apply multiple updates when clearing state");
        if (o) {
          const I = Kl(c, o.pendingWrites || [], this.nodes, _, P, o.config, !0, {
            step: (o.metadata?.step ?? -1) + 1,
            checkpointer: this.checkpointer || void 0,
            store: this.store
          }), N = (o.pendingWrites || []).filter((v) => v[0] === Jn).map((v) => v.slice(1));
          N.length > 0 && yn(o.checkpoint, _, [
            {
              name: Fs,
              writes: N,
              triggers: []
            }
          ]);
          for (const [v, F, L] of o.pendingWrites || [])
            [jn, at, nh].includes(F) || v in I && I[v].writes.push([F, L]);
          yn(c, _, Object.values(I));
        }
        const M = await a.put(l, Eo(c, void 0, p), {
          ...m,
          source: "update",
          step: p + 1,
          writes: {},
          parents: o?.metadata?.parents ?? {}
        }, {});
        return vu(M, o ? o.metadata : void 0);
      }
      if (b == null && g === bx) {
        if (d.length > 1)
          throw new nt("Cannot copy checkpoint with multiple updates");
        const M = await a.put(o?.parentConfig ?? l, Eo(c, void 0, p), {
          source: "fork",
          step: p + 1,
          writes: {},
          parents: o?.metadata?.parents ?? {}
        }, {});
        return vu(M, o ? o.metadata : void 0);
      }
      if (g === Fs) {
        if (d.length > 1)
          throw new nt("Cannot apply multiple updates when updating as input");
        const M = await ao(eM(this.inputChannels, b));
        if (M.length === 0)
          throw new nt(`Received no input writes for ${JSON.stringify(this.inputChannels, null, 2)}`);
        yn(c, _, [
          {
            name: Fs,
            writes: M,
            triggers: []
          }
        ], a.getNextVersion.bind(this.checkpointer));
        const I = o?.metadata?.step != null ? o.metadata.step + 1 : -1, N = await a.put(l, Eo(c, _, I), {
          source: "input",
          step: I,
          writes: Object.fromEntries(M),
          parents: o?.metadata?.parents ?? {}
        }, ng(h, c.channel_versions));
        return await a.putWrites(N, M, Iu(Fs, c.id)), vu(N, o ? o.metadata : void 0);
      }
      if (f.configurable?.checkpoint_id === void 0 && o?.pendingWrites !== void 0 && o.pendingWrites.length > 0) {
        const M = Kl(c, o.pendingWrites, this.nodes, _, P, o.config, !0, {
          store: this.store,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          checkpointer: this.checkpointer,
          step: (o.metadata?.step ?? -1) + 1
        }), I = (o.pendingWrites ?? []).filter((v) => v[0] === Jn).map((v) => v.slice(1));
        I.length > 0 && yn(o.checkpoint, _, [
          {
            name: Fs,
            writes: I,
            triggers: []
          }
        ]);
        for (const [v, F, L] of o.pendingWrites)
          [jn, at, nh].includes(F) || M[v] === void 0 || M[v].writes.push([F, L]);
        const N = Object.values(M).filter((v) => v.writes.length > 0);
        N.length > 0 && yn(c, _, N);
      }
      const R = Object.values(c.versions_seen).map((M) => Object.values(M)).flat().find((M) => !!M), C = [];
      if (d.length === 1) {
        let { values: M, asNode: I } = d[0];
        if (I === void 0 && R === void 0)
          typeof this.inputChannels == "string" && this.nodes[this.inputChannels] !== void 0 && (I = this.inputChannels);
        else if (I === void 0) {
          const N = Object.entries(c.versions_seen).map(([v, F]) => Object.values(F).map((L) => [L, v])).flat().sort(([v], [F]) => Q$(v, F));
          N && (N.length === 1 ? I = N[0][1] : N[N.length - 1][0] !== N[N.length - 2][0] && (I = N[N.length - 1][1]));
        }
        if (I === void 0)
          throw new nt('Ambiguous update, specify "asNode"');
        C.push({ values: M, asNode: I });
      } else
        for (const { asNode: M, values: I } of d) {
          if (M == null)
            throw new nt('"asNode" is required when applying multiple updates');
          C.push({ values: I, asNode: M });
        }
      const T = [];
      for (const { asNode: M, values: I } of C) {
        if (this.nodes[M] === void 0)
          throw new nt(`Node "${M.toString()}" does not exist`);
        const N = this.nodes[M].getWriters();
        if (!N.length)
          throw new nt(`No writers found for node "${M.toString()}"`);
        T.push({
          name: M,
          input: I,
          proc: N.length > 1 ? (
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            gt.from(N, {
              omitSequenceTags: !0
            })
          ) : N[0],
          writes: [],
          triggers: [at],
          id: Iu(at, c.id),
          writers: []
        });
      }
      for (const M of T)
        await M.proc.invoke(M.input, Qe({
          ...f,
          store: f?.store ?? this.store
        }, {
          runName: f.runName ?? `${this.getName()}UpdateState`,
          configurable: {
            [Ls]: (I) => M.writes.push(...I),
            [Lo]: (I, N = !1) => sh(
              p,
              c,
              _,
              P,
              // TODO: Why does keyof StrRecord allow number and symbol?
              M,
              I,
              N
            )
          }
        }));
      for (const M of T) {
        const I = M.writes.filter((N) => N[0] !== Kt);
        o !== void 0 && I.length > 0 && await a.putWrites(l, I, M.id);
      }
      yn(c, _, T, a.getNextVersion.bind(this.checkpointer));
      const O = ng(h, c.channel_versions), A = await a.put(l, Eo(c, _, p + 1), {
        source: "update",
        step: p + 1,
        writes: Object.fromEntries(C.map((M) => [M.asNode, M.values])),
        parents: o?.metadata?.parents ?? {}
      }, O);
      for (const M of T) {
        const I = M.writes.filter((N) => N[0] === Kt);
        I.length > 0 && await a.putWrites(A, I, M.id);
      }
      return vu(A, o ? o.metadata : void 0);
    };
    let s = e;
    for (const { updates: u } of n)
      s = await i(s, u);
    return s;
  }
  /**
   * Updates the state of the graph with new values.
   * Requires a checkpointer to be configured.
   *
   * This method can be used for:
   * - Implementing human-in-the-loop workflows
   * - Modifying graph state during breakpoints
   * - Integrating external inputs into the graph
   *
   * @param inputConfig - Configuration for the update
   * @param values - The values to update the state with
   * @param asNode - Optional node name to attribute the update to
   * @returns Updated configuration
   * @throws {GraphValueError} If no checkpointer is configured
   * @throws {InvalidUpdateError} If the update cannot be attributed to a node
   */
  async updateState(e, n, a) {
    return this.bulkUpdateState(e, [
      { updates: [{ values: n, asNode: a }] }
    ]);
  }
  /**
   * Gets the default values for various graph configuration options.
   * This is an internal method used to process and normalize configuration options.
   *
   * @param config - The input configuration options
   * @returns A tuple containing normalized values for:
   * - debug mode
   * - stream modes
   * - input keys
   * - output keys
   * - remaining config
   * - interrupt before nodes
   * - interrupt after nodes
   * - checkpointer
   * - store
   * - whether stream mode is single
   * @internal
   */
  _defaults(e) {
    const { debug: n, streamMode: a, inputKeys: r, outputKeys: i, interruptAfter: s, interruptBefore: u, ...d } = e;
    let f = !0;
    const o = n !== void 0 ? n : this.debug;
    let c = i;
    c === void 0 ? c = this.streamChannelsAsIs : Gj(c, this.channels);
    let h = r;
    h === void 0 ? h = this.inputChannels : Gj(h, this.channels);
    const p = u ?? this.interruptBefore ?? [], l = s ?? this.interruptAfter ?? [];
    let m;
    a !== void 0 ? (m = Array.isArray(a) ? a : [a], f = typeof a == "string") : (m = this.streamMode, f = !0), e.configurable?.[Zl] !== void 0 && (m = ["values"]);
    let b;
    this.checkpointer === !1 ? b = void 0 : e !== void 0 && e.configurable?.[mt] !== void 0 ? b = e.configurable[mt] : b = this.checkpointer;
    const g = e.store ?? this.store;
    return [
      o,
      m,
      h,
      c,
      d,
      p,
      l,
      b,
      g,
      f
    ];
  }
  /**
   * Streams the execution of the graph, emitting state updates as they occur.
   * This is the primary method for observing graph execution in real-time.
   *
   * Stream modes:
   * - "values": Emits complete state after each step
   * - "updates": Emits only state changes after each step
   * - "debug": Emits detailed debug information
   * - "messages": Emits messages from within nodes
   *
   * For more details, see the [Streaming how-to guides](../../how-tos/#streaming_1).
   *
   * @param input - The input to start graph execution with
   * @param options - Configuration options for streaming
   * @returns An async iterable stream of graph state updates
   */
  async stream(e, n) {
    const a = {
      recursionLimit: this.config?.recursionLimit,
      ...n
    };
    return super.stream(e, a);
  }
  streamEvents(e, n, a) {
    const r = {
      recursionLimit: this.config?.recursionLimit,
      callbacks: this.config?.callbacks,
      ...n
    };
    return super.streamEvents(e, r, a);
  }
  /**
   * Prepares channel specifications and managed values for graph execution.
   * This is an internal method used to set up the graph's communication channels
   * and managed state before execution.
   *
   * @param config - Configuration for preparing specs
   * @param options - Additional options
   * @param options.skipManaged - Whether to skip initialization of managed values
   * @returns Object containing channel specs and managed value mapping
   * @internal
   */
  async prepareSpecs(e, n) {
    const a = {
      ...e,
      store: this.store
    }, r = {}, i = {};
    for (const [u, d] of Object.entries(this.channels))
      Fp(d) ? r[u] = d : n?.skipManaged ? i[u] = {
        cls: K_,
        params: { config: {} }
      } : i[u] = d;
    const s = new jx(await Object.entries(i).reduce(async (u, [d, f]) => {
      const o = await u;
      let c;
      return Z_(f) ? ("key" in f.params && f.params.key === Ox && (f.params.key = d), c = await f.cls.initialize(a, f.params)) : c = await f.initialize(a), c !== void 0 && o.push([d, c]), o;
    }, Promise.resolve([])));
    return {
      channelSpecs: r,
      managed: s
    };
  }
  /**
   * Validates the input for the graph.
   * @param input - The input to validate
   * @returns The validated input
   * @internal
   */
  async _validateInput(e) {
    return e;
  }
  /**
   * Validates the configurable options for the graph.
   * @param config - The configurable options to validate
   * @returns The validated configurable options
   * @internal
   */
  async _validateConfigurable(e) {
    return e;
  }
  /**
   * Internal iterator used by stream() to generate state updates.
   * This method handles the core logic of graph execution and streaming.
   *
   * @param input - The input to start graph execution with
   * @param options - Configuration options for streaming
   * @returns AsyncGenerator yielding state updates
   * @internal
   */
  async *_streamIterator(e, n) {
    const a = n?.subgraphs, r = Y$(this.config, n);
    if (r.recursionLimit === void 0 || r.recursionLimit < 1)
      throw new Error('Passed "recursionLimit" must be at least 1.');
    if (this.checkpointer !== void 0 && this.checkpointer !== !1 && r.configurable === void 0)
      throw new Error('Checkpointer requires one or more of the following "configurable" keys: "thread_id", "checkpoint_ns", "checkpoint_id"');
    const i = await this._validateInput(e), { runId: s, ...u } = r, [d, f, , o, c, h, p, l, m, b] = this._defaults(u);
    c.configurable = await this._validateConfigurable(c.configurable);
    const g = new iM({
      modes: new Set(f)
    });
    if (f.includes("messages")) {
      const I = new Kx((v) => g.push(v)), { callbacks: N } = c;
      if (N === void 0)
        c.callbacks = [I];
      else if (Array.isArray(N))
        c.callbacks = N.concat(I);
      else {
        const v = N.copy();
        v.addHandler(I, !0), c.callbacks = v;
      }
    }
    f.includes("custom") && (c.writer = (I) => g.push([[], "custom", I]));
    const P = await (await Un(c))?.handleChainStart(
      this.toJSON(),
      // chain
      Jx(e, "input"),
      // inputs
      s,
      // run_id
      void 0,
      // run_type
      void 0,
      // tags
      void 0,
      // metadata
      c?.runName ?? this.getName()
      // run_name
    ), { channelSpecs: R, managed: C } = await this.prepareSpecs(c);
    let T, O;
    const M = (async () => {
      try {
        T = await W_.initialize({
          input: i,
          config: c,
          checkpointer: l,
          nodes: this.nodes,
          channelSpecs: R,
          managed: C,
          outputKeys: o,
          streamKeys: this.streamChannelsAsIs,
          store: m,
          stream: g,
          interruptAfter: p,
          interruptBefore: h,
          manager: P,
          debug: this.debug
        });
        const I = new e4({
          loop: T,
          nodeFinished: c.configurable?.[yx]
        });
        n?.subgraphs && (T.config.configurable = {
          ...T.config.configurable,
          [Zh]: T.stream
        }), await this._runLoop({ loop: T, runner: I, debug: d, config: c });
      } catch (I) {
        O = I;
      } finally {
        try {
          T && await T.store?.stop(), await Promise.all([
            ...T?.checkpointerPromises ?? [],
            ...Array.from(C.values()).map((I) => I.promises())
          ]);
        } catch (I) {
          O = O ?? I;
        }
        O ? g.error(O) : g.close();
      }
    })();
    try {
      for await (const I of g) {
        if (I === void 0)
          throw new Error("Data structure error.");
        const [N, v, F] = I;
        f.includes(v) && (a && !b ? yield [N, v, F] : b ? a ? yield [N, F] : yield F : yield [v, F]);
      }
    } catch (I) {
      throw await P?.handleChainError(O), I;
    } finally {
      await M;
    }
    await P?.handleChainEnd(
      T?.output ?? {},
      s,
      // run_id
      void 0,
      // run_type
      void 0,
      // tags
      void 0
      // metadata
    );
  }
  /**
   * Run the graph with a single input and config.
   * @param input The input to the graph.
   * @param options The configuration to use for the run.
   */
  async invoke(e, n) {
    const a = n?.streamMode ?? "values", r = {
      ...n,
      outputKeys: n?.outputKeys ?? this.outputChannels,
      streamMode: a
    }, i = [], s = await this.stream(e, r);
    for await (const u of s)
      i.push(u);
    return a === "values" ? i[i.length - 1] : i;
  }
  async _runLoop(e) {
    const { loop: n, runner: a, debug: r, config: i } = e;
    let s;
    try {
      for (; await n.tick({
        inputKeys: this.inputChannels
      }); )
        r && Fx(n.checkpointMetadata.step, n.channels, this.streamChannelsList), r && rM(n.step, Object.values(n.tasks)), await a.tick({
          timeout: this.stepTimeout,
          retryPolicy: this.retryPolicy,
          onStepWrite: (u, d) => {
            r && kx(u, d, this.streamChannelsList);
          },
          maxConcurrency: i.maxConcurrency,
          signal: i.signal
        });
      if (n.status === "out_of_steps")
        throw new ox([
          `Recursion limit of ${i.recursionLimit} reached`,
          "without hitting a stop condition. You can increase the",
          'limit by setting the "recursionLimit" config key.'
        ].join(" "), {
          lc_error_code: "GRAPH_RECURSION_LIMIT"
        });
    } catch (u) {
      if (s = u, !await n.finishAndHandleError(s))
        throw u;
    } finally {
      s === void 0 && await n.finishAndHandleError();
    }
  }
}
class ca extends kp {
  constructor(e = !0) {
    super(), Object.defineProperty(this, "lc_graph_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EphemeralValue"
    }), Object.defineProperty(this, "guard", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this.guard = e;
  }
  fromCheckpoint(e) {
    const n = new ca(this.guard);
    return e && (n.value = [e]), n;
  }
  update(e) {
    if (e.length === 0) {
      const n = this.value.length > 0;
      return this.value = [], n;
    }
    if (e.length !== 1 && this.guard)
      throw new nt("EphemeralValue can only receive one value per step.");
    return this.value = [e[e.length - 1]], !0;
  }
  get() {
    if (this.value.length === 0)
      throw new sn();
    return this.value[0];
  }
  checkpoint() {
    if (this.value.length === 0)
      throw new sn();
    return this.value[0];
  }
}
class sM {
  constructor(e) {
    Object.defineProperty(this, "condition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ends", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Te.isRunnable(e.path) ? this.condition = e.path : this.condition = Sn(e.path).withConfig({
      runName: "Branch"
    }), this.ends = Array.isArray(e.pathMap) ? e.pathMap.reduce((n, a) => (n[a] = a, n), {}) : e.pathMap;
  }
  run(e, n) {
    return Ct.registerWriter(new au({
      name: "<branch_run>",
      trace: !1,
      func: async (a, r) => {
        try {
          return await this._route(a, r, e, n);
        } catch (i) {
          throw i.name === H$.unminifiable_name && console.warn(`[WARN]: 'NodeInterrupt' thrown in conditional edge. This is likely a bug in your graph implementation.
NodeInterrupt should only be thrown inside a node, not in edge conditions.`), i;
        }
      }
    }));
  }
  async _route(e, n, a, r) {
    let i = await this.condition.invoke(r ? r(n) : e, n);
    Array.isArray(i) || (i = [i]);
    let s;
    if (this.ends ? s = i.map((d) => Pn(d) ? d : this.ends[d]) : s = i, s.some((d) => !d))
      throw new Error("Branch condition returned unknown or null destination");
    if (s.filter(Pn).some((d) => d.node === Me))
      throw new nt("Cannot send a packet to the END node");
    return await a(s, n) ?? e;
  }
}
class a4 {
  constructor() {
    Object.defineProperty(this, "nodes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "edges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "branches", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "entryPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "compiled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.nodes = {}, this.edges = /* @__PURE__ */ new Set(), this.branches = {};
  }
  warnIfCompiled(e) {
    this.compiled && console.warn(e);
  }
  get allEdges() {
    return this.edges;
  }
  addNode(e, n, a) {
    for (const i of [
      rn,
      Bo
    ])
      if (e.includes(i))
        throw new Error(`"${i}" is a reserved character and is not allowed in node names.`);
    if (this.warnIfCompiled("Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph."), e in this.nodes)
      throw new Error(`Node \`${e}\` already present.`);
    if (e === Me)
      throw new Error(`Node \`${e}\` is reserved.`);
    const r = Sn(
      // Account for arbitrary state due to Send API
      n
    );
    return this.nodes[e] = {
      runnable: r,
      metadata: a?.metadata,
      subgraphs: G_(r) ? [r] : a?.subgraphs,
      ends: a?.ends
    }, this;
  }
  addEdge(e, n) {
    if (this.warnIfCompiled("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph."), e === Me)
      throw new Error("END cannot be a start node");
    if (n === Ke)
      throw new Error("START cannot be an end node");
    if (Array.from(this.edges).some(([a]) => a === e) && !("channels" in this))
      throw new Error(`Already found path for ${e}. For multiple edges, use StateGraph.`);
    return this.edges.add([e, n]), this;
  }
  addConditionalEdges(e, n, a) {
    const r = typeof e == "object" ? e : {
      source: e,
      path: n,
      pathMap: a
    };
    if (this.warnIfCompiled("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph."), !Te.isRunnable(r.path)) {
      const s = Array.isArray(r.pathMap) ? r.pathMap.join(",") : Object.keys(r.pathMap ?? {}).join(",");
      r.path = Sn(r.path).withConfig({
        runName: `Branch<${r.source}${s !== "" ? `,${s}` : ""}>`.slice(0, 63)
      });
    }
    const i = r.path.getName() === "RunnableLambda" ? "condition" : r.path.getName();
    if (this.branches[r.source] && this.branches[r.source][i])
      throw new Error(`Condition \`${i}\` already present for node \`${e}\``);
    return this.branches[r.source] || (this.branches[r.source] = {}), this.branches[r.source][i] = new sM(r), this;
  }
  /**
   * @deprecated use `addEdge(START, key)` instead
   */
  setEntryPoint(e) {
    return this.warnIfCompiled("Setting the entry point of a graph that has already been compiled. This will not be reflected in the compiled graph."), this.addEdge(Ke, e);
  }
  /**
   * @deprecated use `addEdge(key, END)` instead
   */
  setFinishPoint(e) {
    return this.warnIfCompiled("Setting a finish point of a graph that has already been compiled. This will not be reflected in the compiled graph."), this.addEdge(e, Me);
  }
  compile({ checkpointer: e, interruptBefore: n, interruptAfter: a, name: r } = {}) {
    this.validate([
      ...Array.isArray(n) ? n : [],
      ...Array.isArray(a) ? a : []
    ]);
    const i = new oM({
      builder: this,
      checkpointer: e,
      interruptAfter: a,
      interruptBefore: n,
      autoValidate: !1,
      nodes: {},
      channels: {
        [Ke]: new ca(),
        [Me]: new ca()
      },
      inputChannels: Ke,
      outputChannels: Me,
      streamChannels: [],
      streamMode: "values",
      name: r
    });
    for (const [s, u] of Object.entries(this.nodes))
      i.attachNode(s, u);
    for (const [s, u] of this.edges)
      i.attachEdge(s, u);
    for (const [s, u] of Object.entries(this.branches))
      for (const [d, f] of Object.entries(u))
        i.attachBranch(s, d, f);
    return i.validate();
  }
  validate(e) {
    const n = new Set([...this.allEdges].map(([r, i]) => r));
    for (const [r] of Object.entries(this.branches))
      n.add(r);
    for (const r of n)
      if (r !== Ke && !(r in this.nodes))
        throw new Error(`Found edge starting at unknown node \`${r}\``);
    const a = new Set([...this.allEdges].map(([r, i]) => i));
    for (const [r, i] of Object.entries(this.branches))
      for (const s of Object.values(i))
        if (s.ends)
          for (const u of Object.values(s.ends))
            a.add(u);
        else {
          a.add(Me);
          for (const u of Object.keys(this.nodes))
            u !== r && a.add(u);
        }
    for (const r of Object.values(this.nodes))
      for (const i of r.ends ?? [])
        a.add(i);
    for (const r of Object.keys(this.nodes))
      if (!a.has(r))
        throw new cx([
          `Node \`${r}\` is not reachable.`,
          "",
          "If you are returning Command objects from your node,",
          'make sure you are passing names of potential destination nodes as an "ends" array',
          'into ".addNode(..., { ends: ["node1", "node2"] })".'
        ].join(`
`), {
          lc_error_code: "UNREACHABLE_NODE"
        });
    for (const r of a)
      if (r !== Me && !(r in this.nodes))
        throw new Error(`Found edge ending at unknown node \`${r}\``);
    if (e) {
      for (const r of e)
        if (!(r in this.nodes))
          throw new Error(`Interrupt node \`${r}\` is not present`);
    }
    this.compiled = !0;
  }
}
class oM extends r4 {
  constructor({ builder: e, ...n }) {
    super(n), Object.defineProperty(this, "builder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.builder = e;
  }
  attachNode(e, n) {
    this.channels[e] = new ca(), this.nodes[e] = new ia({
      channels: [],
      triggers: [],
      metadata: n.metadata,
      subgraphs: n.subgraphs,
      ends: n.ends
    }).pipe(n.runnable).pipe(new Ct([{ channel: e, value: xo }], [lt])), this.streamChannels.push(e);
  }
  attachEdge(e, n) {
    if (n === Me) {
      if (e === Ke)
        throw new Error("Cannot have an edge from START to END");
      this.nodes[e].writers.push(new Ct([{ channel: Me, value: xo }], [lt]));
    } else
      this.nodes[n].triggers.push(e), this.nodes[n].channels.push(e);
  }
  attachBranch(e, n, a) {
    e === Ke && !this.nodes[Ke] && (this.nodes[Ke] = n4.subscribeTo(Ke, { tags: [lt] })), this.nodes[e].pipe(a.run((i) => {
      const s = i.map((u) => Pn(u) ? u : {
        channel: u === Me ? Me : `branch:${e}:${n}:${u}`,
        value: xo
      });
      return new Ct(s, [lt]);
    }));
    const r = a.ends ? Object.values(a.ends) : Object.keys(this.nodes);
    for (const i of r)
      if (i !== Me) {
        const s = `branch:${e}:${n}:${i}`;
        this.channels[s] = new ca(), this.nodes[i].triggers.push(s), this.nodes[i].channels.push(s);
      }
  }
  /**
   * Returns a drawable representation of the computation graph.
   */
  async getGraphAsync(e) {
    const n = e?.xray, a = new Rh(), r = {
      [Ke]: a.addNode({
        schema: wn.any()
      }, Ke)
    }, i = {};
    let s = {};
    n && (s = Object.fromEntries((await ao(this.getSubgraphsAsync())).filter(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (f) => Yj(f[1])
    )));
    function u(f, o, c, h = !1) {
      if (o === Me && i[Me] === void 0 && (i[Me] = a.addNode({ schema: wn.any() }, Me)), r[f] !== void 0) {
        if (i[o] === void 0)
          throw new Error(`End node ${o} not found!`);
        return a.addEdge(r[f], i[o], c !== o ? c : void 0, h);
      }
    }
    for (const [f, o] of Object.entries(this.builder.nodes)) {
      const c = qt(f), h = o.runnable, p = o.metadata ?? {};
      if (this.interruptBefore?.includes(f) && this.interruptAfter?.includes(f) ? p.__interrupt = "before,after" : this.interruptBefore?.includes(f) ? p.__interrupt = "before" : this.interruptAfter?.includes(f) && (p.__interrupt = "after"), n) {
        const l = typeof n == "number" ? n - 1 : n, m = s[f] !== void 0 ? await s[f].getGraphAsync({
          ...e,
          xray: l
        }) : h.getGraph(e);
        if (m.trimFirstNode(), m.trimLastNode(), Object.keys(m.nodes).length > 1) {
          let _ = function(R) {
            return R ? R.lc_runnable : !1;
          }, P = function(R, C) {
            if (R !== void 0 && !qs(R))
              return R;
            if (_(C))
              try {
                let T = C.getName();
                return T = T.startsWith("Runnable") ? T.slice(8) : T, T;
              } catch {
                return C.getName();
              }
            else
              return C.name ?? "UnknownSchema";
          };
          const [b, g] = a.extend(m, c);
          if (b === void 0)
            throw new Error(`Could not extend subgraph "${f}" due to missing entrypoint.`);
          g !== void 0 && (r[c] = {
            name: P(g.id, g.data),
            ...g
          }), i[c] = {
            name: P(b.id, b.data),
            ...b
          };
        } else {
          const b = a.addNode(h, c, p);
          r[c] = b, i[c] = b;
        }
      } else {
        const l = a.addNode(h, c, p);
        r[c] = l, i[c] = l;
      }
    }
    const d = [...this.builder.allEdges].sort(([f], [o]) => f < o ? -1 : o > f ? 1 : 0);
    for (const [f, o] of d)
      u(qt(f), qt(o));
    for (const [f, o] of Object.entries(this.builder.branches)) {
      const c = {
        ...Object.fromEntries(Object.keys(this.builder.nodes).filter((h) => h !== f).map((h) => [qt(h), qt(h)])),
        [Me]: Me
      };
      for (const h of Object.values(o)) {
        let p;
        h.ends !== void 0 ? p = h.ends : p = c;
        for (const [l, m] of Object.entries(p))
          u(qt(f), qt(m), l, !0);
      }
    }
    for (const [f, o] of Object.entries(this.builder.nodes))
      if (o.ends !== void 0)
        for (const c of o.ends)
          u(qt(f), qt(c), void 0, !0);
    return a;
  }
  /**
   * Returns a drawable representation of the computation graph.
   *
   * @deprecated Use getGraphAsync instead. The async method will be the default in the next minor core release.
   */
  getGraph(e) {
    const n = e?.xray, a = new Rh(), r = {
      [Ke]: a.addNode({
        schema: wn.any()
      }, Ke)
    }, i = {};
    let s = {};
    n && (s = Object.fromEntries(Fl(this.getSubgraphs()).filter(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (f) => Yj(f[1])
    )));
    function u(f, o, c, h = !1) {
      return o === Me && i[Me] === void 0 && (i[Me] = a.addNode({ schema: wn.any() }, Me)), a.addEdge(r[f], i[o], c !== o ? c : void 0, h);
    }
    for (const [f, o] of Object.entries(this.builder.nodes)) {
      const c = qt(f), h = o.runnable, p = o.metadata ?? {};
      if (this.interruptBefore?.includes(f) && this.interruptAfter?.includes(f) ? p.__interrupt = "before,after" : this.interruptBefore?.includes(f) ? p.__interrupt = "before" : this.interruptAfter?.includes(f) && (p.__interrupt = "after"), n) {
        const l = typeof n == "number" ? n - 1 : n, m = s[f] !== void 0 ? s[f].getGraph({
          ...e,
          xray: l
        }) : h.getGraph(e);
        if (m.trimFirstNode(), m.trimLastNode(), Object.keys(m.nodes).length > 1) {
          let _ = function(R) {
            return R ? R.lc_runnable : !1;
          }, P = function(R, C) {
            if (R !== void 0 && !qs(R))
              return R;
            if (_(C))
              try {
                let T = C.getName();
                return T = T.startsWith("Runnable") ? T.slice(8) : T, T;
              } catch {
                return C.getName();
              }
            else
              return C.name ?? "UnknownSchema";
          };
          const [b, g] = a.extend(m, c);
          if (b === void 0)
            throw new Error(`Could not extend subgraph "${f}" due to missing entrypoint.`);
          g !== void 0 && (r[c] = {
            name: P(g.id, g.data),
            ...g
          }), i[c] = {
            name: P(b.id, b.data),
            ...b
          };
        } else {
          const b = a.addNode(h, c, p);
          r[c] = b, i[c] = b;
        }
      } else {
        const l = a.addNode(h, c, p);
        r[c] = l, i[c] = l;
      }
    }
    const d = [...this.builder.allEdges].sort(([f], [o]) => f < o ? -1 : o > f ? 1 : 0);
    for (const [f, o] of d)
      u(qt(f), qt(o));
    for (const [f, o] of Object.entries(this.builder.branches)) {
      const c = {
        ...Object.fromEntries(Object.keys(this.builder.nodes).filter((h) => h !== f).map((h) => [qt(h), qt(h)])),
        [Me]: Me
      };
      for (const h of Object.values(o)) {
        let p;
        h.ends !== void 0 ? p = h.ends : p = c;
        for (const [l, m] of Object.entries(p))
          u(qt(f), qt(m), l, !0);
      }
    }
    return a;
  }
}
function Yj(t) {
  return (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof t.attachNode == "function" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof t.attachEdge == "function"
  );
}
function qt(t) {
  return t === "subgraph" ? `"${t}"` : t;
}
const eP = (t, e) => t.size === e.size && [...t].every((n) => e.has(n));
class X_ extends kp {
  constructor(e) {
    super(), Object.defineProperty(this, "lc_graph_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NamedBarrierValue"
    }), Object.defineProperty(this, "names", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "seen", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.names = e, this.seen = /* @__PURE__ */ new Set();
  }
  fromCheckpoint(e) {
    const n = new X_(this.names);
    return e && (n.seen = new Set(e)), n;
  }
  update(e) {
    let n = !1;
    for (const a of e)
      if (this.names.has(a))
        this.seen.has(a) || (this.seen.add(a), n = !0);
      else
        throw new nt(`Value ${JSON.stringify(a)} not in names ${JSON.stringify(this.names)}`);
    return n;
  }
  // If we have not yet seen all the node names we want to wait for,
  // throw an error to prevent continuing.
  get() {
    if (!eP(this.names, this.seen))
      throw new sn();
  }
  checkpoint() {
    return [...this.seen];
  }
  consume() {
    return this.seen && this.names && eP(this.seen, this.names) ? (this.seen = /* @__PURE__ */ new Set(), !0) : !1;
  }
}
const i4 = /* @__PURE__ */ new WeakMap();
function s4(t) {
  return typeof t == "object" && t != null && "_parse" in t && typeof t._parse == "function";
}
function zo(t) {
  return s4(t) && "partial" in t && typeof t.partial == "function";
}
function o4(t) {
  return i4.get(t);
}
function Vf(t) {
  const e = {};
  for (const n in t.shape)
    if (Object.prototype.hasOwnProperty.call(t.shape, n)) {
      const a = t.shape[n], r = o4(a);
      r?.reducer ? e[n] = new gd(r.reducer.fn, r.default) : e[n] = new Dp();
    }
  return e;
}
const Ds = "__root__";
class dz extends a4 {
  constructor(e, n) {
    if (super(), Object.defineProperty(this, "channels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "waitingEdges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "_schemaDefinition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_schemaRuntimeDefinition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_inputDefinition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_inputRuntimeDefinition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_outputDefinition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_outputRuntimeDefinition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_schemaDefinitions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "_configSchema", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), p4(e)) {
      const a = Vf(e.state), r = e.input != null ? Vf(e.input) : a, i = e.output != null ? Vf(e.output) : a;
      this._schemaDefinition = a, this._schemaRuntimeDefinition = e.state, this._inputDefinition = r, this._inputRuntimeDefinition = e.input ?? e.state.partial(), this._outputDefinition = i, this._outputRuntimeDefinition = e.output ?? e.state;
    } else if (zo(e)) {
      const a = Vf(e);
      this._schemaDefinition = a, this._schemaRuntimeDefinition = e, this._inputDefinition = a, this._inputRuntimeDefinition = e.partial(), this._outputDefinition = a, this._outputRuntimeDefinition = e;
    } else if (h4(e))
      this._schemaDefinition = e.input.spec, this._inputDefinition = e.input.spec, this._outputDefinition = e.output.spec;
    else if (f4(e))
      this._schemaDefinition = e.stateSchema.spec, this._inputDefinition = e.input?.spec ?? this._schemaDefinition, this._outputDefinition = e.output?.spec ?? this._schemaDefinition;
    else if (l4(e) || tP(e)) {
      const a = tP(e) ? e.spec : e;
      this._schemaDefinition = a;
    } else if (d4(e)) {
      const a = u4(e.channels);
      this._schemaDefinition = a;
    } else
      throw new Error("Invalid StateGraph input.");
    this._inputDefinition ??= this._schemaDefinition, this._outputDefinition ??= this._schemaDefinition, this._addSchema(this._schemaDefinition), this._addSchema(this._inputDefinition), this._addSchema(this._outputDefinition), this._configSchema = n != null && "spec" in n ? n.spec : zo(n) ? n.passthrough() : n;
  }
  get allEdges() {
    return /* @__PURE__ */ new Set([
      ...this.edges,
      ...Array.from(this.waitingEdges).flatMap(([e, n]) => e.map((a) => [a, n]))
    ]);
  }
  _addSchema(e) {
    if (!this._schemaDefinitions.has(e)) {
      this._schemaDefinitions.set(e, e);
      for (const [n, a] of Object.entries(e)) {
        let r;
        if (typeof a == "function" ? r = a() : r = a, this.channels[n] !== void 0) {
          if (this.channels[n] !== r && !Z_(r) && r.lc_graph_name !== "LastValue")
            throw new Error(`Channel "${n}" already exists with a different type.`);
        } else
          this.channels[n] = r;
      }
    }
  }
  addNode(e, n, a) {
    if (e in this.channels)
      throw new Error(`${e} is already being used as a state attribute (a.k.a. a channel), cannot also be used as a node name.`);
    for (const s of [
      rn,
      Bo
    ])
      if (e.includes(s))
        throw new Error(`"${s}" is a reserved character and is not allowed in node names.`);
    if (this.warnIfCompiled("Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph."), e in this.nodes)
      throw new Error(`Node \`${e}\` already present.`);
    if (e === Me || e === Ke)
      throw new Error(`Node \`${e}\` is reserved.`);
    a?.input !== void 0 && this._addSchema(a.input.spec);
    let r;
    Te.isRunnable(n) ? r = n : typeof n == "function" ? r = new au({
      func: n,
      name: e,
      trace: !1
    }) : r = Sn(n);
    const i = {
      runnable: r,
      retryPolicy: a?.retryPolicy,
      metadata: a?.metadata,
      input: a?.input?.spec ?? this._schemaDefinition,
      subgraphs: G_(r) ? (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        [r]
      ) : a?.subgraphs,
      ends: a?.ends
    };
    return this.nodes[e] = i, this;
  }
  addEdge(e, n) {
    if (typeof e == "string")
      return super.addEdge(e, n);
    this.compiled && console.warn("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.");
    for (const a of e) {
      if (a === Me)
        throw new Error("END cannot be a start node");
      if (!Object.keys(this.nodes).some((r) => r === a))
        throw new Error(`Need to add a node named "${a}" first`);
    }
    if (n === Me)
      throw new Error("END cannot be an end node");
    if (!Object.keys(this.nodes).some((a) => a === n))
      throw new Error(`Need to add a node named "${n}" first`);
    return this.waitingEdges.add([e, n]), this;
  }
  compile({ checkpointer: e, store: n, interruptBefore: a, interruptAfter: r, name: i } = {}) {
    this.validate([
      ...Array.isArray(a) ? a : [],
      ...Array.isArray(r) ? r : []
    ]);
    const s = Object.keys(this._schemaDefinitions.get(this._outputDefinition)), u = s.length === 1 && s[0] === Ds ? Ds : s, d = Object.keys(this.channels), f = d.length === 1 && d[0] === Ds ? Ds : d, o = new c4({
      builder: this,
      checkpointer: e,
      interruptAfter: r,
      interruptBefore: a,
      autoValidate: !1,
      nodes: {},
      channels: {
        ...this.channels,
        [Ke]: new ca()
      },
      inputChannels: Ke,
      outputChannels: u,
      streamChannels: f,
      streamMode: "updates",
      store: n,
      name: i
    });
    o.attachNode(Ke);
    for (const [c, h] of Object.entries(this.nodes))
      o.attachNode(c, h);
    o.attachBranch(Ke, eg, nP(), {
      withReader: !1
    });
    for (const [c] of Object.entries(this.nodes))
      o.attachBranch(c, eg, nP(), {
        withReader: !1
      });
    for (const [c, h] of this.edges)
      o.attachEdge(c, h);
    for (const [c, h] of this.waitingEdges)
      o.attachEdge(c, h);
    for (const [c, h] of Object.entries(this.branches))
      for (const [p, l] of Object.entries(h))
        o.attachBranch(c, p, l);
    return o.validate();
  }
}
function u4(t) {
  const e = {};
  for (const [n, a] of Object.entries(t))
    e[n] = Hj(a);
  return e;
}
class c4 extends oM {
  attachNode(e, n) {
    let a;
    e === Ke ? a = Object.entries(this.builder._schemaDefinitions.get(this.builder._inputDefinition)).filter(([d, f]) => !Z_(f)).map(([d]) => d) : a = Object.keys(this.builder.channels);
    function r(d) {
      if (qn(d))
        return d.graph === lr.PARENT ? null : d._updateAsTuples();
      if (Array.isArray(d) && d.length > 0 && d.some((f) => qn(f))) {
        const f = [];
        for (const o of d)
          if (qn(o)) {
            if (o.graph === lr.PARENT)
              continue;
            f.push(...o._updateAsTuples());
          } else
            f.push([Ds, o]);
        return f;
      } else if (d != null)
        return [[Ds, d]];
      return null;
    }
    const i = e;
    function s(d) {
      if (d) {
        if (qn(d))
          return d.graph === lr.PARENT ? null : d._updateAsTuples().filter(([f]) => a.includes(f));
        if (Array.isArray(d) && d.length > 0 && d.some(qn)) {
          const f = [];
          for (const o of d)
            if (qn(o)) {
              if (o.graph === lr.PARENT)
                continue;
              f.push(...o._updateAsTuples().filter(([c]) => a.includes(c)));
            } else {
              const c = s(o);
              c && f.push(...c ?? []);
            }
          return f;
        } else {
          if (typeof d == "object" && !Array.isArray(d))
            return Object.entries(d).filter(([f]) => a.includes(f));
          {
            const f = Array.isArray(d) ? "array" : typeof d;
            throw new nt(`Expected node "${i.toString()}" to return an object or an array containing at least one Command object, received ${f}`, {
              lc_error_code: "INVALID_GRAPH_NODE_RETURN_VALUE"
            });
          }
        }
      } else return null;
    }
    const u = [
      {
        value: xo,
        mapper: new au({
          func: a.length && a[0] === Ds ? r : s,
          trace: !1,
          recurse: !1
        })
      }
    ];
    if (e === Ke)
      this.nodes[e] = new ia({
        tags: [lt],
        triggers: [Ke],
        channels: [Ke],
        writers: [new Ct(u, [lt])]
      });
    else {
      const d = n?.input ?? this.builder._schemaDefinition, f = Object.fromEntries(Object.keys(this.builder._schemaDefinitions.get(d)).map((c) => [c, c])), o = Object.keys(f).length === 1 && Ds in f;
      this.channels[e] = new ca(!1), this.nodes[e] = new ia({
        triggers: [],
        // read state keys
        channels: o ? Object.keys(f) : f,
        // publish to this channel and state keys
        writers: [
          new Ct(u.concat({ channel: e, value: e }), [lt])
        ],
        mapper: o ? void 0 : (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (c) => Object.fromEntries(Object.entries(c).filter(([h]) => h in f))
        ),
        bound: n?.runnable,
        metadata: n?.metadata,
        retryPolicy: n?.retryPolicy,
        subgraphs: n?.subgraphs,
        ends: n?.ends
      });
    }
  }
  attachEdge(e, n) {
    if (n !== Me)
      if (Array.isArray(e)) {
        const a = `join:${e.join("+")}:${n}`;
        this.channels[a] = new X_(new Set(e)), this.nodes[n].triggers.push(a);
        for (const r of e)
          this.nodes[r].writers.push(new Ct([{ channel: a, value: r }], [lt]));
      } else if (e === Ke) {
        const a = `${Ke}:${n}`;
        this.channels[a] = new ca(), this.nodes[n].triggers.push(a), this.nodes[Ke].writers.push(new Ct([{ channel: a, value: Ke }], [lt]));
      } else
        this.nodes[n].triggers.push(e);
  }
  attachBranch(e, n, a, r = { withReader: !0 }) {
    const i = async (u, d) => {
      const f = u.filter((c) => c !== Me);
      if (!f.length)
        return;
      const o = f.map((c) => Pn(c) ? c : {
        channel: `branch:${e}:${n}:${c}`,
        value: e
      });
      await Ct.doWrite({ ...d, tags: (d.tags ?? []).concat([lt]) }, o);
    };
    this.nodes[e].writers.push(a.run(
      i,
      // reader
      r.withReader ? (u) => H_.doRead(u, this.streamChannels ?? this.outputChannels, !0) : void 0
    ));
    const s = a.ends ? Object.values(a.ends) : Object.keys(this.builder.nodes);
    for (const u of s) {
      if (u === Me)
        continue;
      const d = `branch:${e}:${n}:${u}`;
      this.channels[d] = new ca(!1), this.nodes[u].triggers.push(d);
    }
  }
  async _validateInput(e) {
    const n = this.builder._inputRuntimeDefinition;
    return zo(n) ? n.parse(e) : e;
  }
  async _validateConfigurable(e) {
    const n = this.builder._configSchema;
    return zo(n) && n.parse(e), e;
  }
}
function l4(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t) && Object.keys(t).length > 0 && Object.values(t).every((e) => typeof e == "function" || Fp(e));
}
function tP(t) {
  return typeof t == "object" && t !== null && "lc_graph_name" in t && t.lc_graph_name === "AnnotationRoot";
}
function d4(t) {
  return typeof t == "object" && t !== null && t.channels !== void 0;
}
function f4(t) {
  return typeof t == "object" && t !== null && t.stateSchema !== void 0;
}
function h4(t) {
  return typeof t == "object" && t !== null && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  t.stateSchema === void 0 && t.input !== void 0 && t.output !== void 0;
}
function p4(t) {
  return !(typeof t != "object" || t == null || !("state" in t) || !zo(t.state) || "input" in t && !zo(t.input) || "output" in t && !zo(t.output));
}
function m4(t) {
  if (Pn(t))
    return [t];
  const e = [];
  qn(t) ? e.push(t) : Array.isArray(t) && e.push(...t.filter(qn));
  const n = [];
  for (const a of e) {
    if (a.graph === lr.PARENT)
      throw new G$(a);
    Pn(a.goto) || typeof a.goto == "string" ? n.push(a.goto) : Array.isArray(a.goto) && n.push(...a.goto);
  }
  return n;
}
function nP() {
  const t = new au({
    func: m4,
    tags: [lt],
    trace: !1,
    recurse: !1,
    name: "<control_branch>"
  });
  return new sM({
    path: t
  });
}
const b4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), g4 = {}, _4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: g4
}, Symbol.toStringTag, { value: "Module" }));
export {
  At as AIMessage,
  A$ as AIMessagePromptTemplate,
  U_ as APIChain,
  L$ as AgentExecutor,
  z$ as AnalyzeDocumentChain,
  Qu as BaseCallbackHandler,
  N_ as BaseChatMemory,
  Fo as BaseLLM,
  sa as BaseMessage,
  Fd as BaseOutputParser,
  Ap as BasePromptTemplate,
  AU as BufferMemory,
  it as CallbackManager,
  WV as CharacterTextSplitter,
  Ru as ChatAgent,
  DV as ChatAnthropic,
  GV as ChatCerebras,
  Xo as ChatMessage,
  MU as ChatMessageHistory,
  qV as ChatMistralAI,
  UV as ChatOllama,
  oV as ChatOpenAI,
  ua as ChatPromptTemplate,
  eh as CheerioWebBaseLoader,
  iV as CommaSeparatedListOutputParser,
  iv as ConsoleCallbackHandler,
  uz as ConversationChain,
  QV as ConversationSummaryMemory,
  ez as ConversationTokenBufferMemory,
  Z$ as ConversationalRetrievalQAChain,
  ur as Document,
  lV as DynamicTool,
  Me as END,
  OE as FunctionMessage,
  tz as HTMLWebBaseLoader,
  mr as HumanMessage,
  Bs as HumanMessagePromptTemplate,
  Wk as LLM,
  tt as LLMChain,
  Ip as MapReduceDocumentsChain,
  k_ as MemoryVectorStore,
  JV as MistralAIEmbeddings,
  xV as Ollama,
  BV as OllamaEmbeddings,
  uV as OpenAI,
  cV as OpenAIEmbeddings,
  He as PromptTemplate,
  xh as RecursiveCharacterTextSplitter,
  F$ as RestorableMemoryVectorStore,
  cz as RetrievalQAChain,
  Te as Runnable,
  ec as RunnableMap,
  gt as RunnableSequence,
  Ke as START,
  sz as SearxngSearch,
  B_ as SequentialChain,
  x_ as SimpleSequentialChain,
  dz as StateGraph,
  sV as StringOutputParser,
  $h as StructuredOutputParser,
  Xk as StructuredTool,
  dh as SystemMessage,
  sc as SystemMessagePromptTemplate,
  XV as TokenTextSplitter,
  fp as Tool,
  lz as TransformChain,
  YV as VectorStoreRetrieverMemory,
  nz as WebPDFLoader,
  oz as WikipediaQueryRun,
  Is as ZeroShotAgent,
  az as createOpenAIFunctionsAgent,
  iz as createReactAgent,
  rz as createStructuredChatAgent,
  xn as zodToJsonSchema
};
//# sourceMappingURL=index.js.map
